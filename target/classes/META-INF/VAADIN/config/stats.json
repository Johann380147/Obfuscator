{
 "hash": "167447fd648cb8d97742",
 "assetsByChunkName": {
  "bundle": "build/vaadin-bundle-cd5786f6f81a7e7b9f90.cache.js",
  "bundle.es5": "build/vaadin-bundle.es5-fdc80a33b3718f06c2bd.cache.js"
 },
 "chunks": [
  {
   "id": 0,
   "names": [],
   "files": [
    "build/vaadin-0-4bf6dfa40714b1435880.cache.js"
   ],
   "hash": "a5f693adccaece2ce1aa",
   "modules": [
    {
     "id": 319,
     "name": "../node_modules/buffer/index.js",
     "source": "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n"
    },
    {
     "id": 391,
     "name": "../node_modules/webpack/buildin/global.js",
     "source": "var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"
    },
    {
     "id": 392,
     "name": "../node_modules/base64-js/index.js",
     "source": "'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n"
    },
    {
     "id": 393,
     "name": "../node_modules/ieee754/index.js",
     "source": "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n"
    },
    {
     "id": 394,
     "name": "../node_modules/isarray/index.js",
     "source": "var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n"
    }
   ]
  },
  {
   "id": 1,
   "names": [
    "bundle"
   ],
   "files": [
    "build/vaadin-bundle-cd5786f6f81a7e7b9f90.cache.js"
   ],
   "hash": "62469910ab8b2aa6ad9e",
   "modules": [
    {
     "id": 6,
     "name": "../node_modules/@polymer/polymer/lib/utils/html-tag.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\n/**\n * Class representing a static string value which can be used to filter\n * strings by asseting that they have been created via this class. The\n * `value` property returns the string passed to the constructor.\n */\n\nclass LiteralString {\n  constructor(string) {\n    /** @type {string} */\n    this.value = string.toString();\n  }\n  /**\n   * @return {string} LiteralString string value\n   * @override\n   */\n\n\n  toString() {\n    return this.value;\n  }\n\n}\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\n\n\nfunction literalValue(value) {\n  if (value instanceof LiteralString) {\n    return (\n      /** @type {!LiteralString} */\n      value.value\n    );\n  } else {\n    throw new Error(`non-literal value passed to Polymer's htmlLiteral function: ${value}`);\n  }\n}\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\n\n\nfunction htmlValue(value) {\n  if (value instanceof HTMLTemplateElement) {\n    return (\n      /** @type {!HTMLTemplateElement } */\n      value.innerHTML\n    );\n  } else if (value instanceof LiteralString) {\n    return literalValue(value);\n  } else {\n    throw new Error(`non-template value passed to Polymer's html function: ${value}`);\n  }\n}\n/**\n * A template literal tag that creates an HTML <template> element from the\n * contents of the string.\n *\n * This allows you to write a Polymer Template in JavaScript.\n *\n * Templates can be composed by interpolating `HTMLTemplateElement`s in\n * expressions in the JavaScript template literal. The nested template's\n * `innerHTML` is included in the containing template.  The only other\n * values allowed in expressions are those returned from `htmlLiteral`\n * which ensures only literal values from JS source ever reach the HTML, to\n * guard against XSS risks.\n *\n * All other values are disallowed in expressions to help prevent XSS\n * attacks; however, `htmlLiteral` can be used to compose static\n * string values into templates. This is useful to compose strings into\n * places that do not accept html, like the css text of a `style`\n * element.\n *\n * Example:\n *\n *     static get template() {\n *       return html`\n *         <style>:host{ content:\"...\" }</style>\n *         <div class=\"shadowed\">${this.partialTemplate}</div>\n *         ${super.template}\n *       `;\n *     }\n *     static get partialTemplate() { return html`<span>Partial!</span>`; }\n *\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {...*} values Variable parts of tagged template literal\n * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement\n */\n\n\nexport var html = function html(strings, ...values) {\n  var template =\n  /** @type {!HTMLTemplateElement} */\n  document.createElement('template');\n  template.innerHTML = values.reduce((acc, v, idx) => acc + htmlValue(v) + strings[idx + 1], strings[0]);\n  return template;\n};\n/**\n * An html literal tag that can be used with `html` to compose.\n * a literal string.\n *\n * Example:\n *\n *     static get template() {\n *       return html`\n *         <style>\n *           :host { display: block; }\n *           ${this.styleTemplate()}\n *         </style>\n *         <div class=\"shadowed\">${staticValue}</div>\n *         ${super.template}\n *       `;\n *     }\n *     static get styleTemplate() {\n *        return htmlLiteral`.shadowed { background: gray; }`;\n *     }\n *\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {...*} values Variable parts of tagged template literal\n * @return {!LiteralString} Constructed literal string\n */\n\nexport var htmlLiteral = function (strings, ...values) {\n  return new LiteralString(values.reduce((acc, v, idx) => acc + literalValue(v) + strings[idx + 1], strings[0]));\n};"
    },
    {
     "id": 9,
     "name": "../node_modules/@polymer/polymer/lib/utils/wrap.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable valid-jsdoc */\n\n/**\n * Node wrapper to ensure ShadowDOM safe operation regardless of polyfill\n * presence or mode. Note that with the introduction of `ShadyDOM.noPatch`,\n * a node wrapper must be used to access ShadowDOM API.\n * This is similar to using `Polymer.dom` but relies exclusively\n * on the presence of the ShadyDOM polyfill rather than requiring the loading\n * of legacy (Polymer.dom) API.\n * @type {function(Node):Node}\n */\nexport var wrap = window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap'] ? window['ShadyDOM']['wrap'] : n => n;"
    },
    {
     "id": 11,
     "name": "../node_modules/@polymer/polymer/polymer-element.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { ElementMixin, version } from './lib/mixins/element-mixin.js';\nexport { html } from './lib/utils/html-tag.js';\nexport { version };\n/**\n * Base class that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * @customElement\n * @polymer\n * @constructor\n * @implements {Polymer_ElementMixin}\n * @extends HTMLElement\n * @appliesMixin ElementMixin\n * @summary Custom element base class that provides the core API for Polymer's\n *   key meta-programming features including template stamping, data-binding,\n *   attribute deserialization, and property change observation\n */\n\nexport var PolymerElement = ElementMixin(HTMLElement);"
    },
    {
     "id": 13,
     "name": "../node_modules/@polymer/polymer/lib/utils/path.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\n/**\n * Module with utilities for manipulating structured data path strings.\n *\n * @summary Module with utilities for manipulating structured data path strings.\n */\n\n/**\n * Returns true if the given string is a structured data path (has dots).\n *\n * Example:\n *\n * ```\n * isPath('foo.bar.baz') // true\n * isPath('foo')         // false\n * ```\n *\n * @param {string} path Path string\n * @return {boolean} True if the string contained one or more dots\n */\n\nexport function isPath(path) {\n  return path.indexOf('.') >= 0;\n}\n/**\n * Returns the root property name for the given path.\n *\n * Example:\n *\n * ```\n * root('foo.bar.baz') // 'foo'\n * root('foo')         // 'foo'\n * ```\n *\n * @param {string} path Path string\n * @return {string} Root property name\n */\n\nexport function root(path) {\n  var dotIndex = path.indexOf('.');\n\n  if (dotIndex === -1) {\n    return path;\n  }\n\n  return path.slice(0, dotIndex);\n}\n/**\n * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n * Returns true if the given path is an ancestor of the base path.\n *\n * Example:\n *\n * ```\n * isAncestor('foo.bar', 'foo')         // true\n * isAncestor('foo.bar', 'foo.bar')     // false\n * isAncestor('foo.bar', 'foo.bar.baz') // false\n * ```\n *\n * @param {string} base Path string to test against.\n * @param {string} path Path string to test.\n * @return {boolean} True if `path` is an ancestor of `base`.\n */\n\nexport function isAncestor(base, path) {\n  //     base.startsWith(path + '.');\n  return base.indexOf(path + '.') === 0;\n}\n/**\n * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n *\n * Example:\n *\n * ```\n * isDescendant('foo.bar', 'foo.bar.baz') // true\n * isDescendant('foo.bar', 'foo.bar')     // false\n * isDescendant('foo.bar', 'foo')         // false\n * ```\n *\n * @param {string} base Path string to test against.\n * @param {string} path Path string to test.\n * @return {boolean} True if `path` is a descendant of `base`.\n */\n\nexport function isDescendant(base, path) {\n  //     path.startsWith(base + '.');\n  return path.indexOf(base + '.') === 0;\n}\n/**\n * Replaces a previous base path with a new base path, preserving the\n * remainder of the path.\n *\n * User must ensure `path` has a prefix of `base`.\n *\n * Example:\n *\n * ```\n * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'\n * ```\n *\n * @param {string} base Current base string to remove\n * @param {string} newBase New base string to replace with\n * @param {string} path Path to translate\n * @return {string} Translated string\n */\n\nexport function translate(base, newBase, path) {\n  return newBase + path.slice(base.length);\n}\n/**\n * @param {string} base Path string to test against\n * @param {string} path Path string to test\n * @return {boolean} True if `path` is equal to `base`\n */\n\nexport function matches(base, path) {\n  return base === path || isAncestor(base, path) || isDescendant(base, path);\n}\n/**\n * Converts array-based paths to flattened path.  String-based paths\n * are returned as-is.\n *\n * Example:\n *\n * ```\n * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\n * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\n * ```\n *\n * @param {string | !Array<string|number>} path Input path\n * @return {string} Flattened path\n */\n\nexport function normalize(path) {\n  if (Array.isArray(path)) {\n    var parts = [];\n\n    for (var i = 0; i < path.length; i++) {\n      var args = path[i].toString().split('.');\n\n      for (var j = 0; j < args.length; j++) {\n        parts.push(args[j]);\n      }\n    }\n\n    return parts.join('.');\n  } else {\n    return path;\n  }\n}\n/**\n * Splits a path into an array of property names. Accepts either arrays\n * of path parts or strings.\n *\n * Example:\n *\n * ```\n * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\n * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\n * ```\n *\n * @param {string | !Array<string|number>} path Input path\n * @return {!Array<string>} Array of path parts\n * @suppress {checkTypes}\n */\n\nexport function split(path) {\n  if (Array.isArray(path)) {\n    return normalize(path).split('.');\n  }\n\n  return path.toString().split('.');\n}\n/**\n * Reads a value from a path.  If any sub-property in the path is `undefined`,\n * this method returns `undefined` (will never throw.\n *\n * @param {Object} root Object from which to dereference path from\n * @param {string | !Array<string|number>} path Path to read\n * @param {Object=} info If an object is provided to `info`, the normalized\n *  (flattened) path will be set to `info.path`.\n * @return {*} Value at path, or `undefined` if the path could not be\n *  fully dereferenced.\n */\n\nexport function get(root, path, info) {\n  var prop = root;\n  var parts = split(path); // Loop over path parts[0..n-1] and dereference\n\n  for (var i = 0; i < parts.length; i++) {\n    if (!prop) {\n      return;\n    }\n\n    var part = parts[i];\n    prop = prop[part];\n  }\n\n  if (info) {\n    info.path = parts.join('.');\n  }\n\n  return prop;\n}\n/**\n * Sets a value to a path.  If any sub-property in the path is `undefined`,\n * this method will no-op.\n *\n * @param {Object} root Object from which to dereference path from\n * @param {string | !Array<string|number>} path Path to set\n * @param {*} value Value to set to path\n * @return {string | undefined} The normalized version of the input path\n */\n\nexport function set(root, path, value) {\n  var prop = root;\n  var parts = split(path);\n  var last = parts[parts.length - 1];\n\n  if (parts.length > 1) {\n    // Loop over path parts[0..n-2] and dereference\n    for (var i = 0; i < parts.length - 1; i++) {\n      var part = parts[i];\n      prop = prop[part];\n\n      if (!prop) {\n        return;\n      }\n    } // Set value to object at end of path\n\n\n    prop[last] = value;\n  } else {\n    // Simple property set\n    prop[path] = value;\n  }\n\n  return parts.join('.');\n}\n/**\n * Returns true if the given string is a structured data path (has dots).\n *\n * This function is deprecated.  Use `isPath` instead.\n *\n * Example:\n *\n * ```\n * isDeep('foo.bar.baz') // true\n * isDeep('foo')         // false\n * ```\n *\n * @deprecated\n * @param {string} path Path string\n * @return {boolean} True if the string contained one or more dots\n */\n\nexport var isDeep = isPath;"
    },
    {
     "id": 15,
     "name": "../node_modules/@polymer/polymer/lib/utils/async.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\nimport './boot.js'; // Microtask implemented using Mutation Observer\n\nvar microtaskCurrHandle = 0;\nvar microtaskLastHandle = 0;\nvar microtaskCallbacks = [];\nvar microtaskNodeContent = 0;\nvar microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {\n  characterData: true\n});\n\nfunction microtaskFlush() {\n  var len = microtaskCallbacks.length;\n\n  for (var i = 0; i < len; i++) {\n    var cb = microtaskCallbacks[i];\n\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => {\n          throw e;\n        });\n      }\n    }\n  }\n\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\n\n\nvar timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) {\n        return window.setTimeout(fn, delay);\n      },\n\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n\n    };\n  },\n\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n\n};\nexport { timeOut };\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\n\nvar animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n\n};\nexport { animationFrame };\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\n\nvar idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n  },\n\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n  }\n\n};\nexport { idlePeriod };\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\n\nvar microTask = {\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    microtaskNode.textContent = microtaskNodeContent++;\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    var idx = handle - microtaskLastHandle;\n\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n\n      microtaskCallbacks[idx] = null;\n    }\n  }\n\n};\nexport { microTask };"
    },
    {
     "id": 17,
     "name": "../node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js?babel-target=es6",
     "source": "import { DomModule } from '@polymer/polymer/lib/elements/dom-module.js';\nimport { ThemePropertyMixin } from './vaadin-theme-property-mixin.js';\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\n\nexport var ThemableMixin = superClass => class VaadinThemableMixin extends ThemePropertyMixin(superClass) {\n  /** @protected */\n  static finalize() {\n    super.finalize();\n    var template = this.prototype._template;\n    var hasOwnTemplate = this.template && this.template.parentElement && this.template.parentElement.id === this.is;\n\n    var inheritedTemplate = Object.getPrototypeOf(this.prototype)._template;\n\n    if (inheritedTemplate && !hasOwnTemplate) {\n      // The element doesn't define its own template -> include the theme modules from the inherited template\n      Array.from(inheritedTemplate.content.querySelectorAll('style[include]')).forEach(s => {\n        this._includeStyle(s.getAttribute('include'), template);\n      });\n    }\n\n    this._includeMatchingThemes(template);\n  }\n  /** @private */\n\n\n  static _includeMatchingThemes(template) {\n    var domModule = DomModule;\n    var modules = domModule.prototype.modules;\n    var hasThemes = false;\n    var defaultModuleName = this.is + '-default-theme';\n    Object.keys(modules).sort((moduleNameA, moduleNameB) => {\n      var vaadinA = moduleNameA.indexOf('vaadin-') === 0;\n      var vaadinB = moduleNameB.indexOf('vaadin-') === 0;\n      var vaadinThemePrefixes = ['lumo-', 'material-'];\n      var vaadinThemeA = vaadinThemePrefixes.filter(prefix => moduleNameA.indexOf(prefix) === 0).length > 0;\n      var vaadinThemeB = vaadinThemePrefixes.filter(prefix => moduleNameB.indexOf(prefix) === 0).length > 0;\n\n      if (vaadinA !== vaadinB) {\n        // Include vaadin core styles first\n        return vaadinA ? -1 : 1;\n      } else if (vaadinThemeA !== vaadinThemeB) {\n        // Include vaadin theme styles after that\n        return vaadinThemeA ? -1 : 1;\n      } else {\n        // Lastly include custom styles so they override all vaadin styles\n        return 0;\n      }\n    }).forEach(moduleName => {\n      if (moduleName !== defaultModuleName) {\n        var themeFor = modules[moduleName].getAttribute('theme-for');\n\n        if (themeFor) {\n          themeFor.split(' ').forEach(themeForToken => {\n            if (new RegExp('^' + themeForToken.split('*').join('.*') + '$').test(this.is)) {\n              hasThemes = true;\n\n              this._includeStyle(moduleName, template);\n            }\n          });\n        }\n      }\n    });\n\n    if (!hasThemes && modules[defaultModuleName]) {\n      // No theme modules found, include the default module if it exists\n      this._includeStyle(defaultModuleName, template);\n    }\n  }\n  /** @private */\n\n\n  static _includeStyle(moduleName, template) {\n    if (template && !template.content.querySelector(`style[include=\"${moduleName}\"]`)) {\n      var styleEl = document.createElement('style');\n      styleEl.setAttribute('include', moduleName);\n      template.content.appendChild(styleEl);\n    }\n  }\n\n};"
    },
    {
     "id": 19,
     "name": "../node_modules/@polymer/polymer/lib/utils/debounce.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\nimport './mixin.js';\nimport './async.js';\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\n\nexport class Debouncer {\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n\n\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n\n      this._callback();\n    });\n  }\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n\n\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync(); // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n\n\n      debouncerQueue.delete(this);\n    }\n  }\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n\n\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel(\n      /** @type {number} */\n      this._timer);\n\n      this._timer = null;\n    }\n  }\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n\n\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n\n      this._callback();\n    }\n  }\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n\n\n  isActive() {\n    return this._timer != null;\n  }\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@polymer/polymer/lib/utils/async.js';\n   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n\n\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n\n}\nvar debouncerQueue = new Set();\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\n\nexport var enqueueDebouncer = function (debouncer) {\n  debouncerQueue.add(debouncer);\n};\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\n\nexport var flushDebouncers = function () {\n  var didFlush = Boolean(debouncerQueue.size); // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n\n  debouncerQueue.forEach(debouncer => {\n    try {\n      debouncer.flush();\n    } catch (e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n};"
    },
    {
     "id": 21,
     "name": "../node_modules/@vaadin/vaadin-element-mixin/vaadin-element-mixin.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 24,
     "name": "../node_modules/@polymer/polymer/lib/utils/settings.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\nimport { pathFromUrl } from './resolve-url.js';\nexport var useShadow = !window.ShadyDOM;\nexport var useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);\nexport var useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;\n/**\n * Globally settable property that is automatically assigned to\n * `ElementMixin` instances, useful for binding in templates to\n * make URL's relative to an application's root.  Defaults to the main\n * document URL, but can be overridden by users.  It may be useful to set\n * `rootPath` to provide a stable application mount path when\n * using client side routing.\n */\n\nexport var rootPath = pathFromUrl(document.baseURI || window.location.href);\n/**\n * Sets the global rootPath property used by `ElementMixin` and\n * available via `rootPath`.\n *\n * @param {string} path The new root path\n * @return {void}\n */\n\nexport var setRootPath = function (path) {\n  rootPath = path;\n};\n/**\n * A global callback used to sanitize any value before inserting it into the DOM.\n * The callback signature is:\n *\n *  function sanitizeDOMValue(value, name, type, node) { ... }\n *\n * Where:\n *\n * `value` is the value to sanitize.\n * `name` is the name of an attribute or property (for example, href).\n * `type` indicates where the value is being inserted: one of property, attribute, or text.\n * `node` is the node where the value is being inserted.\n *\n * @type {(function(*,string,string,Node):*)|undefined}\n */\n\nexport var sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || undefined;\n/**\n * Sets the global sanitizeDOMValue available via this module's exported\n * `sanitizeDOMValue` variable.\n *\n * @param {(function(*,string,string,Node):*)|undefined} newSanitizeDOMValue the global sanitizeDOMValue callback\n * @return {void}\n */\n\nexport var setSanitizeDOMValue = function (newSanitizeDOMValue) {\n  sanitizeDOMValue = newSanitizeDOMValue;\n};\n/**\n * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.\n * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother\n * scrolling performance.\n * Defaults to `false` for backwards compatibility.\n */\n\nexport var passiveTouchGestures = false;\n/**\n * Sets `passiveTouchGestures` globally for all elements using Polymer Gestures.\n *\n * @param {boolean} usePassive enable or disable passive touch gestures globally\n * @return {void}\n */\n\nexport var setPassiveTouchGestures = function (usePassive) {\n  passiveTouchGestures = usePassive;\n};\n/**\n * Setting to ensure Polymer template evaluation only occurs based on tempates\n * defined in trusted script.  When true, `<dom-module>` re-registration is\n * disallowed, `<dom-bind>` is disabled, and `<dom-if>`/`<dom-repeat>`\n * templates will only evaluate in the context of a trusted element template.\n */\n\nexport var strictTemplatePolicy = false;\n/**\n * Sets `strictTemplatePolicy` globally for all elements\n *\n * @param {boolean} useStrictPolicy enable or disable strict template policy\n *   globally\n * @return {void}\n */\n\nexport var setStrictTemplatePolicy = function (useStrictPolicy) {\n  strictTemplatePolicy = useStrictPolicy;\n};\n/**\n * Setting to enable dom-module lookup from Polymer.Element.  By default,\n * templates must be defined in script using the `static get template()`\n * getter and the `html` tag function.  To enable legacy loading of templates\n * via dom-module, set this flag to true.\n */\n\nexport var allowTemplateFromDomModule = false;\n/**\n * Sets `lookupTemplateFromDomModule` globally for all elements\n *\n * @param {boolean} allowDomModule enable or disable template lookup\n *   globally\n * @return {void}\n */\n\nexport var setAllowTemplateFromDomModule = function (allowDomModule) {\n  allowTemplateFromDomModule = allowDomModule;\n};\n/**\n * Setting to skip processing style includes and re-writing urls in css styles.\n * Normally \"included\" styles are pulled into the element and all urls in styles\n * are re-written to be relative to the containing script url.\n * If no includes or relative urls are used in styles, these steps can be\n * skipped as an optimization.\n */\n\nexport var legacyOptimizations = false;\n/**\n * Sets `legacyOptimizations` globally for all elements to enable optimizations\n * when only legacy based elements are used.\n *\n * @param {boolean} useLegacyOptimizations enable or disable legacy optimizations\n * includes and url rewriting\n * @return {void}\n */\n\nexport var setLegacyOptimizations = function (useLegacyOptimizations) {\n  legacyOptimizations = useLegacyOptimizations;\n};\n/**\n * Setting to perform initial rendering synchronously when running under ShadyDOM.\n * This matches the behavior of Polymer 1.\n */\n\nexport var syncInitialRender = false;\n/**\n * Sets `syncInitialRender` globally for all elements to enable synchronous\n * initial rendering.\n *\n * @param {boolean} useSyncInitialRender enable or disable synchronous initial\n * rendering globally.\n * @return {void}\n */\n\nexport var setSyncInitialRender = function (useSyncInitialRender) {\n  syncInitialRender = useSyncInitialRender;\n};"
    },
    {
     "id": 26,
     "name": "../node_modules/@polymer/polymer/lib/utils/mixin.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js'; // unique global id for deduping mixins.\n\nvar dedupeId = 0;\n/**\n * @constructor\n * @extends {Function}\n * @private\n */\n\nfunction MixinFunction() {}\n/** @type {(WeakMap | undefined)} */\n\n\nMixinFunction.prototype.__mixinApplications;\n/** @type {(Object | undefined)} */\n\nMixinFunction.prototype.__mixinSet;\n/* eslint-disable valid-jsdoc */\n\n/**\n * Wraps an ES6 class expression mixin such that the mixin is only applied\n * if it has not already been applied its base argument. Also memoizes mixin\n * applications.\n *\n * @template T\n * @param {T} mixin ES6 class expression mixin to wrap\n * @return {T}\n * @suppress {invalidCasts}\n */\n\nexport var dedupingMixin = function (mixin) {\n  var mixinApplications =\n  /** @type {!MixinFunction} */\n  mixin.__mixinApplications;\n\n  if (!mixinApplications) {\n    mixinApplications = new WeakMap();\n    /** @type {!MixinFunction} */\n\n    mixin.__mixinApplications = mixinApplications;\n  } // maintain a unique id for each mixin\n\n\n  var mixinDedupeId = dedupeId++;\n\n  function dedupingMixin(base) {\n    var baseSet =\n    /** @type {!MixinFunction} */\n    base.__mixinSet;\n\n    if (baseSet && baseSet[mixinDedupeId]) {\n      return base;\n    }\n\n    var map = mixinApplications;\n    var extended = map.get(base);\n\n    if (!extended) {\n      extended =\n      /** @type {!Function} */\n      mixin(base);\n      map.set(base, extended);\n    } // copy inherited mixin set from the extended class, or the base class\n    // NOTE: we avoid use of Set here because some browser (IE11)\n    // cannot extend a base Set via the constructor.\n\n\n    var mixinSet = Object.create(\n    /** @type {!MixinFunction} */\n    extended.__mixinSet || baseSet || null);\n    mixinSet[mixinDedupeId] = true;\n    /** @type {!MixinFunction} */\n\n    extended.__mixinSet = mixinSet;\n    return extended;\n  }\n\n  return dedupingMixin;\n};\n/* eslint-enable valid-jsdoc */"
    },
    {
     "id": 28,
     "name": "../node_modules/@polymer/polymer/lib/utils/boot.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable no-unused-vars */\n\n/**\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n *\n * @param {string} prop Property name\n * @param {?Object} obj Reference object\n * @return {string} Potentially renamed property name\n */\nwindow.JSCompiler_renameProperty = function (prop, obj) {\n  return prop;\n};\n/* eslint-enable */\n\n\nexport {};"
    },
    {
     "id": 30,
     "name": "../node_modules/@polymer/polymer/lib/legacy/polymer.dom.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { wrap } from '../utils/wrap.js';\nimport '../utils/settings.js';\nimport { FlattenedNodesObserver } from '../utils/flattened-nodes-observer.js';\nexport { flush, enqueueDebouncer as addDebouncer } from '../utils/flush.js';\n/* eslint-disable no-unused-vars */\n\nimport { Debouncer } from '../utils/debounce.js'; // used in type annotations\n\n/* eslint-enable no-unused-vars */\n\nvar p = Element.prototype;\n/**\n * @const {function(this:Node, string): boolean}\n */\n\nvar normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n/**\n * Cross-platform `element.matches` shim.\n *\n * @function matchesSelector\n * @param {!Node} node Node to check selector against\n * @param {string} selector Selector to match\n * @return {boolean} True if node matched selector\n */\n\nexport var matchesSelector = function (node, selector) {\n  return normalizedMatchesSelector.call(node, selector);\n};\n/**\n * Node API wrapper class returned from `Polymer.dom.(target)` when\n * `target` is a `Node`.\n * @implements {PolymerDomApi}\n * @unrestricted\n */\n\nclass DomApiNative {\n  /**\n   * @param {Node} node Node for which to create a Polymer.dom helper object.\n   */\n  constructor(node) {\n    this.node = node;\n  }\n  /**\n   * Returns an instance of `FlattenedNodesObserver` that\n   * listens for node changes on this element.\n   *\n   * @param {function(this:HTMLElement, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Called when direct or distributed children\n   *   of this element changes\n   * @return {!PolymerDomApi.ObserveHandle} Observer instance\n   * @override\n   */\n\n\n  observeNodes(callback) {\n    return new FlattenedNodesObserver(\n    /** @type {!HTMLElement} */\n    this.node, callback);\n  }\n  /**\n   * Disconnects an observer previously created via `observeNodes`\n   *\n   * @param {!PolymerDomApi.ObserveHandle} observerHandle Observer instance\n   *   to disconnect.\n   * @return {void}\n   * @override\n   */\n\n\n  unobserveNodes(observerHandle) {\n    observerHandle.disconnect();\n  }\n  /**\n   * Provided as a backwards-compatible API only.  This method does nothing.\n   * @return {void}\n   */\n\n\n  notifyObserver() {}\n  /**\n   * Returns true if the provided node is contained with this element's\n   * light-DOM children or shadow root, including any nested shadow roots\n   * of children therein.\n   *\n   * @param {Node} node Node to test\n   * @return {boolean} Returns true if the given `node` is contained within\n   *   this element's light or shadow DOM.\n   * @override\n   */\n\n\n  deepContains(node) {\n    if (wrap(this.node).contains(node)) {\n      return true;\n    }\n\n    var n = node;\n    var doc = node.ownerDocument; // walk from node to `this` or `document`\n\n    while (n && n !== doc && n !== this.node) {\n      // use logical parentnode, or native ShadowRoot host\n      n = wrap(n).parentNode || wrap(n).host;\n    }\n\n    return n === this.node;\n  }\n  /**\n   * Returns the root node of this node.  Equivalent to `getRootNode()`.\n   *\n   * @return {Node} Top most element in the dom tree in which the node\n   * exists. If the node is connected to a document this is either a\n   * shadowRoot or the document; otherwise, it may be the node\n   * itself or a node or document fragment containing it.\n   * @override\n   */\n\n\n  getOwnerRoot() {\n    return wrap(this.node).getRootNode();\n  }\n  /**\n   * For slot elements, returns the nodes assigned to the slot; otherwise\n   * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.\n   *\n   * @return {!Array<!Node>} Array of assigned nodes\n   * @override\n   */\n\n\n  getDistributedNodes() {\n    return this.node.localName === 'slot' ? wrap(this.node).assignedNodes({\n      flatten: true\n    }) : [];\n  }\n  /**\n   * Returns an array of all slots this element was distributed to.\n   *\n   * @return {!Array<!HTMLSlotElement>} Description\n   * @override\n   */\n\n\n  getDestinationInsertionPoints() {\n    var ip$ = [];\n    var n = wrap(this.node).assignedSlot;\n\n    while (n) {\n      ip$.push(n);\n      n = wrap(n).assignedSlot;\n    }\n\n    return ip$;\n  }\n  /**\n   * Calls `importNode` on the `ownerDocument` for this node.\n   *\n   * @param {!Node} node Node to import\n   * @param {boolean} deep True if the node should be cloned deeply during\n   *   import\n   * @return {Node} Clone of given node imported to this owner document\n   */\n\n\n  importNode(node, deep) {\n    var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;\n    return wrap(doc).importNode(node, deep);\n  }\n  /**\n   * @return {!Array<!Node>} Returns a flattened list of all child nodes and\n   * nodes assigned to child slots.\n   * @override\n   */\n\n\n  getEffectiveChildNodes() {\n    return FlattenedNodesObserver.getFlattenedNodes(\n    /** @type {!HTMLElement} */\n    this.node);\n  }\n  /**\n   * Returns a filtered list of flattened child elements for this element based\n   * on the given selector.\n   *\n   * @param {string} selector Selector to filter nodes against\n   * @return {!Array<!HTMLElement>} List of flattened child elements\n   * @override\n   */\n\n\n  queryDistributedElements(selector) {\n    var c$ = this.getEffectiveChildNodes();\n    var list = [];\n\n    for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\n      if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {\n        list.push(c);\n      }\n    }\n\n    return list;\n  }\n  /**\n   * For shadow roots, returns the currently focused element within this\n   * shadow root.\n   *\n   * return {Node|undefined} Currently focused element\n   * @override\n   */\n\n\n  get activeElement() {\n    var node = this.node;\n    return node._activeElement !== undefined ? node._activeElement : node.activeElement;\n  }\n\n}\n\nfunction forwardMethods(proto, methods) {\n  var _loop = function (i) {\n    var method = methods[i];\n    /* eslint-disable valid-jsdoc */\n\n    proto[method] =\n    /** @this {DomApiNative} */\n    function () {\n      return this.node[method].apply(this.node, arguments);\n    };\n    /* eslint-enable */\n\n  };\n\n  for (var i = 0; i < methods.length; i++) {\n    _loop(i);\n  }\n}\n\nfunction forwardReadOnlyProperties(proto, properties) {\n  var _loop2 = function (i) {\n    var name = properties[i];\n    Object.defineProperty(proto, name, {\n      get: function () {\n        var domApi =\n        /** @type {DomApiNative} */\n        this;\n        return domApi.node[name];\n      },\n      configurable: true\n    });\n  };\n\n  for (var i = 0; i < properties.length; i++) {\n    _loop2(i);\n  }\n}\n\nfunction forwardProperties(proto, properties) {\n  var _loop3 = function (i) {\n    var name = properties[i];\n    Object.defineProperty(proto, name, {\n      /**\n       * @this {DomApiNative}\n       * @return {*} .\n       */\n      get: function () {\n        return this.node[name];\n      },\n\n      /**\n       * @this {DomApiNative}\n       * @param {*} value .\n       */\n      set: function (value) {\n        this.node[name] = value;\n      },\n      configurable: true\n    });\n  };\n\n  for (var i = 0; i < properties.length; i++) {\n    _loop3(i);\n  }\n}\n/**\n * Event API wrapper class returned from `dom.(target)` when\n * `target` is an `Event`.\n */\n\n\nexport class EventApi {\n  constructor(event) {\n    this.event = event;\n  }\n  /**\n   * Returns the first node on the `composedPath` of this event.\n   *\n   * @return {!EventTarget} The node this event was dispatched to\n   */\n\n\n  get rootTarget() {\n    return this.path[0];\n  }\n  /**\n   * Returns the local (re-targeted) target for this event.\n   *\n   * @return {!EventTarget} The local (re-targeted) target for this event.\n   */\n\n\n  get localTarget() {\n    return this.event.target;\n  }\n  /**\n   * Returns the `composedPath` for this event.\n   * @return {!Array<!EventTarget>} The nodes this event propagated through\n   */\n\n\n  get path() {\n    return this.event.composedPath();\n  }\n\n}\n/**\n * @function\n * @param {boolean=} deep\n * @return {!Node}\n */\n\nDomApiNative.prototype.cloneNode;\n/**\n * @function\n * @param {!Node} node\n * @return {!Node}\n */\n\nDomApiNative.prototype.appendChild;\n/**\n * @function\n * @param {!Node} newChild\n * @param {Node} refChild\n * @return {!Node}\n */\n\nDomApiNative.prototype.insertBefore;\n/**\n * @function\n * @param {!Node} node\n * @return {!Node}\n */\n\nDomApiNative.prototype.removeChild;\n/**\n * @function\n * @param {!Node} oldChild\n * @param {!Node} newChild\n * @return {!Node}\n */\n\nDomApiNative.prototype.replaceChild;\n/**\n * @function\n * @param {string} name\n * @param {string} value\n * @return {void}\n */\n\nDomApiNative.prototype.setAttribute;\n/**\n * @function\n * @param {string} name\n * @return {void}\n */\n\nDomApiNative.prototype.removeAttribute;\n/**\n * @function\n * @param {string} selector\n * @return {?Element}\n */\n\nDomApiNative.prototype.querySelector;\n/**\n * @function\n * @param {string} selector\n * @return {!NodeList<!Element>}\n */\n\nDomApiNative.prototype.querySelectorAll;\n/** @type {?Node} */\n\nDomApiNative.prototype.parentNode;\n/** @type {?Node} */\n\nDomApiNative.prototype.firstChild;\n/** @type {?Node} */\n\nDomApiNative.prototype.lastChild;\n/** @type {?Node} */\n\nDomApiNative.prototype.nextSibling;\n/** @type {?Node} */\n\nDomApiNative.prototype.previousSibling;\n/** @type {?HTMLElement} */\n\nDomApiNative.prototype.firstElementChild;\n/** @type {?HTMLElement} */\n\nDomApiNative.prototype.lastElementChild;\n/** @type {?HTMLElement} */\n\nDomApiNative.prototype.nextElementSibling;\n/** @type {?HTMLElement} */\n\nDomApiNative.prototype.previousElementSibling;\n/** @type {!Array<!Node>} */\n\nDomApiNative.prototype.childNodes;\n/** @type {!Array<!HTMLElement>} */\n\nDomApiNative.prototype.children;\n/** @type {?DOMTokenList} */\n\nDomApiNative.prototype.classList;\n/** @type {string} */\n\nDomApiNative.prototype.textContent;\n/** @type {string} */\n\nDomApiNative.prototype.innerHTML;\nvar DomApiImpl = DomApiNative;\n\nif (window['ShadyDOM'] && window['ShadyDOM']['inUse'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['Wrapper']) {\n  /**\n   * @private\n   * @extends {HTMLElement}\n   */\n  class Wrapper extends window['ShadyDOM']['Wrapper'] {} // copy bespoke API onto wrapper\n\n\n  Object.getOwnPropertyNames(DomApiNative.prototype).forEach(prop => {\n    if (prop != 'activeElement') {\n      Wrapper.prototype[prop] = DomApiNative.prototype[prop];\n    }\n  }); // Note, `classList` is here only for legacy compatibility since it does not\n  // trigger distribution in v1 Shadow DOM.\n\n  forwardReadOnlyProperties(Wrapper.prototype, ['classList']);\n  DomApiImpl = Wrapper;\n  Object.defineProperties(EventApi.prototype, {\n    localTarget: {\n      get() {\n        return this.event.currentTarget;\n      },\n\n      configurable: true\n    },\n    path: {\n      get() {\n        return window['ShadyDOM']['composedPath'](this.event);\n      },\n\n      configurable: true\n    }\n  });\n} else {\n  // Methods that can provoke distribution or must return the logical, not\n  // composed tree.\n  forwardMethods(DomApiNative.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']); // Properties that should return the logical, not composed tree. Note, `classList`\n  // is here only for legacy compatibility since it does not trigger distribution\n  // in v1 Shadow DOM.\n\n  forwardReadOnlyProperties(DomApiNative.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);\n  forwardProperties(DomApiNative.prototype, ['textContent', 'innerHTML']);\n}\n\nexport var DomApi = DomApiImpl;\n/**\n * Legacy DOM and Event manipulation API wrapper factory used to abstract\n * differences between native Shadow DOM and \"Shady DOM\" when polyfilling on\n * older browsers.\n *\n * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and\n * in the majority of cases simply facades directly to the standard native\n * API.\n *\n * @summary Legacy DOM and Event manipulation API wrapper factory used to\n * abstract differences between native Shadow DOM and \"Shady DOM.\"\n * @param {(Node|Event|DomApiNative|EventApi)=} obj Node or event to operate on\n * @return {!DomApiNative|!EventApi} Wrapper providing either node API or event API\n */\n\nexport var dom = function (obj) {\n  obj = obj || document;\n\n  if (obj instanceof DomApiImpl) {\n    return (\n      /** @type {!DomApi} */\n      obj\n    );\n  }\n\n  if (obj instanceof EventApi) {\n    return (\n      /** @type {!EventApi} */\n      obj\n    );\n  }\n\n  var helper = obj['__domApi'];\n\n  if (!helper) {\n    if (obj instanceof Event) {\n      helper = new EventApi(obj);\n    } else {\n      helper = new DomApiImpl(\n      /** @type {Node} */\n      obj);\n    }\n\n    obj['__domApi'] = helper;\n  }\n\n  return helper;\n};"
    },
    {
     "id": 32,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/spacing.js?babel-target=es6",
     "source": "import './version.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<custom-style>\n  <style>\n    html {\n      /* Square */\n      --lumo-space-xs: 0.25rem;\n      --lumo-space-s: 0.5rem;\n      --lumo-space-m: 1rem;\n      --lumo-space-l: 1.5rem;\n      --lumo-space-xl: 2.5rem;\n\n      /* Wide */\n      --lumo-space-wide-xs: calc(var(--lumo-space-xs) / 2) var(--lumo-space-xs);\n      --lumo-space-wide-s: calc(var(--lumo-space-s) / 2) var(--lumo-space-s);\n      --lumo-space-wide-m: calc(var(--lumo-space-m) / 2) var(--lumo-space-m);\n      --lumo-space-wide-l: calc(var(--lumo-space-l) / 2) var(--lumo-space-l);\n      --lumo-space-wide-xl: calc(var(--lumo-space-xl) / 2) var(--lumo-space-xl);\n\n      /* Tall */\n      --lumo-space-tall-xs: var(--lumo-space-xs) calc(var(--lumo-space-xs) / 2);\n      --lumo-space-tall-s: var(--lumo-space-s) calc(var(--lumo-space-s) / 2);\n      --lumo-space-tall-m: var(--lumo-space-m) calc(var(--lumo-space-m) / 2);\n      --lumo-space-tall-l: var(--lumo-space-l) calc(var(--lumo-space-l) / 2);\n      --lumo-space-tall-xl: var(--lumo-space-xl) calc(var(--lumo-space-xl) / 2);\n    }\n  </style>\n</custom-style>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 34,
     "name": "../node_modules/@polymer/polymer/lib/utils/flush.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\n/* eslint-disable no-unused-vars */\n\nimport { Debouncer } from '../utils/debounce.js'; // used in type annotations\n\n/* eslint-enable no-unused-vars */\n\nimport { flushDebouncers } from '../utils/debounce.js'; // used in type annotations\n\nexport { enqueueDebouncer } from '../utils/debounce.js'; // used in type annotations\n\n/**\n * Forces several classes of asynchronously queued tasks to flush:\n * - Debouncers added via `enqueueDebouncer`\n * - ShadyDOM distribution\n *\n * @return {void}\n */\n\nexport var flush = function () {\n  var shadyDOM, debouncers;\n\n  do {\n    shadyDOM = window.ShadyDOM && ShadyDOM.flush();\n\n    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {\n      window.ShadyCSS.ScopingShim.flush();\n    }\n\n    debouncers = flushDebouncers();\n  } while (shadyDOM || debouncers);\n};"
    },
    {
     "id": 36,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/color.js?babel-target=es6",
     "source": "import './version.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nimport '@polymer/polymer/lib/elements/dom-module.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<custom-style>\n  <style>\n    html {\n      /* Base (background) */\n      --lumo-base-color: #FFF;\n\n      /* Tint */\n      --lumo-tint-5pct: hsla(0, 0%, 100%, 0.3);\n      --lumo-tint-10pct: hsla(0, 0%, 100%, 0.37);\n      --lumo-tint-20pct: hsla(0, 0%, 100%, 0.44);\n      --lumo-tint-30pct: hsla(0, 0%, 100%, 0.5);\n      --lumo-tint-40pct: hsla(0, 0%, 100%, 0.57);\n      --lumo-tint-50pct: hsla(0, 0%, 100%, 0.64);\n      --lumo-tint-60pct: hsla(0, 0%, 100%, 0.7);\n      --lumo-tint-70pct: hsla(0, 0%, 100%, 0.77);\n      --lumo-tint-80pct: hsla(0, 0%, 100%, 0.84);\n      --lumo-tint-90pct: hsla(0, 0%, 100%, 0.9);\n      --lumo-tint: #FFF;\n\n      /* Shade */\n      --lumo-shade-5pct: hsla(214, 61%, 25%, 0.05);\n      --lumo-shade-10pct: hsla(214, 57%, 24%, 0.1);\n      --lumo-shade-20pct: hsla(214, 53%, 23%, 0.16);\n      --lumo-shade-30pct: hsla(214, 50%, 22%, 0.26);\n      --lumo-shade-40pct: hsla(214, 47%, 21%, 0.38);\n      --lumo-shade-50pct: hsla(214, 45%, 20%, 0.5);\n      --lumo-shade-60pct: hsla(214, 43%, 19%, 0.61);\n      --lumo-shade-70pct: hsla(214, 42%, 18%, 0.72);\n      --lumo-shade-80pct: hsla(214, 41%, 17%, 0.83);\n      --lumo-shade-90pct: hsla(214, 40%, 16%, 0.94);\n      --lumo-shade: hsl(214, 35%, 15%);\n\n      /* Contrast */\n      --lumo-contrast-5pct: var(--lumo-shade-5pct);\n      --lumo-contrast-10pct: var(--lumo-shade-10pct);\n      --lumo-contrast-20pct: var(--lumo-shade-20pct);\n      --lumo-contrast-30pct: var(--lumo-shade-30pct);\n      --lumo-contrast-40pct: var(--lumo-shade-40pct);\n      --lumo-contrast-50pct: var(--lumo-shade-50pct);\n      --lumo-contrast-60pct: var(--lumo-shade-60pct);\n      --lumo-contrast-70pct: var(--lumo-shade-70pct);\n      --lumo-contrast-80pct: var(--lumo-shade-80pct);\n      --lumo-contrast-90pct: var(--lumo-shade-90pct);\n      --lumo-contrast: var(--lumo-shade);\n\n      /* Text */\n      --lumo-header-text-color: var(--lumo-contrast);\n      --lumo-body-text-color: var(--lumo-contrast-90pct);\n      --lumo-secondary-text-color: var(--lumo-contrast-70pct);\n      --lumo-tertiary-text-color: var(--lumo-contrast-50pct);\n      --lumo-disabled-text-color: var(--lumo-contrast-30pct);\n\n      /* Primary */\n      --lumo-primary-color: hsl(214, 90%, 52%);\n      --lumo-primary-color-50pct: hsla(214, 90%, 52%, 0.5);\n      --lumo-primary-color-10pct: hsla(214, 90%, 52%, 0.1);\n      --lumo-primary-text-color: var(--lumo-primary-color);\n      --lumo-primary-contrast-color: #FFF;\n\n      /* Error */\n      --lumo-error-color: hsl(3, 100%, 61%);\n      --lumo-error-color-50pct: hsla(3, 100%, 60%, 0.5);\n      --lumo-error-color-10pct: hsla(3, 100%, 60%, 0.1);\n      --lumo-error-text-color: hsl(3, 92%, 53%);\n      --lumo-error-contrast-color: #FFF;\n\n      /* Success */\n      --lumo-success-color: hsl(145, 80%, 42%); /* hsl(144,82%,37%); */\n      --lumo-success-color-50pct: hsla(145, 76%, 44%, 0.55);\n      --lumo-success-color-10pct: hsla(145, 76%, 44%, 0.12);\n      --lumo-success-text-color: hsl(145, 100%, 32%);\n      --lumo-success-contrast-color: #FFF;\n    }\n  </style>\n</custom-style><dom-module id=\"lumo-color\">\n  <template>\n    <style>\n      [theme~=\"dark\"] {\n        /* Base (background) */\n        --lumo-base-color: hsl(214, 35%, 21%);\n\n        /* Tint */\n        --lumo-tint-5pct: hsla(214, 65%, 85%, 0.06);\n        --lumo-tint-10pct: hsla(214, 60%, 80%, 0.14);\n        --lumo-tint-20pct: hsla(214, 64%, 82%, 0.23);\n        --lumo-tint-30pct: hsla(214, 69%, 84%, 0.32);\n        --lumo-tint-40pct: hsla(214, 73%, 86%, 0.41);\n        --lumo-tint-50pct: hsla(214, 78%, 88%, 0.5);\n        --lumo-tint-60pct: hsla(214, 82%, 90%, 0.6);\n        --lumo-tint-70pct: hsla(214, 87%, 92%, 0.7);\n        --lumo-tint-80pct: hsla(214, 91%, 94%, 0.8);\n        --lumo-tint-90pct: hsla(214, 96%, 96%, 0.9);\n        --lumo-tint: hsl(214, 100%, 98%);\n\n        /* Shade */\n        --lumo-shade-5pct: hsla(214, 0%, 0%, 0.07);\n        --lumo-shade-10pct: hsla(214, 4%, 2%, 0.15);\n        --lumo-shade-20pct: hsla(214, 8%, 4%, 0.23);\n        --lumo-shade-30pct: hsla(214, 12%, 6%, 0.32);\n        --lumo-shade-40pct: hsla(214, 16%, 8%, 0.41);\n        --lumo-shade-50pct: hsla(214, 20%, 10%, 0.5);\n        --lumo-shade-60pct: hsla(214, 24%, 12%, 0.6);\n        --lumo-shade-70pct: hsla(214, 28%, 13%, 0.7);\n        --lumo-shade-80pct: hsla(214, 32%, 13%, 0.8);\n        --lumo-shade-90pct: hsla(214, 33%, 13%, 0.9);\n        --lumo-shade: hsl(214, 33%, 13%);\n\n        /* Contrast */\n        --lumo-contrast-5pct: var(--lumo-tint-5pct);\n        --lumo-contrast-10pct: var(--lumo-tint-10pct);\n        --lumo-contrast-20pct: var(--lumo-tint-20pct);\n        --lumo-contrast-30pct: var(--lumo-tint-30pct);\n        --lumo-contrast-40pct: var(--lumo-tint-40pct);\n        --lumo-contrast-50pct: var(--lumo-tint-50pct);\n        --lumo-contrast-60pct: var(--lumo-tint-60pct);\n        --lumo-contrast-70pct: var(--lumo-tint-70pct);\n        --lumo-contrast-80pct: var(--lumo-tint-80pct);\n        --lumo-contrast-90pct: var(--lumo-tint-90pct);\n        --lumo-contrast: var(--lumo-tint);\n\n        /* Text */\n        --lumo-header-text-color: var(--lumo-contrast);\n        --lumo-body-text-color: var(--lumo-contrast-90pct);\n        --lumo-secondary-text-color: var(--lumo-contrast-70pct);\n        --lumo-tertiary-text-color: var(--lumo-contrast-50pct);\n        --lumo-disabled-text-color: var(--lumo-contrast-30pct);\n\n        /* Primary */\n        --lumo-primary-color: hsl(214, 86%, 55%);\n        --lumo-primary-color-50pct: hsla(214, 86%, 55%, 0.5);\n        --lumo-primary-color-10pct: hsla(214, 90%, 63%, 0.1);\n        --lumo-primary-text-color: hsl(214, 100%, 70%);\n        --lumo-primary-contrast-color: #FFF;\n\n        /* Error */\n        --lumo-error-color: hsl(3, 90%, 63%);\n        --lumo-error-color-50pct: hsla(3, 90%, 63%, 0.5);\n        --lumo-error-color-10pct: hsla(3, 90%, 63%, 0.1);\n        --lumo-error-text-color: hsl(3, 100%, 67%);\n\n        /* Success */\n        --lumo-success-color: hsl(145, 65%, 42%);\n        --lumo-success-color-50pct: hsla(145, 65%, 42%, 0.5);\n        --lumo-success-color-10pct: hsla(145, 65%, 42%, 0.1);\n        --lumo-success-text-color: hsl(145, 85%, 47%);\n      }\n\n      html {\n        color: var(--lumo-body-text-color);\n        background-color: var(--lumo-base-color);\n      }\n\n      [theme~=\"dark\"] {\n        color: var(--lumo-body-text-color);\n        background-color: var(--lumo-base-color);\n      }\n\n      h1,\n      h2,\n      h3,\n      h4,\n      h5,\n      h6 {\n        color: var(--lumo-header-text-color);\n      }\n\n      a {\n        color: var(--lumo-primary-text-color);\n      }\n\n      blockquote {\n        color: var(--lumo-secondary-text-color);\n      }\n\n      code,\n      pre {\n        background-color: var(--lumo-contrast-10pct);\n        border-radius: var(--lumo-border-radius-m);\n      }\n    </style>\n  </template>\n</dom-module><dom-module id=\"lumo-color-legacy\">\n  <template>\n    <style include=\"lumo-color\">\n      :host {\n        color: var(--lumo-body-text-color) !important;\n        background-color: var(--lumo-base-color) !important;\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);\n/* Only needed for IE11 when you want to use the dark palette inside the light palette */\n\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\n\n;"
    },
    {
     "id": 38,
     "name": "../node_modules/@webcomponents/shadycss/src/style-settings.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n'use strict';\n\nexport var nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);\nvar nativeCssVariables_;\n/**\n * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings\n */\n\nfunction calcCssVariables(settings) {\n  if (settings && settings['shimcssproperties']) {\n    nativeCssVariables_ = false;\n  } else {\n    // chrome 49 has semi-working css vars, check if box-shadow works\n    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n    // However, shim css custom properties are only supported with ShadyDOM enabled,\n    // so fall back on native if we do not detect ShadyDOM\n    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/\n    nativeCssVariables_ = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\\/601|Edge\\/15/) && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));\n  }\n}\n/** @type {string | undefined} */\n\n\nexport var cssBuild;\n\nif (window.ShadyCSS && window.ShadyCSS.cssBuild !== undefined) {\n  cssBuild = window.ShadyCSS.cssBuild;\n}\n/** @type {boolean} */\n\n\nexport var disableRuntime = Boolean(window.ShadyCSS && window.ShadyCSS.disableRuntime);\n\nif (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {\n  nativeCssVariables_ = window.ShadyCSS.nativeCss;\n} else if (window.ShadyCSS) {\n  calcCssVariables(window.ShadyCSS); // reset window variable to let ShadyCSS API take its place\n\n  window.ShadyCSS = undefined;\n} else {\n  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);\n} // Hack for type error under new type inference which doesn't like that\n// nativeCssVariables is updated in a function and assigns the type\n// `function(): ?` instead of `boolean`.\n\n\nexport var nativeCssVariables =\n/** @type {boolean} */\nnativeCssVariables_;"
    },
    {
     "id": 40,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/style.js?babel-target=es6",
     "source": "import './version.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<custom-style>\n  <style>\n    html {\n      /* Border radius */\n      --lumo-border-radius-s: 0.25em; /* Checkbox, badge, date-picker year indicator, etc */\n      --lumo-border-radius-m: var(--lumo-border-radius, 0.25em); /* Button, text field, menu overlay, etc */\n      --lumo-border-radius-l: 0.5em; /* Dialog, notification, etc */\n      --lumo-border-radius: 0.25em; /* Deprecated */\n\n      /* Shadow */\n      --lumo-box-shadow-xs: 0 1px 4px -1px var(--lumo-shade-50pct);\n      --lumo-box-shadow-s: 0 2px 4px -1px var(--lumo-shade-20pct), 0 3px 12px -1px var(--lumo-shade-30pct);\n      --lumo-box-shadow-m: 0 2px 6px -1px var(--lumo-shade-20pct), 0 8px 24px -4px var(--lumo-shade-40pct);\n      --lumo-box-shadow-l: 0 3px 18px -2px var(--lumo-shade-20pct), 0 12px 48px -6px var(--lumo-shade-40pct);\n      --lumo-box-shadow-xl: 0 4px 24px -3px var(--lumo-shade-20pct), 0 18px 64px -8px var(--lumo-shade-40pct);\n\n      /* Clickable element cursor */\n      --lumo-clickable-cursor: default;\n    }\n  </style>\n</custom-style>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 42,
     "name": "../node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\nimport { calculateSplices } from './array-splice.js';\nimport { microTask } from './async.js';\nimport { wrap } from './wrap.js';\n/**\n * Returns true if `node` is a slot element\n * @param {!Node} node Node to test.\n * @return {boolean} Returns true if the given `node` is a slot\n * @private\n */\n\nfunction isSlot(node) {\n  return node.localName === 'slot';\n}\n/**\n * Class that listens for changes (additions or removals) to\n * \"flattened nodes\" on a given `node`. The list of flattened nodes consists\n * of a node's children and, for any children that are `<slot>` elements,\n * the expanded flattened list of `assignedNodes`.\n * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n * and the `<slot>` has one `<div>` assigned to it, then the flattened\n * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n * `<slot>` elements assigned to it, these are flattened as well.\n *\n * The provided `callback` is called whenever any change to this list\n * of flattened nodes occurs, where an addition or removal of a node is\n * considered a change. The `callback` is called with one argument, an object\n * containing an array of any `addedNodes` and `removedNodes`.\n *\n * Note: the callback is called asynchronous to any changes\n * at a microtask checkpoint. This is because observation is performed using\n * `MutationObserver` and the `<slot>` element's `slotchange` event which\n * are asynchronous.\n *\n * An example:\n * ```js\n * class TestSelfObserve extends PolymerElement {\n *   static get is() { return 'test-self-observe';}\n *   connectedCallback() {\n *     super.connectedCallback();\n *     this._observer = new FlattenedNodesObserver(this, (info) => {\n *       this.info = info;\n *     });\n *   }\n *   disconnectedCallback() {\n *     super.disconnectedCallback();\n *     this._observer.disconnect();\n *   }\n * }\n * customElements.define(TestSelfObserve.is, TestSelfObserve);\n * ```\n *\n * @summary Class that listens for changes (additions or removals) to\n * \"flattened nodes\" on a given `node`.\n * @implements {PolymerDomApi.ObserveHandle}\n */\n\n\nexport var FlattenedNodesObserver = class {\n  /**\n   * Returns the list of flattened nodes for the given `node`.\n   * This list consists of a node's children and, for any children\n   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.\n   * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n   * and the `<slot>` has one `<div>` assigned to it, then the flattened\n   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n   * `<slot>` elements assigned to it, these are flattened as well.\n   *\n   * @param {!HTMLElement|!HTMLSlotElement} node The node for which to\n   *      return the list of flattened nodes.\n   * @return {!Array<!Node>} The list of flattened nodes for the given `node`.\n   * @nocollapse See https://github.com/google/closure-compiler/issues/2763\n   */\n  // eslint-disable-next-line\n  static getFlattenedNodes(node) {\n    var wrapped = wrap(node);\n\n    if (isSlot(node)) {\n      node =\n      /** @type {!HTMLSlotElement} */\n      node; // eslint-disable-line no-self-assign\n\n      return wrapped.assignedNodes({\n        flatten: true\n      });\n    } else {\n      return Array.from(wrapped.childNodes).map(node => {\n        if (isSlot(node)) {\n          node =\n          /** @type {!HTMLSlotElement} */\n          node; // eslint-disable-line no-self-assign\n\n          return wrap(node).assignedNodes({\n            flatten: true\n          });\n        } else {\n          return [node];\n        }\n      }).reduce((a, b) => a.concat(b), []);\n    }\n  }\n  /**\n   * @param {!HTMLElement} target Node on which to listen for changes.\n   * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions\n   * or removals from the target's list of flattened nodes.\n   */\n  // eslint-disable-next-line\n\n\n  constructor(target, callback) {\n    /**\n     * @type {MutationObserver}\n     * @private\n     */\n    this._shadyChildrenObserver = null;\n    /**\n     * @type {MutationObserver}\n     * @private\n     */\n\n    this._nativeChildrenObserver = null;\n    this._connected = false;\n    /**\n     * @type {!HTMLElement}\n     * @private\n     */\n\n    this._target = target;\n    this.callback = callback;\n    this._effectiveNodes = [];\n    this._observer = null;\n    this._scheduled = false;\n    /**\n     * @type {function()}\n     * @private\n     */\n\n    this._boundSchedule = () => {\n      this._schedule();\n    };\n\n    this.connect();\n\n    this._schedule();\n  }\n  /**\n   * Activates an observer. This method is automatically called when\n   * a `FlattenedNodesObserver` is created. It should only be called to\n   * re-activate an observer that has been deactivated via the `disconnect` method.\n   *\n   * @return {void}\n   */\n\n\n  connect() {\n    if (isSlot(this._target)) {\n      this._listenSlots([this._target]);\n    } else if (wrap(this._target).children) {\n      this._listenSlots(\n      /** @type {!NodeList<!Node>} */\n      wrap(this._target).children);\n\n      if (window.ShadyDOM) {\n        this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, mutations => {\n          this._processMutations(mutations);\n        });\n      } else {\n        this._nativeChildrenObserver = new MutationObserver(mutations => {\n          this._processMutations(mutations);\n        });\n\n        this._nativeChildrenObserver.observe(this._target, {\n          childList: true\n        });\n      }\n    }\n\n    this._connected = true;\n  }\n  /**\n   * Deactivates the flattened nodes observer. After calling this method\n   * the observer callback will not be called when changes to flattened nodes\n   * occur. The `connect` method may be subsequently called to reactivate\n   * the observer.\n   *\n   * @return {void}\n   * @override\n   */\n\n\n  disconnect() {\n    if (isSlot(this._target)) {\n      this._unlistenSlots([this._target]);\n    } else if (wrap(this._target).children) {\n      this._unlistenSlots(\n      /** @type {!NodeList<!Node>} */\n      wrap(this._target).children);\n\n      if (window.ShadyDOM && this._shadyChildrenObserver) {\n        ShadyDOM.unobserveChildren(this._shadyChildrenObserver);\n        this._shadyChildrenObserver = null;\n      } else if (this._nativeChildrenObserver) {\n        this._nativeChildrenObserver.disconnect();\n\n        this._nativeChildrenObserver = null;\n      }\n    }\n\n    this._connected = false;\n  }\n  /**\n   * @return {void}\n   * @private\n   */\n\n\n  _schedule() {\n    if (!this._scheduled) {\n      this._scheduled = true;\n      microTask.run(() => this.flush());\n    }\n  }\n  /**\n   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer\n   * @return {void}\n   * @private\n   */\n\n\n  _processMutations(mutations) {\n    this._processSlotMutations(mutations);\n\n    this.flush();\n  }\n  /**\n   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer\n   * @return {void}\n   * @private\n   */\n\n\n  _processSlotMutations(mutations) {\n    if (mutations) {\n      for (var i = 0; i < mutations.length; i++) {\n        var mutation = mutations[i];\n\n        if (mutation.addedNodes) {\n          this._listenSlots(mutation.addedNodes);\n        }\n\n        if (mutation.removedNodes) {\n          this._unlistenSlots(mutation.removedNodes);\n        }\n      }\n    }\n  }\n  /**\n   * Flushes the observer causing any pending changes to be immediately\n   * delivered the observer callback. By default these changes are delivered\n   * asynchronously at the next microtask checkpoint.\n   *\n   * @return {boolean} Returns true if any pending changes caused the observer\n   * callback to run.\n   */\n\n\n  flush() {\n    if (!this._connected) {\n      return false;\n    }\n\n    if (window.ShadyDOM) {\n      ShadyDOM.flush();\n    }\n\n    if (this._nativeChildrenObserver) {\n      this._processSlotMutations(this._nativeChildrenObserver.takeRecords());\n    } else if (this._shadyChildrenObserver) {\n      this._processSlotMutations(this._shadyChildrenObserver.takeRecords());\n    }\n\n    this._scheduled = false;\n    var info = {\n      target: this._target,\n      addedNodes: [],\n      removedNodes: []\n    };\n    var newNodes = this.constructor.getFlattenedNodes(this._target);\n    var splices = calculateSplices(newNodes, this._effectiveNodes); // process removals\n\n    for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {\n      for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\n        info.removedNodes.push(n);\n      }\n    } // process adds\n\n\n    for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {\n      for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {\n        info.addedNodes.push(newNodes[_j]);\n      }\n    } // update cache\n\n\n    this._effectiveNodes = newNodes;\n    var didFlush = false;\n\n    if (info.addedNodes.length || info.removedNodes.length) {\n      didFlush = true;\n      this.callback.call(this._target, info);\n    }\n\n    return didFlush;\n  }\n  /**\n   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change\n   * @return {void}\n   * @private\n   */\n\n\n  _listenSlots(nodeList) {\n    for (var i = 0; i < nodeList.length; i++) {\n      var n = nodeList[i];\n\n      if (isSlot(n)) {\n        n.addEventListener('slotchange', this._boundSchedule);\n      }\n    }\n  }\n  /**\n   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change\n   * @return {void}\n   * @private\n   */\n\n\n  _unlistenSlots(nodeList) {\n    for (var i = 0; i < nodeList.length; i++) {\n      var n = nodeList[i];\n\n      if (isSlot(n)) {\n        n.removeEventListener('slotchange', this._boundSchedule);\n      }\n    }\n  }\n\n};"
    },
    {
     "id": 44,
     "name": "../node_modules/@vaadin/vaadin-date-picker/src/vaadin-date-picker-helper.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/** @private */\nexport var DatePickerHelper = class VaadinDatePickerHelper {\n  /**\n   * Get ISO 8601 week number for the given date.\n   *\n   * @param {Date} Date object\n   * @return {Number} Week number\n   */\n  static _getISOWeekNumber(date) {\n    // Ported from Vaadin Framework method com.vaadin.client.DateTimeService.getISOWeekNumber(date)\n    var dayOfWeek = date.getDay(); // 0 == sunday\n    // ISO 8601 use weeks that start on monday so we use\n    // mon=1,tue=2,...sun=7;\n\n    if (dayOfWeek === 0) {\n      dayOfWeek = 7;\n    } // Find nearest thursday (defines the week in ISO 8601). The week number\n    // for the nearest thursday is the same as for the target date.\n\n\n    var nearestThursdayDiff = 4 - dayOfWeek; // 4 is thursday\n\n    var nearestThursday = new Date(date.getTime() + nearestThursdayDiff * 24 * 3600 * 1000);\n    var firstOfJanuary = new Date(0, 0);\n    firstOfJanuary.setFullYear(nearestThursday.getFullYear());\n    var timeDiff = nearestThursday.getTime() - firstOfJanuary.getTime(); // Rounding the result, as the division doesn't result in an integer\n    // when the given date is inside daylight saving time period.\n\n    var daysSinceFirstOfJanuary = Math.round(timeDiff / (24 * 3600 * 1000));\n    return Math.floor(daysSinceFirstOfJanuary / 7 + 1);\n  }\n  /**\n   * Check if two dates are equal.\n   *\n   * @param {Date} date1\n   * @param {Date} date2\n   * @return {Boolean} True if the given date objects refer to the same date\n   */\n\n\n  static _dateEquals(date1, date2) {\n    return date1 instanceof Date && date2 instanceof Date && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();\n  }\n  /**\n   * Check if the given date is in the range of allowed dates.\n   *\n   * @param {Date} date The date to check\n   * @param {Date} min Range start\n   * @param {Date} max Range end\n   * @return {Boolean} True if the date is in the range\n   */\n\n\n  static _dateAllowed(date, min, max) {\n    return (!min || date >= min) && (!max || date <= max);\n  }\n  /**\n   * Get closest date from array of dates.\n   *\n   * @param {Date} date The date to compare dates with\n   * @param {Array} dates Array of date objects\n   * @return {Date} Closest date\n   */\n\n\n  static _getClosestDate(date, dates) {\n    return dates.filter(date => date !== undefined).reduce((closestDate, candidate) => {\n      if (!candidate) {\n        return closestDate;\n      }\n\n      if (!closestDate) {\n        return candidate;\n      }\n\n      var candidateDiff = Math.abs(date.getTime() - candidate.getTime());\n      var closestDateDiff = Math.abs(closestDate.getTime() - date.getTime());\n      return candidateDiff < closestDateDiff ? candidate : closestDate;\n    });\n  }\n  /**\n   * Extracts the basic component parts of a date (day, month and year)\n   * to the expected format.\n   */\n\n\n  static _extractDateParts(date) {\n    return {\n      day: date.getDate(),\n      month: date.getMonth(),\n      year: date.getFullYear()\n    };\n  }\n\n};"
    },
    {
     "id": 46,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/typography.js?babel-target=es6",
     "source": "import './version.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nimport '@polymer/polymer/lib/elements/dom-module.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<custom-style>\n  <style>\n    html {\n      /* Font families */\n      --lumo-font-family: -apple-system, BlinkMacSystemFont, \"Roboto\", \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n\n      /* Font sizes */\n      --lumo-font-size-xxs: .75rem;\n      --lumo-font-size-xs: .8125rem;\n      --lumo-font-size-s: .875rem;\n      --lumo-font-size-m: 1rem;\n      --lumo-font-size-l: 1.125rem;\n      --lumo-font-size-xl: 1.375rem;\n      --lumo-font-size-xxl: 1.75rem;\n      --lumo-font-size-xxxl: 2.5rem;\n\n      /* Line heights */\n      --lumo-line-height-xs: 1.25;\n      --lumo-line-height-s: 1.375;\n      --lumo-line-height-m: 1.625;\n    }\n\n  </style>\n</custom-style><dom-module id=\"lumo-typography\">\n  <template>\n    <style>\n      html {\n        font-family: var(--lumo-font-family);\n        font-size: var(--lumo-font-size, var(--lumo-font-size-m));\n        line-height: var(--lumo-line-height-m);\n        -webkit-text-size-adjust: 100%;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n      }\n\n      /* Cant combine with the above selector because that doesnt work in browsers without native shadow dom */\n      :host {\n        font-family: var(--lumo-font-family);\n        font-size: var(--lumo-font-size, var(--lumo-font-size-m));\n        line-height: var(--lumo-line-height-m);\n        -webkit-text-size-adjust: 100%;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n      }\n\n      small,\n      [theme~=\"font-size-s\"] {\n        font-size: var(--lumo-font-size-s);\n        line-height: var(--lumo-line-height-s);\n      }\n\n      [theme~=\"font-size-xs\"] {\n        font-size: var(--lumo-font-size-xs);\n        line-height: var(--lumo-line-height-xs);\n      }\n\n      h1,\n      h2,\n      h3,\n      h4,\n      h5,\n      h6 {\n        font-weight: 600;\n        line-height: var(--lumo-line-height-xs);\n        margin-top: 1.25em;\n      }\n\n      h1 {\n        font-size: var(--lumo-font-size-xxxl);\n        margin-bottom: 0.75em;\n      }\n\n      h2 {\n        font-size: var(--lumo-font-size-xxl);\n        margin-bottom: 0.5em;\n      }\n\n      h3 {\n        font-size: var(--lumo-font-size-xl);\n        margin-bottom: 0.5em;\n      }\n\n      h4 {\n        font-size: var(--lumo-font-size-l);\n        margin-bottom: 0.5em;\n      }\n\n      h5 {\n        font-size: var(--lumo-font-size-m);\n        margin-bottom: 0.25em;\n      }\n\n      h6 {\n        font-size: var(--lumo-font-size-xs);\n        margin-bottom: 0;\n        text-transform: uppercase;\n        letter-spacing: 0.03em;\n      }\n\n      p,\n      blockquote {\n        margin-top: 0.5em;\n        margin-bottom: 0.75em;\n      }\n\n      a {\n        text-decoration: none;\n      }\n\n      a:hover {\n        text-decoration: underline;\n      }\n\n      hr {\n        display: block;\n        align-self: stretch;\n        height: 1px;\n        border: 0;\n        padding: 0;\n        margin: var(--lumo-space-s) calc(var(--lumo-border-radius-m) / 2);\n        background-color: var(--lumo-contrast-10pct);\n      }\n\n      blockquote {\n        border-left: 2px solid var(--lumo-contrast-30pct);\n      }\n\n      b,\n      strong {\n        font-weight: 600;\n      }\n\n      /* RTL specific styles */\n\n      blockquote[dir=\"rtl\"] {\n        border-left: none;\n        border-right: 2px solid var(--lumo-contrast-30pct);\n      }\n\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 48,
     "name": "../node_modules/@polymer/polymer/lib/utils/render-status.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module for scheduling flushable pre-render and post-render tasks.\n *\n * @summary Module for scheduling flushable pre-render and post-render tasks.\n */\nimport './boot.js';\nvar scheduled = false;\nvar beforeRenderQueue = [];\nvar afterRenderQueue = [];\n\nfunction schedule() {\n  scheduled = true; // before next render\n\n  requestAnimationFrame(function () {\n    scheduled = false;\n    flushQueue(beforeRenderQueue); // after the render\n\n    setTimeout(function () {\n      runQueue(afterRenderQueue);\n    });\n  });\n}\n\nfunction flushQueue(queue) {\n  while (queue.length) {\n    callMethod(queue.shift());\n  }\n}\n\nfunction runQueue(queue) {\n  for (var i = 0, l = queue.length; i < l; i++) {\n    callMethod(queue.shift());\n  }\n}\n\nfunction callMethod(info) {\n  var context = info[0];\n  var callback = info[1];\n  var args = info[2];\n\n  try {\n    callback.apply(context, args);\n  } catch (e) {\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n/**\n * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`\n * tasks.\n *\n * @return {void}\n */\n\n\nexport function flush() {\n  while (beforeRenderQueue.length || afterRenderQueue.length) {\n    flushQueue(beforeRenderQueue);\n    flushQueue(afterRenderQueue);\n  }\n\n  scheduled = false;\n}\n/**\n * Enqueues a callback which will be run before the next render, at\n * `requestAnimationFrame` timing.\n *\n * This method is useful for enqueuing work that requires DOM measurement,\n * since measurement may not be reliable in custom element callbacks before\n * the first render, as well as for batching measurement tasks in general.\n *\n * Tasks in this queue may be flushed by calling `flush()`.\n *\n * @param {*} context Context object the callback function will be bound to\n * @param {function(...*):void} callback Callback function\n * @param {!Array=} args An array of arguments to call the callback function with\n * @return {void}\n */\n\nexport function beforeNextRender(context, callback, args) {\n  if (!scheduled) {\n    schedule();\n  }\n\n  beforeRenderQueue.push([context, callback, args]);\n}\n/**\n * Enqueues a callback which will be run after the next render, equivalent\n * to one task (`setTimeout`) after the next `requestAnimationFrame`.\n *\n * This method is useful for tuning the first-render performance of an\n * element or application by deferring non-critical work until after the\n * first paint.  Typical non-render-critical work may include adding UI\n * event listeners and aria attributes.\n *\n * @param {*} context Context object the callback function will be bound to\n * @param {function(...*):void} callback Callback function\n * @param {!Array=} args An array of arguments to call the callback function with\n * @return {void}\n */\n\nexport function afterNextRender(context, callback, args) {\n  if (!scheduled) {\n    schedule();\n  }\n\n  afterRenderQueue.push([context, callback, args]);\n}"
    },
    {
     "id": 50,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/sizing.js?babel-target=es6",
     "source": "import './version.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<custom-style>\n  <style>\n    html {\n      --lumo-size-xs: 1.625rem;\n      --lumo-size-s: 1.875rem;\n      --lumo-size-m: 2.25rem;\n      --lumo-size-l: 2.75rem;\n      --lumo-size-xl: 3.5rem;\n\n      /* Icons */\n      --lumo-icon-size-s: 1.25em;\n      --lumo-icon-size-m: 1.5em;\n      --lumo-icon-size-l: 2.25em;\n      /* For backwards compatibility */\n      --lumo-icon-size: var(--lumo-icon-size-m);\n    }\n  </style>\n</custom-style>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 52,
     "name": "../node_modules/@polymer/polymer/lib/utils/gestures.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * Module for adding listeners to a node for the following normalized\n * cross-platform \"gesture\" events:\n * - `down` - mouse or touch went down\n * - `up` - mouse or touch went up\n * - `tap` - mouse click or finger tap\n * - `track` - mouse drag or touch move\n *\n * @summary Module for adding cross-platform gesture event listeners.\n */\nimport './boot.js';\nimport { timeOut, microTask } from './async.js';\nimport { Debouncer } from './debounce.js';\nimport { passiveTouchGestures } from './settings.js';\nimport { wrap } from './wrap.js'; // detect native touch action support\n\nvar HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nvar GESTURE_KEY = '__polymerGestures';\nvar HANDLED_OBJ = '__polymerGesturesHandled';\nvar TOUCH_ACTION = '__polymerGesturesTouchAction'; // radius for tap and track\n\nvar TAP_DISTANCE = 25;\nvar TRACK_DISTANCE = 5; // number of last N track positions to keep\n\nvar TRACK_LENGTH = 2; // Disabling \"mouse\" handlers for 2500ms is enough\n\nvar MOUSE_TIMEOUT = 2500;\nvar MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click']; // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\n\nvar MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\n\nvar MOUSE_HAS_BUTTONS = function () {\n  try {\n    return new MouseEvent('test', {\n      buttons: 1\n    }).buttons === 1;\n  } catch (e) {\n    return false;\n  }\n}();\n/**\n * @param {string} name Possible mouse event name\n * @return {boolean} true if mouse event, false if not\n */\n\n\nfunction isMouseEvent(name) {\n  return MOUSE_EVENTS.indexOf(name) > -1;\n}\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n// check for passive event listeners\n\n\nvar SUPPORTS_PASSIVE = false;\n\n(function () {\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get() {\n        SUPPORTS_PASSIVE = true;\n      }\n\n    });\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch (e) {}\n})();\n/**\n * Generate settings for event listeners, dependant on `passiveTouchGestures`\n *\n * @param {string} eventName Event name to determine if `{passive}` option is\n *   needed\n * @return {{passive: boolean} | undefined} Options to use for addEventListener\n *   and removeEventListener\n */\n\n\nfunction PASSIVE_TOUCH(eventName) {\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\n    return;\n  }\n\n  if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && passiveTouchGestures) {\n    return {\n      passive: true\n    };\n  } else {\n    return;\n  }\n} // Check for touch-only devices\n\n\nvar IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/); // keep track of any labels hit by the mouseCanceller\n\n/** @type {!Array<!HTMLLabelElement>} */\n\nvar clickedLabels = [];\n/** @type {!Object<boolean>} */\n\nvar labellable = {\n  'button': true,\n  'input': true,\n  'keygen': true,\n  'meter': true,\n  'output': true,\n  'textarea': true,\n  'progress': true,\n  'select': true\n}; // Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute\n\n/** @type {!Object<boolean>} */\n\nvar canBeDisabled = {\n  'button': true,\n  'command': true,\n  'fieldset': true,\n  'input': true,\n  'keygen': true,\n  'optgroup': true,\n  'option': true,\n  'select': true,\n  'textarea': true\n};\n/**\n * @param {HTMLElement} el Element to check labelling status\n * @return {boolean} element can have labels\n */\n\nfunction canBeLabelled(el) {\n  return labellable[el.localName] || false;\n}\n/**\n * @param {HTMLElement} el Element that may be labelled.\n * @return {!Array<!HTMLLabelElement>} Relevant label for `el`\n */\n\n\nfunction matchingLabels(el) {\n  var labels = Array.prototype.slice.call(\n  /** @type {HTMLInputElement} */\n  el.labels || []); // IE doesn't have `labels` and Safari doesn't populate `labels`\n  // if element is in a shadowroot.\n  // In this instance, finding the non-ancestor labels is enough,\n  // as the mouseCancellor code will handle ancstor labels\n\n  if (!labels.length) {\n    labels = [];\n    var root = el.getRootNode(); // if there is an id on `el`, check for all labels with a matching `for` attribute\n\n    if (el.id) {\n      var matching = root.querySelectorAll(`label[for = ${el.id}]`);\n\n      for (var i = 0; i < matching.length; i++) {\n        labels.push(\n        /** @type {!HTMLLabelElement} */\n        matching[i]);\n      }\n    }\n  }\n\n  return labels;\n} // touch will make synthetic mouse events\n// `preventDefault` on touchend will cancel them,\n// but this breaks `<input>` focus and link clicks\n// disable mouse handlers for MOUSE_TIMEOUT ms after\n// a touchend to ignore synthetic mouse events\n\n\nvar mouseCanceller = function (mouseEvent) {\n  // Check for sourceCapabilities, used to distinguish synthetic events\n  // if mouseEvent did not come from a device that fires touch events,\n  // it was made by a real mouse and should be counted\n  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents\n  var sc = mouseEvent.sourceCapabilities;\n\n  if (sc && !sc.firesTouchEvents) {\n    return;\n  } // skip synthetic mouse events\n\n\n  mouseEvent[HANDLED_OBJ] = {\n    skip: true\n  }; // disable \"ghost clicks\"\n\n  if (mouseEvent.type === 'click') {\n    var clickFromLabel = false;\n    var path = getComposedPath(mouseEvent);\n\n    for (var i = 0; i < path.length; i++) {\n      if (path[i].nodeType === Node.ELEMENT_NODE) {\n        if (path[i].localName === 'label') {\n          clickedLabels.push(\n          /** @type {!HTMLLabelElement} */\n          path[i]);\n        } else if (canBeLabelled(\n        /** @type {!HTMLElement} */\n        path[i])) {\n          var ownerLabels = matchingLabels(\n          /** @type {!HTMLElement} */\n          path[i]); // check if one of the clicked labels is labelling this element\n\n          for (var j = 0; j < ownerLabels.length; j++) {\n            clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;\n          }\n        }\n      }\n\n      if (path[i] === POINTERSTATE.mouse.target) {\n        return;\n      }\n    } // if one of the clicked labels was labelling the target element,\n    // this is not a ghost click\n\n\n    if (clickFromLabel) {\n      return;\n    }\n\n    mouseEvent.preventDefault();\n    mouseEvent.stopPropagation();\n  }\n};\n/**\n * @param {boolean=} setup True to add, false to remove.\n * @return {void}\n */\n\n\nfunction setupTeardownMouseCanceller(setup) {\n  var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;\n\n  for (var i = 0, en; i < events.length; i++) {\n    en = events[i];\n\n    if (setup) {\n      // reset clickLabels array\n      clickedLabels.length = 0;\n      document.addEventListener(en, mouseCanceller, true);\n    } else {\n      document.removeEventListener(en, mouseCanceller, true);\n    }\n  }\n}\n\nfunction ignoreMouse(e) {\n  if (!POINTERSTATE.mouse.mouseIgnoreJob) {\n    setupTeardownMouseCanceller(true);\n  }\n\n  var unset = function () {\n    setupTeardownMouseCanceller();\n    POINTERSTATE.mouse.target = null;\n    POINTERSTATE.mouse.mouseIgnoreJob = null;\n  };\n\n  POINTERSTATE.mouse.target = getComposedPath(e)[0];\n  POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, timeOut.after(MOUSE_TIMEOUT), unset);\n}\n/**\n * @param {MouseEvent} ev event to test for left mouse button down\n * @return {boolean} has left mouse button down\n */\n\n\nfunction hasLeftMouseButton(ev) {\n  var type = ev.type; // exit early if the event is not a mouse event\n\n  if (!isMouseEvent(type)) {\n    return false;\n  } // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\n\n\n  if (type === 'mousemove') {\n    // allow undefined for testing events\n    var buttons = ev.buttons === undefined ? 1 : ev.buttons;\n\n    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n    } // buttons is a bitmask, check that the left button bit is set (1)\n\n\n    return Boolean(buttons & 1);\n  } else {\n    // allow undefined for testing events\n    var button = ev.button === undefined ? 0 : ev.button; // ev.button is 0 in mousedown/mouseup/click for left button activation\n\n    return button === 0;\n  }\n}\n\nfunction isSyntheticClick(ev) {\n  if (ev.type === 'click') {\n    // ev.detail is 0 for HTMLElement.click in most browsers\n    if (ev.detail === 0) {\n      return true;\n    } // in the worst case, check that the x/y position of the click is within\n    // the bounding box of the target of the event\n    // Thanks IE 10 >:(\n\n\n    var t = _findOriginalTarget(ev); // make sure the target of the event is an element so we can use getBoundingClientRect,\n    // if not, just assume it is a synthetic click\n\n\n    if (!t.nodeType ||\n    /** @type {Element} */\n    t.nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n\n    var bcr =\n    /** @type {Element} */\n    t.getBoundingClientRect(); // use page x/y to account for scrolling\n\n    var x = ev.pageX,\n        y = ev.pageY; // ev is a synthetic click if the position is outside the bounding box of the target\n\n    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);\n  }\n\n  return false;\n}\n\nvar POINTERSTATE = {\n  mouse: {\n    target: null,\n    mouseIgnoreJob: null\n  },\n  touch: {\n    x: 0,\n    y: 0,\n    id: -1,\n    scrollDecided: false\n  }\n};\n\nfunction firstTouchAction(ev) {\n  var ta = 'auto';\n  var path = getComposedPath(ev);\n\n  for (var i = 0, n; i < path.length; i++) {\n    n = path[i];\n\n    if (n[TOUCH_ACTION]) {\n      ta = n[TOUCH_ACTION];\n      break;\n    }\n  }\n\n  return ta;\n}\n\nfunction trackDocument(stateObj, movefn, upfn) {\n  stateObj.movefn = movefn;\n  stateObj.upfn = upfn;\n  document.addEventListener('mousemove', movefn);\n  document.addEventListener('mouseup', upfn);\n}\n\nfunction untrackDocument(stateObj) {\n  document.removeEventListener('mousemove', stateObj.movefn);\n  document.removeEventListener('mouseup', stateObj.upfn);\n  stateObj.movefn = null;\n  stateObj.upfn = null;\n} // use a document-wide touchend listener to start the ghost-click prevention mechanism\n// Use passive event listeners, if supported, to not affect scrolling performance\n\n\ndocument.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? {\n  passive: true\n} : false);\n/**\n * Returns the composedPath for the given event.\n * @param {Event} event to process\n * @return {!Array<!EventTarget>} Path of the event\n */\n\nvar getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : event => event.composedPath && event.composedPath() || [];\n/** @type {!Object<string, !GestureRecognizer>} */\n\nexport var gestures = {};\n/** @type {!Array<!GestureRecognizer>} */\n\nexport var recognizers = [];\n/**\n * Finds the element rendered on the screen at the provided coordinates.\n *\n * Similar to `document.elementFromPoint`, but pierces through\n * shadow roots.\n *\n * @param {number} x Horizontal pixel coordinate\n * @param {number} y Vertical pixel coordinate\n * @return {Element} Returns the deepest shadowRoot inclusive element\n * found at the screen position given.\n */\n\nexport function deepTargetFind(x, y) {\n  var node = document.elementFromPoint(x, y);\n  var next = node; // this code path is only taken when native ShadowDOM is used\n  // if there is a shadowroot, it may have a node at x/y\n  // if there is not a shadowroot, exit the loop\n\n  while (next && next.shadowRoot && !window.ShadyDOM) {\n    // if there is a node at x/y in the shadowroot, look deeper\n    var oldNext = next;\n    next = next.shadowRoot.elementFromPoint(x, y); // on Safari, elementFromPoint may return the shadowRoot host\n\n    if (oldNext === next) {\n      break;\n    }\n\n    if (next) {\n      node = next;\n    }\n  }\n\n  return node;\n}\n/**\n * a cheaper check than ev.composedPath()[0];\n *\n * @private\n * @param {Event|Touch} ev Event.\n * @return {EventTarget} Returns the event target.\n */\n\nfunction _findOriginalTarget(ev) {\n  var path = getComposedPath(\n  /** @type {?Event} */\n  ev); // It shouldn't be, but sometimes path is empty (window on Safari).\n\n  return path.length > 0 ? path[0] : ev.target;\n}\n/**\n * @private\n * @param {Event} ev Event.\n * @return {void}\n */\n\n\nfunction _handleNative(ev) {\n  var handled;\n  var type = ev.type;\n  var node = ev.currentTarget;\n  var gobj = node[GESTURE_KEY];\n\n  if (!gobj) {\n    return;\n  }\n\n  var gs = gobj[type];\n\n  if (!gs) {\n    return;\n  }\n\n  if (!ev[HANDLED_OBJ]) {\n    ev[HANDLED_OBJ] = {};\n\n    if (type.slice(0, 5) === 'touch') {\n      ev =\n      /** @type {TouchEvent} */\n      ev; // eslint-disable-line no-self-assign\n\n      var t = ev.changedTouches[0];\n\n      if (type === 'touchstart') {\n        // only handle the first finger\n        if (ev.touches.length === 1) {\n          POINTERSTATE.touch.id = t.identifier;\n        }\n      }\n\n      if (POINTERSTATE.touch.id !== t.identifier) {\n        return;\n      }\n\n      if (!HAS_NATIVE_TA) {\n        if (type === 'touchstart' || type === 'touchmove') {\n          _handleTouchAction(ev);\n        }\n      }\n    }\n  }\n\n  handled = ev[HANDLED_OBJ]; // used to ignore synthetic mouse events\n\n  if (handled.skip) {\n    return;\n  } // reset recognizer state\n\n\n  for (var i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n\n    if (gs[r.name] && !handled[r.name]) {\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\n        r.reset();\n      }\n    }\n  } // enforce gesture recognizer order\n\n\n  for (var _i = 0, _r; _i < recognizers.length; _i++) {\n    _r = recognizers[_i];\n\n    if (gs[_r.name] && !handled[_r.name]) {\n      handled[_r.name] = true;\n\n      _r[type](ev);\n    }\n  }\n}\n/**\n * @private\n * @param {TouchEvent} ev Event.\n * @return {void}\n */\n\n\nfunction _handleTouchAction(ev) {\n  var t = ev.changedTouches[0];\n  var type = ev.type;\n\n  if (type === 'touchstart') {\n    POINTERSTATE.touch.x = t.clientX;\n    POINTERSTATE.touch.y = t.clientY;\n    POINTERSTATE.touch.scrollDecided = false;\n  } else if (type === 'touchmove') {\n    if (POINTERSTATE.touch.scrollDecided) {\n      return;\n    }\n\n    POINTERSTATE.touch.scrollDecided = true;\n    var ta = firstTouchAction(ev);\n    var shouldPrevent = false;\n    var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\n    var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\n\n    if (!ev.cancelable) {// scrolling is happening\n    } else if (ta === 'none') {\n      shouldPrevent = true;\n    } else if (ta === 'pan-x') {\n      shouldPrevent = dy > dx;\n    } else if (ta === 'pan-y') {\n      shouldPrevent = dx > dy;\n    }\n\n    if (shouldPrevent) {\n      ev.preventDefault();\n    } else {\n      prevent('track');\n    }\n  }\n}\n/**\n * Adds an event listener to a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to add listener on\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function to call\n * @return {boolean} Returns true if a gesture event listener was added.\n */\n\n\nexport function addListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _add(node, evType, handler);\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Removes an event listener from a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to remove listener from\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function previously passed to\n *  `addListener`.\n * @return {boolean} Returns true if a gesture event listener was removed.\n */\n\nexport function removeListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _remove(node, evType, handler);\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * automate the event listeners for the native events\n *\n * @private\n * @param {!EventTarget} node Node on which to add the event.\n * @param {string} evType Event type to add.\n * @param {function(!Event)} handler Event handler function.\n * @return {void}\n */\n\nfunction _add(node, evType, handler) {\n  var recognizer = gestures[evType];\n  var deps = recognizer.deps;\n  var name = recognizer.name;\n  var gobj = node[GESTURE_KEY];\n\n  if (!gobj) {\n    node[GESTURE_KEY] = gobj = {};\n  }\n\n  for (var i = 0, dep, gd; i < deps.length; i++) {\n    dep = deps[i]; // don't add mouse handlers on iOS because they cause gray selection overlays\n\n    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {\n      continue;\n    }\n\n    gd = gobj[dep];\n\n    if (!gd) {\n      gobj[dep] = gd = {\n        _count: 0\n      };\n    }\n\n    if (gd._count === 0) {\n      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n    }\n\n    gd[name] = (gd[name] || 0) + 1;\n    gd._count = (gd._count || 0) + 1;\n  }\n\n  node.addEventListener(evType, handler);\n\n  if (recognizer.touchAction) {\n    setTouchAction(node, recognizer.touchAction);\n  }\n}\n/**\n * automate event listener removal for native events\n *\n * @private\n * @param {!EventTarget} node Node on which to remove the event.\n * @param {string} evType Event type to remove.\n * @param {function(!Event): void} handler Event handler function.\n * @return {void}\n */\n\n\nfunction _remove(node, evType, handler) {\n  var recognizer = gestures[evType];\n  var deps = recognizer.deps;\n  var name = recognizer.name;\n  var gobj = node[GESTURE_KEY];\n\n  if (gobj) {\n    for (var i = 0, dep, gd; i < deps.length; i++) {\n      dep = deps[i];\n      gd = gobj[dep];\n\n      if (gd && gd[name]) {\n        gd[name] = (gd[name] || 1) - 1;\n        gd._count = (gd._count || 1) - 1;\n\n        if (gd._count === 0) {\n          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n        }\n      }\n    }\n  }\n\n  node.removeEventListener(evType, handler);\n}\n/**\n * Registers a new gesture event recognizer for adding new custom\n * gesture event types.\n *\n * @param {!GestureRecognizer} recog Gesture recognizer descriptor\n * @return {void}\n */\n\n\nexport function register(recog) {\n  recognizers.push(recog);\n\n  for (var i = 0; i < recog.emits.length; i++) {\n    gestures[recog.emits[i]] = recog;\n  }\n}\n/**\n * @private\n * @param {string} evName Event name.\n * @return {Object} Returns the gesture for the given event name.\n */\n\nfunction _findRecognizerByEvent(evName) {\n  for (var i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n\n    for (var j = 0, n; j < r.emits.length; j++) {\n      n = r.emits[j];\n\n      if (n === evName) {\n        return r;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * Sets scrolling direction on node.\n *\n * This value is checked on first move, thus it should be called prior to\n * adding event listeners.\n *\n * @param {!EventTarget} node Node to set touch action setting on\n * @param {string} value Touch action value\n * @return {void}\n */\n\n\nexport function setTouchAction(node, value) {\n  if (HAS_NATIVE_TA && node instanceof HTMLElement) {\n    // NOTE: add touchAction async so that events can be added in\n    // custom element constructors. Otherwise we run afoul of custom\n    // elements restriction against settings attributes (style) in the\n    // constructor.\n    microTask.run(() => {\n      node.style.touchAction = value;\n    });\n  }\n\n  node[TOUCH_ACTION] = value;\n}\n/**\n * Dispatches an event on the `target` element of `type` with the given\n * `detail`.\n * @private\n * @param {!EventTarget} target The element on which to fire an event.\n * @param {string} type The type of event to fire.\n * @param {!Object=} detail The detail object to populate on the event.\n * @return {void}\n */\n\nfunction _fire(target, type, detail) {\n  var ev = new Event(type, {\n    bubbles: true,\n    cancelable: true,\n    composed: true\n  });\n  ev.detail = detail;\n  wrap(\n  /** @type {!Node} */\n  target).dispatchEvent(ev); // forward `preventDefault` in a clean way\n\n  if (ev.defaultPrevented) {\n    var preventer = detail.preventer || detail.sourceEvent;\n\n    if (preventer && preventer.preventDefault) {\n      preventer.preventDefault();\n    }\n  }\n}\n/**\n * Prevents the dispatch and default action of the given event name.\n *\n * @param {string} evName Event name.\n * @return {void}\n */\n\n\nexport function prevent(evName) {\n  var recognizer = _findRecognizerByEvent(evName);\n\n  if (recognizer.info) {\n    recognizer.info.prevent = true;\n  }\n}\n/**\n * Reset the 2500ms timeout on processing mouse input after detecting touch input.\n *\n * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.\n * This method should only be called during testing with simulated touch inputs.\n * Calling this method in production may cause duplicate taps or other Gestures.\n *\n * @return {void}\n */\n\nexport function resetMouseCanceller() {\n  if (POINTERSTATE.mouse.mouseIgnoreJob) {\n    POINTERSTATE.mouse.mouseIgnoreJob.flush();\n  }\n}\n/* eslint-disable valid-jsdoc */\n\nregister({\n  name: 'downup',\n  deps: ['mousedown', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['down', 'up'],\n  info: {\n    movefn: null,\n    upfn: null\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function () {\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function (e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n\n    var t = _findOriginalTarget(e);\n\n    var self = this;\n\n    var movefn = function movefn(e) {\n      if (!hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n        untrackDocument(self.info);\n      }\n    };\n\n    var upfn = function upfn(e) {\n      if (hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n      }\n\n      untrackDocument(self.info);\n    };\n\n    trackDocument(this.info, movefn, upfn);\n    downupFire('down', t, e);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function (e) {\n    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function (e) {\n    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);\n  }\n});\n/**\n * @param {string} type\n * @param {EventTarget} target\n * @param {Event|Touch} event\n * @param {Event=} preventer\n * @return {void}\n */\n\nfunction downupFire(type, target, event, preventer) {\n  if (!target) {\n    return;\n  }\n\n  _fire(target, type, {\n    x: event.clientX,\n    y: event.clientY,\n    sourceEvent: event,\n    preventer: preventer,\n    prevent: function (e) {\n      return prevent(e);\n    }\n  });\n}\n\nregister({\n  name: 'track',\n  touchAction: 'none',\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['track'],\n  info: {\n    x: 0,\n    y: 0,\n    state: 'start',\n    started: false,\n    moves: [],\n\n    /** @this {GestureInfo} */\n    addMove: function (move) {\n      if (this.moves.length > TRACK_LENGTH) {\n        this.moves.shift();\n      }\n\n      this.moves.push(move);\n    },\n    movefn: null,\n    upfn: null,\n    prevent: false\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function () {\n    this.info.state = 'start';\n    this.info.started = false;\n    this.info.moves = [];\n    this.info.x = 0;\n    this.info.y = 0;\n    this.info.prevent = false;\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function (e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n\n    var t = _findOriginalTarget(e);\n\n    var self = this;\n\n    var movefn = function movefn(e) {\n      var x = e.clientX,\n          y = e.clientY;\n\n      if (trackHasMovedEnough(self.info, x, y)) {\n        // first move is 'start', subsequent moves are 'move', mouseup is 'end'\n        self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';\n\n        if (self.info.state === 'start') {\n          // if and only if tracking, always prevent tap\n          prevent('tap');\n        }\n\n        self.info.addMove({\n          x: x,\n          y: y\n        });\n\n        if (!hasLeftMouseButton(e)) {\n          // always fire \"end\"\n          self.info.state = 'end';\n          untrackDocument(self.info);\n        }\n\n        if (t) {\n          trackFire(self.info, t, e);\n        }\n\n        self.info.started = true;\n      }\n    };\n\n    var upfn = function upfn(e) {\n      if (self.info.started) {\n        movefn(e);\n      } // remove the temporary listeners\n\n\n      untrackDocument(self.info);\n    }; // add temporary document listeners as mouse retargets\n\n\n    trackDocument(this.info, movefn, upfn);\n    this.info.x = e.clientX;\n    this.info.y = e.clientY;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function (e) {\n    var ct = e.changedTouches[0];\n    this.info.x = ct.clientX;\n    this.info.y = ct.clientY;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchmove: function (e) {\n    var t = _findOriginalTarget(e);\n\n    var ct = e.changedTouches[0];\n    var x = ct.clientX,\n        y = ct.clientY;\n\n    if (trackHasMovedEnough(this.info, x, y)) {\n      if (this.info.state === 'start') {\n        // if and only if tracking, always prevent tap\n        prevent('tap');\n      }\n\n      this.info.addMove({\n        x: x,\n        y: y\n      });\n      trackFire(this.info, t, ct);\n      this.info.state = 'track';\n      this.info.started = true;\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function (e) {\n    var t = _findOriginalTarget(e);\n\n    var ct = e.changedTouches[0]; // only trackend if track was started and not aborted\n\n    if (this.info.started) {\n      // reset started state on up\n      this.info.state = 'end';\n      this.info.addMove({\n        x: ct.clientX,\n        y: ct.clientY\n      });\n      trackFire(this.info, t, ct);\n    }\n  }\n});\n/**\n * @param {!GestureInfo} info\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\n\nfunction trackHasMovedEnough(info, x, y) {\n  if (info.prevent) {\n    return false;\n  }\n\n  if (info.started) {\n    return true;\n  }\n\n  var dx = Math.abs(info.x - x);\n  var dy = Math.abs(info.y - y);\n  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;\n}\n/**\n * @param {!GestureInfo} info\n * @param {?EventTarget} target\n * @param {Touch} touch\n * @return {void}\n */\n\n\nfunction trackFire(info, target, touch) {\n  if (!target) {\n    return;\n  }\n\n  var secondlast = info.moves[info.moves.length - 2];\n  var lastmove = info.moves[info.moves.length - 1];\n  var dx = lastmove.x - info.x;\n  var dy = lastmove.y - info.y;\n  var ddx,\n      ddy = 0;\n\n  if (secondlast) {\n    ddx = lastmove.x - secondlast.x;\n    ddy = lastmove.y - secondlast.y;\n  }\n\n  _fire(target, 'track', {\n    state: info.state,\n    x: touch.clientX,\n    y: touch.clientY,\n    dx: dx,\n    dy: dy,\n    ddx: ddx,\n    ddy: ddy,\n    sourceEvent: touch,\n    hover: function () {\n      return deepTargetFind(touch.clientX, touch.clientY);\n    }\n  });\n}\n\nregister({\n  name: 'tap',\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['click', 'touchend']\n  },\n  emits: ['tap'],\n  info: {\n    x: NaN,\n    y: NaN,\n    prevent: false\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function () {\n    this.info.x = NaN;\n    this.info.y = NaN;\n    this.info.prevent = false;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function (e) {\n    if (hasLeftMouseButton(e)) {\n      this.info.x = e.clientX;\n      this.info.y = e.clientY;\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  click: function (e) {\n    if (hasLeftMouseButton(e)) {\n      trackForward(this.info, e);\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function (e) {\n    var touch = e.changedTouches[0];\n    this.info.x = touch.clientX;\n    this.info.y = touch.clientY;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function (e) {\n    trackForward(this.info, e.changedTouches[0], e);\n  }\n});\n/**\n * @param {!GestureInfo} info\n * @param {Event | Touch} e\n * @param {Event=} preventer\n * @return {void}\n */\n\nfunction trackForward(info, e, preventer) {\n  var dx = Math.abs(e.clientX - info.x);\n  var dy = Math.abs(e.clientY - info.y); // find original target from `preventer` for TouchEvents, or `e` for MouseEvents\n\n  var t = _findOriginalTarget(preventer || e);\n\n  if (!t || canBeDisabled[\n  /** @type {!HTMLElement} */\n  t.localName] && t.hasAttribute('disabled')) {\n    return;\n  } // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\n\n\n  if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {\n    // prevent taps from being generated if an event has canceled them\n    if (!info.prevent) {\n      _fire(t, 'tap', {\n        x: e.clientX,\n        y: e.clientY,\n        sourceEvent: e,\n        preventer: preventer\n      });\n    }\n  }\n}\n/* eslint-enable valid-jsdoc */\n\n/** @deprecated */\n\n\nexport var findOriginalTarget = _findOriginalTarget;\n/** @deprecated */\n\nexport var add = addListener;\n/** @deprecated */\n\nexport var remove = removeListener;"
    },
    {
     "id": 54,
     "name": "../node_modules/@polymer/polymer/lib/utils/templatize.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module for preparing and stamping instances of templates that utilize\n * Polymer's data-binding and declarative event listener features.\n *\n * Example:\n *\n *     // Get a template from somewhere, e.g. light DOM\n *     let template = this.querySelector('template');\n *     // Prepare the template\n *     let TemplateClass = Templatize.templatize(template);\n *     // Instance the template with an initial data model\n *     let instance = new TemplateClass({myProp: 'initial'});\n *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM\n *     this.shadowRoot.appendChild(instance.root);\n *     // Changing a property on the instance will propagate to bindings\n *     // in the template\n *     instance.myProp = 'new value';\n *\n * The `options` dictionary passed to `templatize` allows for customizing\n * features of the generated template class, including how outer-scope host\n * properties should be forwarded into template instances, how any instance\n * properties added into the template's scope should be notified out to\n * the host, and whether the instance should be decorated as a \"parent model\"\n * of any event handlers.\n *\n *     // Customize property forwarding and event model decoration\n *     let TemplateClass = Templatize.templatize(template, this, {\n *       parentModel: true,\n *       forwardHostProp(property, value) {...},\n *       instanceProps: {...},\n *       notifyInstanceProp(instance, property, value) {...},\n *     });\n *\n * @summary Module for preparing and stamping instances of templates\n *   utilizing Polymer templating features.\n */\nimport './boot.js';\nimport { PropertyEffects } from '../mixins/property-effects.js';\nimport { MutableData } from '../mixins/mutable-data.js';\nimport { strictTemplatePolicy } from './settings.js';\nimport { wrap } from './wrap.js'; // Base class for HTMLTemplateElement extension that has property effects\n// machinery for propagating host properties to children. This is an ES5\n// class only because Babel (incorrectly) requires super() in the class\n// constructor even though no `this` is used and it returns an instance.\n\nvar newInstance = null;\n/**\n * @constructor\n * @extends {HTMLTemplateElement}\n * @private\n */\n\nfunction HTMLTemplateElementExtension() {\n  return newInstance;\n}\n\nHTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {\n  constructor: {\n    value: HTMLTemplateElementExtension,\n    writable: true\n  }\n});\n/**\n * @constructor\n * @implements {Polymer_PropertyEffects}\n * @extends {HTMLTemplateElementExtension}\n * @private\n */\n\nvar DataTemplate = PropertyEffects(HTMLTemplateElementExtension);\n/**\n * @constructor\n * @implements {Polymer_MutableData}\n * @extends {DataTemplate}\n * @private\n */\n\nvar MutableDataTemplate = MutableData(DataTemplate); // Applies a DataTemplate subclass to a <template> instance\n\nfunction upgradeTemplate(template, constructor) {\n  newInstance = template;\n  Object.setPrototypeOf(template, constructor.prototype);\n  new constructor();\n  newInstance = null;\n}\n/**\n * Base class for TemplateInstance.\n * @constructor\n * @implements {Polymer_PropertyEffects}\n * @private\n */\n\n\nvar templateInstanceBase = PropertyEffects(class {});\n/**\n * @polymer\n * @customElement\n * @appliesMixin PropertyEffects\n * @unrestricted\n */\n\nclass TemplateInstanceBase extends templateInstanceBase {\n  constructor(props) {\n    super();\n\n    this._configureProperties(props);\n    /** @type {!StampedTemplate} */\n\n\n    this.root = this._stampTemplate(this.__dataHost); // Save list of stamped children\n\n    var children = this.children = []; // Polymer 1.x did not use `Polymer.dom` here so not bothering.\n\n    for (var n = this.root.firstChild; n; n = n.nextSibling) {\n      children.push(n);\n      n.__templatizeInstance = this;\n    }\n\n    if (this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__) {\n      this._showHideChildren(true);\n    } // Flush props only when props are passed if instance props exist\n    // or when there isn't instance props.\n\n\n    var options = this.__templatizeOptions;\n\n    if (props && options.instanceProps || !options.instanceProps) {\n      this._enableProperties();\n    }\n  }\n  /**\n   * Configure the given `props` by calling `_setPendingProperty`. Also\n   * sets any properties stored in `__hostProps`.\n   * @private\n   * @param {Object} props Object of property name-value pairs to set.\n   * @return {void}\n   */\n\n\n  _configureProperties(props) {\n    var options = this.__templatizeOptions;\n\n    if (options.forwardHostProp) {\n      for (var hprop in this.__hostProps) {\n        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);\n      }\n    } // Any instance props passed in the constructor will overwrite host props;\n    // normally this would be a user error but we don't specifically filter them\n\n\n    for (var iprop in props) {\n      this._setPendingProperty(iprop, props[iprop]);\n    }\n  }\n  /**\n   * Forwards a host property to this instance.  This method should be\n   * called on instances from the `options.forwardHostProp` callback\n   * to propagate changes of host properties to each instance.\n   *\n   * Note this method enqueues the change, which are flushed as a batch.\n   *\n   * @param {string} prop Property or path name\n   * @param {*} value Value of the property to forward\n   * @return {void}\n   */\n\n\n  forwardHostProp(prop, value) {\n    if (this._setPendingPropertyOrPath(prop, value, false, true)) {\n      this.__dataHost._enqueueClient(this);\n    }\n  }\n  /**\n   * Override point for adding custom or simulated event handling.\n   *\n   * @override\n   * @param {!Node} node Node to add event listener to\n   * @param {string} eventName Name of event\n   * @param {function(!Event):void} handler Listener function to add\n   * @return {void}\n   */\n\n\n  _addEventListenerToNode(node, eventName, handler) {\n    if (this._methodHost && this.__templatizeOptions.parentModel) {\n      // If this instance should be considered a parent model, decorate\n      // events this template instance as `model`\n      this._methodHost._addEventListenerToNode(node, eventName, e => {\n        e.model = this;\n        handler(e);\n      });\n    } else {\n      // Otherwise delegate to the template's host (which could be)\n      // another template instance\n      var templateHost = this.__dataHost.__dataHost;\n\n      if (templateHost) {\n        templateHost._addEventListenerToNode(node, eventName, handler);\n      }\n    }\n  }\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @param {boolean} hide Set to true to hide the children;\n   * set to false to show them.\n   * @return {void}\n   * @protected\n   */\n\n\n  _showHideChildren(hide) {\n    var c = this.children;\n\n    for (var i = 0; i < c.length; i++) {\n      var n = c[i]; // Ignore non-changes\n\n      if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {\n        if (n.nodeType === Node.TEXT_NODE) {\n          if (hide) {\n            n.__polymerTextContent__ = n.textContent;\n            n.textContent = '';\n          } else {\n            n.textContent = n.__polymerTextContent__;\n          } // remove and replace slot\n\n        } else if (n.localName === 'slot') {\n          if (hide) {\n            n.__polymerReplaced__ = document.createComment('hidden-slot');\n            wrap(wrap(n).parentNode).replaceChild(n.__polymerReplaced__, n);\n          } else {\n            var replace = n.__polymerReplaced__;\n\n            if (replace) {\n              wrap(wrap(replace).parentNode).replaceChild(n, replace);\n            }\n          }\n        } else if (n.style) {\n          if (hide) {\n            n.__polymerDisplay__ = n.style.display;\n            n.style.display = 'none';\n          } else {\n            n.style.display = n.__polymerDisplay__;\n          }\n        }\n      }\n\n      n.__hideTemplateChildren__ = hide;\n\n      if (n._showHideChildren) {\n        n._showHideChildren(hide);\n      }\n    }\n  }\n  /**\n   * Overrides default property-effects implementation to intercept\n   * textContent bindings while children are \"hidden\" and cache in\n   * private storage for later retrieval.\n   *\n   * @override\n   * @param {!Node} node The node to set a property on\n   * @param {string} prop The property to set\n   * @param {*} value The value to set\n   * @return {void}\n   * @protected\n   */\n\n\n  _setUnmanagedPropertyToNode(node, prop, value) {\n    if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {\n      node.__polymerTextContent__ = value;\n    } else {\n      super._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n  /**\n   * Find the parent model of this template instance.  The parent model\n   * is either another templatize instance that had option `parentModel: true`,\n   * or else the host element.\n   *\n   * @return {!Polymer_PropertyEffects} The parent model of this instance\n   */\n\n\n  get parentModel() {\n    var model = this.__parentModel;\n\n    if (!model) {\n      var options;\n      model = this;\n\n      do {\n        // A template instance's `__dataHost` is a <template>\n        // `model.__dataHost.__dataHost` is the template's host\n        model = model.__dataHost.__dataHost;\n      } while ((options = model.__templatizeOptions) && !options.parentModel);\n\n      this.__parentModel = model;\n    }\n\n    return model;\n  }\n  /**\n   * Stub of HTMLElement's `dispatchEvent`, so that effects that may\n   * dispatch events safely no-op.\n   *\n   * @param {Event} event Event to dispatch\n   * @return {boolean} Always true.\n   */\n\n\n  dispatchEvent(event) {\n    // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n}\n/** @type {!DataTemplate} */\n\n\nTemplateInstanceBase.prototype.__dataHost;\n/** @type {!TemplatizeOptions} */\n\nTemplateInstanceBase.prototype.__templatizeOptions;\n/** @type {!Polymer_PropertyEffects} */\n\nTemplateInstanceBase.prototype._methodHost;\n/** @type {!Object} */\n\nTemplateInstanceBase.prototype.__templatizeOwner;\n/** @type {!Object} */\n\nTemplateInstanceBase.prototype.__hostProps;\n/**\n * @constructor\n * @extends {TemplateInstanceBase}\n * @implements {Polymer_MutableData}\n * @private\n */\n\nvar MutableTemplateInstanceBase = MutableData(TemplateInstanceBase);\n\nfunction findMethodHost(template) {\n  // Technically this should be the owner of the outermost template.\n  // In shadow dom, this is always getRootNode().host, but we can\n  // approximate this via cooperation with our dataHost always setting\n  // `_methodHost` as long as there were bindings (or id's) on this\n  // instance causing it to get a dataHost.\n  var templateHost = template.__dataHost;\n  return templateHost && templateHost._methodHost || templateHost;\n}\n/* eslint-disable valid-jsdoc */\n\n/**\n * @suppress {missingProperties} class.prototype is not defined for some reason\n */\n\n\nfunction createTemplatizerClass(template, templateInfo, options) {\n  /**\n   * @constructor\n   * @extends {TemplateInstanceBase}\n   */\n  var templatizerBase = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase; // Affordance for global mixins onto TemplatizeInstance\n\n  if (templatize.mixin) {\n    templatizerBase = templatize.mixin(templatizerBase);\n  }\n  /**\n   * Anonymous class created by the templatize\n   * @constructor\n   * @private\n   */\n\n\n  var klass = class extends templatizerBase {};\n  /** @override */\n\n  klass.prototype.__templatizeOptions = options;\n\n  klass.prototype._bindTemplate(template);\n\n  addNotifyEffects(klass, template, templateInfo, options);\n  return klass;\n}\n/**\n * @suppress {missingProperties} class.prototype is not defined for some reason\n */\n\n\nfunction addPropagateEffects(template, templateInfo, options) {\n  var userForwardHostProp = options.forwardHostProp;\n\n  if (userForwardHostProp) {\n    // Provide data API and property effects on memoized template class\n    var klass = templateInfo.templatizeTemplateClass;\n\n    if (!klass) {\n      /**\n       * @constructor\n       * @extends {DataTemplate}\n       */\n      var templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate;\n      /** @private */\n\n      klass = templateInfo.templatizeTemplateClass = class TemplatizedTemplate extends templatizedBase {}; // Add template - >instances effects\n      // and host <- template effects\n\n      var hostProps = templateInfo.hostProps;\n\n      for (var prop in hostProps) {\n        klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, {\n          fn: createForwardHostPropEffect(prop, userForwardHostProp)\n        });\n\n        klass.prototype._createNotifyingProperty('_host_' + prop);\n      }\n    }\n\n    upgradeTemplate(template, klass); // Mix any pre-bound data into __data; no need to flush this to\n    // instances since they pull from the template at instance-time\n\n    if (template.__dataProto) {\n      // Note, generally `__dataProto` could be chained, but it's guaranteed\n      // to not be since this is a vanilla template we just added effects to\n      Object.assign(template.__data, template.__dataProto);\n    } // Clear any pending data for performance\n\n\n    template.__dataTemp = {};\n    template.__dataPending = null;\n    template.__dataOld = null;\n\n    template._enableProperties();\n  }\n}\n/* eslint-enable valid-jsdoc */\n\n\nfunction createForwardHostPropEffect(hostProp, userForwardHostProp) {\n  return function forwardHostProp(template, prop, props) {\n    userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);\n  };\n}\n\nfunction addNotifyEffects(klass, template, templateInfo, options) {\n  var hostProps = templateInfo.hostProps || {};\n\n  for (var iprop in options.instanceProps) {\n    delete hostProps[iprop];\n    var userNotifyInstanceProp = options.notifyInstanceProp;\n\n    if (userNotifyInstanceProp) {\n      klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {\n        fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)\n      });\n    }\n  }\n\n  if (options.forwardHostProp && template.__dataHost) {\n    for (var hprop in hostProps) {\n      klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {\n        fn: createNotifyHostPropEffect()\n      });\n    }\n  }\n}\n\nfunction createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {\n  return function notifyInstanceProp(inst, prop, props) {\n    userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);\n  };\n}\n\nfunction createNotifyHostPropEffect() {\n  return function notifyHostProp(inst, prop, props) {\n    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);\n  };\n}\n/**\n * Returns an anonymous `PropertyEffects` class bound to the\n * `<template>` provided.  Instancing the class will result in the\n * template being stamped into a document fragment stored as the instance's\n * `root` property, after which it can be appended to the DOM.\n *\n * Templates may utilize all Polymer data-binding features as well as\n * declarative event listeners.  Event listeners and inline computing\n * functions in the template will be called on the host of the template.\n *\n * The constructor returned takes a single argument dictionary of initial\n * property values to propagate into template bindings.  Additionally\n * host properties can be forwarded in, and instance properties can be\n * notified out by providing optional callbacks in the `options` dictionary.\n *\n * Valid configuration in `options` are as follows:\n *\n * - `forwardHostProp(property, value)`: Called when a property referenced\n *   in the template changed on the template's host. As this library does\n *   not retain references to templates instanced by the user, it is the\n *   templatize owner's responsibility to forward host property changes into\n *   user-stamped instances.  The `instance.forwardHostProp(property, value)`\n *    method on the generated class should be called to forward host\n *   properties into the template to prevent unnecessary property-changed\n *   notifications. Any properties referenced in the template that are not\n *   defined in `instanceProps` will be notified up to the template's host\n *   automatically.\n * - `instanceProps`: Dictionary of property names that will be added\n *   to the instance by the templatize owner.  These properties shadow any\n *   host properties, and changes within the template to these properties\n *   will result in `notifyInstanceProp` being called.\n * - `mutableData`: When `true`, the generated class will skip strict\n *   dirty-checking for objects and arrays (always consider them to be\n *   \"dirty\").\n * - `notifyInstanceProp(instance, property, value)`: Called when\n *   an instance property changes.  Users may choose to call `notifyPath`\n *   on e.g. the owner to notify the change.\n * - `parentModel`: When `true`, events handled by declarative event listeners\n *   (`on-event=\"handler\"`) will be decorated with a `model` property pointing\n *   to the template instance that stamped it.  It will also be returned\n *   from `instance.parentModel` in cases where template instance nesting\n *   causes an inner model to shadow an outer model.\n *\n * All callbacks are called bound to the `owner`. Any context\n * needed for the callbacks (such as references to `instances` stamped)\n * should be stored on the `owner` such that they can be retrieved via\n * `this`.\n *\n * When `options.forwardHostProp` is declared as an option, any properties\n * referenced in the template will be automatically forwarded from the host of\n * the `<template>` to instances, with the exception of any properties listed in\n * the `options.instanceProps` object.  `instanceProps` are assumed to be\n * managed by the owner of the instances, either passed into the constructor\n * or set after the fact.  Note, any properties passed into the constructor will\n * always be set to the instance (regardless of whether they would normally\n * be forwarded from the host).\n *\n * Note that `templatize()` can be run only once for a given `<template>`.\n * Further calls will result in an error. Also, there is a special\n * behavior if the template was duplicated through a mechanism such as\n * `<dom-repeat>` or `<test-fixture>`. In this case, all calls to\n * `templatize()` return the same class for all duplicates of a template.\n * The class returned from `templatize()` is generated only once using\n * the `options` from the first call. This means that any `options`\n * provided to subsequent calls will be ignored. Therefore, it is very\n * important not to close over any variables inside the callbacks. Also,\n * arrow functions must be avoided because they bind the outer `this`.\n * Inside the callbacks, any contextual information can be accessed\n * through `this`, which points to the `owner`.\n *\n * @param {!HTMLTemplateElement} template Template to templatize\n * @param {Polymer_PropertyEffects=} owner Owner of the template instances;\n *   any optional callbacks will be bound to this owner.\n * @param {Object=} options Options dictionary (see summary for details)\n * @return {function(new:TemplateInstanceBase)} Generated class bound to the template\n *   provided\n * @suppress {invalidCasts}\n */\n\n\nexport function templatize(template, owner, options) {\n  // Under strictTemplatePolicy, the templatized element must be owned\n  // by a (trusted) Polymer element, indicated by existence of _methodHost;\n  // e.g. for dom-if & dom-repeat in main document, _methodHost is null\n  if (strictTemplatePolicy && !findMethodHost(template)) {\n    throw new Error('strictTemplatePolicy: template owner not trusted');\n  }\n\n  options =\n  /** @type {!TemplatizeOptions} */\n  options || {};\n\n  if (template.__templatizeOwner) {\n    throw new Error('A <template> can only be templatized once');\n  }\n\n  template.__templatizeOwner = owner;\n  var ctor = owner ? owner.constructor : TemplateInstanceBase;\n\n  var templateInfo = ctor._parseTemplate(template); // Get memoized base class for the prototypical template, which\n  // includes property effects for binding template & forwarding\n\n  /**\n   * @constructor\n   * @extends {TemplateInstanceBase}\n   */\n\n\n  var baseClass = templateInfo.templatizeInstanceClass;\n\n  if (!baseClass) {\n    baseClass = createTemplatizerClass(template, templateInfo, options);\n    templateInfo.templatizeInstanceClass = baseClass;\n  } // Host property forwarding must be installed onto template instance\n\n\n  addPropagateEffects(template, templateInfo, options); // Subclass base class and add reference for this specific template\n\n  /** @private */\n\n  var klass = class TemplateInstance extends baseClass {};\n  /** @override */\n\n  klass.prototype._methodHost = findMethodHost(template);\n  /** @override */\n\n  klass.prototype.__dataHost =\n  /** @type {!DataTemplate} */\n  template;\n  /** @override */\n\n  klass.prototype.__templatizeOwner =\n  /** @type {!Object} */\n  owner;\n  /** @override */\n\n  klass.prototype.__hostProps = templateInfo.hostProps;\n  klass =\n  /** @type {function(new:TemplateInstanceBase)} */\n  klass; //eslint-disable-line no-self-assign\n\n  return klass;\n}\n/**\n * Returns the template \"model\" associated with a given element, which\n * serves as the binding scope for the template instance the element is\n * contained in. A template model is an instance of\n * `TemplateInstanceBase`, and should be used to manipulate data\n * associated with this template instance.\n *\n * Example:\n *\n *   let model = modelForElement(el);\n *   if (model.index < 10) {\n *     model.set('item.checked', true);\n *   }\n *\n * @param {HTMLTemplateElement} template The model will be returned for\n *   elements stamped from this template\n * @param {Node=} node Node for which to return a template model.\n * @return {TemplateInstanceBase} Template instance representing the\n *   binding scope for the element\n */\n\nexport function modelForElement(template, node) {\n  var model;\n\n  while (node) {\n    // An element with a __templatizeInstance marks the top boundary\n    // of a scope; walk up until we find one, and then ensure that\n    // its __dataHost matches `this`, meaning this dom-repeat stamped it\n    if (model = node.__templatizeInstance) {\n      // Found an element stamped by another template; keep walking up\n      // from its __dataHost\n      if (model.__dataHost != template) {\n        node = model.__dataHost;\n      } else {\n        return model;\n      }\n    } else {\n      // Still in a template scope, keep going up until\n      // a __templatizeInstance is found\n      node = wrap(node).parentNode;\n    }\n  }\n\n  return null;\n}\nexport { TemplateInstanceBase };"
    },
    {
     "id": 56,
     "name": "../node_modules/@webcomponents/shadycss/src/style-util.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 58,
     "name": "../node_modules/@polymer/polymer/lib/legacy/polymer-fn.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { Class } from './class.js';\nimport '../utils/boot.js';\n/**\n * Legacy class factory and registration helper for defining Polymer\n * elements.\n *\n * This method is equivalent to\n *\n *     import {Class} from '@polymer/polymer/lib/legacy/class.js';\n *     customElements.define(info.is, Class(info));\n *\n * See `Class` for details on valid legacy metadata format for `info`.\n *\n * @global\n * @override\n * @function\n * @param {!PolymerInit} info Object containing Polymer metadata and functions\n *   to become class methods.\n * @return {function(new: HTMLElement)} Generated class\n * @suppress {duplicate, invalidCasts, checkTypes}\n */\n\nvar Polymer = function (info) {\n  // if input is a `class` (aka a function with a prototype), use the prototype\n  // remember that the `constructor` will never be called\n  var klass;\n\n  if (typeof info === 'function') {\n    klass = info;\n  } else {\n    klass = Polymer.Class(info);\n  }\n\n  customElements.define(klass.is,\n  /** @type {!HTMLElement} */\n  klass);\n  return klass;\n};\n\nPolymer.Class = Class;\nexport { Polymer };"
    },
    {
     "id": 60,
     "name": "../node_modules/@polymer/polymer/lib/utils/resolve-url.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\nvar CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\nvar ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\nvar workingURL;\nvar resolveDoc;\n/**\n * Resolves the given URL against the provided `baseUri'.\n *\n * Note that this function performs no resolution for URLs that start\n * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n * URL resolution, use `window.URL`.\n *\n * @param {string} url Input URL to resolve\n * @param {?string=} baseURI Base URI to resolve the URL against\n * @return {string} resolved URL\n */\n\nexport function resolveUrl(url, baseURI) {\n  if (url && ABS_URL.test(url)) {\n    return url;\n  } // Lazy feature detection.\n\n\n  if (workingURL === undefined) {\n    workingURL = false;\n\n    try {\n      var u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      workingURL = u.href === 'http://a/c%20d';\n    } catch (e) {// silently fail\n    }\n  }\n\n  if (!baseURI) {\n    baseURI = document.baseURI || window.location.href;\n  }\n\n  if (workingURL) {\n    return new URL(url, baseURI).href;\n  } // Fallback to creating an anchor into a disconnected document.\n\n\n  if (!resolveDoc) {\n    resolveDoc = document.implementation.createHTMLDocument('temp');\n    resolveDoc.base = resolveDoc.createElement('base');\n    resolveDoc.head.appendChild(resolveDoc.base);\n    resolveDoc.anchor = resolveDoc.createElement('a');\n    resolveDoc.body.appendChild(resolveDoc.anchor);\n  }\n\n  resolveDoc.base.href = baseURI;\n  resolveDoc.anchor.href = url;\n  return resolveDoc.anchor.href || url;\n}\n/**\n * Resolves any relative URL's in the given CSS text against the provided\n * `ownerDocument`'s `baseURI`.\n *\n * @param {string} cssText CSS text to process\n * @param {string} baseURI Base URI to resolve the URL against\n * @return {string} Processed CSS text with resolved URL's\n */\n\nexport function resolveCss(cssText, baseURI) {\n  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {\n    return pre + '\\'' + resolveUrl(url.replace(/[\"']/g, ''), baseURI) + '\\'' + post;\n  });\n}\n/**\n * Returns a path from a given `url`. The path includes the trailing\n * `/` from the url.\n *\n * @param {string} url Input URL to transform\n * @return {string} resolved path\n */\n\nexport function pathFromUrl(url) {\n  return url.substring(0, url.lastIndexOf('/') + 1);\n}"
    },
    {
     "id": 62,
     "name": "../node_modules/@polymer/polymer/lib/elements/custom-style.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 65,
     "name": "../node_modules/@polymer/polymer/lib/mixins/gesture-event-listeners.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { addListener, removeListener } from '../utils/gestures.js';\n/**\n * Element class mixin that provides API for adding Polymer's cross-platform\n * gesture events to nodes.\n *\n * The API is designed to be compatible with override points implemented\n * in `TemplateStamp` such that declarative event listeners in\n * templates will support gesture events when this mixin is applied along with\n * `TemplateStamp`.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides API for adding Polymer's\n *   cross-platform\n * gesture events to nodes\n */\n\nexport var GestureEventListeners = dedupingMixin(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_GestureEventListeners}\n   */\n  class GestureEventListeners extends superClass {\n    /**\n     * Add the event listener to the node if it is a gestures event.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      if (!addListener(node, eventName, handler)) {\n        super._addEventListenerToNode(node, eventName, handler);\n      }\n    }\n    /**\n     * Remove the event listener to the node if it is a gestures event.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n\n\n    _removeEventListenerFromNode(node, eventName, handler) {\n      if (!removeListener(node, eventName, handler)) {\n        super._removeEventListenerFromNode(node, eventName, handler);\n      }\n    }\n\n  }\n\n  return GestureEventListeners;\n});"
    },
    {
     "id": 68,
     "name": "../node_modules/@polymer/polymer/polymer-legacy.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 70,
     "name": "../node_modules/@polymer/polymer/lib/elements/dom-module.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { resolveUrl, pathFromUrl } from '../utils/resolve-url.js';\nimport { strictTemplatePolicy } from '../utils/settings.js';\nvar modules = {};\nvar lcModules = {};\n/**\n * Sets a dom-module into the global registry by id.\n *\n * @param {string} id dom-module id\n * @param {DomModule} module dom-module instance\n * @return {void}\n */\n\nfunction setModule(id, module) {\n  // store id separate from lowercased id so that\n  // in all cases mixedCase id will stored distinctly\n  // and lowercase version is a fallback\n  modules[id] = lcModules[id.toLowerCase()] = module;\n}\n/**\n * Retrieves a dom-module from the global registry by id.\n *\n * @param {string} id dom-module id\n * @return {DomModule!} dom-module instance\n */\n\n\nfunction findModule(id) {\n  return modules[id] || lcModules[id.toLowerCase()];\n}\n\nfunction styleOutsideTemplateCheck(inst) {\n  if (inst.querySelector('style')) {\n    console.warn('dom-module %s has style outside template', inst.id);\n  }\n}\n/**\n * The `dom-module` element registers the dom it contains to the name given\n * by the module's id attribute. It provides a unified database of dom\n * accessible via its static `import` API.\n *\n * A key use case of `dom-module` is for providing custom element `<template>`s\n * via HTML imports that are parsed by the native HTML parser, that can be\n * relocated during a bundling pass and still looked up by `id`.\n *\n * Example:\n *\n *     <dom-module id=\"foo\">\n *       <img src=\"stuff.png\">\n *     </dom-module>\n *\n * Then in code in some other location that cannot access the dom-module above\n *\n *     let img = customElements.get('dom-module').import('foo', 'img');\n *\n * @customElement\n * @extends HTMLElement\n * @summary Custom element that provides a registry of relocatable DOM content\n *   by `id` that is agnostic to bundling.\n * @unrestricted\n */\n\n\nexport class DomModule extends HTMLElement {\n  static get observedAttributes() {\n    return ['id'];\n  }\n  /**\n   * Retrieves the element specified by the css `selector` in the module\n   * registered by `id`. For example, this.import('foo', 'img');\n   * @param {string} id The id of the dom-module in which to search.\n   * @param {string=} selector The css selector by which to find the element.\n   * @return {Element} Returns the element which matches `selector` in the\n   * module registered at the specified `id`.\n   *\n   * @export\n   * @nocollapse Referred to indirectly in style-gather.js\n   */\n\n\n  static import(id, selector) {\n    if (id) {\n      var m = findModule(id);\n\n      if (m && selector) {\n        return m.querySelector(selector);\n      }\n\n      return m;\n    }\n\n    return null;\n  }\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * @param {string} name Name of attribute.\n   * @param {?string} old Old value of attribute.\n   * @param {?string} value Current value of attribute.\n   * @param {?string} namespace Attribute namespace.\n   * @return {void}\n   * @override\n   */\n\n\n  attributeChangedCallback(name, old, value, namespace) {\n    if (old !== value) {\n      this.register();\n    }\n  }\n  /* eslint-enable no-unused-args */\n\n  /**\n   * The absolute URL of the original location of this `dom-module`.\n   *\n   * This value will differ from this element's `ownerDocument` in the\n   * following ways:\n   * - Takes into account any `assetpath` attribute added during bundling\n   *   to indicate the original location relative to the bundled location\n   * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n   *   the path is relative to the import document's location since\n   *   `ownerDocument` is not currently polyfilled\n   */\n\n\n  get assetpath() {\n    // Don't override existing assetpath.\n    if (!this.__assetpath) {\n      // note: assetpath set via an attribute must be relative to this\n      // element's location; accomodate polyfilled HTMLImports\n      var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;\n      var url = resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);\n      this.__assetpath = pathFromUrl(url);\n    }\n\n    return this.__assetpath;\n  }\n  /**\n   * Registers the dom-module at a given id. This method should only be called\n   * when a dom-module is imperatively created. For\n   * example, `document.createElement('dom-module').register('foo')`.\n   * @param {string=} id The id at which to register the dom-module.\n   * @return {void}\n   */\n\n\n  register(id) {\n    id = id || this.id;\n\n    if (id) {\n      // Under strictTemplatePolicy, reject and null out any re-registered\n      // dom-module since it is ambiguous whether first-in or last-in is trusted\n      if (strictTemplatePolicy && findModule(id) !== undefined) {\n        setModule(id, null);\n        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);\n      }\n\n      this.id = id;\n      setModule(id, this);\n      styleOutsideTemplateCheck(this);\n    }\n  }\n\n}\nDomModule.prototype['modules'] = modules;\ncustomElements.define('dom-module', DomModule);"
    },
    {
     "id": 72,
     "name": "../node_modules/@webcomponents/shadycss/src/css-parse.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n'use strict';\n/** @unrestricted */\n\nclass StyleNode {\n  constructor() {\n    /** @type {number} */\n    this['start'] = 0;\n    /** @type {number} */\n\n    this['end'] = 0;\n    /** @type {StyleNode} */\n\n    this['previous'] = null;\n    /** @type {StyleNode} */\n\n    this['parent'] = null;\n    /** @type {Array<StyleNode>} */\n\n    this['rules'] = null;\n    /** @type {string} */\n\n    this['parsedCssText'] = '';\n    /** @type {string} */\n\n    this['cssText'] = '';\n    /** @type {boolean} */\n\n    this['atRule'] = false;\n    /** @type {number} */\n\n    this['type'] = 0;\n    /** @type {string} */\n\n    this['keyframesName'] = '';\n    /** @type {string} */\n\n    this['selector'] = '';\n    /** @type {string} */\n\n    this['parsedSelector'] = '';\n  }\n\n}\n\nexport { StyleNode }; // given a string of css, return a simple rule tree\n\n/**\n * @param {string} text\n * @return {StyleNode}\n */\n\nexport function parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n} // remove stuff we don't care about that may hinder parsing\n\n/**\n * @param {string} cssText\n * @return {string}\n */\n\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n} // super simple {...} lexer that returns a node tree\n\n/**\n * @param {string} text\n * @return {!StyleNode}\n */\n\n\nfunction lex(text) {\n  var root = new StyleNode();\n  root['start'] = 0;\n  root['end'] = text.length;\n  var n = root;\n\n  for (var i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n['rules']) {\n        n['rules'] = [];\n      }\n\n      var p = n;\n      var previous = p['rules'][p['rules'].length - 1] || null;\n      n = new StyleNode();\n      n['start'] = i + 1;\n      n['parent'] = p;\n      n['previous'] = previous;\n      p['rules'].push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n['end'] = i + 1;\n      n = n['parent'] || root;\n    }\n  }\n\n  return root;\n} // add selectors/cssText to node tree\n\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {!StyleNode}\n */\n\n\nfunction parseCss(node, text) {\n  var t = text.substring(node['start'], node['end'] - 1);\n  node['parsedCssText'] = node['cssText'] = t.trim();\n\n  if (node['parent']) {\n    var ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];\n    t = text.substring(ss, node['start'] - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' '); // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n\n    t = t.substring(t.lastIndexOf(';') + 1);\n    var s = node['parsedSelector'] = node['selector'] = t.trim();\n    node['atRule'] = s.indexOf(AT_START) === 0; // note, support a subset of rule types...\n\n    if (node['atRule']) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node['type'] = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node['type'] = types.KEYFRAMES_RULE;\n        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node['type'] = types.MIXIN_RULE;\n      } else {\n        node['type'] = types.STYLE_RULE;\n      }\n    }\n  }\n\n  var r$ = node['rules'];\n\n  if (r$) {\n    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n\n  return node;\n}\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\n\n\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n    var code = arguments[1],\n        repeat = 6 - code.length;\n\n    while (repeat--) {\n      code = '0' + code;\n    }\n\n    return '\\\\' + code;\n  });\n}\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\n\n\nexport function stringify(node, preserveProperties, text = '') {\n  // calc rule cssText\n  var cssText = '';\n\n  if (node['cssText'] || node['rules']) {\n    var r$ = node['rules'];\n\n    if (r$ && !_hasMixinRules(r$)) {\n      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties ? node['cssText'] : removeCustomProps(node['cssText']);\n      cssText = cssText.trim();\n\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  } // emit rule if there is cssText\n\n\n  if (cssText) {\n    if (node['selector']) {\n      text += node['selector'] + ' ' + OPEN_BRACE + '\\n';\n    }\n\n    text += cssText;\n\n    if (node['selector']) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n\n  return text;\n}\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\n\nfunction _hasMixinRules(rules) {\n  var r = rules[0];\n  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;\n}\n/**\n * @param {string} cssText\n * @return {string}\n */\n\n\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n/**\n * @param {string} cssText\n * @return {string}\n */\n\n\nexport function removeCustomPropAssignment(cssText) {\n  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n}\n/**\n * @param {string} cssText\n * @return {string}\n */\n\nfunction removeCustomPropApply(cssText) {\n  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n}\n/** @enum {number} */\n\n\nexport var types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000\n};\nvar OPEN_BRACE = '{';\nvar CLOSE_BRACE = '}'; // helper regexp's\n\nvar RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g\n};\nvar VAR_START = '--';\nvar MEDIA_START = '@media';\nvar AT_START = '@';"
    },
    {
     "id": 74,
     "name": "../node_modules/@webcomponents/shadycss/src/common-regex.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nexport var VAR_ASSIGN = /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};{])+)|\\{([^}]*)\\}(?:(?=[;\\s}])|$))/gi;\nexport var MIXIN_MATCH = /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi;\nexport var VAR_CONSUMED = /(--[\\w-]+)\\s*([:,;)]|$)/gi;\nexport var ANIMATION_MATCH = /(animation\\s*:)|(animation-name\\s*:)/;\nexport var MEDIA_MATCH = /@media\\s(.*)/;\nexport var IS_VAR = /^--/;\nexport var BRACKETED = /\\{[^}]*\\}/g;\nexport var HOST_PREFIX = '(?:^|[^.#[:])';\nexport var HOST_SUFFIX = '($|[.:[\\\\s>+~])';"
    },
    {
     "id": 76,
     "name": "../node_modules/@polymer/iron-resizable-behavior/iron-resizable-behavior.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport { useShadow } from '@polymer/polymer/lib/utils/settings.js'; // Contains all connected resizables that do not have a parent.\n\nvar ORPHANS = new Set();\n/**\n * `IronResizableBehavior` is a behavior that can be used in Polymer elements to\n * coordinate the flow of resize events between \"resizers\" (elements that\n *control the size or hidden state of their children) and \"resizables\" (elements\n *that need to be notified when they are resized or un-hidden by their parents\n *in order to take action on their new measurements).\n *\n * Elements that perform measurement should add the `IronResizableBehavior`\n *behavior to their element definition and listen for the `iron-resize` event on\n *themselves. This event will be fired when they become showing after having\n *been hidden, when they are resized explicitly by another resizable, or when\n *the window has been resized.\n *\n * Note, the `iron-resize` event is non-bubbling.\n *\n * @polymerBehavior\n * @demo demo/index.html\n **/\n\nexport var IronResizableBehavior = {\n  properties: {\n    /**\n     * The closest ancestor element that implements `IronResizableBehavior`.\n     */\n    _parentResizable: {\n      type: Object,\n      observer: '_parentResizableChanged'\n    },\n\n    /**\n     * True if this element is currently notifying its descendant elements of\n     * resize.\n     */\n    _notifyingDescendant: {\n      type: Boolean,\n      value: false\n    }\n  },\n  listeners: {\n    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'\n  },\n  created: function () {\n    // We don't really need property effects on these, and also we want them\n    // to be created before the `_parentResizable` observer fires:\n    this._interestedResizables = [];\n    this._boundNotifyResize = this.notifyResize.bind(this);\n    this._boundOnDescendantIronResize = this._onDescendantIronResize.bind(this);\n  },\n  attached: function () {\n    this._requestResizeNotifications();\n  },\n  detached: function () {\n    if (this._parentResizable) {\n      this._parentResizable.stopResizeNotificationsFor(this);\n    } else {\n      ORPHANS.delete(this);\n      window.removeEventListener('resize', this._boundNotifyResize);\n    }\n\n    this._parentResizable = null;\n  },\n\n  /**\n   * Can be called to manually notify a resizable and its descendant\n   * resizables of a resize change.\n   */\n  notifyResize: function () {\n    if (!this.isAttached) {\n      return;\n    }\n\n    this._interestedResizables.forEach(function (resizable) {\n      if (this.resizerShouldNotify(resizable)) {\n        this._notifyDescendant(resizable);\n      }\n    }, this);\n\n    this._fireResize();\n  },\n\n  /**\n   * Used to assign the closest resizable ancestor to this resizable\n   * if the ancestor detects a request for notifications.\n   */\n  assignParentResizable: function (parentResizable) {\n    if (this._parentResizable) {\n      this._parentResizable.stopResizeNotificationsFor(this);\n    }\n\n    this._parentResizable = parentResizable;\n\n    if (parentResizable && parentResizable._interestedResizables.indexOf(this) === -1) {\n      parentResizable._interestedResizables.push(this);\n\n      parentResizable._subscribeIronResize(this);\n    }\n  },\n\n  /**\n   * Used to remove a resizable descendant from the list of descendants\n   * that should be notified of a resize change.\n   */\n  stopResizeNotificationsFor: function (target) {\n    var index = this._interestedResizables.indexOf(target);\n\n    if (index > -1) {\n      this._interestedResizables.splice(index, 1);\n\n      this._unsubscribeIronResize(target);\n    }\n  },\n\n  /**\n   * Subscribe this element to listen to iron-resize events on the given target.\n   *\n   * Preferred over target.listen because the property renamer does not\n   * understand to rename when the target is not specifically \"this\"\n   *\n   * @param {!HTMLElement} target Element to listen to for iron-resize events.\n   */\n  _subscribeIronResize: function (target) {\n    target.addEventListener('iron-resize', this._boundOnDescendantIronResize);\n  },\n\n  /**\n   * Unsubscribe this element from listening to to iron-resize events on the\n   * given target.\n   *\n   * Preferred over target.unlisten because the property renamer does not\n   * understand to rename when the target is not specifically \"this\"\n   *\n   * @param {!HTMLElement} target Element to listen to for iron-resize events.\n   */\n  _unsubscribeIronResize: function (target) {\n    target.removeEventListener('iron-resize', this._boundOnDescendantIronResize);\n  },\n\n  /**\n   * This method can be overridden to filter nested elements that should or\n   * should not be notified by the current element. Return true if an element\n   * should be notified, or false if it should not be notified.\n   *\n   * @param {HTMLElement} element A candidate descendant element that\n   * implements `IronResizableBehavior`.\n   * @return {boolean} True if the `element` should be notified of resize.\n   */\n  resizerShouldNotify: function (element) {\n    return true;\n  },\n  _onDescendantIronResize: function (event) {\n    if (this._notifyingDescendant) {\n      event.stopPropagation();\n      return;\n    } // no need to use this during shadow dom because of event retargeting\n\n\n    if (!useShadow) {\n      this._fireResize();\n    }\n  },\n  _fireResize: function () {\n    this.fire('iron-resize', null, {\n      node: this,\n      bubbles: false\n    });\n  },\n  _onIronRequestResizeNotifications: function (event) {\n    var target =\n    /** @type {!EventTarget} */\n    dom(event).rootTarget;\n\n    if (target === this) {\n      return;\n    }\n\n    target.assignParentResizable(this);\n\n    this._notifyDescendant(target);\n\n    event.stopPropagation();\n  },\n  _parentResizableChanged: function (parentResizable) {\n    if (parentResizable) {\n      window.removeEventListener('resize', this._boundNotifyResize);\n    }\n  },\n  _notifyDescendant: function (descendant) {\n    // NOTE(cdata): In IE10, attached is fired on children first, so it's\n    // important not to notify them if the parent is not attached yet (or\n    // else they will get redundantly notified when the parent attaches).\n    if (!this.isAttached) {\n      return;\n    }\n\n    this._notifyingDescendant = true;\n    descendant.notifyResize();\n    this._notifyingDescendant = false;\n  },\n  _requestResizeNotifications: function () {\n    if (!this.isAttached) {\n      return;\n    }\n\n    if (document.readyState === 'loading') {\n      var _requestResizeNotifications = this._requestResizeNotifications.bind(this);\n\n      document.addEventListener('readystatechange', function readystatechanged() {\n        document.removeEventListener('readystatechange', readystatechanged);\n\n        _requestResizeNotifications();\n      });\n    } else {\n      this._findParent();\n\n      if (!this._parentResizable) {\n        // If this resizable is an orphan, tell other orphans to try to find\n        // their parent again, in case it's this resizable.\n        ORPHANS.forEach(function (orphan) {\n          if (orphan !== this) {\n            orphan._findParent();\n          }\n        }, this);\n        window.addEventListener('resize', this._boundNotifyResize);\n        this.notifyResize();\n      } else {\n        // If this resizable has a parent, tell other child resizables of\n        // that parent to try finding their parent again, in case it's this\n        // resizable.\n        this._parentResizable._interestedResizables.forEach(function (resizable) {\n          if (resizable !== this) {\n            resizable._findParent();\n          }\n        }, this);\n      }\n    }\n  },\n  _findParent: function () {\n    this.assignParentResizable(null);\n    this.fire('iron-request-resize-notifications', null, {\n      node: this,\n      bubbles: true,\n      cancelable: true\n    });\n\n    if (!this._parentResizable) {\n      ORPHANS.add(this);\n    } else {\n      ORPHANS.delete(this);\n    }\n  }\n};"
    },
    {
     "id": 77,
     "name": "../node_modules/@polymer/polymer/lib/legacy/class.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { LegacyElementMixin } from './legacy-element-mixin.js';\nimport { legacyOptimizations } from '../utils/settings.js';\nvar lifecycleProps = {\n  attached: true,\n  detached: true,\n  ready: true,\n  created: true,\n  beforeRegister: true,\n  registered: true,\n  attributeChanged: true,\n  listeners: true,\n  hostAttributes: true\n};\nvar excludeOnInfo = {\n  attached: true,\n  detached: true,\n  ready: true,\n  created: true,\n  beforeRegister: true,\n  registered: true,\n  attributeChanged: true,\n  behaviors: true,\n  _noAccessors: true\n};\nvar excludeOnBehaviors = Object.assign({\n  listeners: true,\n  hostAttributes: true,\n  properties: true,\n  observers: true\n}, excludeOnInfo);\n\nfunction copyProperties(source, target, excludeProps) {\n  var noAccessors = source._noAccessors;\n  var propertyNames = Object.getOwnPropertyNames(source);\n\n  for (var i = 0; i < propertyNames.length; i++) {\n    var p = propertyNames[i];\n\n    if (p in excludeProps) {\n      continue;\n    }\n\n    if (noAccessors) {\n      target[p] = source[p];\n    } else {\n      var pd = Object.getOwnPropertyDescriptor(source, p);\n\n      if (pd) {\n        // ensure property is configurable so that a later behavior can\n        // re-configure it.\n        pd.configurable = true;\n        Object.defineProperty(target, p, pd);\n      }\n    }\n  }\n}\n/**\n * Applies a \"legacy\" behavior or array of behaviors to the provided class.\n *\n * Note: this method will automatically also apply the `LegacyElementMixin`\n * to ensure that any legacy behaviors can rely on legacy Polymer API on\n * the underlying element.\n *\n * @function\n * @template T\n * @param {!Object|!Array<!Object>} behaviors Behavior object or array of behaviors.\n * @param {function(new:T)} klass Element class.\n * @return {?} Returns a new Element class extended by the\n * passed in `behaviors` and also by `LegacyElementMixin`.\n * @suppress {invalidCasts, checkTypes}\n */\n\n\nexport function mixinBehaviors(behaviors, klass) {\n  return GenerateClassFromInfo({}, LegacyElementMixin(klass), behaviors);\n} // NOTE:\n// 1.x\n// Behaviors were mixed in *in reverse order* and de-duped on the fly.\n// The rule was that behavior properties were copied onto the element\n// prototype if and only if the property did not already exist.\n// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:\n// (1), B, (2), A, (3) C. This means prototype properties win over\n// B properties win over A win over C. This mirrors what would happen\n// with inheritance if element extended B extended A extended C.\n//\n// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting\n// `behaviors` array was [C, A, B].\n// Behavior lifecycle methods were called in behavior array order\n// followed by the element, e.g. (1) C.created, (2) A.created,\n// (3) B.created, (4) element.created. There was no support for\n// super, and \"super-behavior\" methods were callable only by name).\n//\n// 2.x\n// Behaviors are made into proper mixins which live in the\n// element's prototype chain. Behaviors are placed in the element prototype\n// eldest to youngest and de-duped youngest to oldest:\n// So, first [A, B, C, A, B] becomes [C, A, B] then,\n// the element prototype becomes (oldest) (1) PolymerElement, (2) class(C),\n// (3) class(A), (4) class(B), (5) class(Polymer({...})).\n// Result:\n// This means element properties win over B properties win over A win\n// over C. (same as 1.x)\n// If lifecycle is called (super then me), order is\n// (1) C.created, (2) A.created, (3) B.created, (4) element.created\n// (again same as 1.x)\n\nfunction applyBehaviors(proto, behaviors, lifecycle) {\n  for (var i = 0; i < behaviors.length; i++) {\n    applyInfo(proto, behaviors[i], lifecycle, excludeOnBehaviors);\n  }\n}\n\nfunction applyInfo(proto, info, lifecycle, excludeProps) {\n  copyProperties(info, proto, excludeProps);\n\n  for (var p in lifecycleProps) {\n    if (info[p]) {\n      lifecycle[p] = lifecycle[p] || [];\n      lifecycle[p].push(info[p]);\n    }\n  }\n}\n/**\n * @param {Array} behaviors List of behaviors to flatten.\n * @param {Array=} list Target list to flatten behaviors into.\n * @param {Array=} exclude List of behaviors to exclude from the list.\n * @return {!Array} Returns the list of flattened behaviors.\n */\n\n\nfunction flattenBehaviors(behaviors, list, exclude) {\n  list = list || [];\n\n  for (var i = behaviors.length - 1; i >= 0; i--) {\n    var b = behaviors[i];\n\n    if (b) {\n      if (Array.isArray(b)) {\n        flattenBehaviors(b, list);\n      } else {\n        // dedup\n        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {\n          list.unshift(b);\n        }\n      }\n    } else {\n      console.warn('behavior is null, check for missing or 404 import');\n    }\n  }\n\n  return list;\n}\n/**\n * Copies property descriptors from source to target, overwriting all fields\n * of any previous descriptor for a property *except* for `value`, which is\n * merged in from the target if it does not exist on the source.\n * \n * @param {*} target Target properties object\n * @param {*} source Source properties object\n */\n\n\nfunction mergeProperties(target, source) {\n  for (var p in source) {\n    var targetInfo = target[p];\n    var sourceInfo = source[p];\n\n    if (!('value' in sourceInfo) && targetInfo && 'value' in targetInfo) {\n      target[p] = Object.assign({\n        value: targetInfo.value\n      }, sourceInfo);\n    } else {\n      target[p] = sourceInfo;\n    }\n  }\n}\n/* Note about construction and extension of legacy classes.\n  [Changed in Q4 2018 to optimize performance.]\n\n  When calling `Polymer` or `mixinBehaviors`, the generated class below is\n  made. The list of behaviors was previously made into one generated class per\n  behavior, but this is no longer the case as behaviors are now called\n  manually. Note, there may *still* be multiple generated classes in the\n  element's prototype chain if extension is used with `mixinBehaviors`.\n\n  The generated class is directly tied to the info object and behaviors\n  used to create it. That list of behaviors is filtered so it's only the\n  behaviors not active on the superclass. In order to call through to the\n  entire list of lifecycle methods, it's important to call `super`.\n\n  The element's `properties` and `observers` are controlled via the finalization\n  mechanism provided by `PropertiesMixin`. `Properties` and `observers` are\n  collected by manually traversing the prototype chain and merging.\n\n  To limit changes, the `_registered` method is called via `_initializeProperties`\n  and not `_finalizeClass`.\n\n*/\n\n/**\n * @param {!PolymerInit} info Polymer info object\n * @param {function(new:HTMLElement)} Base base class to extend with info object\n * @param {Object=} behaviors behaviors to copy into the element\n * @return {function(new:HTMLElement)} Generated class\n * @suppress {checkTypes}\n * @private\n */\n\n\nfunction GenerateClassFromInfo(info, Base, behaviors) {\n  // manages behavior and lifecycle processing (filled in after class definition)\n  var behaviorList;\n  var lifecycle = {};\n  /** @private */\n\n  class PolymerGenerated extends Base {\n    // explicitly not calling super._finalizeClass\n    static _finalizeClass() {\n      // if calling via a subclass that hasn't been generated, pass through to super\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('generatedFrom', this))) {\n        super._finalizeClass();\n      } else {\n        // interleave properties and observers per behavior and `info`\n        if (behaviorList) {\n          for (var i = 0, b; i < behaviorList.length; i++) {\n            b = behaviorList[i];\n\n            if (b.properties) {\n              this.createProperties(b.properties);\n            }\n\n            if (b.observers) {\n              this.createObservers(b.observers, b.properties);\n            }\n          }\n        }\n\n        if (info.properties) {\n          this.createProperties(info.properties);\n        }\n\n        if (info.observers) {\n          this.createObservers(info.observers, info.properties);\n        } // make sure to prepare the element template\n\n\n        this._prepareTemplate();\n      }\n    }\n\n    static get properties() {\n      var properties = {};\n\n      if (behaviorList) {\n        for (var i = 0; i < behaviorList.length; i++) {\n          mergeProperties(properties, behaviorList[i].properties);\n        }\n      }\n\n      mergeProperties(properties, info.properties);\n      return properties;\n    }\n\n    static get observers() {\n      var observers = [];\n\n      if (behaviorList) {\n        for (var i = 0, b; i < behaviorList.length; i++) {\n          b = behaviorList[i];\n\n          if (b.observers) {\n            observers = observers.concat(b.observers);\n          }\n        }\n      }\n\n      if (info.observers) {\n        observers = observers.concat(info.observers);\n      }\n\n      return observers;\n    }\n    /**\n     * @return {void}\n     */\n\n\n    created() {\n      super.created();\n      var list = lifecycle.created;\n\n      if (list) {\n        for (var i = 0; i < list.length; i++) {\n          list[i].call(this);\n        }\n      }\n    }\n    /**\n     * @return {void}\n     */\n\n\n    _registered() {\n      /* NOTE: `beforeRegister` is called here for bc, but the behavior\n        is different than in 1.x. In 1.0, the method was called *after*\n        mixing prototypes together but *before* processing of meta-objects.\n        However, dynamic effects can still be set here and can be done either\n        in `beforeRegister` or `registered`. It is no longer possible to set\n        `is` in `beforeRegister` as you could in 1.x.\n      */\n      // only proceed if the generated class' prototype has not been registered.\n      var generatedProto = PolymerGenerated.prototype;\n\n      if (!generatedProto.hasOwnProperty('__hasRegisterFinished')) {\n        generatedProto.__hasRegisterFinished = true; // ensure superclass is registered first.\n\n        super._registered(); // copy properties onto the generated class lazily if we're optimizing,\n\n\n        if (legacyOptimizations) {\n          copyPropertiesToProto(generatedProto);\n        } // make sure legacy lifecycle is called on the *element*'s prototype\n        // and not the generated class prototype; if the element has been\n        // extended, these are *not* the same.\n\n\n        var proto = Object.getPrototypeOf(this);\n        var list = lifecycle.beforeRegister;\n\n        if (list) {\n          for (var i = 0; i < list.length; i++) {\n            list[i].call(proto);\n          }\n        }\n\n        list = lifecycle.registered;\n\n        if (list) {\n          for (var _i = 0; _i < list.length; _i++) {\n            list[_i].call(proto);\n          }\n        }\n      }\n    }\n    /**\n     * @return {void}\n     */\n\n\n    _applyListeners() {\n      super._applyListeners();\n\n      var list = lifecycle.listeners;\n\n      if (list) {\n        for (var i = 0; i < list.length; i++) {\n          var listeners = list[i];\n\n          if (listeners) {\n            for (var l in listeners) {\n              this._addMethodEventListenerToNode(this, l, listeners[l]);\n            }\n          }\n        }\n      }\n    } // note: exception to \"super then me\" rule;\n    // do work before calling super so that super attributes\n    // only apply if not already set.\n\n    /**\n     * @return {void}\n     */\n\n\n    _ensureAttributes() {\n      var list = lifecycle.hostAttributes;\n\n      if (list) {\n        for (var i = list.length - 1; i >= 0; i--) {\n          var hostAttributes = list[i];\n\n          for (var a in hostAttributes) {\n            this._ensureAttribute(a, hostAttributes[a]);\n          }\n        }\n      }\n\n      super._ensureAttributes();\n    }\n    /**\n     * @return {void}\n     */\n\n\n    ready() {\n      super.ready();\n      var list = lifecycle.ready;\n\n      if (list) {\n        for (var i = 0; i < list.length; i++) {\n          list[i].call(this);\n        }\n      }\n    }\n    /**\n     * @return {void}\n     */\n\n\n    attached() {\n      super.attached();\n      var list = lifecycle.attached;\n\n      if (list) {\n        for (var i = 0; i < list.length; i++) {\n          list[i].call(this);\n        }\n      }\n    }\n    /**\n     * @return {void}\n     */\n\n\n    detached() {\n      super.detached();\n      var list = lifecycle.detached;\n\n      if (list) {\n        for (var i = 0; i < list.length; i++) {\n          list[i].call(this);\n        }\n      }\n    }\n    /**\n     * Implements native Custom Elements `attributeChangedCallback` to\n     * set an attribute value to a property via `_attributeToProperty`.\n     *\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @return {void}\n     */\n\n\n    attributeChanged(name, old, value) {\n      super.attributeChanged();\n      var list = lifecycle.attributeChanged;\n\n      if (list) {\n        for (var i = 0; i < list.length; i++) {\n          list[i].call(this, name, old, value);\n        }\n      }\n    }\n\n  } // apply behaviors, note actual copying is done lazily at first instance creation\n\n\n  if (behaviors) {\n    // NOTE: ensure the behavior is extending a class with\n    // legacy element api. This is necessary since behaviors expect to be able\n    // to access 1.x legacy api.\n    if (!Array.isArray(behaviors)) {\n      behaviors = [behaviors];\n    }\n\n    var superBehaviors = Base.prototype.behaviors; // get flattened, deduped list of behaviors *not* already on super class\n\n    behaviorList = flattenBehaviors(behaviors, null, superBehaviors);\n    PolymerGenerated.prototype.behaviors = superBehaviors ? superBehaviors.concat(behaviors) : behaviorList;\n  }\n\n  var copyPropertiesToProto = proto => {\n    if (behaviorList) {\n      applyBehaviors(proto, behaviorList, lifecycle);\n    }\n\n    applyInfo(proto, info, lifecycle, excludeOnInfo);\n  }; // copy properties if we're not optimizing\n\n\n  if (!legacyOptimizations) {\n    copyPropertiesToProto(PolymerGenerated.prototype);\n  }\n\n  PolymerGenerated.generatedFrom = info;\n  return PolymerGenerated;\n}\n/**\n * Generates a class that extends `LegacyElement` based on the\n * provided info object.  Metadata objects on the `info` object\n * (`properties`, `observers`, `listeners`, `behaviors`, `is`) are used\n * for Polymer's meta-programming systems, and any functions are copied\n * to the generated class.\n *\n * Valid \"metadata\" values are as follows:\n *\n * `is`: String providing the tag name to register the element under. In\n * addition, if a `dom-module` with the same id exists, the first template\n * in that `dom-module` will be stamped into the shadow root of this element,\n * with support for declarative event listeners (`on-...`), Polymer data\n * bindings (`[[...]]` and `{{...}}`), and id-based node finding into\n * `this.$`.\n *\n * `properties`: Object describing property-related metadata used by Polymer\n * features (key: property names, value: object containing property metadata).\n * Valid keys in per-property metadata include:\n * - `type` (String|Number|Object|Array|...): Used by\n *   `attributeChangedCallback` to determine how string-based attributes\n *   are deserialized to JavaScript property values.\n * - `notify` (boolean): Causes a change in the property to fire a\n *   non-bubbling event called `<property>-changed`. Elements that have\n *   enabled two-way binding to the property use this event to observe changes.\n * - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *   To set a read-only property, use the private setter method\n *   `_setProperty(property, value)`.\n * - `observer` (string): Observer method name that will be called when\n *   the property changes. The arguments of the method are\n *   `(value, previousValue)`.\n * - `computed` (string): String describing method and dependent properties\n *   for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *   Computed properties are read-only by default and can only be changed\n *   via the return value of the computing method.\n *\n * `observers`: Array of strings describing multi-property observer methods\n *  and their dependent properties (e.g. `'observeABC(a, b, c)'`).\n *\n * `listeners`: Object describing event listeners to be added to each\n *  instance of this element (key: event name, value: method name).\n *\n * `behaviors`: Array of additional `info` objects containing metadata\n * and callbacks in the same format as the `info` object here which are\n * merged into this element.\n *\n * `hostAttributes`: Object listing attributes to be applied to the host\n *  once created (key: attribute name, value: attribute value).  Values\n *  are serialized based on the type of the value.  Host attributes should\n *  generally be limited to attributes such as `tabIndex` and `aria-...`.\n *  Attributes in `hostAttributes` are only applied if a user-supplied\n *  attribute is not already present (attributes in markup override\n *  `hostAttributes`).\n *\n * In addition, the following Polymer-specific callbacks may be provided:\n * - `registered`: called after first instance of this element,\n * - `created`: called during `constructor`\n * - `attached`: called during `connectedCallback`\n * - `detached`: called during `disconnectedCallback`\n * - `ready`: called before first `attached`, after all properties of\n *   this element have been propagated to its template and all observers\n *   have run\n *\n * @param {!PolymerInit} info Object containing Polymer metadata and functions\n *   to become class methods.\n * @template T\n * @param {function(T):T} mixin Optional mixin to apply to legacy base class\n *   before extending with Polymer metaprogramming.\n * @return {function(new:HTMLElement)} Generated class\n */\n\n\nexport var Class = function (info, mixin) {\n  if (!info) {\n    console.warn('Polymer.Class requires `info` argument');\n  }\n\n  var klass = mixin ? mixin(LegacyElementMixin(HTMLElement)) : LegacyElementMixin(HTMLElement);\n  klass = GenerateClassFromInfo(info, klass, info.behaviors); // decorate klass with registration info\n\n  klass.is = klass.prototype.is = info.is;\n  return klass;\n};"
    },
    {
     "id": 80,
     "name": "../node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js?babel-target=es6",
     "source": "import { DirHelper } from './vaadin-dir-helper.js';\n/**\n * Array of Vaadin custom element classes that have been subscribed to the dir changes.\n */\n\nvar directionSubscribers = [];\n\nvar directionUpdater = function () {\n  var documentDir = getDocumentDir();\n  directionSubscribers.forEach(element => {\n    alignDirs(element, documentDir);\n  });\n};\n\nvar scrollType;\nvar directionObserver = new MutationObserver(directionUpdater);\ndirectionObserver.observe(document.documentElement, {\n  attributes: true,\n  attributeFilter: ['dir']\n});\n\nvar alignDirs = function (element, documentDir) {\n  if (documentDir) {\n    element.setAttribute('dir', documentDir);\n  } else {\n    element.removeAttribute('dir');\n  }\n};\n\nvar getDocumentDir = function () {\n  return document.documentElement.getAttribute('dir');\n};\n/**\n * @polymerMixin\n */\n\n\nexport var DirMixin = superClass => class VaadinDirMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * @protected\n       */\n      dir: {\n        type: String,\n        readOnly: true\n      }\n    };\n  }\n  /** @protected */\n\n\n  static finalize() {\n    super.finalize();\n\n    if (!scrollType) {\n      scrollType = DirHelper.detectScrollType();\n    }\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    if (!this.hasAttribute('dir')) {\n      this.__subscribe();\n\n      alignDirs(this, getDocumentDir());\n    }\n  }\n  /** @protected */\n\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    super.attributeChangedCallback(name, oldValue, newValue);\n\n    if (name !== 'dir') {\n      return;\n    } // New value equals to the document direction and the element is not subscribed to the changes\n\n\n    var newValueEqlDocDir = newValue === getDocumentDir() && directionSubscribers.indexOf(this) === -1; // Value was emptied and the element is not subscribed to the changes\n\n    var newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1; // New value is different and the old equals to document direction and the element is not subscribed to the changes\n\n    var newDiffValue = newValue !== getDocumentDir() && oldValue === getDocumentDir();\n\n    if (newValueEqlDocDir || newValueEmptied) {\n      this.__subscribe();\n\n      alignDirs(this, getDocumentDir());\n    } else if (newDiffValue) {\n      this.__subscribe(false);\n    }\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    this.__subscribe(false);\n\n    this.removeAttribute('dir');\n  }\n  /** @private */\n\n\n  __subscribe(push = true) {\n    if (push) {\n      directionSubscribers.indexOf(this) === -1 && directionSubscribers.push(this);\n    } else {\n      directionSubscribers.indexOf(this) > -1 && directionSubscribers.splice(directionSubscribers.indexOf(this), 1);\n    }\n  }\n  /**\n   * @param {Element} element\n   * @return {number}\n   * @protected\n   */\n\n\n  __getNormalizedScrollLeft(element) {\n    return DirHelper.getNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', element);\n  }\n  /**\n   * @param {Element} element\n   * @param {number} scrollLeft\n   * @protected\n   */\n\n\n  __setNormalizedScrollLeft(element, scrollLeft) {\n    return DirHelper.setNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', element, scrollLeft);\n  }\n\n};"
    },
    {
     "id": 82,
     "name": "../node_modules/@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n// We consider the keyboard to be active if the window has received a keydown\n// event since the last mousedown event.\nvar keyboardActive = false; // Listen for top-level keydown and mousedown events.\n// Use capture phase so we detect events even if they're handled.\n\nwindow.addEventListener('keydown', () => {\n  keyboardActive = true;\n}, {\n  capture: true\n});\nwindow.addEventListener('mousedown', () => {\n  keyboardActive = false;\n}, {\n  capture: true\n});\n/**\n * A private mixin to avoid problems with dynamic properties and Polymer Analyzer.\n * No need to expose these properties in the API docs.\n * @polymerMixin\n * @private\n */\n\nvar TabIndexMixin = superClass => class VaadinTabIndexMixin extends superClass {\n  static get properties() {\n    var properties = {\n      /**\n       * Internal property needed to listen to `tabindex` attribute changes.\n       *\n       * For changing the tabindex of this component use the native `tabIndex` property.\n       * @private\n       */\n      tabindex: {\n        type: Number,\n        value: 0,\n        reflectToAttribute: true,\n        observer: '_tabindexChanged'\n      }\n    };\n\n    if (window.ShadyDOM) {\n      // ShadyDOM browsers need the `tabIndex` in order to notify when the user changes it programmatically.\n      properties['tabIndex'] = properties.tabindex;\n    }\n\n    return properties;\n  }\n\n};\n/**\n * Polymer.IronControlState is not a proper 2.0 class, also, its tabindex\n * implementation fails in the shadow dom, so we have this for vaadin elements.\n * @polymerMixin\n */\n\n\nexport var ControlStateMixin = superClass => class VaadinControlStateMixin extends TabIndexMixin(superClass) {\n  static get properties() {\n    return {\n      /**\n       * Specify that this control should have input focus when the page loads.\n       */\n      autofocus: {\n        type: Boolean\n      },\n\n      /**\n       * Stores the previous value of tabindex attribute of the disabled element\n       * @private\n       */\n      _previousTabIndex: {\n        type: Number\n      },\n\n      /**\n       * If true, the user cannot interact with this element.\n       */\n      disabled: {\n        type: Boolean,\n        observer: '_disabledChanged',\n        reflectToAttribute: true\n      },\n\n      /**\n       * @private\n       */\n      _isShiftTabbing: {\n        type: Boolean\n      }\n    };\n  }\n  /**\n   * @protected\n   */\n\n\n  ready() {\n    this.addEventListener('focusin', e => {\n      if (e.composedPath()[0] === this) {\n        // Only focus if the focus is received from somewhere outside\n        if (!this.contains(e.relatedTarget)) {\n          this._focus();\n        }\n      } else if (e.composedPath().indexOf(this.focusElement) !== -1 && !this.disabled) {\n        this._setFocused(true);\n      }\n    });\n    this.addEventListener('focusout', e => this._setFocused(false)); // In super.ready() other 'focusin' and 'focusout' listeners might be\n    // added, so we call it after our own ones to ensure they execute first.\n    // Issue to watch out: when incorrect, <vaadin-combo-box> refocuses the\n    // input field on iOS after Done is pressed.\n\n    super.ready(); // This fixes the bug in Firefox 61 (https://bugzilla.mozilla.org/show_bug.cgi?id=1472887)\n    // where focusout event does not go out of shady DOM because composed property in the event is not true\n\n    var ensureEventComposed = e => {\n      if (!e.composed) {\n        e.target.dispatchEvent(new CustomEvent(e.type, {\n          bubbles: true,\n          composed: true,\n          cancelable: false\n        }));\n      }\n    };\n\n    this.shadowRoot.addEventListener('focusin', ensureEventComposed);\n    this.shadowRoot.addEventListener('focusout', ensureEventComposed);\n    this.addEventListener('keydown', e => {\n      if (!e.defaultPrevented && e.keyCode === 9) {\n        if (e.shiftKey) {\n          // Flag is checked in _focus event handler.\n          this._isShiftTabbing = true;\n          HTMLElement.prototype.focus.apply(this);\n\n          this._setFocused(false); // Event handling in IE is asynchronous and the flag is removed asynchronously as well\n\n\n          setTimeout(() => this._isShiftTabbing = false, 0);\n        } else {\n          // Workaround for FF63-65 bug that causes the focus to get lost when\n          // blurring a slotted component with focusable shadow root content\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1528686\n          // TODO: Remove when safe\n          var firefox = window.navigator.userAgent.match(/Firefox\\/(\\d\\d\\.\\d)/);\n\n          if (firefox && parseFloat(firefox[1]) >= 63 && parseFloat(firefox[1]) < 66 && this.parentNode && this.nextSibling) {\n            var fakeTarget = document.createElement('input');\n            fakeTarget.style.position = 'absolute';\n            fakeTarget.style.opacity = '0';\n            fakeTarget.tabIndex = this.tabIndex;\n            this.parentNode.insertBefore(fakeTarget, this.nextSibling);\n            fakeTarget.focus();\n            fakeTarget.addEventListener('focusout', () => this.parentNode.removeChild(fakeTarget));\n          }\n        }\n      }\n    });\n\n    if (this.autofocus && !this.disabled) {\n      window.requestAnimationFrame(() => {\n        this._focus();\n\n        this._setFocused(true);\n\n        this.setAttribute('focus-ring', '');\n      });\n    }\n  }\n  /**\n   * @protected\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback(); // in non-Chrome browsers, blur does not fire on the element when it is disconnected.\n    // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.\n\n    if (this.hasAttribute('focused')) {\n      this._setFocused(false);\n    }\n  }\n  /**\n   * @param {boolean} focused\n   * @protected\n   */\n\n\n  _setFocused(focused) {\n    if (focused) {\n      this.setAttribute('focused', '');\n    } else {\n      this.removeAttribute('focused');\n    } // focus-ring is true when the element was focused from the keyboard.\n    // Focus Ring [A11ycasts]: https://youtu.be/ilj2P5-5CjI\n\n\n    if (focused && keyboardActive) {\n      this.setAttribute('focus-ring', '');\n    } else {\n      this.removeAttribute('focus-ring');\n    }\n  }\n  /**\n   * Any element extending this mixin is required to implement this getter.\n   * It returns the actual focusable element in the component.\n   * @return {Element | null | undefined}\n   */\n\n\n  get focusElement() {\n    window.console.warn(`Please implement the 'focusElement' property in <${this.localName}>`);\n    return this;\n  }\n  /**\n   * @protected\n   */\n\n\n  _focus() {\n    if (!this.focusElement || this._isShiftTabbing) {\n      return;\n    }\n\n    this.focusElement.focus();\n\n    this._setFocused(true);\n  }\n  /**\n   * Moving the focus from the host element causes firing of the blur event what leads to problems in IE.\n   * @private\n   */\n\n\n  focus() {\n    if (!this.focusElement || this.disabled) {\n      return;\n    }\n\n    this.focusElement.focus();\n\n    this._setFocused(true);\n  }\n  /**\n   * Native bluring in the host element does nothing because it does not have the focus.\n   * In chrome it works, but not in FF.\n   * @private\n   */\n\n\n  blur() {\n    if (!this.focusElement) {\n      return;\n    }\n\n    this.focusElement.blur();\n\n    this._setFocused(false);\n  }\n  /**\n   * @param {boolean} disabled\n   * @private\n   */\n\n\n  _disabledChanged(disabled) {\n    this.focusElement.disabled = disabled;\n\n    if (disabled) {\n      this.blur();\n      this._previousTabIndex = this.tabindex;\n      this.tabindex = -1;\n      this.setAttribute('aria-disabled', 'true');\n    } else {\n      if (typeof this._previousTabIndex !== 'undefined') {\n        this.tabindex = this._previousTabIndex;\n      }\n\n      this.removeAttribute('aria-disabled');\n    }\n  }\n  /**\n   * @param {number | null | undefined} tabindex\n   * @private\n   */\n\n\n  _tabindexChanged(tabindex) {\n    if (tabindex !== undefined) {\n      this.focusElement.tabIndex = tabindex;\n    }\n\n    if (this.disabled && this.tabindex) {\n      // If tabindex attribute was changed while checkbox was disabled\n      if (this.tabindex !== -1) {\n        this._previousTabIndex = this.tabindex;\n      }\n\n      this.tabindex = tabindex = undefined;\n    }\n\n    if (window.ShadyDOM) {\n      this.setProperties({\n        tabIndex: tabindex,\n        tabindex: tabindex\n      });\n    }\n  }\n  /**\n   * @protected\n   */\n\n\n  click() {\n    if (!this.disabled) {\n      super.click();\n    }\n  }\n\n};"
    },
    {
     "id": 84,
     "name": "../node_modules/@webcomponents/shadycss/src/template-map.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n'use strict';\n/**\n * @const {!Object<string, !HTMLTemplateElement>}\n */\n\nvar templateMap = {};\nexport default templateMap;"
    },
    {
     "id": 86,
     "name": "./styles/views/main/main-view.css",
     "source": "export default \"#header {\\n  height: var(--lumo-size-xl);\\n}\\n#header h1 {\\n  font-size: var(--lumo-font-size-l);\\n  margin: 0;\\n}\\n#header img#logo {\\n  height: var(--lumo-size-l);\\n  margin: 0 var(--lumo-space-s);\\n}\\n#header img#avatar {\\n  border-radius: 50%;\\n  height: var(--lumo-size-s);\\n  margin-right: var(--lumo-space-m);\\n  overflow: hidden;\\n  margin-left: auto;\\n  background-color: var(--lumo-contrast);\\n}\\nvaadin-app-layout[dir='rtl'] vaadin-horizontal-layout #header img#avatar {\\n  margin-left: var(--lumo-space-m);\\n  margin-right: auto;\\n}\\n\""
    },
    {
     "id": 87,
     "name": "../node_modules/@polymer/polymer/lib/mixins/element-mixin.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 89,
     "name": "../node_modules/@webcomponents/shadycss/src/common-utils.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n'use strict';\n\nimport { MIXIN_MATCH, VAR_ASSIGN } from './common-regex.js';\n/**\n * @param {Element} element\n * @param {Object=} properties\n */\n\nexport function updateNativeProperties(element, properties) {\n  // remove previous properties\n  for (var p in properties) {\n    // NOTE: for bc with shim, don't apply null values.\n    if (p === null) {\n      element.style.removeProperty(p);\n    } else {\n      element.style.setProperty(p, properties[p]);\n    }\n  }\n}\n/**\n * @param {Element} element\n * @param {string} property\n * @return {string}\n */\n\nexport function getComputedStyleValue(element, property) {\n  /**\n   * @const {string}\n   */\n  var value = window.getComputedStyle(element).getPropertyValue(property);\n\n  if (!value) {\n    return '';\n  } else {\n    return value.trim();\n  }\n}\n/**\n * return true if `cssText` contains a mixin definition or consumption\n * @param {string} cssText\n * @return {boolean}\n */\n\nexport function detectMixin(cssText) {\n  var has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText); // reset state of the regexes\n\n  MIXIN_MATCH.lastIndex = 0;\n  VAR_ASSIGN.lastIndex = 0;\n  return has;\n}"
    },
    {
     "id": 90,
     "name": "../node_modules/@polymer/polymer/lib/mixins/mutable-data.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { dedupingMixin } from '../utils/mixin.js'; // Common implementation for mixin & behavior\n\nfunction mutablePropertyChange(inst, property, value, old, mutableData) {\n  var isObject;\n\n  if (mutableData) {\n    isObject = typeof value === 'object' && value !== null; // Pull `old` for Objects from temp cache, but treat `null` as a primitive\n\n    if (isObject) {\n      old = inst.__dataTemp[property];\n    }\n  } // Strict equality check, but return false for NaN===NaN\n\n\n  var shouldChange = old !== value && (old === old || value === value); // Objects are stored in temporary cache (cleared at end of\n  // turn), which is used for dirty-checking\n\n  if (isObject && shouldChange) {\n    inst.__dataTemp[property] = value;\n  }\n\n  return shouldChange;\n}\n/**\n * Element class mixin to skip strict dirty-checking for objects and arrays\n * (always consider them to be \"dirty\"), for use on elements utilizing\n * `PropertyEffects`\n *\n * By default, `PropertyEffects` performs strict dirty checking on\n * objects, which means that any deep modifications to an object or array will\n * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n * references from the root to the mutation were changed).\n *\n * Polymer also provides a proprietary data mutation and path notification API\n * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n * mutation and notification of deep changes in an object graph to all elements\n * bound to the same object graph.\n *\n * In cases where neither immutable patterns nor the data mutation API can be\n * used, applying this mixin will cause Polymer to skip dirty checking for\n * objects and arrays (always consider them to be \"dirty\").  This allows a\n * user to make a deep modification to a bound object graph, and then either\n * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n * elements that wish to be updated based on deep mutations must apply this\n * mixin or otherwise skip strict dirty checking for objects/arrays.\n * Specifically, any elements in the binding tree between the source of a\n * mutation and the consumption of it must apply this mixin or enable the\n * `OptionalMutableData` mixin.\n *\n * In order to make the dirty check strategy configurable, see\n * `OptionalMutableData`.\n *\n * Note, the performance characteristics of propagating large object graphs\n * will be worse as opposed to using strict dirty checking with immutable\n * patterns or Polymer's path notification API.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin to skip strict dirty-checking for objects\n *   and arrays\n */\n\n\nexport var MutableData = dedupingMixin(superClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_MutableData}\n   */\n  class MutableData extends superClass {\n    /**\n     * Overrides `PropertyEffects` to provide option for skipping\n     * strict equality checking for Objects and Arrays.\n     *\n     * This method pulls the value to dirty check against from the `__dataTemp`\n     * cache (rather than the normal `__data` cache) for Objects.  Since the temp\n     * cache is cleared at the end of a turn, this implementation allows\n     * side-effects of deep object changes to be processed by re-setting the\n     * same object (using the temp cache as an in-turn backstop to prevent\n     * cycles due to 2-way notification).\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     * @protected\n     */\n    _shouldPropertyChange(property, value, old) {\n      return mutablePropertyChange(this, property, value, old, true);\n    }\n\n  }\n\n  return MutableData;\n});\n/**\n * Element class mixin to add the optional ability to skip strict\n * dirty-checking for objects and arrays (always consider them to be\n * \"dirty\") by setting a `mutable-data` attribute on an element instance.\n *\n * By default, `PropertyEffects` performs strict dirty checking on\n * objects, which means that any deep modifications to an object or array will\n * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n * references from the root to the mutation were changed).\n *\n * Polymer also provides a proprietary data mutation and path notification API\n * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n * mutation and notification of deep changes in an object graph to all elements\n * bound to the same object graph.\n *\n * In cases where neither immutable patterns nor the data mutation API can be\n * used, applying this mixin will allow Polymer to skip dirty checking for\n * objects and arrays (always consider them to be \"dirty\").  This allows a\n * user to make a deep modification to a bound object graph, and then either\n * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n * elements that wish to be updated based on deep mutations must apply this\n * mixin or otherwise skip strict dirty checking for objects/arrays.\n * Specifically, any elements in the binding tree between the source of a\n * mutation and the consumption of it must enable this mixin or apply the\n * `MutableData` mixin.\n *\n * While this mixin adds the ability to forgo Object/Array dirty checking,\n * the `mutableData` flag defaults to false and must be set on the instance.\n *\n * Note, the performance characteristics of propagating large object graphs\n * will be worse by relying on `mutableData: true` as opposed to using\n * strict dirty checking with immutable patterns or Polymer's path notification\n * API.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin to optionally skip strict dirty-checking\n *   for objects and arrays\n */\n\nexport var OptionalMutableData = dedupingMixin(superClass => {\n  /**\n   * @mixinClass\n   * @polymer\n   * @implements {Polymer_OptionalMutableData}\n   */\n  class OptionalMutableData extends superClass {\n    static get properties() {\n      return {\n        /**\n         * Instance-level flag for configuring the dirty-checking strategy\n         * for this element.  When true, Objects and Arrays will skip dirty\n         * checking, otherwise strict equality checking will be used.\n         */\n        mutableData: Boolean\n      };\n    }\n    /**\n     * Overrides `PropertyEffects` to provide option for skipping\n     * strict equality checking for Objects and Arrays.\n     *\n     * When `this.mutableData` is true on this instance, this method\n     * pulls the value to dirty check against from the `__dataTemp` cache\n     * (rather than the normal `__data` cache) for Objects.  Since the temp\n     * cache is cleared at the end of a turn, this implementation allows\n     * side-effects of deep object changes to be processed by re-setting the\n     * same object (using the temp cache as an in-turn backstop to prevent\n     * cycles due to 2-way notification).\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     * @protected\n     */\n\n\n    _shouldPropertyChange(property, value, old) {\n      return mutablePropertyChange(this, property, value, old, this.mutableData);\n    }\n\n  }\n\n  return OptionalMutableData;\n}); // Export for use by legacy behavior\n\nMutableData._mutablePropertyChange = mutablePropertyChange;"
    },
    {
     "id": 93,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/font-icons.js?babel-target=es6",
     "source": "import '@polymer/polymer/lib/elements/custom-style.js';\nimport './version.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<custom-style>\n  <style>\n    @font-face {\n      font-family: 'lumo-icons';\n      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABEgAAsAAAAAIiwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUuKY21hcAAAAYgAAAD4AAADrsCU8d5nbHlmAAACgAAAC2MAABd4h9To2WhlYWQAAA3kAAAAMQAAADYSnCkuaGhlYQAADhgAAAAdAAAAJAbpA35obXR4AAAOOAAAABAAAACspBAAAGxvY2EAAA5IAAAAWAAAAFh55IAsbWF4cAAADqAAAAAfAAAAIAFKAXBuYW1lAAAOwAAAATEAAAIuUUJZCHBvc3QAAA/0AAABKwAAAelm8SzVeJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGS+yDiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+0mIO+p/FEMUcxDANKMwIkgMABn8MLQB4nO3SWW6DMABF0UtwCEnIPM/zhLK8LqhfXRybSP14XUYtHV9hGYQwQBNIo3cUIPkhQeM7rib1ekqnXg981XuC1qvy84lzojleh3puxL0hPjGjRU473teloEefAUNGjJkwZcacBUtWrNmwZceeA0dOnLlw5cadB09elPGhGf+j0NTI/65KfXerT6JhqKnpRKtgOpuqaTrtKjPUlqHmhto21I7pL6i6hlqY3q7qGWrfUAeGOjTUkaGODXViqFNDnRnq3FAXhro01JWhrg11Y6hbQ90Z6t5QD4Z6NNSToZ4N9WKoV0O9GerdUB+G+jTUl6GWRvkL24BkEXictVh9bFvVFb/nxvbz+7Rf/N6zHcd2bCfP+Wgc1Z9N0jpNnEL6kbRVS6HA2hQYGh9TGR1CbCqa2rXrWOkQE/sHNJgmtZvoVNZqE1B1DNHxzTQxCehUTYiJTQyENui0qSLezr3PduyQfgmRWOfde8+9551z7rnn/O4jLoJ/bRP0UaKQMLFJjpBAvphLZC3Dk0ok7WBzR2/upJs7Ryw/nfFbln/uuN/apCvwrKLrSvUqRufbm5pn0fs0w4gYxnGVP6qHnO4bWiDQGQgwtS6lm3lB3QoX1M2vwEmuzirF39y+Es2+DJ8d1pkyqBIqoze3D1+Zz4DrFoazxI8dWwMrDlZ2DMqQAR9AROsJU+2cmlTPazTco52F1xTa2a2+K8vvq92dVHmtLoPeQX/AZPRYGthDYOeZjBjKoFsVGulR3lWU95WeCK44qHU7MhWUGUKZDT3oKUcG2GWuh+EDDfUYA/jhAhl0TOsJNYSEu7mQmi3UzfXwZKA4BsVsHLXQYGgRW95uEtpJ1Vfn9XiLriRBlFEqxsDjA09yCNUoQxxwd7KWSTt2y3GTKiflqHRSoWZc3m11Wa/fJdFgXD4sSYfleJBKd8GMz7J8dZn/cGRCcKGDnA2Ge3fKzcvlnTDNthGWLXzX/WaXtUAmRgeLlHSr30r0G9UTXMb0AtmwzOoy73fkSlHZkduw/TYuU9cAD4YutPoxTTsA3797wVr4Z/1NC5zARHr4vtxJjxIfiZMhMkbWk+14BnJZKwqGZwDfswLyxWDSg11rFLJF7Nopxjd1h1/QOT+oezgfu3Yq+Hk+duf5x+40o1GTkaIgikK/IEnC6aYxCUBaZJSN4XTYFjU/YMNIKqJwhDGOCCI8FDXnXmXjtGhGJyShqjAOnBOkW2JG9S7GgYeMWAU5JzhnWmBOaOM+CKEPoqSfFDC2Unq+DLlUgUVUFFLZGJg6jtlojsdsa8kPObPuJdi5dnBdBsLJMGTWDa4t2JvtwuPo9s+Y86suv/W33QG1rAaOAUV+vx4K6f2D04PVKlC7WLSrZzAi45ZV6lIC7WoXqmRyvUqoVwrzUoVsIjeTXWQv+RH5GTlBXiB/In8ln0IbBCAFOajAJrgZYyOHWqOfUe/aHjI12R6OQo1jCgt215l+4f6XPb+0MNou0V+43n2F77tSfRb24d7zitgnKmvYHs69zugaPvBwv6ioXkb2LdL65Atw51uLkXlu1bhMMRcXSPcYoqKIRlh34lQP8/5JbuUFye4vxD6/6MxFF11C0uVLr9Ulgw44tS3pMViNLUExbycFgLIct+QDMibRimx1ydUz8FXZiuOIDBOMVX2nUZc+huNE5XUJ81uiJoiabwqaVF0uacKbau/pl4R2VW0XXlJra6boVrYG646TF5NYzwy4vjENVrDlcNpZPl8DH6XX8XWCx0mvWVZY6KFLrvsY66/zPict5FnxaNUR/juvZCM3TvD60E2W1tZizbXTPDuabcm0nbbzpWKpmA1ayBQ8giedLUM+A0kNjBjQjmuYz7YrgIXYvmF63ZLBwSXrpn9Tb9wwdd/U1H0PMQK3XcO8ul3WT7PyPPdpy0TemKxNRcJNauiXJnnUDpUppQWs4SnUIy0EESGYqJYQLGHxzaGWwVIaS6Y7mQFM8ZjYDQ3axjf61SWjU33JwOZA1pwaG1L9mzf71aHRdX1JHw6Fp0aXhNwbqyeGNg4NbdzGCBxoz4ZXjy4Nu69Zr6sDY6vMrLU5nA1P8JkbdWXJ6ERfMryvNh1JfQ9+T4dIhGvK9w3dxjBBzatsQ/MlOHVIDnYpDz6odAXlQ01t2Pa5Iafd8MMpxAeDKP0C6CjgVLT5osB6icUx01lWjXxzT/GyRF2welEM5Z/7jG3VjQ1SrNn5IbyzOG5dobB3/QHxyZvsXcoz8IoEwS7plCg+zxHQk424q9BfEpkESJbFHQusDBSWFkuBkoPO0kLKwRVYjxGXlHTcTDQMJ/H6TX9afkO7mnraTO1feTnZAXLu4cp7HAXMmNG1yeFk9TgS/NHhZR/4QoBTr/ZB+6hCgyl15Nq1UbN6nE1/ZnP1U2cizCBpvs8cJQZJ4LkYx5N/yZPAUZNQQ0V4f3BQllWrK3YRzl30dOT6RVn2upNur6woSa8CqpdT/aKnBM4o3jNur9d9xqtUT6veBEt9Ca9at+ERzEEhUkR8sa5mQ4aVvJoVeEA8zI4ei5mULXFGyU7z/6TAeYLVcpzSWZY8PYYF5yrTV60sT0+XV141vX++Wf16V2bFeGVPZXxFpkvyeKTWLlzfW0mnKxsY6Y3294/0998SCfX1blm5pbcvFGlq/r07MRAMhYIDiW5JFKWW3vdrEpCsZSJG+om7Zu/PSScZJhNkLbmW5Wsr12pWqW5zKtlwRS4bFOxUw17mCzy6lskCDl1WYOGWDYrADrMA7BDDweWWNd5koiJnR1dz+ytLP2q0SqPB1lnK2ccB7RYe4FSoPks3iB3t4txTSHctb2sy1ivk0pvHuCNm6w1f6wxv3+OCgN78LqdQnUVh7R0oTAp0zOf2rbW770Vu5C2dIyGdTnHo8zSji7dppj0USoVCz+lhRMTh53Teq9VbGfbjuSbAooSdXayY4PYHg374C6f7gl1B/DXuJ4/QXxOBdJFJspFsI3egpoWUUCjlTIFnNYNl+ZyZKmBeYKGHkD1QyDlhaKbKwKcIJqJ4TLJ2OmdY/JWXae4DdGBw8HZ7eXcgFF2zr2SoalDry5iKqoa0Puhe3hPQ2s3elTYM+MI+n3rK0KgL7/La3GeMLt6m7u912vGnvtORiIa0qBmhqVi+XW9XNBmqb8eVgKzIHfGI5bNoG7X0UCzeISmqIcO/nY8FH7U8avX9fx/ST+hx0sezPw9Qy8Mum3GWf2N4Uy/yIYGVBXbJHWIZp7dfTcptdMTr9Qmq7DaiK/ukqCL4kt4RUfS5XPnMtmT22/mQFqF7emSqtrlu8SVElxDRJrZODkpuwe0VfTfjdEp1f7A7v+fozNBXUJ/6WTuK2TtFlpFVZAZ3LcFvUi1Z2p2YT+EMAkGJVStOzLTAPg4IqWIAlzRSjOBkl2zxj3TKycpzT/MnvX3uaSMWM+gU0rkXjohhefVRMaps3/kLMSKv23lT23uxQrkQjyOJleMDsdhAnD6ZGElWZ5MjCXzCE/hkWX+WF4knzGhVOyK2eQZekV3eyo0zL8kuYWCnDCvjjhAkcTPOBDXVdoav3HVcFnQjLvtV9S2p0zA6JegPwMQxt+yFb3ll9zGlq/5dRKb3cEyQYoaNYpharJ7xCB7AWxsLY3jjZXY0XsZj0Wjwc9I6PP/dKABnCZaqHpaZEACxk4ZeLZSKNgZABl+lYQX1sJQOSX3n6r410evcoud5JeAGUXVP9H1tZOKejTq4Ono0z0erro1FrnOpohva1d/hTdtVsQdKN5W9RlT3NjD0nznyKNTgKAMfWNWcyodV0IGLPIHOF0o4JyqufaK4z6WIIzuGh3d8c8cwQg8ER+OVxyrjdm8vNuhts4LoOihGxIMuUdgzwiYN7xhh1+oZnJNuTG7gQZvu4XWZ9GAZZjGEubwePqYhtKDTH+9VQkl17/iGybsnJ+8+sKtyPrcll9ty65Zsdst/9iqpEKh7M5VdBxh3csOdNc6tW3I1uyM1PzOXegSOrLFsFNI2O27M+TF2ApnN9MUv5ud6LjxIvEQnHRzxIu4IsA9MLFkJn2tcZoZ7ON7dXe7ujrc8HrusPKamlqXwd77lQUuLpilau4PUMapueBb7irU4RoUXEYXuVuIGlRGmOp+2lNkaRPVziOqmlaZvaqG4dFgSj0jxEJWrv12IUWntmw+rfQarRE0Aph4ocI6nlUlGqs+u3/+T/ethW62PpHp2eHbZstnh/wOO95yDAHicY2BkYGAAYi2NOJ94fpuvDNzML4AiDNc/fzqEoP+/Zp7KdAvI5WBgAokCAGkcDfgAAAB4nGNgZGBgDvqfBSRfMAAB81QGRgZUoA0AVvYDbwAAAHicY2BgYGB+MTQwAM8EJo8AAAAAAE4AmgDoAQoBLAFOAXABmgHEAe4CGgKcAugEmgS8BNYE8gUOBSoFegXQBf4GRAZmBrYHGAeQCBgIUghqCP4JRgm+CdoKBAo8CoIKuArwC1ALlgu8eJxjYGRgYNBmTGEQZQABJiDmAkIGhv9gPgMAGJQBvAB4nG2RPU7DMBiG3/QP0UoIBGJh8QILavozdmRo9w7d09RpUzlx5LgVvQMn4BAcgoEzcAgOwVvzSZVQbcnf48fvFysJgGt8IcJxROiG9TgauODuj5ukG+EW+UG4jR4ehTv0Q+EunjER7uEWmk+IWpc0d3gVbuAKb8JN+nfhFvlDuI17fAp36L+Fu1jgR7iHp+jF7Arbz1Nb1nO93pnEncSJFtrVuS3VKB6e5EyX2iVer9TyoOr9eux9pjJnCzW1pdfGWFU5u9WpjzfeV5PBIBMfp7aAwQ4FLPrIkbKWqDHn+67pDRK4s4lzbsEux5qHvcIIMb/nueSMyTKkE3jWFdNLHLjW2PPmMa1Hxn3GjGW/wjT0HtOG09JU4WxLk9LH2ISuiv9twJn9y8fh9uIXI+BknAAAAHicbY7ZboMwEEW5CVBCSLrv+76kfJRjTwHFsdGAG+Xvy5JUfehIHp0rnxmNN/D6ir3/a4YBhvARIMQOIowQY4wEE0yxiz3s4wCHOMIxTnCKM5zjApe4wjVucIs73OMBj3jCM17wije84wMzfHqJ0EVmUkmmJo77oOmrHvfIRZbXsTCZplTZldlgb3TYGVHProwFs11t1A57tcON2rErR3PBqcwF1/6ctI6k0GSU4JHMSS6WghdJQ99sTbfuN7QLJ9vQ37dNrgyktnIxlDYLJNuqitpRbYWKFNuyDT6pog6oOYKHtKakeakqKjHXpPwlGRcsC+OqxLIiJpXqoqqDMreG2l5bv9Ri3TRX+c23DZna9WFFgmXuO6Ps1Jm/w6ErW8N3FbHn/QC444j0AA==) format('woff');\n      font-weight: normal;\n      font-style: normal;\n    }\n\n    html {\n      --lumo-icons-align-center: \"\\\\ea01\";\n      --lumo-icons-align-left: \"\\\\ea02\";\n      --lumo-icons-align-right: \"\\\\ea03\";\n      --lumo-icons-angle-down: \"\\\\ea04\";\n      --lumo-icons-angle-left: \"\\\\ea05\";\n      --lumo-icons-angle-right: \"\\\\ea06\";\n      --lumo-icons-angle-up: \"\\\\ea07\";\n      --lumo-icons-arrow-down: \"\\\\ea08\";\n      --lumo-icons-arrow-left: \"\\\\ea09\";\n      --lumo-icons-arrow-right: \"\\\\ea0a\";\n      --lumo-icons-arrow-up: \"\\\\ea0b\";\n      --lumo-icons-bar-chart: \"\\\\ea0c\";\n      --lumo-icons-bell: \"\\\\ea0d\";\n      --lumo-icons-calendar: \"\\\\ea0e\";\n      --lumo-icons-checkmark: \"\\\\ea0f\";\n      --lumo-icons-chevron-down: \"\\\\ea10\";\n      --lumo-icons-chevron-left: \"\\\\ea11\";\n      --lumo-icons-chevron-right: \"\\\\ea12\";\n      --lumo-icons-chevron-up: \"\\\\ea13\";\n      --lumo-icons-clock: \"\\\\ea14\";\n      --lumo-icons-cog: \"\\\\ea15\";\n      --lumo-icons-cross: \"\\\\ea16\";\n      --lumo-icons-download: \"\\\\ea17\";\n      --lumo-icons-dropdown: \"\\\\ea18\";\n      --lumo-icons-edit: \"\\\\ea19\";\n      --lumo-icons-error: \"\\\\ea1a\";\n      --lumo-icons-eye: \"\\\\ea1b\";\n      --lumo-icons-eye-disabled: \"\\\\ea1c\";\n      --lumo-icons-menu: \"\\\\ea1d\";\n      --lumo-icons-minus: \"\\\\ea1e\";\n      --lumo-icons-ordered-list: \"\\\\ea1f\";\n      --lumo-icons-phone: \"\\\\ea20\";\n      --lumo-icons-photo: \"\\\\ea21\";\n      --lumo-icons-play: \"\\\\ea22\";\n      --lumo-icons-plus: \"\\\\ea23\";\n      --lumo-icons-redo: \"\\\\ea24\";\n      --lumo-icons-reload: \"\\\\ea25\";\n      --lumo-icons-search: \"\\\\ea26\";\n      --lumo-icons-undo: \"\\\\ea27\";\n      --lumo-icons-unordered-list: \"\\\\ea28\";\n      --lumo-icons-upload: \"\\\\ea29\";\n      --lumo-icons-user: \"\\\\ea2a\";\n    }\n  </style>\n</custom-style>`;\ndocument.head.appendChild($_documentContainer.content);\n/* NOTICE: Generated with 'gulp icons' */\n\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\n\n;"
    },
    {
     "id": 95,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/version.js?babel-target=es6",
     "source": "class Lumo extends HTMLElement {\n  static get version() {\n    return '1.6.0';\n  }\n\n}\n\ncustomElements.define('vaadin-lumo-styles', Lumo);\nexport { Lumo };"
    },
    {
     "id": 97,
     "name": "../node_modules/@vaadin/vaadin-combo-box/src/vaadin-combo-box-placeholder.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2018 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/*\n * Placeholder object class representing items being loaded.\n *\n * @private\n */\nexport var ComboBoxPlaceholder = class ComboBoxPlaceholder {\n  toString() {\n    return '';\n  }\n\n};"
    },
    {
     "id": 100,
     "name": "../node_modules/@polymer/polymer/lib/utils/case-map.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\nvar caseMap = {};\nvar DASH_TO_CAMEL = /-[a-z]/g;\nvar CAMEL_TO_DASH = /([A-Z])/g;\n/**\n * @fileoverview Module with utilities for converting between \"dash-case\" and\n * \"camelCase\" identifiers.\n */\n\n/**\n * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\n * (e.g. `fooBarBaz`).\n *\n * @param {string} dash Dash-case identifier\n * @return {string} Camel-case representation of the identifier\n */\n\nexport function dashToCamelCase(dash) {\n  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, m => m[1].toUpperCase()));\n}\n/**\n * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\n * (e.g. `foo-bar-baz`).\n *\n * @param {string} camel Camel-case identifier\n * @return {string} Dash-case representation of the identifier\n */\n\nexport function camelToDashCase(camel) {\n  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());\n}"
    },
    {
     "id": 102,
     "name": "../node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-helper.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2020 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/**\n * Helper that provides a set of functions for RTL.\n */\nclass DirHelper {\n  /**\n   * Get the scroll type in the current browser view.\n   *\n   * @return {string} the scroll type. Possible values are `default|reverse|negative`\n   */\n  static detectScrollType() {\n    var dummy = document.createElement('div');\n    dummy.textContent = 'ABCD';\n    dummy.dir = 'rtl';\n    dummy.style.fontSize = '14px';\n    dummy.style.width = '4px';\n    dummy.style.height = '1px';\n    dummy.style.position = 'absolute';\n    dummy.style.top = '-1000px';\n    dummy.style.overflow = 'scroll';\n    document.body.appendChild(dummy);\n    var cachedType = 'reverse';\n\n    if (dummy.scrollLeft > 0) {\n      cachedType = 'default';\n    } else {\n      dummy.scrollLeft = 2;\n\n      if (dummy.scrollLeft < 2) {\n        cachedType = 'negative';\n      }\n    }\n\n    document.body.removeChild(dummy);\n    return cachedType;\n  }\n  /**\n   * Get the scrollLeft value of the element relative to the direction\n   *\n   * @param {string} scrollType type of the scroll detected with `detectScrollType`\n   * @param {string} direction current direction of the element\n   * @param {Element} element\n   * @return {number} the scrollLeft value.\n  */\n\n\n  static getNormalizedScrollLeft(scrollType, direction, element) {\n    var {\n      scrollLeft\n    } = element;\n\n    if (direction !== 'rtl' || !scrollType) {\n      return scrollLeft;\n    }\n\n    switch (scrollType) {\n      case 'negative':\n        return element.scrollWidth - element.clientWidth + scrollLeft;\n\n      case 'reverse':\n        return element.scrollWidth - element.clientWidth - scrollLeft;\n    }\n\n    return scrollLeft;\n  }\n  /**\n   * Set the scrollLeft value of the element relative to the direction\n   *\n   * @param {string} scrollType type of the scroll detected with `detectScrollType`\n   * @param {string} direction current direction of the element\n   * @param {Element} element\n   * @param {number} scrollLeft the scrollLeft value to be set\n   */\n\n\n  static setNormalizedScrollLeft(scrollType, direction, element, scrollLeft) {\n    if (direction !== 'rtl' || !scrollType) {\n      element.scrollLeft = scrollLeft;\n      return;\n    }\n\n    switch (scrollType) {\n      case 'negative':\n        element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;\n        break;\n\n      case 'reverse':\n        element.scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;\n        break;\n\n      default:\n        element.scrollLeft = scrollLeft;\n        break;\n    }\n  }\n\n}\n\nexport { DirHelper };"
    },
    {
     "id": 104,
     "name": "../node_modules/@vaadin/vaadin-text-field/src/vaadin-text-field.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { TextFieldMixin } from './vaadin-text-field-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-text-field>` is a Web Component for text field control in forms.\n *\n * ```html\n * <vaadin-text-field label=\"First Name\">\n * </vaadin-text-field>\n * ```\n *\n * ### Prefixes and suffixes\n *\n * These are child elements of a `<vaadin-text-field>` that are displayed\n * inline with the input, before or after.\n * In order for an element to be considered as a prefix, it must have the slot\n * attribute set to `prefix` (and similarly for `suffix`).\n *\n * ```html\n * <vaadin-text-field label=\"Email address\">\n *   <div slot=\"prefix\">Sent to:</div>\n *   <div slot=\"suffix\">@vaadin.com</div>\n * </vaadin-text-area>\n * ```\n *\n * ### Styling\n *\n * The following custom properties are available for styling:\n *\n * Custom property | Description | Default\n * ----------------|-------------|-------------\n * `--vaadin-text-field-default-width` | Set the default width of the input field | `12em`\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ----------------|----------------\n * `label` | The label element\n * `input-field` | The element that wraps prefix, value and suffix\n * `value` | The text value element inside the `input-field` element\n * `error-message` | The error message element\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `disabled` | Set to a disabled text field | :host\n * `has-value` | Set when the element has a value | :host\n * `has-label` | Set when the element has a label | :host\n * `has-helper` | Set when the element has helper text or slot | :host\n * `has-error-message` | Set when the element has an error message | :host\n * `invalid` | Set when the element is invalid | :host\n * `input-prevented` | Temporarily set when invalid input is prevented | :host\n * `focused` | Set when the element is focused | :host\n * `focus-ring` | Set when the element is keyboard focused | :host\n * `readonly` | Set to a readonly text field | :host\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes TextFieldMixin\n * @mixes ControlStateMixin\n * @mixes ThemableMixin\n * @mixes ElementMixin\n * @demo demo/index.html\n */\n\nclass TextFieldElement extends ElementMixin(TextFieldMixin(ControlStateMixin(ThemableMixin(PolymerElement)))) {\n  static get template() {\n    return html`\n    <style include=\"vaadin-text-field-shared-styles\">\n      /* polymer-cli linter breaks with empty line */\n    </style>\n\n    <div class=\"vaadin-text-field-container\">\n\n      <label part=\"label\" on-click=\"focus\" id=\"[[_labelId]]\">[[label]]</label>\n\n      <div part=\"input-field\" id=\"[[_inputId]]\">\n\n        <slot name=\"prefix\"></slot>\n\n        <slot name=\"input\">\n          <input part=\"value\">\n        </slot>\n\n        <div part=\"clear-button\" id=\"clearButton\" role=\"button\" aria-label\\$=\"[[i18n.clear]]\"></div>\n        <slot name=\"suffix\"></slot>\n\n      </div>\n\n      <div part=\"helper-text\" on-click=\"focus\" id=\"[[_helperTextId]]\">\n        <slot name=\"helper\">[[helperText]]</slot>\n      </div>\n\n      <div part=\"error-message\" id=\"[[_errorId]]\" aria-live=\"assertive\" aria-hidden\\$=\"[[_getErrorMessageAriaHidden(invalid, errorMessage, _errorId)]]\">[[errorMessage]]</div>\n\n    </div>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-text-field';\n  }\n\n  static get version() {\n    return '2.8.2';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Identifies a list of pre-defined options to suggest to the user.\n       * The value must be the id of a <datalist> element in the same document.\n       */\n      list: {\n        type: String\n      },\n\n      /**\n       * A regular expression that the value is checked against.\n       * The pattern must match the entire value, not just some subset.\n       */\n      pattern: {\n        type: String\n      },\n\n      /**\n       * The text usually displayed in a tooltip popup when the mouse is over the field.\n       * @type {string}\n       */\n      title: {\n        type: String\n      }\n    };\n  }\n\n}\n\ncustomElements.define(TextFieldElement.is, TextFieldElement);\nexport { TextFieldElement };"
    },
    {
     "id": 106,
     "name": "../node_modules/@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n/**\n * Chrome uses an older version of DOM Level 3 Keyboard Events\n *\n * Most keys are labeled as text, but some are Unicode codepoints.\n * Values taken from:\n * http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set\n */\n\nvar KEY_IDENTIFIER = {\n  'U+0008': 'backspace',\n  'U+0009': 'tab',\n  'U+001B': 'esc',\n  'U+0020': 'space',\n  'U+007F': 'del'\n};\n/**\n * Special table for KeyboardEvent.keyCode.\n * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better\n * than that.\n *\n * Values from:\n * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode\n */\n\nvar KEY_CODE = {\n  8: 'backspace',\n  9: 'tab',\n  13: 'enter',\n  27: 'esc',\n  33: 'pageup',\n  34: 'pagedown',\n  35: 'end',\n  36: 'home',\n  32: 'space',\n  37: 'left',\n  38: 'up',\n  39: 'right',\n  40: 'down',\n  46: 'del',\n  106: '*'\n};\n/**\n * MODIFIER_KEYS maps the short name for modifier keys used in a key\n * combo string to the property name that references those same keys\n * in a KeyboardEvent instance.\n */\n\nvar MODIFIER_KEYS = {\n  'shift': 'shiftKey',\n  'ctrl': 'ctrlKey',\n  'alt': 'altKey',\n  'meta': 'metaKey'\n};\n/**\n * KeyboardEvent.key is mostly represented by printable character made by\n * the keyboard, with unprintable keys labeled nicely.\n *\n * However, on OS X, Alt+char can make a Unicode character that follows an\n * Apple-specific mapping. In this case, we fall back to .keyCode.\n */\n\nvar KEY_CHAR = /[a-z0-9*]/;\n/**\n * Matches a keyIdentifier string.\n */\n\nvar IDENT_CHAR = /U\\+/;\n/**\n * Matches arrow keys in Gecko 27.0+\n */\n\nvar ARROW_KEY = /^arrow/;\n/**\n * Matches space keys everywhere (notably including IE10's exceptional name\n * `spacebar`).\n */\n\nvar SPACE_KEY = /^space(bar)?/;\n/**\n * Matches ESC key.\n *\n * Value from: http://w3c.github.io/uievents-key/#key-Escape\n */\n\nvar ESC_KEY = /^escape$/;\n/**\n * Transforms the key.\n * @param {string} key The KeyBoardEvent.key\n * @param {Boolean} [noSpecialChars] Limits the transformation to\n * alpha-numeric characters.\n */\n\nfunction transformKey(key, noSpecialChars) {\n  var validKey = '';\n\n  if (key) {\n    var lKey = key.toLowerCase();\n\n    if (lKey === ' ' || SPACE_KEY.test(lKey)) {\n      validKey = 'space';\n    } else if (ESC_KEY.test(lKey)) {\n      validKey = 'esc';\n    } else if (lKey.length == 1) {\n      if (!noSpecialChars || KEY_CHAR.test(lKey)) {\n        validKey = lKey;\n      }\n    } else if (ARROW_KEY.test(lKey)) {\n      validKey = lKey.replace('arrow', '');\n    } else if (lKey == 'multiply') {\n      // numpad '*' can map to Multiply on IE/Windows\n      validKey = '*';\n    } else {\n      validKey = lKey;\n    }\n  }\n\n  return validKey;\n}\n\nfunction transformKeyIdentifier(keyIdent) {\n  var validKey = '';\n\n  if (keyIdent) {\n    if (keyIdent in KEY_IDENTIFIER) {\n      validKey = KEY_IDENTIFIER[keyIdent];\n    } else if (IDENT_CHAR.test(keyIdent)) {\n      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);\n      validKey = String.fromCharCode(keyIdent).toLowerCase();\n    } else {\n      validKey = keyIdent.toLowerCase();\n    }\n  }\n\n  return validKey;\n}\n\nfunction transformKeyCode(keyCode) {\n  var validKey = '';\n\n  if (Number(keyCode)) {\n    if (keyCode >= 65 && keyCode <= 90) {\n      // ascii a-z\n      // lowercase is 32 offset from uppercase\n      validKey = String.fromCharCode(32 + keyCode);\n    } else if (keyCode >= 112 && keyCode <= 123) {\n      // function keys f1-f12\n      validKey = 'f' + (keyCode - 112 + 1);\n    } else if (keyCode >= 48 && keyCode <= 57) {\n      // top 0-9 keys\n      validKey = String(keyCode - 48);\n    } else if (keyCode >= 96 && keyCode <= 105) {\n      // num pad 0-9\n      validKey = String(keyCode - 96);\n    } else {\n      validKey = KEY_CODE[keyCode];\n    }\n  }\n\n  return validKey;\n}\n/**\n * Calculates the normalized key for a KeyboardEvent.\n * @param {KeyboardEvent} keyEvent\n * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key\n * transformation to alpha-numeric chars. This is useful with key\n * combinations like shift + 2, which on FF for MacOS produces\n * keyEvent.key = @\n * To get 2 returned, set noSpecialChars = true\n * To get @ returned, set noSpecialChars = false\n */\n\n\nfunction normalizedKeyForEvent(keyEvent, noSpecialChars) {\n  // Fall back from .key, to .detail.key for artifical keyboard events,\n  // and then to deprecated .keyIdentifier and .keyCode.\n  if (keyEvent.key) {\n    return transformKey(keyEvent.key, noSpecialChars);\n  }\n\n  if (keyEvent.detail && keyEvent.detail.key) {\n    return transformKey(keyEvent.detail.key, noSpecialChars);\n  }\n\n  return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';\n}\n\nfunction keyComboMatchesEvent(keyCombo, event) {\n  // For combos with modifiers we support only alpha-numeric keys\n  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);\n  return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);\n}\n\nfunction parseKeyComboString(keyComboString) {\n  if (keyComboString.length === 1) {\n    return {\n      combo: keyComboString,\n      key: keyComboString,\n      event: 'keydown'\n    };\n  }\n\n  return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {\n    var eventParts = keyComboPart.split(':');\n    var keyName = eventParts[0];\n    var event = eventParts[1];\n\n    if (keyName in MODIFIER_KEYS) {\n      parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;\n      parsedKeyCombo.hasModifiers = true;\n    } else {\n      parsedKeyCombo.key = keyName;\n      parsedKeyCombo.event = event || 'keydown';\n    }\n\n    return parsedKeyCombo;\n  }, {\n    combo: keyComboString.split(':').shift()\n  });\n}\n\nfunction parseEventString(eventString) {\n  return eventString.trim().split(' ').map(function (keyComboString) {\n    return parseKeyComboString(keyComboString);\n  });\n}\n/**\n * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing\n * keyboard commands that pertain to [WAI-ARIA best\n * practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding). The\n * element takes care of browser differences with respect to Keyboard events and\n * uses an expressive syntax to filter key presses.\n *\n * Use the `keyBindings` prototype property to express what combination of keys\n * will trigger the callback. A key binding has the format\n * `\"KEY+MODIFIER:EVENT\": \"callback\"` (`\"KEY\": \"callback\"` or\n * `\"KEY:EVENT\": \"callback\"` are valid as well). Some examples:\n *\n *      keyBindings: {\n *        'space': '_onKeydown', // same as 'space:keydown'\n *        'shift+tab': '_onKeydown',\n *        'enter:keypress': '_onKeypress',\n *        'esc:keyup': '_onKeyup'\n *      }\n *\n * The callback will receive with an event containing the following information\n * in `event.detail`:\n *\n *      _onKeydown: function(event) {\n *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. \"shift+tab\"\n *        console.log(event.detail.key); // KEY only, e.g. \"tab\"\n *        console.log(event.detail.event); // EVENT, e.g. \"keydown\"\n *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent\n *      }\n *\n * Use the `keyEventTarget` attribute to set up event handlers on a specific\n * node.\n *\n * See the [demo source\n * code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)\n * for an example.\n *\n * @demo demo/index.html\n * @polymerBehavior\n */\n\n\nexport var IronA11yKeysBehavior = {\n  properties: {\n    /**\n     * The EventTarget that will be firing relevant KeyboardEvents. Set it to\n     * `null` to disable the listeners.\n     * @type {?EventTarget}\n     */\n    keyEventTarget: {\n      type: Object,\n      value: function () {\n        return this;\n      }\n    },\n\n    /**\n     * If true, this property will cause the implementing element to\n     * automatically stop propagation on any handled KeyboardEvents.\n     */\n    stopKeyboardEventPropagation: {\n      type: Boolean,\n      value: false\n    },\n    _boundKeyHandlers: {\n      type: Array,\n      value: function () {\n        return [];\n      }\n    },\n    // We use this due to a limitation in IE10 where instances will have\n    // own properties of everything on the \"prototype\".\n    _imperativeKeyBindings: {\n      type: Object,\n      value: function () {\n        return {};\n      }\n    }\n  },\n  observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],\n\n  /**\n   * To be used to express what combination of keys  will trigger the relative\n   * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`\n   * @type {!Object}\n   */\n  keyBindings: {},\n  registered: function () {\n    this._prepKeyBindings();\n  },\n  attached: function () {\n    this._listenKeyEventListeners();\n  },\n  detached: function () {\n    this._unlistenKeyEventListeners();\n  },\n\n  /**\n   * Can be used to imperatively add a key binding to the implementing\n   * element. This is the imperative equivalent of declaring a keybinding\n   * in the `keyBindings` prototype property.\n   *\n   * @param {string} eventString\n   * @param {string} handlerName\n   */\n  addOwnKeyBinding: function (eventString, handlerName) {\n    this._imperativeKeyBindings[eventString] = handlerName;\n\n    this._prepKeyBindings();\n\n    this._resetKeyEventListeners();\n  },\n\n  /**\n   * When called, will remove all imperatively-added key bindings.\n   */\n  removeOwnKeyBindings: function () {\n    this._imperativeKeyBindings = {};\n\n    this._prepKeyBindings();\n\n    this._resetKeyEventListeners();\n  },\n\n  /**\n   * Returns true if a keyboard event matches `eventString`.\n   *\n   * @param {KeyboardEvent} event\n   * @param {string} eventString\n   * @return {boolean}\n   */\n  keyboardEventMatchesKeys: function (event, eventString) {\n    var keyCombos = parseEventString(eventString);\n\n    for (var i = 0; i < keyCombos.length; ++i) {\n      if (keyComboMatchesEvent(keyCombos[i], event)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  _collectKeyBindings: function () {\n    var keyBindings = this.behaviors.map(function (behavior) {\n      return behavior.keyBindings;\n    });\n\n    if (keyBindings.indexOf(this.keyBindings) === -1) {\n      keyBindings.push(this.keyBindings);\n    }\n\n    return keyBindings;\n  },\n  _prepKeyBindings: function () {\n    this._keyBindings = {};\n\n    this._collectKeyBindings().forEach(function (keyBindings) {\n      for (var eventString in keyBindings) {\n        this._addKeyBinding(eventString, keyBindings[eventString]);\n      }\n    }, this);\n\n    for (var eventString in this._imperativeKeyBindings) {\n      this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);\n    } // Give precedence to combos with modifiers to be checked first.\n\n\n    for (var eventName in this._keyBindings) {\n      this._keyBindings[eventName].sort(function (kb1, kb2) {\n        var b1 = kb1[0].hasModifiers;\n        var b2 = kb2[0].hasModifiers;\n        return b1 === b2 ? 0 : b1 ? -1 : 1;\n      });\n    }\n  },\n  _addKeyBinding: function (eventString, handlerName) {\n    parseEventString(eventString).forEach(function (keyCombo) {\n      this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];\n\n      this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);\n    }, this);\n  },\n  _resetKeyEventListeners: function () {\n    this._unlistenKeyEventListeners();\n\n    if (this.isAttached) {\n      this._listenKeyEventListeners();\n    }\n  },\n  _listenKeyEventListeners: function () {\n    if (!this.keyEventTarget) {\n      return;\n    }\n\n    Object.keys(this._keyBindings).forEach(function (eventName) {\n      var keyBindings = this._keyBindings[eventName];\n\n      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);\n\n      this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);\n\n      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);\n    }, this);\n  },\n  _unlistenKeyEventListeners: function () {\n    var keyHandlerTuple;\n    var keyEventTarget;\n    var eventName;\n    var boundKeyHandler;\n\n    while (this._boundKeyHandlers.length) {\n      // My kingdom for block-scope binding and destructuring assignment..\n      keyHandlerTuple = this._boundKeyHandlers.pop();\n      keyEventTarget = keyHandlerTuple[0];\n      eventName = keyHandlerTuple[1];\n      boundKeyHandler = keyHandlerTuple[2];\n      keyEventTarget.removeEventListener(eventName, boundKeyHandler);\n    }\n  },\n  _onKeyBindingEvent: function (keyBindings, event) {\n    if (this.stopKeyboardEventPropagation) {\n      event.stopPropagation();\n    } // if event has been already prevented, don't do anything\n\n\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    for (var i = 0; i < keyBindings.length; i++) {\n      var keyCombo = keyBindings[i][0];\n      var handlerName = keyBindings[i][1];\n\n      if (keyComboMatchesEvent(keyCombo, event)) {\n        this._triggerKeyHandler(keyCombo, handlerName, event); // exit the loop if eventDefault was prevented\n\n\n        if (event.defaultPrevented) {\n          return;\n        }\n      }\n    }\n  },\n  _triggerKeyHandler: function (keyCombo, handlerName, keyboardEvent) {\n    var detail = Object.create(keyCombo);\n    detail.keyboardEvent = keyboardEvent;\n    var event = new CustomEvent(keyCombo.event, {\n      detail: detail,\n      cancelable: true\n    });\n    this[handlerName].call(this, event);\n\n    if (event.defaultPrevented) {\n      keyboardEvent.preventDefault();\n    }\n  }\n};"
    },
    {
     "id": 108,
     "name": "../node_modules/@polymer/polymer/lib/mixins/property-effects.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 110,
     "name": "../node_modules/@polymer/polymer/lib/legacy/legacy-element-mixin.js?babel-target=es6 + 4 modules"
    },
    {
     "id": 112,
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-text-field.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 114,
     "name": "../node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 116,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/mixins/field-button.js?babel-target=es6",
     "source": "import '../color.js';\nimport '../font-icons.js';\nimport '../sizing.js';\nimport '../style.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<dom-module id=\"lumo-field-button\">\n  <template>\n    <style>\n      [part\\$=\"button\"] {\n        flex: none;\n        width: 1em;\n        height: 1em;\n        line-height: 1;\n        font-size: var(--lumo-icon-size-m);\n        text-align: center;\n        color: var(--lumo-contrast-60pct);\n        transition: 0.2s color;\n        cursor: var(--lumo-clickable-cursor);\n      }\n\n      :host(:not([readonly])) [part\\$=\"button\"]:hover {\n        color: var(--lumo-contrast-90pct);\n      }\n\n      :host([disabled]) [part\\$=\"button\"],\n      :host([readonly]) [part\\$=\"button\"] {\n        color: var(--lumo-contrast-20pct);\n      }\n\n      [part\\$=\"button\"]::before {\n        font-family: \"lumo-icons\";\n        display: block;\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 118,
     "name": "../node_modules/@polymer/polymer/lib/utils/style-gather.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module with utilities for collection CSS text from `<templates>`, external\n * stylesheets, and `dom-module`s.\n *\n * @summary Module with utilities for collection CSS text from various sources.\n */\nimport { DomModule } from '../elements/dom-module.js';\nimport { resolveCss } from './resolve-url.js';\nvar MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\nvar INCLUDE_ATTR = 'include';\nvar SHADY_UNSCOPED_ATTR = 'shady-unscoped';\n/**\n * @param {string} moduleId .\n * @return {?DomModule} .\n */\n\nfunction importModule(moduleId) {\n  return (\n    /** @type {?DomModule} */\n    DomModule.import(moduleId)\n  );\n}\n\nfunction styleForImport(importDoc) {\n  // NOTE: polyfill affordance.\n  // under the HTMLImports polyfill, there will be no 'body',\n  // but the import pseudo-doc can be used directly.\n  var container = importDoc.body ? importDoc.body : importDoc;\n  var importCss = resolveCss(container.textContent, importDoc.baseURI);\n  var style = document.createElement('style');\n  style.textContent = importCss;\n  return style;\n}\n/** @typedef {{assetpath: string}} */\n\n\nvar templateWithAssetPath; // eslint-disable-line no-unused-vars\n\n/**\n * Returns a list of <style> elements in a space-separated list of `dom-module`s.\n *\n * @function\n * @param {string} moduleIds List of dom-module id's within which to\n * search for css.\n * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements\n */\n\nexport function stylesFromModules(moduleIds) {\n  var modules = moduleIds.trim().split(/\\s+/);\n  var styles = [];\n\n  for (var i = 0; i < modules.length; i++) {\n    styles.push(...stylesFromModule(modules[i]));\n  }\n\n  return styles;\n}\n/**\n * Returns a list of <style> elements in a given `dom-module`.\n * Styles in a `dom-module` can come either from `<style>`s within the\n * first `<template>`, or else from one or more\n * `<link rel=\"import\" type=\"css\">` links outside the template.\n *\n * @param {string} moduleId dom-module id to gather styles from\n * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n */\n\nexport function stylesFromModule(moduleId) {\n  var m = importModule(moduleId);\n\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n    return [];\n  }\n\n  if (m._styles === undefined) {\n    var styles = []; // module imports: <link rel=\"import\" type=\"css\">\n\n    styles.push(..._stylesFromModuleImports(m)); // include css from the first template in the module\n\n    var template =\n    /** @type {?HTMLTemplateElement} */\n    m.querySelector('template');\n\n    if (template) {\n      styles.push(...stylesFromTemplate(template,\n      /** @type {templateWithAssetPath} */\n      m.assetpath));\n    }\n\n    m._styles = styles;\n  }\n\n  return m._styles;\n}\n/**\n * Returns the `<style>` elements within a given template.\n *\n * @param {!HTMLTemplateElement} template Template to gather styles from\n * @param {string=} baseURI baseURI for style content\n * @return {!Array<!HTMLStyleElement>} Array of styles\n */\n\nexport function stylesFromTemplate(template, baseURI) {\n  if (!template._styles) {\n    var styles = []; // if element is a template, get content from its .content\n\n    var e$ = template.content.querySelectorAll('style');\n\n    for (var i = 0; i < e$.length; i++) {\n      var e = e$[i]; // support style sharing by allowing styles to \"include\"\n      // other dom-modules that contain styling\n\n      var include = e.getAttribute(INCLUDE_ATTR);\n\n      if (include) {\n        styles.push(...stylesFromModules(include).filter(function (item, index, self) {\n          return self.indexOf(item) === index;\n        }));\n      }\n\n      if (baseURI) {\n        e.textContent = resolveCss(e.textContent,\n        /** @type {string} */\n        baseURI);\n      }\n\n      styles.push(e);\n    }\n\n    template._styles = styles;\n  }\n\n  return template._styles;\n}\n/**\n * Returns a list of <style> elements  from stylesheets loaded via `<link rel=\"import\" type=\"css\">` links within the specified `dom-module`.\n *\n * @param {string} moduleId Id of `dom-module` to gather CSS from\n * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n */\n\nexport function stylesFromModuleImports(moduleId) {\n  var m = importModule(moduleId);\n  return m ? _stylesFromModuleImports(m) : [];\n}\n/**\n * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n * @return {!Array<!HTMLStyleElement>} Array of contained styles\n */\n\nfunction _stylesFromModuleImports(module) {\n  var styles = [];\n  var p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n\n  for (var i = 0; i < p$.length; i++) {\n    var p = p$[i];\n\n    if (p.import) {\n      var importDoc = p.import;\n      var unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);\n\n      if (unscoped && !importDoc._unscopedStyle) {\n        var style = styleForImport(importDoc);\n        style.setAttribute(SHADY_UNSCOPED_ATTR, '');\n        importDoc._unscopedStyle = style;\n      } else if (!importDoc._style) {\n        importDoc._style = styleForImport(importDoc);\n      }\n\n      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);\n    }\n  }\n\n  return styles;\n}\n/**\n *\n * Returns CSS text of styles in a space-separated list of `dom-module`s.\n * Note: This method is deprecated, use `stylesFromModules` instead.\n *\n * @deprecated\n * @param {string} moduleIds List of dom-module id's within which to\n * search for css.\n * @return {string} Concatenated CSS content from specified `dom-module`s\n */\n\n\nexport function cssFromModules(moduleIds) {\n  var modules = moduleIds.trim().split(/\\s+/);\n  var cssText = '';\n\n  for (var i = 0; i < modules.length; i++) {\n    cssText += cssFromModule(modules[i]);\n  }\n\n  return cssText;\n}\n/**\n * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`\n * can come either from `<style>`s within the first `<template>`, or else\n * from one or more `<link rel=\"import\" type=\"css\">` links outside the\n * template.\n *\n * Any `<styles>` processed are removed from their original location.\n * Note: This method is deprecated, use `styleFromModule` instead.\n *\n * @deprecated\n * @param {string} moduleId dom-module id to gather styles from\n * @return {string} Concatenated CSS content from specified `dom-module`\n */\n\nexport function cssFromModule(moduleId) {\n  var m = importModule(moduleId);\n\n  if (m && m._cssText === undefined) {\n    // module imports: <link rel=\"import\" type=\"css\">\n    var cssText = _cssFromModuleImports(m); // include css from the first template in the module\n\n\n    var t =\n    /** @type {?HTMLTemplateElement} */\n    m.querySelector('template');\n\n    if (t) {\n      cssText += cssFromTemplate(t,\n      /** @type {templateWithAssetPath} */\n      m.assetpath);\n    }\n\n    m._cssText = cssText || null;\n  }\n\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n  }\n\n  return m && m._cssText || '';\n}\n/**\n * Returns CSS text of `<styles>` within a given template.\n *\n * Any `<styles>` processed are removed from their original location.\n * Note: This method is deprecated, use `styleFromTemplate` instead.\n *\n * @deprecated\n * @param {!HTMLTemplateElement} template Template to gather styles from\n * @param {string} baseURI Base URI to resolve the URL against\n * @return {string} Concatenated CSS content from specified template\n */\n\nexport function cssFromTemplate(template, baseURI) {\n  var cssText = '';\n  var e$ = stylesFromTemplate(template, baseURI); // if element is a template, get content from its .content\n\n  for (var i = 0; i < e$.length; i++) {\n    var e = e$[i];\n\n    if (e.parentNode) {\n      e.parentNode.removeChild(e);\n    }\n\n    cssText += e.textContent;\n  }\n\n  return cssText;\n}\n/**\n * Returns CSS text from stylesheets loaded via `<link rel=\"import\" type=\"css\">`\n * links within the specified `dom-module`.\n *\n * Note: This method is deprecated, use `stylesFromModuleImports` instead.\n *\n * @deprecated\n *\n * @param {string} moduleId Id of `dom-module` to gather CSS from\n * @return {string} Concatenated CSS content from links in specified `dom-module`\n */\n\nexport function cssFromModuleImports(moduleId) {\n  var m = importModule(moduleId);\n  return m ? _cssFromModuleImports(m) : '';\n}\n/**\n * @deprecated\n * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n * @return {string} Concatenated CSS content from links in the dom-module\n */\n\nfunction _cssFromModuleImports(module) {\n  var cssText = '';\n\n  var styles = _stylesFromModuleImports(module);\n\n  for (var i = 0; i < styles.length; i++) {\n    cssText += styles[i].textContent;\n  }\n\n  return cssText;\n}"
    },
    {
     "id": 119,
     "name": "../node_modules/@webcomponents/shadycss/src/apply-shim-utils.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n'use strict';\n\nimport templateMap from './template-map.js';\nimport { StyleNode } from './css-parse.js'; // eslint-disable-line no-unused-vars\n\n/*\n * Utilities for handling invalidating apply-shim mixins for a given template.\n *\n * The invalidation strategy involves keeping track of the \"current\" version of a template's mixins, and updating that count when a mixin is invalidated.\n * The template\n */\n\n/** @const {string} */\n\nvar CURRENT_VERSION = '_applyShimCurrentVersion';\n/** @const {string} */\n\nvar NEXT_VERSION = '_applyShimNextVersion';\n/** @const {string} */\n\nvar VALIDATING_VERSION = '_applyShimValidatingVersion';\n/**\n * @const {Promise<void>}\n */\n\nvar promise = Promise.resolve();\n/**\n * @param {string} elementName\n */\n\nexport function invalidate(elementName) {\n  var template = templateMap[elementName];\n\n  if (template) {\n    invalidateTemplate(template);\n  }\n}\n/**\n * This function can be called multiple times to mark a template invalid\n * and signal that the style inside must be regenerated.\n *\n * Use `startValidatingTemplate` to begin an asynchronous validation cycle.\n * During that cycle, call `templateIsValidating` to see if the template must\n * be revalidated\n * @param {HTMLTemplateElement} template\n */\n\nexport function invalidateTemplate(template) {\n  // default the current version to 0\n  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0; // ensure the \"validating for\" flag exists\n\n  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0; // increment the next version\n\n  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;\n}\n/**\n * @param {string} elementName\n * @return {boolean}\n */\n\nexport function isValid(elementName) {\n  var template = templateMap[elementName];\n\n  if (template) {\n    return templateIsValid(template);\n  }\n\n  return true;\n}\n/**\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\n\nexport function templateIsValid(template) {\n  return template[CURRENT_VERSION] === template[NEXT_VERSION];\n}\n/**\n * @param {string} elementName\n * @return {boolean}\n */\n\nexport function isValidating(elementName) {\n  var template = templateMap[elementName];\n\n  if (template) {\n    return templateIsValidating(template);\n  }\n\n  return false;\n}\n/**\n * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.\n * If false, the template must be validated.\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\n\nexport function templateIsValidating(template) {\n  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];\n}\n/**\n * the template is marked as `validating` for one microtask so that all instances\n * found in the tree crawl of `applyStyle` will update themselves,\n * but the template will only be updated once.\n * @param {string} elementName\n*/\n\nexport function startValidating(elementName) {\n  var template = templateMap[elementName];\n  startValidatingTemplate(template);\n}\n/**\n * Begin an asynchronous invalidation cycle.\n * This should be called after every validation of a template\n *\n * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`\n * @param {HTMLTemplateElement} template\n */\n\nexport function startValidatingTemplate(template) {\n  // remember that the current \"next version\" is the reason for this validation cycle\n  template[VALIDATING_VERSION] = template[NEXT_VERSION]; // however, there only needs to be one async task to clear the counters\n\n  if (!template._validating) {\n    template._validating = true;\n    promise.then(function () {\n      // sync the current version to let future invalidations cause a refresh cycle\n      template[CURRENT_VERSION] = template[NEXT_VERSION];\n      template._validating = false;\n    });\n  }\n}\n/**\n * @return {boolean}\n */\n\nexport function elementsAreInvalid() {\n  for (var elementName in templateMap) {\n    var template = templateMap[elementName];\n\n    if (!templateIsValid(template)) {\n      return true;\n    }\n  }\n\n  return false;\n}"
    },
    {
     "id": 122,
     "name": "../node_modules/@vaadin/vaadin-button/src/vaadin-button.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { addListener } from '@polymer/polymer/lib/utils/gestures.js';\n/**\n * `<vaadin-button>` is a Web Component providing an accessible and customizable button.\n *\n * ```html\n * <vaadin-button>\n * </vaadin-button>\n * ```\n *\n * ```js\n * document.querySelector('vaadin-button').addEventListener('click', () => alert('Hello World!'));\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are exposed for styling:\n *\n * Part name | Description\n * ----------------|----------------\n * `label` | The label (text) inside the button\n * `prefix` | A slot for e.g. an icon before the label\n * `suffix` | A slot for e.g. an icon after the label\n *\n *\n * The following attributes are exposed for styling:\n *\n * Attribute | Description\n * --------- | -----------\n * `active` | Set when the button is pressed down, either with mouse, touch or the keyboard.\n * `disabled` | Set when the button is disabled.\n * `focus-ring` | Set when the button is focused using the keyboard.\n * `focused` | Set when the button is focused.\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ControlStateMixin\n * @mixes ThemableMixin\n * @mixes GestureEventListeners\n * @demo demo/index.html\n */\n\nclass ButtonElement extends ElementMixin(ControlStateMixin(ThemableMixin(GestureEventListeners(PolymerElement)))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n        outline: none;\n        white-space: nowrap;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      /* Ensure the button is always aligned on the baseline */\n      .vaadin-button-container::before {\n        content: \"\\\\2003\";\n        display: inline-block;\n        width: 0;\n      }\n\n      .vaadin-button-container {\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n        text-align: center;\n        width: 100%;\n        height: 100%;\n        min-height: inherit;\n        text-shadow: inherit;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        user-select: none;\n      }\n\n      [part=\"prefix\"],\n      [part=\"suffix\"] {\n        flex: none;\n      }\n\n      [part=\"label\"] {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      #button {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        width: 100%;\n        height: 100%;\n        opacity: 0;\n        cursor: inherit;\n      }\n    </style>\n    <div class=\"vaadin-button-container\">\n      <div part=\"prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div part=\"label\">\n        <slot></slot>\n      </div>\n      <div part=\"suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <button id=\"button\" type=\"button\"></button>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-button';\n  }\n\n  static get version() {\n    return '2.4.0';\n  }\n\n  ready() {\n    super.ready(); // Leaving default role in the native button, makes navigation announcement\n    // being different when using focus navigation (tab) versus using normal\n    // navigation (arrows). The first way announces the label on a button\n    // since the focus is moved programmatically, and the second on a group.\n\n    this.setAttribute('role', 'button');\n    this.$.button.setAttribute('role', 'presentation');\n\n    this._addActiveListeners(); // Fix for https://github.com/vaadin/vaadin-button-flow/issues/120\n\n\n    window.ShadyDOM && window.ShadyDOM.flush();\n  }\n  /**\n   * @protected\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback(); // `active` state is preserved when the element is disconnected between keydown and keyup events.\n    // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.\n\n    if (this.hasAttribute('active')) {\n      this.removeAttribute('active');\n    }\n  }\n  /** @private */\n\n\n  _addActiveListeners() {\n    addListener(this, 'down', () => !this.disabled && this.setAttribute('active', ''));\n    addListener(this, 'up', () => this.removeAttribute('active'));\n    this.addEventListener('keydown', e => !this.disabled && [13, 32].indexOf(e.keyCode) >= 0 && this.setAttribute('active', ''));\n    this.addEventListener('keyup', () => this.removeAttribute('active'));\n    this.addEventListener('blur', () => this.removeAttribute('active'));\n  }\n  /**\n   * @protected\n   * @return {Element}\n   */\n\n\n  get focusElement() {\n    return this.$.button;\n  }\n\n}\n\ncustomElements.define(ButtonElement.is, ButtonElement);\nexport { ButtonElement };"
    },
    {
     "id": 124,
     "name": "../node_modules/@polymer/polymer/lib/mixins/property-accessors.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertiesChanged } from './properties-changed.js'; // Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\n\nvar nativeProperties = {};\nvar proto = HTMLElement.prototype;\n\nwhile (proto) {\n  var props = Object.getOwnPropertyNames(proto);\n\n  for (var i = 0; i < props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n\n  proto = Object.getPrototypeOf(proto);\n}\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\n\n\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    var value = model[property];\n\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin:\n *\n * -   Declare attributes to observe via the standard `static get\n *     observedAttributes()`. Use `dash-case` attribute names to represent\n *     `camelCase` property names.\n * -   Implement the `_propertiesChanged` callback on the class.\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\n *     generate property accessors for each observed attribute. This must be\n *     called before the first instance is created, for example, by calling it\n *     before calling `customElements.define`. It can also be called lazily from\n *     the element's `constructor`, as long as it's guarded so that the call is\n *     only made once, when the first instance is created.\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\n *     enable the accessors.\n *\n * Any `observedAttributes` will automatically be\n * deserialized via `attributeChangedCallback` and set to the associated\n * property using `dash-case`-to-`camelCase` convention.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n */\n\n\nexport var PropertyAccessors = dedupingMixin(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */\n  var base = PropertiesChanged(superClass);\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n\n  class PropertyAccessors extends base {\n    /**\n     * Generates property accessors for all attributes in the standard\n     * static `observedAttributes` array.\n     *\n     * Attribute names are mapped to property names using the `dash-case` to\n     * `camelCase` convention\n     *\n     * @return {void}\n     */\n    static createPropertiesForAttributes() {\n      var a$ = this.observedAttributes;\n\n      for (var _i = 0; _i < a$.length; _i++) {\n        this.prototype._createPropertyAccessor(dashToCamelCase(a$[_i]));\n      }\n    }\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     */\n\n\n    static attributeNameForProperty(property) {\n      return camelToDashCase(property);\n    }\n    /**\n     * Overrides PropertiesChanged implementation to initialize values for\n     * accessors created for values that already existed on the element\n     * prototype.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _initializeProperties() {\n      if (this.__dataProto) {\n        this._initializeProtoProperties(this.__dataProto);\n\n        this.__dataProto = null;\n      }\n\n      super._initializeProperties();\n    }\n    /**\n     * Called at instance time with bag of properties that were overwritten\n     * by accessors on the prototype when accessors were created.\n     *\n     * The default implementation sets these properties back into the\n     * setter at instance time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _initializeProtoProperties(props) {\n      for (var p in props) {\n        this._setProperty(p, props[p]);\n      }\n    }\n    /**\n     * Ensures the element has the given attribute. If it does not,\n     * assigns the given value to the attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is infact an\n     *     element\n     *\n     * @param {string} attribute Name of attribute to ensure is set.\n     * @param {string} value of the attribute.\n     * @return {void}\n     * @override\n     */\n\n\n    _ensureAttribute(attribute, value) {\n      var el =\n      /** @type {!HTMLElement} */\n      this;\n\n      if (!el.hasAttribute(attribute)) {\n        this._valueToNodeAttribute(el, value, attribute);\n      }\n    }\n    /**\n     * Overrides PropertiesChanged implemention to serialize objects as JSON.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided property\n     *     value.\n     * @override\n     */\n\n\n    _serializeValue(value) {\n      /* eslint-disable no-fallthrough */\n      switch (typeof value) {\n        case 'object':\n          if (value instanceof Date) {\n            return value.toString();\n          } else if (value) {\n            try {\n              return JSON.stringify(value);\n            } catch (x) {\n              return '';\n            }\n          }\n\n        default:\n          return super._serializeValue(value);\n      }\n    }\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called by Polymer when reading HTML attribute values to\n     * JS properties.  Users may override this method on Polymer element\n     * prototypes to provide deserialization for custom `type`s.  Note,\n     * the `type` argument is the value of the `type` field provided in the\n     * `properties` configuration object for a given property, and is\n     * by convention the constructor for the type to deserialize.\n     *\n     *\n     * @param {?string} value Attribute value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n\n\n    _deserializeValue(value, type) {\n      /**\n       * @type {*}\n       */\n      var outValue;\n\n      switch (type) {\n        case Object:\n          try {\n            outValue = JSON.parse(\n            /** @type {string} */\n            value);\n          } catch (x) {\n            // allow non-JSON literals like Strings and Numbers\n            outValue = value;\n          }\n\n          break;\n\n        case Array:\n          try {\n            outValue = JSON.parse(\n            /** @type {string} */\n            value);\n          } catch (x) {\n            outValue = null;\n            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n          }\n\n          break;\n\n        case Date:\n          outValue = isNaN(value) ? String(value) : Number(value);\n          outValue = new Date(outValue);\n          break;\n\n        default:\n          outValue = super._deserializeValue(value, type);\n          break;\n      }\n\n      return outValue;\n    }\n    /* eslint-enable no-fallthrough */\n\n    /**\n     * Overrides PropertiesChanged implementation to save existing prototype\n     * property value so that it can be reset.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     *\n     * When calling on a prototype, any overwritten values are saved in\n     * `__dataProto`, and it is up to the subclasser to decide how/when\n     * to set those properties back into the accessor.  When calling on an\n     * instance, the overwritten value is set via `_setPendingProperty`,\n     * and the user should call `_invalidateProperties` or `_flushProperties`\n     * for the values to take effect.\n     * @protected\n     * @return {void}\n     * @override\n     */\n\n\n    _definePropertyAccessor(property, readOnly) {\n      saveAccessorValue(this, property);\n\n      super._definePropertyAccessor(property, readOnly);\n    }\n    /**\n     * Returns true if this library created an accessor for the given property.\n     *\n     * @param {string} property Property name\n     * @return {boolean} True if an accessor was created\n     * @override\n     */\n\n\n    _hasAccessor(property) {\n      return this.__dataHasAccessor && this.__dataHasAccessor[property];\n    }\n    /**\n     * Returns true if the specified property has a pending change.\n     *\n     * @param {string} prop Property name\n     * @return {boolean} True if property has a pending change\n     * @protected\n     * @override\n     */\n\n\n    _isPropertyPending(prop) {\n      return Boolean(this.__dataPending && prop in this.__dataPending);\n    }\n\n  }\n\n  return PropertyAccessors;\n});"
    },
    {
     "id": 125,
     "name": "../node_modules/@polymer/polymer/lib/mixins/properties-changed.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\n/** @const {!AsyncInterface} */\n\nvar microtask = microTask;\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n */\n\nexport var PropertiesChanged = dedupingMixin(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  class PropertiesChanged extends superClass {\n    /**\n     * Creates property accessors for the given property names.\n     * @param {!Object} props Object whose keys are names of accessors.\n     * @return {void}\n     * @protected\n     */\n    static createProperties(props) {\n      var proto = this.prototype;\n\n      for (var prop in props) {\n        // don't stomp an existing accessor\n        if (!(prop in proto)) {\n          proto._createPropertyAccessor(prop);\n        }\n      }\n    }\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * The attribute name is the lowercased property name. Override to\n     * customize this mapping.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     */\n\n\n    static attributeNameForProperty(property) {\n      return property.toLowerCase();\n    }\n    /**\n     * Override point to provide a type to which to deserialize a value to\n     * a given property.\n     * @param {string} name Name of property\n     *\n     * @protected\n     */\n\n\n    static typeForProperty(name) {} //eslint-disable-line no-unused-vars\n\n    /**\n     * Creates a setter/getter pair for the named property with its own\n     * local storage.  The getter returns the value in the local storage,\n     * and the setter calls `_setProperty`, which updates the local storage\n     * for the property and enqueues a `_propertiesChanged` callback.\n     *\n     * This method may be called on a prototype or an instance.  Calling\n     * this method may overwrite a property value that already exists on\n     * the prototype/instance by creating the accessor.\n     *\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created; the\n     *   protected `_setProperty` function must be used to set the property\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _createPropertyAccessor(property, readOnly) {\n      this._addPropertyToAttributeMap(property);\n\n      if (!this.hasOwnProperty('__dataHasAccessor')) {\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n      }\n\n      if (!this.__dataHasAccessor[property]) {\n        this.__dataHasAccessor[property] = true;\n\n        this._definePropertyAccessor(property, readOnly);\n      }\n    }\n    /**\n     * Adds the given `property` to a map matching attribute names\n     * to property names, using `attributeNameForProperty`. This map is\n     * used when deserializing attribute values to properties.\n     *\n     * @param {string} property Name of the property\n     * @override\n     */\n\n\n    _addPropertyToAttributeMap(property) {\n      if (!this.hasOwnProperty('__dataAttributes')) {\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n      }\n\n      if (!this.__dataAttributes[property]) {\n        var attr = this.constructor.attributeNameForProperty(property);\n        this.__dataAttributes[attr] = property;\n      }\n    }\n    /**\n     * Defines a property accessor for the given property.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     * @return {void}\n     * @override\n     */\n\n\n    _definePropertyAccessor(property, readOnly) {\n      Object.defineProperty(this, property, {\n        /* eslint-disable valid-jsdoc */\n\n        /** @this {PropertiesChanged} */\n        get() {\n          return this._getProperty(property);\n        },\n\n        /** @this {PropertiesChanged} */\n        set: readOnly ? function () {} : function (value) {\n          this._setProperty(property, value);\n        }\n        /* eslint-enable */\n\n      });\n    }\n\n    constructor() {\n      super();\n      /** @protected {boolean} */\n\n      this.__dataEnabled = false;\n      this.__dataReady = false;\n      this.__dataInvalid = false;\n      this.__data = {};\n      this.__dataPending = null;\n      this.__dataOld = null;\n      this.__dataInstanceProps = null;\n      this.__serializing = false;\n\n      this._initializeProperties();\n    }\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     * @override\n     */\n\n\n    ready() {\n      this.__dataReady = true;\n\n      this._flushProperties();\n    }\n    /**\n     * Initializes the local storage for property accessors.\n     *\n     * Provided as an override point for performing any setup work prior\n     * to initializing the property accessor system.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _initializeProperties() {\n      // Capture instance properties; these will be set into accessors\n      // during first flush. Don't set them here, since we want\n      // these to overwrite defaults/constructor assignments\n      for (var p in this.__dataHasAccessor) {\n        if (this.hasOwnProperty(p)) {\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\n          this.__dataInstanceProps[p] = this[p];\n          delete this[p];\n        }\n      }\n    }\n    /**\n     * Called at ready time with bag of instance properties that overwrote\n     * accessors when the element upgraded.\n     *\n     * The default implementation sets these properties back into the\n     * setter at ready time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _initializeInstanceProperties(props) {\n      Object.assign(this, props);\n    }\n    /**\n     * Updates the local storage for a property (via `_setPendingProperty`)\n     * and enqueues a `_proeprtiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value)) {\n        this._invalidateProperties();\n      }\n    }\n    /**\n     * Returns the value for the given property.\n     * @param {string} property Name of property\n     * @return {*} Value for the given property\n     * @protected\n     * @override\n     */\n\n\n    _getProperty(property) {\n      return this.__data[property];\n    }\n    /* eslint-disable no-unused-vars */\n\n    /**\n     * Updates the local storage for a property, records the previous value,\n     * and adds it to the set of \"pending changes\" that will be passed to the\n     * `_propertiesChanged` callback.  This method does not enqueue the\n     * `_propertiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} ext Not used here; affordance for closure\n     * @return {boolean} Returns true if the property changed\n     * @protected\n     * @override\n     */\n\n\n    _setPendingProperty(property, value, ext) {\n      var old = this.__data[property];\n\n      var changed = this._shouldPropertyChange(property, value, old);\n\n      if (changed) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        } // Ensure old is captured from the last turn\n\n\n        if (this.__dataOld && !(property in this.__dataOld)) {\n          this.__dataOld[property] = old;\n        }\n\n        this.__data[property] = value;\n        this.__dataPending[property] = value;\n      }\n\n      return changed;\n    }\n    /* eslint-enable */\n\n    /**\n     * Marks the properties as invalid, and enqueues an async\n     * `_propertiesChanged` callback.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _invalidateProperties() {\n      if (!this.__dataInvalid && this.__dataReady) {\n        this.__dataInvalid = true;\n        microtask.run(() => {\n          if (this.__dataInvalid) {\n            this.__dataInvalid = false;\n\n            this._flushProperties();\n          }\n        });\n      }\n    }\n    /**\n     * Call to enable property accessor processing. Before this method is\n     * called accessor values will be set but side effects are\n     * queued. When called, any pending side effects occur immediately.\n     * For elements, generally `connectedCallback` is a normal spot to do so.\n     * It is safe to call this method multiple times as it only turns on\n     * property accessors once.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _enableProperties() {\n      if (!this.__dataEnabled) {\n        this.__dataEnabled = true;\n\n        if (this.__dataInstanceProps) {\n          this._initializeInstanceProperties(this.__dataInstanceProps);\n\n          this.__dataInstanceProps = null;\n        }\n\n        this.ready();\n      }\n    }\n    /**\n     * Calls the `_propertiesChanged` callback with the current set of\n     * pending changes (and old values recorded when pending changes were\n     * set), and resets the pending set of changes. Generally, this method\n     * should not be called in user code.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _flushProperties() {\n      var props = this.__data;\n      var changedProps = this.__dataPending;\n      var old = this.__dataOld;\n\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\n        this.__dataPending = null;\n        this.__dataOld = null;\n\n        this._propertiesChanged(props, changedProps, old);\n      }\n    }\n    /**\n     * Called in `_flushProperties` to determine if `_propertiesChanged`\n     * should be called. The default implementation returns true if\n     * properties are pending. Override to customize when\n     * `_propertiesChanged` is called.\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {boolean} true if changedProps is truthy\n     * @override\n     */\n\n\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) {\n      // eslint-disable-line no-unused-vars\n      return Boolean(changedProps);\n    }\n    /**\n     * Callback called when any properties with accessors created via\n     * `_createPropertyAccessor` have been set.\n     *\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _propertiesChanged(currentProps, changedProps, oldProps) {// eslint-disable-line no-unused-vars\n    }\n    /**\n     * Method called to determine whether a property value should be\n     * considered as a change and cause the `_propertiesChanged` callback\n     * to be enqueued.\n     *\n     * The default implementation returns `true` if a strict equality\n     * check fails. The method always returns false for `NaN`.\n     *\n     * Override this method to e.g. provide stricter checking for\n     * Objects/Arrays when using immutable patterns.\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     *   and enqueue a `_proeprtiesChanged` callback\n     * @protected\n     * @override\n     */\n\n\n    _shouldPropertyChange(property, value, old) {\n      return (// Strict equality check\n        old !== value && ( // This ensures (old==NaN, value==NaN) always returns false\n        old === old || value === value)\n      );\n    }\n    /**\n     * Implements native Custom Elements `attributeChangedCallback` to\n     * set an attribute value to a property via `_attributeToProperty`.\n     *\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @param {?string=} namespace Attribute namespace.\n     * @return {void}\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @override\n     */\n\n\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, old, value, namespace);\n      }\n    }\n    /**\n     * Deserializes an attribute to its associated property.\n     *\n     * This method calls the `_deserializeValue` method to convert the string to\n     * a typed value.\n     *\n     * @param {string} attribute Name of attribute to deserialize.\n     * @param {?string} value of the attribute.\n     * @param {*=} type type to deserialize to, defaults to the value\n     * returned from `typeForProperty`\n     * @return {void}\n     * @override\n     */\n\n\n    _attributeToProperty(attribute, value, type) {\n      if (!this.__serializing) {\n        var map = this.__dataAttributes;\n        var property = map && map[attribute] || attribute;\n        this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));\n      }\n    }\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect to.\n     * @param {*=} value Property value to refect.\n     * @return {void}\n     * @override\n     */\n\n\n    _propertyToAttribute(property, attribute, value) {\n      this.__serializing = true;\n      value = arguments.length < 3 ? this[property] : value;\n\n      this._valueToNodeAttribute(\n      /** @type {!HTMLElement} */\n      this, value, attribute || this.constructor.attributeNameForProperty(property));\n\n      this.__serializing = false;\n    }\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * This method calls the `_serializeValue` method to convert the typed\n     * value to a string.  If the `_serializeValue` method returns `undefined`,\n     * the attribute will be removed (this is the default for boolean\n     * type `false`).\n     *\n     * @param {Element} node Element to set attribute to.\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @return {void}\n     * @override\n     */\n\n\n    _valueToNodeAttribute(node, value, attribute) {\n      var str = this._serializeValue(value);\n\n      if (str === undefined) {\n        node.removeAttribute(attribute);\n      } else {\n        if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {\n          node =\n          /** @type {?Element} */\n          wrap(node);\n        }\n\n        node.setAttribute(attribute, str);\n      }\n    }\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * This method is called when setting JS property values to\n     * HTML attributes.  Users may override this method to provide\n     * serialization for custom types.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided\n     * property  value.\n     * @override\n     */\n\n\n    _serializeValue(value) {\n      switch (typeof value) {\n        case 'boolean':\n          return value ? '' : undefined;\n\n        default:\n          return value != null ? value.toString() : undefined;\n      }\n    }\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called when reading HTML attribute values to\n     * JS properties.  Users may override this method to provide\n     * deserialization for custom `type`s. Types for `Boolean`, `String`,\n     * and `Number` convert attributes to the expected types.\n     *\n     * @param {?string} value Value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n\n\n    _deserializeValue(value, type) {\n      switch (type) {\n        case Boolean:\n          return value !== null;\n\n        case Number:\n          return Number(value);\n\n        default:\n          return value;\n      }\n    }\n\n  }\n\n  return PropertiesChanged;\n});"
    },
    {
     "id": 126,
     "name": "../node_modules/@polymer/polymer/lib/utils/array-splice.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\n\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\n\nvar EDIT_LEAVE = 0;\nvar EDIT_UPDATE = 1;\nvar EDIT_ADD = 2;\nvar EDIT_DELETE = 3; // Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\n\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  var rowCount = oldEnd - oldStart + 1;\n  var columnCount = currentEnd - currentStart + 1;\n  var distances = new Array(rowCount); // \"Addition\" rows. Initialize null column.\n\n  for (var i = 0; i < rowCount; i++) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  } // Initialize null row\n\n\n  for (var j = 0; j < columnCount; j++) {\n    distances[0][j] = j;\n  }\n\n  for (var _i = 1; _i < rowCount; _i++) {\n    for (var _j = 1; _j < columnCount; _j++) {\n      if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {\n        var north = distances[_i - 1][_j] + 1;\n        var west = distances[_i][_j - 1] + 1;\n        distances[_i][_j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n} // This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\n\n\nfunction spliceOperationsFromEditDistances(distances) {\n  var i = distances.length - 1;\n  var j = distances[0].length - 1;\n  var current = distances[i][j];\n  var edits = [];\n\n  while (i > 0 || j > 0) {\n    if (i == 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n\n    if (j == 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n\n    var northWest = distances[i - 1][j - 1];\n    var west = distances[i - 1][j];\n    var north = distances[i][j - 1];\n    var min = void 0;\n    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;\n\n    if (min == northWest) {\n      if (northWest == current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n\n      i--;\n      j--;\n    } else if (min == west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n *\n * @param {!Array} current The current \"changed\" array for which to\n * calculate splices.\n * @param {number} currentStart Starting index in the `current` array for\n * which splices are calculated.\n * @param {number} currentEnd Ending index in the `current` array for\n * which splices are calculated.\n * @param {!Array} old The original \"unchanged\" array to compare `current`\n * against to determine splices.\n * @param {number} oldStart Starting index in the `old` array for\n * which splices are calculated.\n * @param {number} oldEnd Ending index in the `old` array for\n * which splices are calculated.\n * @return {!Array} Returns an array of splice record objects. Each of these\n * contains: `index` the location where the splice occurred; `removed`\n * the array of removed items from this location; `addedCount` the number\n * of items added at this location.\n */\n\n\nfunction calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  var prefixCount = 0;\n  var suffixCount = 0;\n  var splice;\n  var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);\n  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n\n  if (currentStart == currentEnd) {\n    splice = newSplice(currentStart, [], 0);\n\n    while (oldStart < oldEnd) {\n      splice.removed.push(old[oldStart++]);\n    }\n\n    return [splice];\n  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];\n\n  var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n  splice = undefined;\n  var splices = [];\n  var index = currentStart;\n  var oldIndex = oldStart;\n\n  for (var i = 0; i < ops.length; i++) {\n    switch (ops[i]) {\n      case EDIT_LEAVE:\n        if (splice) {\n          splices.push(splice);\n          splice = undefined;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n\n      case EDIT_UPDATE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n\n      case EDIT_ADD:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        break;\n\n      case EDIT_DELETE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n    }\n  }\n\n  if (splice) {\n    splices.push(splice);\n  }\n\n  return splices;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (var i = 0; i < searchLength; i++) {\n    if (!equals(current[i], old[i])) return i;\n  }\n\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  var index1 = current.length;\n  var index2 = old.length;\n  var count = 0;\n\n  while (count < searchLength && equals(current[--index1], old[--index2])) {\n    count++;\n  }\n\n  return count;\n}\n/**\n * Returns an array of splice records indicating the minimum edits required\n * to transform the `previous` array into the `current` array.\n *\n * Splice records are ordered by index and contain the following fields:\n * - `index`: index where edit started\n * - `removed`: array of removed items from this index\n * - `addedCount`: number of items added at this index\n *\n * This function is based on the Levenshtein \"minimum edit distance\"\n * algorithm. Note that updates are treated as removal followed by addition.\n *\n * The worst-case time complexity of this algorithm is `O(l * p)`\n *   l: The length of the current array\n *   p: The length of the previous array\n *\n * However, the worst-case complexity is reduced by an `O(n)` optimization\n * to detect any shared prefix & suffix between the two arrays and only\n * perform the more expensive minimum edit distance calculation over the\n * non-shared portions of the arrays.\n *\n * @function\n * @param {!Array} current The \"changed\" array for which splices will be\n * calculated.\n * @param {!Array} previous The \"unchanged\" original array to compare\n * `current` against to determine the splices.\n * @return {!Array} Returns an array of splice record objects. Each of these\n * contains: `index` the location where the splice occurred; `removed`\n * the array of removed items from this location; `addedCount` the number\n * of items added at this location.\n */\n\n\nexport function calculateSplices(current, previous) {\n  return calcSplices(current, 0, current.length, previous, 0, previous.length);\n}\n\nfunction equals(currentValue, previousValue) {\n  return currentValue === previousValue;\n}"
    },
    {
     "id": 127,
     "name": "../node_modules/@vaadin/vaadin-text-field/src/vaadin-text-field-mixin.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { timeOut, animationFrame } from '@polymer/polymer/lib/utils/async.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"vaadin-text-field-shared-styles\">\n  <template>\n    <style>\n      :host {\n        display: inline-flex;\n        outline: none;\n      }\n\n      :host::before {\n        content: \"\\\\2003\";\n        width: 0;\n        display: inline-block;\n        /* Size and position this element on the same vertical position as the input-field element\n           to make vertical align for the host element work as expected */\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      .vaadin-text-field-container,\n      .vaadin-text-area-container {\n        display: flex;\n        flex-direction: column;\n        min-width: 100%;\n        max-width: 100%;\n        width: var(--vaadin-text-field-default-width, 12em);\n      }\n\n      [part=\"label\"]:empty {\n        display: none;\n      }\n\n      [part=\"input-field\"] {\n        display: flex;\n        align-items: center;\n        flex: auto;\n      }\n\n      .vaadin-text-field-container [part=\"input-field\"] {\n        flex-grow: 0;\n      }\n\n      /* Reset the native input styles */\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(input),\n      [part=\"input-field\"] ::slotted(textarea) {\n        -webkit-appearance: none;\n        -moz-appearance: none;\n        outline: none;\n        margin: 0;\n        padding: 0;\n        border: 0;\n        border-radius: 0;\n        min-width: 0;\n        font: inherit;\n        font-size: 1em;\n        line-height: normal;\n        color: inherit;\n        background-color: transparent;\n        /* Disable default invalid style in Firefox */\n        box-shadow: none;\n      }\n\n      [part=\"input-field\"] ::slotted(*) {\n        flex: none;\n      }\n\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(input),\n      [part=\"input-field\"] ::slotted(textarea),\n      /* Slotted by vaadin-select-text-field */\n      [part=\"input-field\"] ::slotted([part=\"value\"]) {\n        flex: auto;\n        white-space: nowrap;\n        overflow: hidden;\n        width: 100%;\n        height: 100%;\n      }\n\n      [part=\"input-field\"] ::slotted(textarea) {\n        resize: none;\n      }\n\n      [part=\"value\"]::-ms-clear,\n      [part=\"input-field\"] ::slotted(input)::-ms-clear {\n        display: none;\n      }\n\n      [part=\"clear-button\"] {\n        cursor: default;\n      }\n\n      [part=\"clear-button\"]::before {\n        content: \"\";\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);\nvar HOST_PROPS = {\n  default: ['list', 'autofocus', 'pattern', 'autocapitalize', 'autocorrect', 'maxlength', 'minlength', 'name', 'placeholder', 'autocomplete', 'title', 'disabled', 'readonly', 'required'],\n  accessible: ['invalid']\n};\nvar PROP_TYPE = {\n  DEFAULT: 'default',\n  ACCESSIBLE: 'accessible'\n};\n/**\n * @polymerMixin\n */\n\nexport var TextFieldMixin = subclass => class VaadinTextFieldMixin extends subclass {\n  static get properties() {\n    return {\n      /**\n       * Whether the value of the control can be automatically completed by the browser.\n       * List of available options at:\n       * https://developer.mozilla.org/en/docs/Web/HTML/Element/input#attr-autocomplete\n       */\n      autocomplete: {\n        type: String\n      },\n\n      /**\n       * This is a property supported by Safari that is used to control whether\n       * autocorrection should be enabled when the user is entering/editing the text.\n       * Possible values are:\n       * on: Enable autocorrection.\n       * off: Disable autocorrection.\n       * @type {!TextFieldAutoCorrect | undefined}\n       */\n      autocorrect: {\n        type: String\n      },\n\n      /**\n       * This is a property supported by Safari and Chrome that is used to control whether\n       * autocapitalization should be enabled when the user is entering/editing the text.\n       * Possible values are:\n       * characters: Characters capitalization.\n       * words: Words capitalization.\n       * sentences: Sentences capitalization.\n       * none: No capitalization.\n       * @type {!TextFieldAutoCapitalize | undefined}\n       */\n      autocapitalize: {\n        type: String\n      },\n\n      /**\n       * Specify that the value should be automatically selected when the field gains focus.\n       * @type {boolean}\n       */\n      autoselect: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Set to true to display the clear icon which clears the input.\n       * @attr {boolean} clear-button-visible\n       * @type {boolean}\n       */\n      clearButtonVisible: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Error to show when the input value is invalid.\n       * @attr {string} error-message\n       * @type {string}\n       */\n      errorMessage: {\n        type: String,\n        value: '',\n        observer: '_errorMessageChanged'\n      },\n\n      /**\n       * Object with translated strings used for localization. Has\n       * the following structure and default values:\n       *\n       * ```\n       * {\n       *   // Translation of the clear icon button accessible label\n       *   clear: 'Clear'\n       * }\n       * ```\n       * @type {{clear: string}}\n       */\n      i18n: {\n        type: Object,\n        value: () => {\n          return {\n            clear: 'Clear'\n          };\n        }\n      },\n\n      /**\n       * String used for the label element.\n       * @type {string}\n       */\n      label: {\n        type: String,\n        value: '',\n        observer: '_labelChanged'\n      },\n\n      /**\n       * String used for the helper text.\n       * @attr {string} helper-text\n       * @type {string | null}\n       */\n      helperText: {\n        type: String,\n        value: '',\n        observer: '_helperTextChanged'\n      },\n\n      /**\n       * Maximum number of characters (in Unicode code points) that the user can enter.\n       */\n      maxlength: {\n        type: Number\n      },\n\n      /**\n       * Minimum number of characters (in Unicode code points) that the user can enter.\n       */\n      minlength: {\n        type: Number\n      },\n\n      /**\n       * The name of the control, which is submitted with the form data.\n       */\n      name: {\n        type: String\n      },\n\n      /**\n       * A hint to the user of what can be entered in the control.\n       */\n      placeholder: {\n        type: String\n      },\n\n      /**\n       * This attribute indicates that the user cannot modify the value of the control.\n       */\n      readonly: {\n        type: Boolean,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies that the user must fill in a value.\n       */\n      required: {\n        type: Boolean,\n        reflectToAttribute: true\n      },\n\n      /**\n       * The initial value of the control.\n       * It can be used for two-way data binding.\n       * @type {string}\n       */\n      value: {\n        type: String,\n        value: '',\n        observer: '_valueChanged',\n        notify: true\n      },\n\n      /**\n       * This property is set to true when the control value is invalid.\n       * @type {boolean}\n       */\n      invalid: {\n        type: Boolean,\n        reflectToAttribute: true,\n        notify: true,\n        value: false\n      },\n\n      /**\n       * Specifies that the text field has value.\n       * @attr {boolean} has-value\n       */\n      hasValue: {\n        type: Boolean,\n        reflectToAttribute: true\n      },\n\n      /**\n       * When set to true, user is prevented from typing a value that\n       * conflicts with the given `pattern`.\n       * @attr {boolean} prevent-invalid-input\n       */\n      preventInvalidInput: {\n        type: Boolean\n      },\n\n      /**\n       * A pattern matched against individual characters the user inputs.\n       * When set, the field will prevent:\n       * - `keyDown` events if the entered key doesn't match `/^_enabledCharPattern$/`\n       * - `paste` events if the pasted text doesn't match `/^_enabledCharPattern*$/`\n       * - `drop` events if the dropped text doesn't match `/^_enabledCharPattern*$/`\n       *\n       * For example, to enable entering only numbers and minus signs,\n       * `_enabledCharPattern = \"[\\\\d-]\"`\n       * @protected\n       */\n      _enabledCharPattern: String,\n\n      /** @private */\n      _labelId: String,\n\n      /** @private */\n      _helperTextId: String,\n\n      /** @private */\n      _errorId: String,\n\n      /** @private */\n      _inputId: String,\n\n      /** @private */\n      _hasSlottedHelper: Boolean\n    };\n  }\n\n  static get observers() {\n    return ['_stateChanged(disabled, readonly, clearButtonVisible, hasValue)', '_hostPropsChanged(' + HOST_PROPS.default.join(', ') + ')', '_hostAccessiblePropsChanged(' + HOST_PROPS.accessible.join(', ') + ')', '_getActiveErrorId(invalid, errorMessage, _errorId, helperText, _helperTextId, _hasSlottedHelper)', '_getActiveLabelId(label, _labelId, _inputId)', '__observeOffsetHeight(errorMessage, invalid, label, helperText)', '__enabledCharPatternChanged(_enabledCharPattern)'];\n  }\n  /**\n   * @return {HTMLElement | undefined}\n   * @protected\n   */\n\n\n  get focusElement() {\n    if (!this.shadowRoot) {\n      return;\n    }\n\n    var slotted = this.querySelector(`${this._slottedTagName}[slot=\"${this._slottedTagName}\"]`);\n\n    if (slotted) {\n      return slotted;\n    }\n\n    return this.shadowRoot.querySelector('[part=\"value\"]');\n  }\n  /**\n   * @return {HTMLElement | undefined}}\n   * @protected\n   */\n\n\n  get inputElement() {\n    return this.focusElement;\n  }\n  /**\n   * @return {string}\n   * @protected\n   */\n\n\n  get _slottedTagName() {\n    return 'input';\n  }\n  /** @protected */\n\n\n  _createConstraintsObserver() {\n    // This complex observer needs to be added dynamically here (instead of defining it above in the `get observers()`)\n    // so that it runs after complex observers of inheriting classes. Otherwise e.g. `_stepOrMinChanged()` observer of\n    // vaadin-number-field would run after this and the `min` and `step` properties would not yet be propagated to\n    // the `inputElement` when this runs.\n    this._createMethodObserver('_constraintsChanged(required, minlength, maxlength, pattern)');\n  }\n  /** @private */\n\n\n  _onInput(e) {\n    if (this.__preventInput) {\n      e.stopImmediatePropagation();\n      this.__preventInput = false;\n      return;\n    }\n\n    if (this.preventInvalidInput) {\n      var input = this.inputElement;\n\n      if (input.value.length > 0 && !this.checkValidity()) {\n        input.value = this.value || ''; // add input-prevented attribute for 200ms\n\n        this.setAttribute('input-prevented', '');\n        this._inputDebouncer = Debouncer.debounce(this._inputDebouncer, timeOut.after(200), () => {\n          this.removeAttribute('input-prevented');\n        });\n        return;\n      }\n    }\n\n    if (!e.__fromClearButton) {\n      this.__userInput = true;\n    }\n\n    this.value = e.target.value;\n    this.__userInput = false;\n  } // NOTE(yuriy): Workaround needed for IE11 and Edge for proper displaying\n  // of the clear button instead of setting display property for it depending on state.\n\n  /** @private */\n\n\n  _stateChanged(disabled, readonly, clearButtonVisible, hasValue) {\n    if (!disabled && !readonly && clearButtonVisible && hasValue) {\n      this.$.clearButton.removeAttribute('hidden');\n    } else {\n      this.$.clearButton.setAttribute('hidden', true);\n    }\n  }\n  /**\n   * @param {!Event} e\n   * @protected\n   */\n\n\n  _onChange(e) {\n    if (this._valueClearing) {\n      return;\n    } // In the Shadow DOM, the `change` event is not leaked into the\n    // ancestor tree, so we must do this manually.\n\n\n    var changeEvent = new CustomEvent('change', {\n      detail: {\n        sourceEvent: e\n      },\n      bubbles: e.bubbles,\n      cancelable: e.cancelable\n    });\n    this.dispatchEvent(changeEvent);\n  }\n  /**\n   * @param {unknown} newVal\n   * @param {unknown} oldVal\n   * @protected\n   */\n\n\n  _valueChanged(newVal, oldVal) {\n    // setting initial value to empty string, skip validation\n    if (newVal === '' && oldVal === undefined) {\n      return;\n    }\n\n    if (newVal !== '' && newVal != null) {\n      this.hasValue = true;\n    } else {\n      this.hasValue = false;\n    }\n\n    if (this.__userInput) {\n      return;\n    } else if (newVal !== undefined) {\n      this.inputElement.value = newVal;\n    } else {\n      this.value = this.inputElement.value = '';\n    }\n\n    if (this.invalid) {\n      this.validate();\n    }\n  }\n  /** @private */\n\n\n  _labelChanged(label) {\n    this._setOrToggleAttribute('has-label', !!label, this);\n  }\n  /** @private */\n\n\n  _helperTextChanged(helperText) {\n    this._setOrToggleAttribute('has-helper', !!helperText, this);\n  }\n  /** @private */\n\n\n  _errorMessageChanged(errorMessage) {\n    this._setOrToggleAttribute('has-error-message', !!errorMessage, this);\n  }\n  /** @private */\n\n\n  _onHelperSlotChange() {\n    var slottedNodes = this.shadowRoot.querySelector(`[name=\"helper\"]`).assignedNodes({\n      flatten: true\n    }); // Only has slotted helper if not a text node\n    // Text nodes are added by the helperText prop and not the helper slot\n    // The filter is added due to shady DOM triggering this callback on helperText prop change\n\n    this._hasSlottedHelper = slottedNodes.filter(node => node.nodeType !== 3).length;\n\n    if (this._hasSlottedHelper) {\n      this.setAttribute('has-helper', 'slotted');\n    } else if (this.helperText === '' || this.helperText === null) {\n      this.removeAttribute('has-helper');\n    }\n  }\n  /** @private */\n\n\n  _onSlotChange() {\n    var slotted = this.querySelector(`${this._slottedTagName}[slot=\"${this._slottedTagName}\"]`);\n\n    if (this.value) {\n      this.inputElement.value = this.value;\n      this.validate();\n    }\n\n    if (slotted && !this._slottedInput) {\n      this._validateSlottedValue(slotted);\n\n      this._addInputListeners(slotted);\n\n      this._addIEListeners(slotted);\n\n      this._slottedInput = slotted;\n    } else if (!slotted && this._slottedInput) {\n      this._removeInputListeners(this._slottedInput);\n\n      this._removeIEListeners(this._slottedInput);\n\n      this._slottedInput = undefined;\n    }\n\n    Object.keys(PROP_TYPE).map(key => PROP_TYPE[key]).forEach(type => this._propagateHostAttributes(HOST_PROPS[type].map(attr => this[attr]), type));\n  }\n  /** @private */\n\n\n  _hostPropsChanged(...attributesValues) {\n    this._propagateHostAttributes(attributesValues, PROP_TYPE.DEFAULT);\n  }\n  /** @private */\n\n\n  _hostAccessiblePropsChanged(...attributesValues) {\n    this._propagateHostAttributes(attributesValues, PROP_TYPE.ACCESSIBLE);\n  }\n  /** @private */\n\n\n  _validateSlottedValue(slotted) {\n    if (slotted.value !== this.value) {\n      console.warn('Please define value on the vaadin-text-field component!');\n      slotted.value = '';\n    }\n  }\n  /** @private */\n\n\n  _propagateHostAttributes(attributesValues, type) {\n    var input = this.inputElement;\n    var attributeNames = HOST_PROPS[type];\n\n    if (type === PROP_TYPE.ACCESSIBLE) {\n      attributeNames.forEach((attr, index) => {\n        this._setOrToggleAttribute(attr, attributesValues[index], input);\n\n        this._setOrToggleAttribute(`aria-${attr}`, attributesValues[index] ? 'true' : false, input);\n      });\n    } else {\n      attributeNames.forEach((attr, index) => {\n        this._setOrToggleAttribute(attr, attributesValues[index], input);\n      });\n    }\n  }\n  /** @private */\n\n\n  _setOrToggleAttribute(name, value, node) {\n    if (!name || !node) {\n      return;\n    }\n\n    if (value) {\n      node.setAttribute(name, typeof value === 'boolean' ? '' : value);\n    } else {\n      node.removeAttribute(name);\n    }\n  }\n  /**\n   * @param {boolean | undefined} required\n   * @param {number | undefined} minlength\n   * @param {number | undefined} maxlength\n   * @param {string | undefined} maxlength\n   * @protected\n   */\n\n\n  _constraintsChanged(required, minlength, maxlength, pattern) {\n    if (!this.invalid) {\n      return;\n    }\n\n    if (!required && !minlength && !maxlength && !pattern) {\n      this.invalid = false;\n    } else {\n      this.validate();\n    }\n  }\n  /**\n   * Returns true if the current input value satisfies all constraints (if any)\n   * @return {boolean}\n   */\n\n\n  checkValidity() {\n    // Note (Yuriy): `__forceCheckValidity` is used in containing components (i.e. `vaadin-date-picker`) in order\n    // to force the checkValidity instead of returning the previous invalid state.\n    if (this.required || this.pattern || this.maxlength || this.minlength || this.__forceCheckValidity) {\n      return this.inputElement.checkValidity();\n    } else {\n      return !this.invalid;\n    }\n  }\n  /** @private */\n\n\n  _addInputListeners(node) {\n    node.addEventListener('input', this._boundOnInput);\n    node.addEventListener('change', this._boundOnChange);\n    node.addEventListener('blur', this._boundOnBlur);\n    node.addEventListener('focus', this._boundOnFocus);\n    node.addEventListener('paste', this._boundOnPaste);\n    node.addEventListener('drop', this._boundOnDrop);\n    node.addEventListener('beforeinput', this._boundOnBeforeInput);\n  }\n  /** @private */\n\n\n  _removeInputListeners(node) {\n    node.removeEventListener('input', this._boundOnInput);\n    node.removeEventListener('change', this._boundOnChange);\n    node.removeEventListener('blur', this._boundOnBlur);\n    node.removeEventListener('focus', this._boundOnFocus);\n    node.removeEventListener('paste', this._boundOnPaste);\n    node.removeEventListener('drop', this._boundOnDrop);\n    node.removeEventListener('beforeinput', this._boundOnBeforeInput);\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n\n    this._createConstraintsObserver();\n\n    this._boundOnInput = this._onInput.bind(this);\n    this._boundOnChange = this._onChange.bind(this);\n    this._boundOnBlur = this._onBlur.bind(this);\n    this._boundOnFocus = this._onFocus.bind(this);\n    this._boundOnPaste = this._onPaste.bind(this);\n    this._boundOnDrop = this._onDrop.bind(this);\n    this._boundOnBeforeInput = this._onBeforeInput.bind(this);\n    var defaultInput = this.shadowRoot.querySelector('[part=\"value\"]');\n    this._slottedInput = this.querySelector(`${this._slottedTagName}[slot=\"${this._slottedTagName}\"]`);\n\n    this._addInputListeners(defaultInput);\n\n    this._addIEListeners(defaultInput);\n\n    if (this._slottedInput) {\n      this._addIEListeners(this._slottedInput);\n\n      this._addInputListeners(this._slottedInput);\n    }\n\n    this.shadowRoot.querySelector('[name=\"input\"], [name=\"textarea\"]').addEventListener('slotchange', this._onSlotChange.bind(this));\n\n    this._onHelperSlotChange();\n\n    this.shadowRoot.querySelector('[name=\"helper\"]').addEventListener('slotchange', this._onHelperSlotChange.bind(this));\n\n    if (!(window.ShadyCSS && window.ShadyCSS.nativeCss)) {\n      this.updateStyles();\n    }\n\n    this.$.clearButton.addEventListener('mousedown', () => this._valueClearing = true);\n    this.$.clearButton.addEventListener('mouseleave', () => this._valueClearing = false);\n    this.$.clearButton.addEventListener('click', this._onClearButtonClick.bind(this));\n    this.addEventListener('keydown', this._onKeyDown.bind(this));\n    var uniqueId = TextFieldMixin._uniqueId = 1 + TextFieldMixin._uniqueId || 0;\n    this._errorId = `${this.constructor.is}-error-${uniqueId}`;\n    this._labelId = `${this.constructor.is}-label-${uniqueId}`;\n    this._helperTextId = `${this.constructor.is}-helper-${uniqueId}`;\n    this._inputId = `${this.constructor.is}-input-${uniqueId}`; // Lumo theme defines a max-height transition for the \"error-message\"\n    // part on invalid state change.\n\n    this.shadowRoot.querySelector('[part=\"error-message\"]').addEventListener('transitionend', () => {\n      this.__observeOffsetHeight();\n    });\n  }\n  /**\n   * Returns true if `value` is valid.\n   * `<iron-form>` uses this to check the validity for all its elements.\n   *\n   * @return {boolean} True if the value is valid.\n   */\n\n\n  validate() {\n    return !(this.invalid = !this.checkValidity());\n  }\n\n  clear() {\n    this.value = '';\n  }\n  /** @private */\n\n\n  _onBlur() {\n    this.validate();\n  }\n  /** @private */\n\n\n  _onFocus() {\n    if (this.autoselect) {\n      this.inputElement.select(); // iOS 9 workaround: https://stackoverflow.com/a/7436574\n\n      setTimeout(() => {\n        try {\n          this.inputElement.setSelectionRange(0, 9999);\n        } catch (e) {// The workaround may cause errors on different input types.\n          // Needs to be suppressed. See https://github.com/vaadin/flow/issues/6070\n        }\n      });\n    }\n  }\n  /** @private */\n\n\n  _onClearButtonClick(e) {\n    e.preventDefault(); // NOTE(yuriy): This line won't affect focus on the host. Cannot be properly tested.\n\n    this.inputElement.focus();\n    this.clear();\n    this._valueClearing = false;\n\n    if (navigator.userAgent.match(/Trident/)) {\n      // Disable IE input\" event prevention here, we want the input event from\n      // below to propagate normally.\n      this.__preventInput = false;\n    }\n\n    var inputEvent = new Event('input', {\n      bubbles: true,\n      composed: true\n    });\n    inputEvent.__fromClearButton = true;\n    var changeEvent = new Event('change', {\n      bubbles: !this._slottedInput\n    });\n    changeEvent.__fromClearButton = true;\n    this.inputElement.dispatchEvent(inputEvent);\n    this.inputElement.dispatchEvent(changeEvent);\n  }\n  /**\n   * @param {!KeyboardEvent} e\n   * @protected\n   */\n\n\n  _onKeyDown(e) {\n    if (e.keyCode === 27 && this.clearButtonVisible) {\n      var dispatchChange = !!this.value;\n      this.clear();\n      dispatchChange && this.inputElement.dispatchEvent(new Event('change', {\n        bubbles: !this._slottedInput\n      }));\n    }\n\n    if (this._enabledCharPattern && !this.__shouldAcceptKey(e)) {\n      e.preventDefault();\n    }\n  }\n  /** @private */\n\n\n  __shouldAcceptKey(event) {\n    return event.metaKey || event.ctrlKey || !event.key // allow typing anything if event.key is not supported\n    || event.key.length !== 1 // allow \"Backspace\", \"ArrowLeft\" etc.\n    || this.__enabledCharRegExp.test(event.key);\n  }\n  /** @private */\n\n\n  _onPaste(e) {\n    if (this._enabledCharPattern) {\n      var pastedText = (e.clipboardData || window.clipboardData).getData('text');\n\n      if (!this.__enabledTextRegExp.test(pastedText)) {\n        e.preventDefault();\n      }\n    }\n  }\n  /** @private */\n\n\n  _onDrop(e) {\n    if (this._enabledCharPattern) {\n      var draggedText = e.dataTransfer.getData('text');\n\n      if (!this.__enabledTextRegExp.test(draggedText)) {\n        e.preventDefault();\n      }\n    }\n  }\n  /** @private */\n\n\n  _onBeforeInput(e) {\n    // The `beforeinput` event covers all the cases for `_enabledCharPattern`: keyboard, pasting and dropping,\n    // but it is still experimental technology so we can't rely on it. It's used here just as an additional check,\n    // because it seems to be the only way to detect and prevent specific keys on mobile devices. See issue #429.\n    if (this._enabledCharPattern && e.data && !this.__enabledTextRegExp.test(e.data)) {\n      e.preventDefault();\n    }\n  }\n  /** @private */\n\n\n  __enabledCharPatternChanged(_enabledCharPattern) {\n    this.__enabledCharRegExp = _enabledCharPattern && new RegExp('^' + _enabledCharPattern + '$');\n    this.__enabledTextRegExp = _enabledCharPattern && new RegExp('^' + _enabledCharPattern + '*$');\n  }\n  /** @private */\n\n\n  _addIEListeners(node) {\n    /* istanbul ignore if */\n    if (navigator.userAgent.match(/Trident/)) {\n      // IE11 dispatches `input` event in following cases:\n      // - focus or blur, when placeholder attribute is set\n      // - placeholder attribute value changed\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/101220/\n      this._shouldPreventInput = () => {\n        this.__preventInput = true;\n        requestAnimationFrame(() => {\n          this.__preventInput = false;\n        });\n      };\n\n      node.addEventListener('focusin', this._shouldPreventInput);\n      node.addEventListener('focusout', this._shouldPreventInput);\n\n      this._createPropertyObserver('placeholder', this._shouldPreventInput);\n    }\n  }\n  /** @private */\n\n\n  _removeIEListeners(node) {\n    /* istanbul ignore if */\n    if (navigator.userAgent.match(/Trident/)) {\n      node.removeEventListener('focusin', this._shouldPreventInput);\n      node.removeEventListener('focusout', this._shouldPreventInput);\n    }\n  }\n  /** @private */\n\n\n  _getActiveErrorId(invalid, errorMessage, errorId, helperText, helperTextId, hasSlottedHelper) {\n    var ids = [];\n\n    if (helperText || hasSlottedHelper) {\n      ids.push(helperTextId);\n    }\n\n    if (errorMessage && invalid) {\n      ids.push(errorId);\n    }\n\n    this._setOrToggleAttribute('aria-describedby', ids.join(' '), this.focusElement);\n  }\n  /** @private */\n\n\n  _getActiveLabelId(label, _labelId, _inputId) {\n    var ids = _inputId;\n\n    if (label) {\n      ids = `${_labelId} ${_inputId}`;\n    }\n\n    this.focusElement.setAttribute('aria-labelledby', ids);\n  }\n  /** @private */\n\n\n  _getErrorMessageAriaHidden(invalid, errorMessage, errorId) {\n    return (!(errorMessage && invalid ? errorId : undefined)).toString();\n  }\n  /** @private */\n\n\n  _dispatchIronResizeEventIfNeeded(sizePropertyName, value) {\n    var previousSizePropertyName = '__previous' + sizePropertyName;\n\n    if (this[previousSizePropertyName] !== undefined && this[previousSizePropertyName] !== value) {\n      this.dispatchEvent(new CustomEvent('iron-resize', {\n        bubbles: true\n      }));\n    }\n\n    this[previousSizePropertyName] = value;\n  }\n  /** @private */\n\n\n  __observeOffsetHeight() {\n    this.__observeOffsetHeightDebouncer = Debouncer.debounce(this.__observeOffsetHeightDebouncer, animationFrame, () => {\n      this._dispatchIronResizeEventIfNeeded('Height', this.offsetHeight);\n    });\n  }\n  /**\n   * @param {string} prop\n   * @param {string} oldVal\n   * @param {string} newVal\n   * @protected\n   */\n\n\n  attributeChangedCallback(prop, oldVal, newVal) {\n    super.attributeChangedCallback(prop, oldVal, newVal); // Needed until Edge has CSS Custom Properties (present in Edge Preview)\n\n    /* istanbul ignore if */\n\n    if (!(window.ShadyCSS && window.ShadyCSS.nativeCss) && /^(focused|focus-ring|invalid|disabled|placeholder|has-value)$/.test(prop)) {\n      this.updateStyles();\n    } // Safari has an issue with repainting shadow root element styles when a host attribute changes.\n    // Need this workaround (toggle any inline css property on and off) until the issue gets fixed.\n\n\n    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    /* istanbul ignore if */\n\n    if (isSafari && this.root) {\n      var WEBKIT_PROPERTY = '-webkit-backface-visibility';\n      this.root.querySelectorAll('*').forEach(el => {\n        el.style[WEBKIT_PROPERTY] = 'visible';\n        el.style[WEBKIT_PROPERTY] = '';\n      });\n    }\n  } // Workaround for https://github.com/Polymer/polymer/issues/5259\n\n\n  get __data() {\n    return this.__dataValue || {};\n  }\n\n  set __data(value) {\n    this.__dataValue = value;\n  }\n  /**\n   * Fired when the user commits a value change.\n   *\n   * @event change\n   */\n\n  /**\n   * Fired when the value is changed by the user: on every typing keystroke,\n   * and the value is cleared using the clear button.\n   *\n   * @event input\n   */\n\n  /**\n   * Fired when the size of the element changes.\n   *\n   * @event iron-resize\n   */\n\n\n};"
    },
    {
     "id": 128,
     "name": "../node_modules/@vaadin/vaadin-item/src/vaadin-item-mixin.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/**\n * A mixin providing `focused`, `focus-ring`, `active`, `disabled` and `selected`.\n *\n * `focused`, `active` and `focus-ring` are set as only as attributes.\n * @polymerMixin\n */\nexport var ItemMixin = superClass => class VaadinItemMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Used for mixin detection because `instanceof` does not work with mixins.\n       * e.g. in VaadinListMixin it filters items by using the\n       * `element._hasVaadinItemMixin` condition.\n       * @type {boolean}\n       */\n      _hasVaadinItemMixin: {\n        value: true\n      },\n\n      /**\n       * If true, the user cannot interact with this element.\n       * @type {boolean}\n       */\n      disabled: {\n        type: Boolean,\n        value: false,\n        observer: '_disabledChanged',\n        reflectToAttribute: true\n      },\n\n      /**\n       * If true, the item is in selected state.\n       * @type {boolean}\n       */\n      selected: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_selectedChanged'\n      },\n\n      /** @private */\n      _value: String\n    };\n  }\n  /**\n   * @return {string}\n   */\n\n\n  get value() {\n    return this._value !== undefined ? this._value : this.textContent.trim();\n  }\n  /**\n   * @param {string} value\n   */\n\n\n  set value(value) {\n    this._value = value;\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    var attrValue = this.getAttribute('value');\n\n    if (attrValue !== null) {\n      this.value = attrValue;\n    }\n\n    this.addEventListener('focus', e => this._setFocused(true), true);\n    this.addEventListener('blur', e => this._setFocused(false), true);\n    this.addEventListener('mousedown', e => {\n      this._setActive(this._mousedown = true);\n\n      var mouseUpListener = () => {\n        this._setActive(this._mousedown = false);\n\n        document.removeEventListener('mouseup', mouseUpListener);\n      };\n\n      document.addEventListener('mouseup', mouseUpListener);\n    });\n    this.addEventListener('keydown', e => this._onKeydown(e));\n    this.addEventListener('keyup', e => this._onKeyup(e));\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback(); // in Firefox and Safari, blur does not fire on the element when it is removed,\n    // especially between keydown and keyup events, being active at the same time.\n    // reproducible in `<vaadin-select>` when closing overlay on select.\n\n    if (this.hasAttribute('active')) {\n      this._setFocused(false);\n    }\n  }\n  /** @private */\n\n\n  _selectedChanged(selected) {\n    this.setAttribute('aria-selected', selected);\n  }\n  /** @private */\n\n\n  _disabledChanged(disabled) {\n    if (disabled) {\n      this.selected = false;\n      this.setAttribute('aria-disabled', 'true');\n      this.blur();\n    } else {\n      this.removeAttribute('aria-disabled');\n    }\n  }\n  /**\n   * @param {boolean} focused\n   * @protected\n   */\n\n\n  _setFocused(focused) {\n    if (focused) {\n      this.setAttribute('focused', '');\n\n      if (!this._mousedown) {\n        this.setAttribute('focus-ring', '');\n      }\n    } else {\n      this.removeAttribute('focused');\n      this.removeAttribute('focus-ring');\n\n      this._setActive(false);\n    }\n  }\n  /**\n   * @param {boolean} active\n   * @protected\n   */\n\n\n  _setActive(active) {\n    if (active) {\n      this.setAttribute('active', '');\n    } else {\n      this.removeAttribute('active');\n    }\n  }\n  /**\n   * @param {!KeyboardEvent} event\n   * @protected\n   */\n\n\n  _onKeydown(event) {\n    if (/^( |SpaceBar|Enter)$/.test(event.key) && !event.defaultPrevented) {\n      event.preventDefault();\n\n      this._setActive(true);\n    }\n  }\n  /**\n   * @param {!KeyboardEvent} event\n   * @protected\n   */\n\n\n  _onKeyup(event) {\n    if (this.hasAttribute('active')) {\n      this._setActive(false);\n\n      this.click();\n    }\n  }\n\n};"
    },
    {
     "id": 129,
     "name": "../node_modules/@polymer/iron-a11y-announcer/iron-a11y-announcer.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { Polymer } from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n`iron-a11y-announcer` is a singleton element that is intended to add a11y\nto features that require on-demand announcement from screen readers. In\norder to make use of the announcer, it is best to request its availability\nin the announcing element.\n\nExample:\n\n    Polymer({\n\n      is: 'x-chatty',\n\n      attached: function() {\n        // This will create the singleton element if it has not\n        // been created yet:\n        Polymer.IronA11yAnnouncer.requestAvailability();\n      }\n    });\n\nAfter the `iron-a11y-announcer` has been made available, elements can\nmake announces by firing bubbling `iron-announce` events.\n\nExample:\n\n    this.fire('iron-announce', {\n      text: 'This is an announcement!'\n    }, { bubbles: true });\n\nNote: announcements are only audible if you have a screen reader enabled.\n\n@demo demo/index.html\n*/\n\nexport var IronA11yAnnouncer = Polymer({\n  /** @override */\n  _template: html`\n    <style>\n      :host {\n        display: inline-block;\n        position: fixed;\n        clip: rect(0px,0px,0px,0px);\n      }\n    </style>\n    <div aria-live$=\"[[mode]]\">[[_text]]</div>\n`,\n  is: 'iron-a11y-announcer',\n  properties: {\n    /**\n     * The value of mode is used to set the `aria-live` attribute\n     * for the element that will be announced. Valid values are: `off`,\n     * `polite` and `assertive`.\n     */\n    mode: {\n      type: String,\n      value: 'polite'\n    },\n\n    /**\n     * The timeout on refreshing the announcement text. Larger timeouts are\n     * needed for certain screen readers to re-announce the same message.\n     */\n    timeout: {\n      type: Number,\n      value: 150\n    },\n    _text: {\n      type: String,\n      value: ''\n    }\n  },\n\n  /** @override */\n  created: function () {\n    if (!IronA11yAnnouncer.instance) {\n      IronA11yAnnouncer.instance = this;\n    }\n\n    document.addEventListener('iron-announce', this._onIronAnnounce.bind(this));\n  },\n\n  /**\n   * Cause a text string to be announced by screen readers.\n   *\n   * @param {string} text The text that should be announced.\n   */\n  announce: function (text) {\n    this._text = '';\n    this.async(function () {\n      this._text = text;\n    }, this.timeout);\n  },\n  _onIronAnnounce: function (event) {\n    if (event.detail && event.detail.text) {\n      this.announce(event.detail.text);\n    }\n  }\n});\nIronA11yAnnouncer.instance = null;\n\nIronA11yAnnouncer.requestAvailability = function () {\n  if (!IronA11yAnnouncer.instance) {\n    IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');\n  }\n\n  if (document.body) {\n    document.body.appendChild(IronA11yAnnouncer.instance);\n  } else {\n    document.addEventListener('load', function () {\n      document.body.appendChild(IronA11yAnnouncer.instance);\n    });\n  }\n};"
    },
    {
     "id": 130,
     "name": "../node_modules/@polymer/polymer/lib/mixins/disable-upgrade-mixin.js?babel-target=es6",
     "source": "/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { ElementMixin } from './element-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nvar DISABLED_ATTR = 'disable-upgrade';\n/**\n * Element class mixin that allows the element to boot up in a non-enabled\n * state when the `disable-upgrade` attribute is present. This mixin is\n * designed to be used with element classes like PolymerElement that perform\n * initial startup work when they are first connected. When the\n * `disable-upgrade` attribute is removed, if the element is connected, it\n * boots up and \"enables\" as it otherwise would; if it is not connected, the\n * element boots up when it is next connected.\n *\n * Using `disable-upgrade` with PolymerElement prevents any data propagation\n * to the element, any element DOM from stamping, or any work done in\n * connected/disconnctedCallback from occuring, but it does not prevent work\n * done in the element constructor.\n *\n * Note, this mixin must be applied on top of any element class that\n * itself implements a `connectedCallback` so that it can control the work\n * done in `connectedCallback`. For example,\n *\n *     MyClass = DisableUpgradeMixin(class extends BaseClass {...});\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n */\n\nexport var DisableUpgradeMixin = dedupingMixin(base => {\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  var superClass = ElementMixin(base);\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_DisableUpgradeMixin}\n   */\n\n  class DisableUpgradeClass extends superClass {\n    /**\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    static get observedAttributes() {\n      return super.observedAttributes.concat(DISABLED_ATTR);\n    }\n    /**\n     * @override\n     * @param {string} name Attribute name.\n     * @param {?string} old The previous value for the attribute.\n     * @param {?string} value The new value for the attribute.\n     * @param {?string=} namespace The XML namespace for the attribute.\n     * @return {undefined}\n     */\n\n\n    attributeChangedCallback(name, old, value, namespace) {\n      if (name == DISABLED_ATTR) {\n        if (!this.__dataEnabled && value == null && this.isConnected) {\n          super.connectedCallback();\n        }\n      } else {\n        super.attributeChangedCallback(name, old, value,\n        /** @type {null|string} */\n        namespace);\n      }\n    }\n    /*\n      NOTE: cannot gate on attribute because this is called before\n      attributes are delivered. Therefore, we stub this out and\n      call `super._initializeProperties()` manually.\n    */\n\n    /** @override */\n\n\n    _initializeProperties() {} // prevent user code in connected from running\n\n    /** @override */\n\n\n    connectedCallback() {\n      if (this.__dataEnabled || !this.hasAttribute(DISABLED_ATTR)) {\n        super.connectedCallback();\n      }\n    } // prevent element from turning on properties\n\n    /** @override */\n\n\n    _enableProperties() {\n      if (!this.hasAttribute(DISABLED_ATTR)) {\n        if (!this.__dataEnabled) {\n          super._initializeProperties();\n        }\n\n        super._enableProperties();\n      }\n    } // only go if \"enabled\"\n\n    /** @override */\n\n\n    disconnectedCallback() {\n      if (this.__dataEnabled) {\n        super.disconnectedCallback();\n      }\n    }\n\n  }\n\n  return DisableUpgradeClass;\n});"
    },
    {
     "id": 138,
     "name": "../node_modules/@vaadin/vaadin-button/theme/lumo/vaadin-button.js?babel-target=es6",
     "source": "import './vaadin-button-styles.js';\nimport '../../src/vaadin-button.js';"
    },
    {
     "id": 140,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/mixins/required-field.js?babel-target=es6",
     "source": "import '../color.js';\nimport '../spacing.js';\nimport '../style.js';\nimport '../typography.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<dom-module id=\"lumo-required-field\">\n  <template>\n    <style>\n      [part=\"label\"] {\n        align-self: flex-start;\n        color: var(--lumo-secondary-text-color);\n        font-weight: 500;\n        font-size: var(--lumo-font-size-s);\n        margin-left: calc(var(--lumo-border-radius-m) / 4);\n        transition: color 0.2s;\n        line-height: 1;\n        padding-bottom: 0.5em;\n        overflow: hidden;\n        white-space: nowrap;\n        text-overflow: ellipsis;\n        position: relative;\n        max-width: 100%;\n        box-sizing: border-box;\n      }\n\n      :host([has-label])::before {\n        margin-top: calc(var(--lumo-font-size-s) * 1.5);\n      }\n\n      :host([has-label]) {\n        padding-top: var(--lumo-space-m);\n      }\n\n      :host([required]) [part=\"label\"] {\n        padding-right: 1em;\n      }\n\n      [part=\"label\"]::after {\n        content: var(--lumo-required-field-indicator, \"\");\n        transition: opacity 0.2s;\n        opacity: 0;\n        color: var(--lumo-primary-text-color);\n        position: absolute;\n        right: 0;\n        width: 1em;\n        text-align: center;\n      }\n\n      :host([required]:not([has-value])) [part=\"label\"]::after {\n        opacity: 1;\n      }\n\n      :host([invalid]) [part=\"label\"]::after {\n        color: var(--lumo-error-text-color);\n      }\n\n      [part=\"error-message\"] {\n        margin-left: calc(var(--lumo-border-radius-m) / 4);\n        font-size: var(--lumo-font-size-xs);\n        line-height: var(--lumo-line-height-xs);\n        color: var(--lumo-error-text-color);\n        will-change: max-height;\n        transition: 0.4s max-height;\n        max-height: 5em;\n      }\n\n      /* Margin that doesnt reserve space when theres no error message */\n      [part=\"error-message\"]:not(:empty)::before,\n      [part=\"error-message\"]:not(:empty)::after {\n        content: \"\";\n        display: block;\n        height: 0.4em;\n      }\n\n      :host(:not([invalid])) [part=\"error-message\"] {\n        max-height: 0;\n        overflow: hidden;\n      }\n\n      /* RTL specific styles */\n\n      :host([dir=\"rtl\"]) [part=\"label\"] {\n        margin-left: 0;\n        margin-right: calc(var(--lumo-border-radius-m) / 4);\n      }\n\n      :host([required][dir=\"rtl\"]) [part=\"label\"] {\n        padding-left: 1em;\n        padding-right: 0;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"label\"]::after {\n        right: auto;\n        left: 0;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"error-message\"] {\n        margin-left: 0;\n        margin-right: calc(var(--lumo-border-radius-m) / 4);\n      }\n\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 141,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/mixins/menu-overlay.js?babel-target=es6",
     "source": "import '../spacing.js';\nimport '../style.js';\nimport './overlay.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<dom-module id=\"lumo-menu-overlay-core\">\n  <template>\n    <style>\n      :host([opening]),\n      :host([closing]) {\n        animation: 0.14s lumo-overlay-dummy-animation;\n      }\n\n      [part=\"overlay\"] {\n        will-change: opacity, transform;\n      }\n\n      :host([opening]) [part=\"overlay\"] {\n        animation: 0.1s lumo-menu-overlay-enter ease-out both;\n      }\n\n      @keyframes lumo-menu-overlay-enter {\n        0% {\n          opacity: 0;\n          transform: translateY(-4px);\n        }\n      }\n\n      :host([closing]) [part=\"overlay\"] {\n        animation: 0.1s lumo-menu-overlay-exit both;\n      }\n\n      @keyframes lumo-menu-overlay-exit {\n        100% {\n          opacity: 0;\n        }\n      }\n    </style>\n  </template>\n</dom-module><dom-module id=\"lumo-menu-overlay\">\n  <template>\n    <style include=\"lumo-overlay lumo-menu-overlay-core\">\n      /* Small viewport (bottom sheet) styles */\n      /* Use direct media queries instead of the state attributes (\\`[phone]\\` and \\`[fullscreen]\\`) provided by the elements */\n      @media (max-width: 420px), (max-height: 420px) {\n        :host {\n          top: 0 !important;\n          right: 0 !important;\n          bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;\n          left: 0 !important;\n          align-items: stretch !important;\n          justify-content: flex-end !important;\n        }\n\n        [part=\"overlay\"] {\n          max-height: 50vh;\n          width: 100vw;\n          border-radius: 0;\n          box-shadow: var(--lumo-box-shadow-xl);\n        }\n\n        /* The content part scrolls instead of the overlay part, because of the gradient fade-out */\n        [part=\"content\"] {\n          padding: 30px var(--lumo-space-m);\n          max-height: inherit;\n          box-sizing: border-box;\n          -webkit-overflow-scrolling: touch;\n          overflow: auto;\n          -webkit-mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);\n          mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);\n        }\n\n        [part=\"backdrop\"] {\n          display: block;\n        }\n\n        /* Animations */\n\n        :host([opening]) [part=\"overlay\"] {\n          animation: 0.2s lumo-mobile-menu-overlay-enter cubic-bezier(.215, .61, .355, 1) both;\n        }\n\n        :host([closing]),\n        :host([closing]) [part=\"backdrop\"] {\n          animation-delay: 0.14s;\n        }\n\n        :host([closing]) [part=\"overlay\"] {\n          animation: 0.14s 0.14s lumo-mobile-menu-overlay-exit cubic-bezier(.55, .055, .675, .19) both;\n        }\n      }\n\n      @keyframes lumo-mobile-menu-overlay-enter {\n        0% {\n          transform: translateY(150%);\n        }\n      }\n\n      @keyframes lumo-mobile-menu-overlay-exit {\n        100% {\n          transform: translateY(150%);\n        }\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);\n/* Split as a separate module because combo box can only use the \"fullscreen\" styles */\n\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\n\n;"
    },
    {
     "id": 144,
     "name": "../node_modules/@polymer/polymer/lib/elements/dom-repeat.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { TemplateInstanceBase, templatize, modelForElement } from '../utils/templatize.js'; // eslint-disable-line no-unused-vars\n\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { OptionalMutableData } from '../mixins/mutable-data.js';\nimport { matches, translate } from '../utils/path.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\n/**\n * @constructor\n * @implements {Polymer_OptionalMutableData}\n * @extends {PolymerElement}\n * @private\n */\n\nvar domRepeatBase = OptionalMutableData(PolymerElement);\n/**\n * The `<dom-repeat>` element will automatically stamp and binds one instance\n * of template content to each object in a user-provided array.\n * `dom-repeat` accepts an `items` property, and one instance of the template\n * is stamped for each item into the DOM at the location of the `dom-repeat`\n * element.  The `item` property will be set on each instance's binding\n * scope, thus templates should bind to sub-properties of `item`.\n *\n * Example:\n *\n * ```html\n * <dom-module id=\"employee-list\">\n *\n *   <template>\n *\n *     <div> Employee list: </div>\n *     <dom-repeat items=\"{{employees}}\">\n *       <template>\n *         <div>First name: <span>{{item.first}}</span></div>\n *         <div>Last name: <span>{{item.last}}</span></div>\n *       </template>\n *     </dom-repeat>\n *\n *   </template>\n *\n * </dom-module>\n * ```\n *\n * With the following custom element definition:\n *\n * ```js\n * class EmployeeList extends PolymerElement {\n *   static get is() { return 'employee-list'; }\n *   static get properties() {\n *     return {\n *       employees: {\n *         value() {\n *           return [\n *             {first: 'Bob', last: 'Smith'},\n *             {first: 'Sally', last: 'Johnson'},\n *             ...\n *           ];\n *         }\n *       }\n *     };\n *   }\n * }\n * ```\n *\n * Notifications for changes to items sub-properties will be forwarded to template\n * instances, which will update via the normal structured data notification system.\n *\n * Mutations to the `items` array itself should be made using the Array\n * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,\n * `shift`, `unshift`), and template instances will be kept in sync with the\n * data in the array.\n *\n * Events caught by event handlers within the `dom-repeat` template will be\n * decorated with a `model` property, which represents the binding scope for\n * each template instance.  The model should be used to manipulate data on the\n * instance, for example `event.model.set('item.checked', true);`.\n *\n * Alternatively, the model for a template instance for an element stamped by\n * a `dom-repeat` can be obtained using the `modelForElement` API on the\n * `dom-repeat` that stamped it, for example\n * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n * This may be useful for manipulating instance data of event targets obtained\n * by event handlers on parents of the `dom-repeat` (event delegation).\n *\n * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n * `filter` and/or `sort` property.  This may be a string that names a function on\n * the host, or a function may be assigned to the property directly.  The functions\n * should implemented following the standard `Array` filter/sort API.\n *\n * In order to re-run the filter or sort functions based on changes to sub-fields\n * of `items`, the `observe` property may be set as a space-separated list of\n * `item` sub-fields that should cause a re-filter/sort when modified.  If\n * the filter or sort function depends on properties not contained in `items`,\n * the user should observe changes to those properties and call `render` to update\n * the view based on the dependency change.\n *\n * For example, for an `dom-repeat` with a filter of the following:\n *\n * ```js\n * isEngineer(item) {\n *   return item.type == 'engineer' || item.manager.type == 'engineer';\n * }\n * ```\n *\n * Then the `observe` property should be configured as follows:\n *\n * ```html\n * <dom-repeat items=\"{{employees}}\" filter=\"isEngineer\" observe=\"type manager.type\">\n * ```\n *\n * @customElement\n * @polymer\n * @extends {domRepeatBase}\n * @appliesMixin OptionalMutableData\n * @summary Custom element for stamping instance of a template bound to\n *   items in an array.\n */\n\nexport class DomRepeat extends domRepeatBase {\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() {\n    return 'dom-repeat';\n  }\n\n  static get template() {\n    return null;\n  }\n\n  static get properties() {\n    /**\n     * Fired whenever DOM is added or removed by this template (by\n     * default, rendering occurs lazily).  To force immediate rendering, call\n     * `render`.\n     *\n     * @event dom-change\n     */\n    return {\n      /**\n       * An array containing items determining how many instances of the template\n       * to stamp and that that each template instance should bind to.\n       */\n      items: {\n        type: Array\n      },\n\n      /**\n       * The name of the variable to add to the binding scope for the array\n       * element associated with a given template instance.\n       */\n      as: {\n        type: String,\n        value: 'item'\n      },\n\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the sorted and filtered list of rendered items.\n       * Note, for the index in the `this.items` array, use the value of the\n       * `itemsIndexAs` property.\n       */\n      indexAs: {\n        type: String,\n        value: 'index'\n      },\n\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the `this.items` array. Note, for the index of\n       * this instance in the sorted and filtered list of rendered items,\n       * use the value of the `indexAs` property.\n       */\n      itemsIndexAs: {\n        type: String,\n        value: 'itemsIndex'\n      },\n\n      /**\n       * A function that should determine the sort order of the items.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.sort`.\n       * Using a sort function has no effect on the underlying `items` array.\n       */\n      sort: {\n        type: Function,\n        observer: '__sortChanged'\n      },\n\n      /**\n       * A function that can be used to filter items out of the view.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.filter`.\n       * Using a filter function has no effect on the underlying `items` array.\n       */\n      filter: {\n        type: Function,\n        observer: '__filterChanged'\n      },\n\n      /**\n       * When using a `filter` or `sort` function, the `observe` property\n       * should be set to a space-separated list of the names of item\n       * sub-fields that should trigger a re-sort or re-filter when changed.\n       * These should generally be fields of `item` that the sort or filter\n       * function depends on.\n       */\n      observe: {\n        type: String,\n        observer: '__observeChanged'\n      },\n\n      /**\n       * When using a `filter` or `sort` function, the `delay` property\n       * determines a debounce time in ms after a change to observed item\n       * properties that must pass before the filter or sort is re-run.\n       * This is useful in rate-limiting shuffling of the view when\n       * item changes may be frequent.\n       */\n      delay: Number,\n\n      /**\n       * Count of currently rendered items after `filter` (if any) has been applied.\n       * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n       * set of template instances is rendered.\n       *\n       */\n      renderedItemCount: {\n        type: Number,\n        notify: true,\n        readOnly: true\n      },\n\n      /**\n       * Defines an initial count of template instances to render after setting\n       * the `items` array, before the next paint, and puts the `dom-repeat`\n       * into \"chunking mode\".  The remaining items will be created and rendered\n       * incrementally at each animation frame therof until all instances have\n       * been rendered.\n       */\n      initialCount: {\n        type: Number,\n        observer: '__initializeChunking'\n      },\n\n      /**\n       * When `initialCount` is used, this property defines a frame rate (in\n       * fps) to target by throttling the number of instances rendered each\n       * frame to not exceed the budget for the target frame rate.  The\n       * framerate is effectively the number of `requestAnimationFrame`s that\n       * it tries to allow to actually fire in a given second. It does this\n       * by measuring the time between `rAF`s and continuously adjusting the\n       * number of items created each `rAF` to maintain the target framerate.\n       * Setting this to a higher number allows lower latency and higher\n       * throughput for event handlers and other tasks, but results in a\n       * longer time for the remaining items to complete rendering.\n       */\n      targetFramerate: {\n        type: Number,\n        value: 20\n      },\n      _targetFrameTime: {\n        type: Number,\n        computed: '__computeFrameTime(targetFramerate)'\n      }\n    };\n  }\n\n  static get observers() {\n    return ['__itemsChanged(items.*)'];\n  }\n\n  constructor() {\n    super();\n    this.__instances = [];\n    this.__limit = Infinity;\n    this.__pool = [];\n    this.__renderDebouncer = null;\n    this.__itemsIdxToInstIdx = {};\n    this.__chunkCount = null;\n    this.__lastChunkTime = null;\n    this.__sortFn = null;\n    this.__filterFn = null;\n    this.__observePaths = null;\n    /** @type {?function(new:Polymer.TemplateInstanceBase, *)} */\n\n    this.__ctor = null;\n    this.__isDetached = true;\n    this.template = null;\n  }\n  /**\n   * @override\n   * @return {void}\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__isDetached = true;\n\n    for (var i = 0; i < this.__instances.length; i++) {\n      this.__detachInstance(i);\n    }\n  }\n  /**\n   * @override\n   * @return {void}\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.style.display = 'none'; // only perform attachment if the element was previously detached.\n\n    if (this.__isDetached) {\n      this.__isDetached = false;\n      var wrappedParent = wrap(wrap(this).parentNode);\n\n      for (var i = 0; i < this.__instances.length; i++) {\n        this.__attachInstance(i, wrappedParent);\n      }\n    }\n  }\n\n  __ensureTemplatized() {\n    // Templatizing (generating the instance constructor) needs to wait\n    // until ready, since won't have its template content handed back to\n    // it until then\n    if (!this.__ctor) {\n      var template = this.template =\n      /** @type {HTMLTemplateElement} */\n      this.querySelector('template');\n\n      if (!template) {\n        // // Wait until childList changes and template should be there by then\n        var observer = new MutationObserver(() => {\n          if (this.querySelector('template')) {\n            observer.disconnect();\n\n            this.__render();\n          } else {\n            throw new Error('dom-repeat requires a <template> child');\n          }\n        });\n        observer.observe(this, {\n          childList: true\n        });\n        return false;\n      } // Template instance props that should be excluded from forwarding\n\n\n      var instanceProps = {};\n      instanceProps[this.as] = true;\n      instanceProps[this.indexAs] = true;\n      instanceProps[this.itemsIndexAs] = true;\n      this.__ctor = templatize(template, this, {\n        mutableData: this.mutableData,\n        parentModel: true,\n        instanceProps: instanceProps,\n\n        /**\n         * @this {DomRepeat}\n         * @param {string} prop Property to set\n         * @param {*} value Value to set property to\n         */\n        forwardHostProp: function (prop, value) {\n          var i$ = this.__instances;\n\n          for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {\n            inst.forwardHostProp(prop, value);\n          }\n        },\n\n        /**\n         * @this {DomRepeat}\n         * @param {Object} inst Instance to notify\n         * @param {string} prop Property to notify\n         * @param {*} value Value to notify\n         */\n        notifyInstanceProp: function (inst, prop, value) {\n          if (matches(this.as, prop)) {\n            var idx = inst[this.itemsIndexAs];\n\n            if (prop == this.as) {\n              this.items[idx] = value;\n            }\n\n            var path = translate(this.as, `${JSCompiler_renameProperty('items', this)}.${idx}`, prop);\n            this.notifyPath(path, value);\n          }\n        }\n      });\n    }\n\n    return true;\n  }\n\n  __getMethodHost() {\n    // Technically this should be the owner of the outermost template.\n    // In shadow dom, this is always getRootNode().host, but we can\n    // approximate this via cooperation with our dataHost always setting\n    // `_methodHost` as long as there were bindings (or id's) on this\n    // instance causing it to get a dataHost.\n    return this.__dataHost._methodHost || this.__dataHost;\n  }\n\n  __functionFromPropertyValue(functionOrMethodName) {\n    if (typeof functionOrMethodName === 'string') {\n      var methodName = functionOrMethodName;\n\n      var obj = this.__getMethodHost();\n\n      return function () {\n        return obj[methodName].apply(obj, arguments);\n      };\n    }\n\n    return functionOrMethodName;\n  }\n\n  __sortChanged(sort) {\n    this.__sortFn = this.__functionFromPropertyValue(sort);\n\n    if (this.items) {\n      this.__debounceRender(this.__render);\n    }\n  }\n\n  __filterChanged(filter) {\n    this.__filterFn = this.__functionFromPropertyValue(filter);\n\n    if (this.items) {\n      this.__debounceRender(this.__render);\n    }\n  }\n\n  __computeFrameTime(rate) {\n    return Math.ceil(1000 / rate);\n  }\n\n  __initializeChunking() {\n    if (this.initialCount) {\n      this.__limit = this.initialCount;\n      this.__chunkCount = this.initialCount;\n      this.__lastChunkTime = performance.now();\n    }\n  }\n\n  __tryRenderChunk() {\n    // Debounced so that multiple calls through `_render` between animation\n    // frames only queue one new rAF (e.g. array mutation & chunked render)\n    if (this.items && this.__limit < this.items.length) {\n      this.__debounceRender(this.__requestRenderChunk);\n    }\n  }\n\n  __requestRenderChunk() {\n    requestAnimationFrame(() => this.__renderChunk());\n  }\n\n  __renderChunk() {\n    // Simple auto chunkSize throttling algorithm based on feedback loop:\n    // measure actual time between frames and scale chunk count by ratio\n    // of target/actual frame time\n    var currChunkTime = performance.now();\n    var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);\n    this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n    this.__limit += this.__chunkCount;\n    this.__lastChunkTime = currChunkTime;\n\n    this.__debounceRender(this.__render);\n  }\n\n  __observeChanged() {\n    this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');\n  }\n\n  __itemsChanged(change) {\n    if (this.items && !Array.isArray(this.items)) {\n      console.warn('dom-repeat expected array for `items`, found', this.items);\n    } // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n    // path to that instance synchronously (returns false for non-item paths)\n\n\n    if (!this.__handleItemPath(change.path, change.value)) {\n      // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n      // so queue a full refresh\n      this.__initializeChunking();\n\n      this.__debounceRender(this.__render);\n    }\n  }\n\n  __handleObservedPaths(path) {\n    // Handle cases where path changes should cause a re-sort/filter\n    if (this.__sortFn || this.__filterFn) {\n      if (!path) {\n        // Always re-render if the item itself changed\n        this.__debounceRender(this.__render, this.delay);\n      } else if (this.__observePaths) {\n        // Otherwise, re-render if the path changed matches an observed path\n        var paths = this.__observePaths;\n\n        for (var i = 0; i < paths.length; i++) {\n          if (path.indexOf(paths[i]) === 0) {\n            this.__debounceRender(this.__render, this.delay);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @param {function(this:DomRepeat)} fn Function to debounce.\n   * @param {number=} delay Delay in ms to debounce by.\n   */\n\n\n  __debounceRender(fn, delay = 0) {\n    this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, delay > 0 ? timeOut.after(delay) : microTask, fn.bind(this));\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   * @return {void}\n   */\n\n\n  render() {\n    // Queue this repeater, then flush all in order\n    this.__debounceRender(this.__render);\n\n    flush();\n  }\n\n  __render() {\n    if (!this.__ensureTemplatized()) {\n      // No template found yet\n      return;\n    }\n\n    this.__applyFullRefresh(); // Reset the pool\n    // TODO(kschaaf): Reuse pool across turns and nested templates\n    // Now that objects/arrays are re-evaluated when set, we can safely\n    // reuse pooled instances across turns, however we still need to decide\n    // semantics regarding how long to hold, how many to hold, etc.\n\n\n    this.__pool.length = 0; // Set rendered item count\n\n    this._setRenderedItemCount(this.__instances.length); // Notify users\n\n\n    this.dispatchEvent(new CustomEvent('dom-change', {\n      bubbles: true,\n      composed: true\n    })); // Check to see if we need to render more items\n\n    this.__tryRenderChunk();\n  }\n\n  __applyFullRefresh() {\n    var items = this.items || [];\n    var isntIdxToItemsIdx = new Array(items.length);\n\n    for (var i = 0; i < items.length; i++) {\n      isntIdxToItemsIdx[i] = i;\n    } // Apply user filter\n\n\n    if (this.__filterFn) {\n      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) => this.__filterFn(items[i], idx, array));\n    } // Apply user sort\n\n\n    if (this.__sortFn) {\n      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));\n    } // items->inst map kept for item path forwarding\n\n\n    var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n    var instIdx = 0; // Generate instances and assign items\n\n    var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);\n\n    for (; instIdx < limit; instIdx++) {\n      var inst = this.__instances[instIdx];\n      var itemIdx = isntIdxToItemsIdx[instIdx];\n      var item = items[itemIdx];\n      itemsIdxToInstIdx[itemIdx] = instIdx;\n\n      if (inst) {\n        inst._setPendingProperty(this.as, item);\n\n        inst._setPendingProperty(this.indexAs, instIdx);\n\n        inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n\n        inst._flushProperties();\n      } else {\n        this.__insertInstance(item, instIdx, itemIdx);\n      }\n    } // Remove any extra instances from previous state\n\n\n    for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {\n      this.__detachAndRemoveInstance(_i);\n    }\n  }\n\n  __detachInstance(idx) {\n    var inst = this.__instances[idx];\n    var wrappedRoot = wrap(inst.root);\n\n    for (var i = 0; i < inst.children.length; i++) {\n      var el = inst.children[i];\n      wrappedRoot.appendChild(el);\n    }\n\n    return inst;\n  }\n\n  __attachInstance(idx, parent) {\n    var inst = this.__instances[idx]; // Note, this is pre-wrapped as an optimization\n\n    parent.insertBefore(inst.root, this);\n  }\n\n  __detachAndRemoveInstance(idx) {\n    var inst = this.__detachInstance(idx);\n\n    if (inst) {\n      this.__pool.push(inst);\n    }\n\n    this.__instances.splice(idx, 1);\n  }\n\n  __stampInstance(item, instIdx, itemIdx) {\n    var model = {};\n    model[this.as] = item;\n    model[this.indexAs] = instIdx;\n    model[this.itemsIndexAs] = itemIdx;\n    return new this.__ctor(model);\n  }\n\n  __insertInstance(item, instIdx, itemIdx) {\n    var inst = this.__pool.pop();\n\n    if (inst) {\n      // TODO(kschaaf): If the pool is shared across turns, hostProps\n      // need to be re-set to reused instances in addition to item\n      inst._setPendingProperty(this.as, item);\n\n      inst._setPendingProperty(this.indexAs, instIdx);\n\n      inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n\n      inst._flushProperties();\n    } else {\n      inst = this.__stampInstance(item, instIdx, itemIdx);\n    }\n\n    var beforeRow = this.__instances[instIdx + 1];\n    var beforeNode = beforeRow ? beforeRow.children[0] : this;\n    wrap(wrap(this).parentNode).insertBefore(inst.root, beforeNode);\n    this.__instances[instIdx] = inst;\n    return inst;\n  } // Implements extension point from Templatize mixin\n\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @param {boolean} hidden Set to true to hide the children;\n   * set to false to show them.\n   * @return {void}\n   * @protected\n   */\n\n\n  _showHideChildren(hidden) {\n    for (var i = 0; i < this.__instances.length; i++) {\n      this.__instances[i]._showHideChildren(hidden);\n    }\n  } // Called as a side effect of a host items.<key>.<path> path change,\n  // responsible for notifying item.<path> changes to inst for key\n\n\n  __handleItemPath(path, value) {\n    var itemsPath = path.slice(6); // 'items.'.length == 6\n\n    var dot = itemsPath.indexOf('.');\n    var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot); // If path was index into array...\n\n    if (itemsIdx == parseInt(itemsIdx, 10)) {\n      var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1); // If the path is observed, it will trigger a full refresh\n\n      this.__handleObservedPaths(itemSubPath); // Note, even if a rull refresh is triggered, always do the path\n      // notification because unless mutableData is used for dom-repeat\n      // and all elements in the instance subtree, a full refresh may\n      // not trigger the proper update.\n\n\n      var instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n      var inst = this.__instances[instIdx];\n\n      if (inst) {\n        var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : ''); // This is effectively `notifyPath`, but avoids some of the overhead\n        // of the public API\n\n        inst._setPendingPropertyOrPath(itemPath, value, false, true);\n\n        inst._flushProperties();\n      }\n\n      return true;\n    }\n  }\n  /**\n   * Returns the item associated with a given element stamped by\n   * this `dom-repeat`.\n   *\n   * Note, to modify sub-properties of the item,\n   * `modelForElement(el).set('item.<sub-prop>', value)`\n   * should be used.\n   *\n   * @param {!HTMLElement} el Element for which to return the item.\n   * @return {*} Item associated with the element.\n   */\n\n\n  itemForElement(el) {\n    var instance = this.modelForElement(el);\n    return instance && instance[this.as];\n  }\n  /**\n   * Returns the inst index for a given element stamped by this `dom-repeat`.\n   * If `sort` is provided, the index will reflect the sorted order (rather\n   * than the original array order).\n   *\n   * @param {!HTMLElement} el Element for which to return the index.\n   * @return {?number} Row index associated with the element (note this may\n   *   not correspond to the array index if a user `sort` is applied).\n   */\n\n\n  indexForElement(el) {\n    var instance = this.modelForElement(el);\n    return instance && instance[this.indexAs];\n  }\n  /**\n   * Returns the template \"model\" associated with a given element, which\n   * serves as the binding scope for the template instance the element is\n   * contained in. A template model\n   * should be used to manipulate data associated with this template instance.\n   *\n   * Example:\n   *\n   *   let model = modelForElement(el);\n   *   if (model.index < 10) {\n   *     model.set('item.checked', true);\n   *   }\n   *\n   * @param {!HTMLElement} el Element for which to return a template model.\n   * @return {TemplateInstanceBase} Model representing the binding scope for\n   *   the element.\n   */\n\n\n  modelForElement(el) {\n    return modelForElement(this.template, el);\n  }\n\n}\ncustomElements.define(DomRepeat.is, DomRepeat);"
    },
    {
     "id": 145,
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/mixins/overlay.js?babel-target=es6",
     "source": "import '../color.js';\nimport '../spacing.js';\nimport '../style.js';\nimport '../typography.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<dom-module id=\"lumo-overlay\">\n  <template>\n    <style>\n      :host {\n        top: var(--lumo-space-m);\n        right: var(--lumo-space-m);\n        bottom: var(--lumo-space-m);\n        left: var(--lumo-space-m);\n        /* Workaround for Edge issue (only on Surface), where an overflowing vaadin-list-box inside vaadin-select-overlay makes the overlay transparent */\n        /* stylelint-disable-next-line */\n        outline: 0px solid transparent;\n      }\n\n      [part=\"overlay\"] {\n        background-color: var(--lumo-base-color);\n        background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));\n        border-radius: var(--lumo-border-radius-m);\n        box-shadow: 0 0 0 1px var(--lumo-shade-5pct), var(--lumo-box-shadow-m);\n        color: var(--lumo-body-text-color);\n        font-family: var(--lumo-font-family);\n        font-size: var(--lumo-font-size-m);\n        font-weight: 400;\n        line-height: var(--lumo-line-height-m);\n        letter-spacing: 0;\n        text-transform: none;\n        -webkit-text-size-adjust: 100%;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n      }\n\n      [part=\"content\"] {\n        padding: var(--lumo-space-xs);\n      }\n\n      [part=\"backdrop\"] {\n        background-color: var(--lumo-shade-20pct);\n        animation: 0.2s lumo-overlay-backdrop-enter both;\n        will-change: opacity;\n      }\n\n      @keyframes lumo-overlay-backdrop-enter {\n        0% {\n          opacity: 0;\n        }\n      }\n\n      :host([closing]) [part=\"backdrop\"] {\n        animation: 0.2s lumo-overlay-backdrop-exit both;\n      }\n\n      @keyframes lumo-overlay-backdrop-exit {\n        100% {\n          opacity: 0;\n        }\n      }\n\n      @keyframes lumo-overlay-dummy-animation {\n        0% { opacity: 1; }\n        100% { opacity: 1; }\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 149,
     "name": "../node_modules/@webcomponents/shadycss/src/custom-style-interface.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 151,
     "name": "../node_modules/@polymer/polymer/lib/legacy/templatizer-behavior.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { TemplateInstanceBase, templatize, modelForElement } from '../utils/templatize.js'; // eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n *   _templatizerTemplate: HTMLTemplateElement,\n *   _parentModel: boolean,\n *   _instanceProps: Object,\n *   _forwardHostPropV2: Function,\n *   _notifyInstancePropV2: Function,\n *   ctor: TemplateInstanceBase\n * }}\n */\n\nvar TemplatizerUser; // eslint-disable-line\n\n/**\n * The `Templatizer` behavior adds methods to generate instances of\n * templates that are each managed by an anonymous `PropertyEffects`\n * instance where data-bindings in the stamped template content are bound to\n * accessors on itself.\n *\n * This behavior is provided in Polymer 2.x-3.x as a hybrid-element convenience\n * only.  For non-hybrid usage, the `Templatize` library\n * should be used instead.\n *\n * Example:\n *\n *     import {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n *     // Get a template from somewhere, e.g. light DOM\n *     let template = this.querySelector('template');\n *     // Prepare the template\n *     this.templatize(template);\n *     // Instance the template with an initial data model\n *     let instance = this.stamp({myProp: 'initial'});\n *     // Insert the instance's DOM somewhere, e.g. light DOM\n *     dom(this).appendChild(instance.root);\n *     // Changing a property on the instance will propagate to bindings\n *     // in the template\n *     instance.myProp = 'new value';\n *\n * Users of `Templatizer` may need to implement the following abstract\n * API's to determine how properties and paths from the host should be\n * forwarded into to instances:\n *\n *     _forwardHostPropV2: function(prop, value)\n *\n * Likewise, users may implement these additional abstract API's to determine\n * how instance-specific properties that change on the instance should be\n * forwarded out to the host, if necessary.\n *\n *     _notifyInstancePropV2: function(inst, prop, value)\n *\n * In order to determine which properties are instance-specific and require\n * custom notification via `_notifyInstanceProp`, define an `_instanceProps`\n * object containing keys for each instance prop, for example:\n *\n *     _instanceProps: {\n *       item: true,\n *       index: true\n *     }\n *\n * Any properties used in the template that are not defined in _instanceProp\n * will be forwarded out to the Templatize `owner` automatically.\n *\n * Users may also implement the following abstract function to show or\n * hide any DOM generated using `stamp`:\n *\n *     _showHideChildren: function(shouldHide)\n *\n * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior\n * as the implementations will need to differ from the callbacks required\n * by the 1.x Templatizer API due to changes in the `TemplateInstance` API\n * between versions 1.x and 2.x.\n *\n * @polymerBehavior\n */\n\nexport var Templatizer = {\n  /**\n   * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)\n   * for the provided template.  This method should be called once per\n   * template to prepare an element for stamping the template, followed\n   * by `stamp` to create new instances of the template.\n   *\n   * @param {!HTMLTemplateElement} template Template to prepare\n   * @param {boolean=} mutableData When `true`, the generated class will skip\n   *   strict dirty-checking for objects and arrays (always consider them to\n   *   be \"dirty\"). Defaults to false.\n   * @return {void}\n   * @this {TemplatizerUser}\n   */\n  templatize(template, mutableData) {\n    this._templatizerTemplate = template;\n    this.ctor = templatize(template, this, {\n      mutableData: Boolean(mutableData),\n      parentModel: this._parentModel,\n      instanceProps: this._instanceProps,\n      forwardHostProp: this._forwardHostPropV2,\n      notifyInstanceProp: this._notifyInstancePropV2\n    });\n  },\n\n  /**\n   * Creates an instance of the template prepared by `templatize`.  The object\n   * returned is an instance of the anonymous class generated by `templatize`\n   * whose `root` property is a document fragment containing newly cloned\n   * template content, and which has property accessors corresponding to\n   * properties referenced in template bindings.\n   *\n   * @param {Object=} model Object containing initial property values to\n   *   populate into the template bindings.\n   * @return {TemplateInstanceBase} Returns the created instance of\n   * the template prepared by `templatize`.\n   * @this {TemplatizerUser}\n   */\n  stamp(model) {\n    return new this.ctor(model);\n  },\n\n  /**\n   * Returns the template \"model\" (`TemplateInstance`) associated with\n   * a given element, which serves as the binding scope for the template\n   * instance the element is contained in.  A template model should be used\n   * to manipulate data associated with this template instance.\n   *\n   * @param {HTMLElement} el Element for which to return a template model.\n   * @return {TemplateInstanceBase} Model representing the binding scope for\n   *   the element.\n   * @this {TemplatizerUser}\n   */\n  modelForElement(el) {\n    return modelForElement(this._templatizerTemplate, el);\n  }\n\n};"
    },
    {
     "id": 152,
     "name": "../node_modules/@polymer/polymer/lib/legacy/mutable-data-behavior.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { MutableData } from '../mixins/mutable-data.js';\nvar mutablePropertyChange;\n/** @suppress {missingProperties} */\n\n(() => {\n  mutablePropertyChange = MutableData._mutablePropertyChange;\n})();\n/**\n * Legacy element behavior to skip strict dirty-checking for objects and arrays,\n * (always consider them to be \"dirty\") for use on legacy API Polymer elements.\n *\n * By default, `Polymer.PropertyEffects` performs strict dirty checking on\n * objects, which means that any deep modifications to an object or array will\n * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n * references from the root to the mutation were changed).\n *\n * Polymer also provides a proprietary data mutation and path notification API\n * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n * mutation and notification of deep changes in an object graph to all elements\n * bound to the same object graph.\n *\n * In cases where neither immutable patterns nor the data mutation API can be\n * used, applying this mixin will cause Polymer to skip dirty checking for\n * objects and arrays (always consider them to be \"dirty\").  This allows a\n * user to make a deep modification to a bound object graph, and then either\n * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n * elements that wish to be updated based on deep mutations must apply this\n * mixin or otherwise skip strict dirty checking for objects/arrays.\n * Specifically, any elements in the binding tree between the source of a\n * mutation and the consumption of it must apply this behavior or enable the\n * `Polymer.OptionalMutableDataBehavior`.\n *\n * In order to make the dirty check strategy configurable, see\n * `Polymer.OptionalMutableDataBehavior`.\n *\n * Note, the performance characteristics of propagating large object graphs\n * will be worse as opposed to using strict dirty checking with immutable\n * patterns or Polymer's path notification API.\n *\n * @polymerBehavior\n * @summary Behavior to skip strict dirty-checking for objects and\n *   arrays\n */\n\n\nexport var MutableDataBehavior = {\n  /**\n   * Overrides `Polymer.PropertyEffects` to provide option for skipping\n   * strict equality checking for Objects and Arrays.\n   *\n   * This method pulls the value to dirty check against from the `__dataTemp`\n   * cache (rather than the normal `__data` cache) for Objects.  Since the temp\n   * cache is cleared at the end of a turn, this implementation allows\n   * side-effects of deep object changes to be processed by re-setting the\n   * same object (using the temp cache as an in-turn backstop to prevent\n   * cycles due to 2-way notification).\n   *\n   * @param {string} property Property name\n   * @param {*} value New property value\n   * @param {*} old Previous property value\n   * @return {boolean} Whether the property should be considered a change\n   * @protected\n   */\n  _shouldPropertyChange(property, value, old) {\n    return mutablePropertyChange(this, property, value, old, true);\n  }\n\n};\n/**\n * Legacy element behavior to add the optional ability to skip strict\n * dirty-checking for objects and arrays (always consider them to be\n * \"dirty\") by setting a `mutable-data` attribute on an element instance.\n *\n * By default, `Polymer.PropertyEffects` performs strict dirty checking on\n * objects, which means that any deep modifications to an object or array will\n * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n * references from the root to the mutation were changed).\n *\n * Polymer also provides a proprietary data mutation and path notification API\n * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n * mutation and notification of deep changes in an object graph to all elements\n * bound to the same object graph.\n *\n * In cases where neither immutable patterns nor the data mutation API can be\n * used, applying this mixin will allow Polymer to skip dirty checking for\n * objects and arrays (always consider them to be \"dirty\").  This allows a\n * user to make a deep modification to a bound object graph, and then either\n * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n * elements that wish to be updated based on deep mutations must apply this\n * mixin or otherwise skip strict dirty checking for objects/arrays.\n * Specifically, any elements in the binding tree between the source of a\n * mutation and the consumption of it must enable this behavior or apply the\n * `Polymer.OptionalMutableDataBehavior`.\n *\n * While this behavior adds the ability to forgo Object/Array dirty checking,\n * the `mutableData` flag defaults to false and must be set on the instance.\n *\n * Note, the performance characteristics of propagating large object graphs\n * will be worse by relying on `mutableData: true` as opposed to using\n * strict dirty checking with immutable patterns or Polymer's path notification\n * API.\n *\n * @polymerBehavior\n * @summary Behavior to optionally skip strict dirty-checking for objects and\n *   arrays\n */\n\nexport var OptionalMutableDataBehavior = {\n  properties: {\n    /**\n     * Instance-level flag for configuring the dirty-checking strategy\n     * for this element.  When true, Objects and Arrays will skip dirty\n     * checking, otherwise strict equality checking will be used.\n     */\n    mutableData: Boolean\n  },\n\n  /**\n   * Overrides `Polymer.PropertyEffects` to skip strict equality checking\n   * for Objects and Arrays.\n   *\n   * Pulls the value to dirty check against from the `__dataTemp` cache\n   * (rather than the normal `__data` cache) for Objects.  Since the temp\n   * cache is cleared at the end of a turn, this implementation allows\n   * side-effects of deep object changes to be processed by re-setting the\n   * same object (using the temp cache as an in-turn backstop to prevent\n   * cycles due to 2-way notification).\n   *\n   * @param {string} property Property name\n   * @param {*} value New property value\n   * @param {*} old Previous property value\n   * @return {boolean} Whether the property should be considered a change\n   * @this {this}\n   * @protected\n   */\n  _shouldPropertyChange(property, value, old) {\n    return mutablePropertyChange(this, property, value, old, this.mutableData);\n  }\n\n};"
    },
    {
     "id": 153,
     "name": "../node_modules/@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js?babel-target=es6",
     "source": "var DEV_MODE_CODE_REGEXP = /\\/\\*\\*\\s+vaadin-dev-mode:start([\\s\\S]*)vaadin-dev-mode:end\\s+\\*\\*\\//i;\nvar FlowClients = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;\n\nfunction isMinified() {\n  function test() {\n    /** vaadin-dev-mode:start\n    return false;\n    vaadin-dev-mode:end **/\n    return true;\n  }\n\n  return uncommentAndRun(test);\n}\n\nfunction isDevelopmentMode() {\n  try {\n    if (isForcedDevelopmentMode()) {\n      return true;\n    }\n\n    if (!isLocalhost()) {\n      return false;\n    }\n\n    if (FlowClients) {\n      return !isFlowProductionMode();\n    }\n\n    return !isMinified();\n  } catch (e) {\n    // Some error in this code, assume production so no further actions will be taken\n    return false;\n  }\n}\n\nfunction isForcedDevelopmentMode() {\n  return localStorage.getItem(\"vaadin.developmentmode.force\");\n}\n\nfunction isLocalhost() {\n  return [\"localhost\", \"127.0.0.1\"].indexOf(window.location.hostname) >= 0;\n}\n\nfunction isFlowProductionMode() {\n  if (FlowClients) {\n    var productionModeApps = Object.keys(FlowClients).map(key => FlowClients[key]).filter(client => client.productionMode);\n\n    if (productionModeApps.length > 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction uncommentAndRun(callback, args) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n\n  var match = DEV_MODE_CODE_REGEXP.exec(callback.toString());\n\n  if (match) {\n    try {\n      // requires CSP: script-src 'unsafe-eval'\n      callback = new Function(match[1]);\n    } catch (e) {\n      // eat the exception\n      console.log('vaadin-development-mode-detector: uncommentAndRun() failed', e);\n    }\n  }\n\n  return callback(args);\n} // A guard against polymer-modulizer removing the window.Vaadin\n// initialization above.\n\n\nwindow['Vaadin'] = window['Vaadin'] || {};\n/**\n * Inspects the source code of the given `callback` function for\n * specially-marked _commented_ code. If such commented code is found in the\n * callback source, uncomments and runs that code instead of the callback\n * itself. Otherwise runs the callback as is.\n *\n * The optional arguments are passed into the callback / uncommented code,\n * the result is returned.\n *\n * See the `isMinified()` function source code in this file for an example.\n *\n */\n\nexport var runIfDevelopmentMode = function (callback, args) {\n  if (window.Vaadin.developmentMode) {\n    return uncommentAndRun(callback, args);\n  }\n};\n\nif (window.Vaadin.developmentMode === undefined) {\n  window.Vaadin.developmentMode = isDevelopmentMode();\n}"
    },
    {
     "id": 154,
     "name": "../node_modules/@polymer/iron-meta/iron-meta.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { Polymer } from '@polymer/polymer/lib/legacy/polymer-fn.js';\nexport class IronMeta {\n  /**\n   * @param {{\n   *   type: (string|null|undefined),\n   *   key: (string|null|undefined),\n   *   value: *,\n   * }=} options\n   */\n  constructor(options) {\n    IronMeta[' '](options);\n    /** @type {string} */\n\n    this.type = options && options.type || 'default';\n    /** @type {string|null|undefined} */\n\n    this.key = options && options.key;\n\n    if (options && 'value' in options) {\n      /** @type {*} */\n      this.value = options.value;\n    }\n  }\n  /** @return {*} */\n\n\n  get value() {\n    var type = this.type;\n    var key = this.key;\n\n    if (type && key) {\n      return IronMeta.types[type] && IronMeta.types[type][key];\n    }\n  }\n  /** @param {*} value */\n\n\n  set value(value) {\n    var type = this.type;\n    var key = this.key;\n\n    if (type && key) {\n      type = IronMeta.types[type] = IronMeta.types[type] || {};\n\n      if (value == null) {\n        delete type[key];\n      } else {\n        type[key] = value;\n      }\n    }\n  }\n  /** @return {!Array<*>} */\n\n\n  get list() {\n    var type = this.type;\n\n    if (type) {\n      var items = IronMeta.types[this.type];\n\n      if (!items) {\n        return [];\n      }\n\n      return Object.keys(items).map(function (key) {\n        return metaDatas[this.type][key];\n      }, this);\n    }\n  }\n  /**\n   * @param {string} key\n   * @return {*}\n   */\n\n\n  byKey(key) {\n    this.key = key;\n    return this.value;\n  }\n\n}\n; // This function is used to convince Closure not to remove constructor calls\n// for instances that are not held anywhere. For example, when\n// `new IronMeta({...})` is used only for the side effect of adding a value.\n\nIronMeta[' '] = function () {};\n\nIronMeta.types = {};\nvar metaDatas = IronMeta.types;\n/**\n`iron-meta` is a generic element you can use for sharing information across the\nDOM tree. It uses [monostate pattern](http://c2.com/cgi/wiki?MonostatePattern)\nsuch that any instance of iron-meta has access to the shared information. You\ncan use `iron-meta` to share whatever you want (or create an extension [like\nx-meta] for enhancements).\n\nThe `iron-meta` instances containing your actual data can be loaded in an\nimport, or constructed in any way you see fit. The only requirement is that you\ncreate them before you try to access them.\n\nExamples:\n\nIf I create an instance like this:\n\n    <iron-meta key=\"info\" value=\"foo/bar\"></iron-meta>\n\nNote that value=\"foo/bar\" is the metadata I've defined. I could define more\nattributes or use child nodes to define additional metadata.\n\nNow I can access that element (and it's metadata) from any iron-meta instance\nvia the byKey method, e.g.\n\n    meta.byKey('info');\n\nPure imperative form would be like:\n\n    document.createElement('iron-meta').byKey('info');\n\nOr, in a Polymer element, you can include a meta in your template:\n\n    <iron-meta id=\"meta\"></iron-meta>\n    ...\n    this.$.meta.byKey('info');\n\n@group Iron Elements\n@demo demo/index.html\n@element iron-meta\n*/\n\nPolymer({\n  is: 'iron-meta',\n  properties: {\n    /**\n     * The type of meta-data.  All meta-data of the same type is stored\n     * together.\n     * @type {string}\n     */\n    type: {\n      type: String,\n      value: 'default'\n    },\n\n    /**\n     * The key used to store `value` under the `type` namespace.\n     * @type {?string}\n     */\n    key: {\n      type: String\n    },\n\n    /**\n     * The meta-data to store or retrieve.\n     * @type {*}\n     */\n    value: {\n      type: String,\n      notify: true\n    },\n\n    /**\n     * If true, `value` is set to the iron-meta instance itself.\n     */\n    self: {\n      type: Boolean,\n      observer: '_selfChanged'\n    },\n    __meta: {\n      type: Boolean,\n      computed: '__computeMeta(type, key, value)'\n    }\n  },\n  hostAttributes: {\n    hidden: true\n  },\n  __computeMeta: function (type, key, value) {\n    var meta = new IronMeta({\n      type: type,\n      key: key\n    });\n\n    if (value !== undefined && value !== meta.value) {\n      meta.value = value;\n    } else if (this.value !== meta.value) {\n      this.value = meta.value;\n    }\n\n    return meta;\n  },\n\n  get list() {\n    return this.__meta && this.__meta.list;\n  },\n\n  _selfChanged: function (self) {\n    if (self) {\n      this.value = this;\n    }\n  },\n\n  /**\n   * Retrieves meta data value by key.\n   *\n   * @method byKey\n   * @param {string} key The key of the meta-data to be returned.\n   * @return {*}\n   */\n  byKey: function (key) {\n    return new IronMeta({\n      type: this.type,\n      key: key\n    }).value;\n  }\n});"
    },
    {
     "id": 159,
     "name": "../node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js?babel-target=es6",
     "source": "/**\n * @polymerMixin\n */\nexport var ThemePropertyMixin = superClass => class VaadinThemePropertyMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the subcomponents in Shadow DOM by binding\n       * the subcomponents \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Theme Attribute and Subcomponents](https://github.com/vaadin/vaadin-themable-mixin/wiki/5.-Theme-Attribute-and-Subcomponents).\n       * page for more information.\n       *\n       * @protected\n       */\n      theme: {\n        type: String,\n        readOnly: true\n      }\n    };\n  }\n  /** @protected */\n\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    super.attributeChangedCallback(name, oldValue, newValue);\n\n    if (name === 'theme') {\n      this._setTheme(newValue);\n    }\n  }\n\n};"
    },
    {
     "id": 160,
     "name": "../node_modules/@polymer/iron-media-query/iron-media-query.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { Polymer } from '@polymer/polymer/lib/legacy/polymer-fn.js';\n/**\n`iron-media-query` can be used to data bind to a CSS media query.\nThe `query` property is a bare CSS media query.\nThe `query-matches` property is a boolean representing whether the page matches\nthat media query.\n\nExample:\n\n```html\n<iron-media-query query=\"(min-width: 600px)\" query-matches=\"{{queryMatches}}\">\n</iron-media-query>\n```\n\n@group Iron Elements\n@demo demo/index.html\n@hero hero.svg\n@element iron-media-query\n*/\n\nPolymer({\n  is: 'iron-media-query',\n  properties: {\n    /**\n     * The Boolean return value of the media query.\n     */\n    queryMatches: {\n      type: Boolean,\n      value: false,\n      readOnly: true,\n      notify: true\n    },\n\n    /**\n     * The CSS media query to evaluate.\n     */\n    query: {\n      type: String,\n      observer: 'queryChanged'\n    },\n\n    /**\n     * If true, the query attribute is assumed to be a complete media query\n     * string rather than a single media feature.\n     */\n    full: {\n      type: Boolean,\n      value: false\n    },\n\n    /**\n     * @type {function(MediaQueryList)}\n     */\n    _boundMQHandler: {\n      value: function () {\n        return this.queryHandler.bind(this);\n      }\n    },\n\n    /**\n     * @type {MediaQueryList}\n     */\n    _mq: {\n      value: null\n    }\n  },\n  attached: function () {\n    this.style.display = 'none';\n    this.queryChanged();\n  },\n  detached: function () {\n    this._remove();\n  },\n  _add: function () {\n    if (this._mq) {\n      this._mq.addListener(this._boundMQHandler);\n    }\n  },\n  _remove: function () {\n    if (this._mq) {\n      this._mq.removeListener(this._boundMQHandler);\n    }\n\n    this._mq = null;\n  },\n  queryChanged: function () {\n    this._remove();\n\n    var query = this.query;\n\n    if (!query) {\n      return;\n    }\n\n    if (!this.full && query[0] !== '(') {\n      query = '(' + query + ')';\n    }\n\n    this._mq = window.matchMedia(query);\n\n    this._add();\n\n    this.queryHandler(this._mq);\n  },\n  queryHandler: function (mq) {\n    this._setQueryMatches(mq.matches);\n  }\n});"
    },
    {
     "id": 163,
     "name": "../node_modules/@vaadin/vaadin-form-layout/src/vaadin-form-layout.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { IronResizableBehavior } from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { beforeNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { mixinBehaviors } from '@polymer/polymer/lib/legacy/class.js';\n/**\n * `<vaadin-form-layout>` is a Web Component providing configurable responsive\n * layout for form elements.\n *\n * ```html\n * <vaadin-form-layout>\n *\n *   <vaadin-form-item>\n *     <label slot=\"label\">First Name</label>\n *     <input class=\"full-width\" value=\"Jane\">\n *   </vaadin-form-item>\n *\n *   <vaadin-form-item>\n *     <label slot=\"label\">Last Name</label>\n *     <input class=\"full-width\" value=\"Doe\">\n *   </vaadin-form-item>\n *\n *   <vaadin-form-item>\n *     <label slot=\"label\">Email</label>\n *     <input class=\"full-width\" value=\"jane.doe@example.com\">\n *   </vaadin-form-item>\n *\n * </vaadin-form-layout>\n * ```\n *\n * It supports any child elements as layout items.\n *\n * By default, it makes a layout of two columns if the element width is equal or\n * wider than 40em, and a single column layout otherwise.\n *\n * The number of columns and the responsive behavior are customizable with\n * the `responsiveSteps` property.\n *\n * ### Spanning Items on Multiple Columns\n *\n * You can use `colspan` attribute on the items.\n * In the example below, the first text field spans on two columns:\n *\n * ```html\n * <vaadin-form-layout>\n *\n *   <vaadin-form-item colspan=\"2\">\n *     <label slot=\"label\">Address</label>\n *     <input class=\"full-width\">\n *   </vaadin-form-item>\n *\n *   <vaadin-form-item>\n *     <label slot=\"label\">First Name</label>\n *     <input class=\"full-width\" value=\"Jane\">\n *   </vaadin-form-item>\n *\n *   <vaadin-form-item>\n *     <label slot=\"label\">Last Name</label>\n *     <input class=\"full-width\" value=\"Doe\">\n *   </vaadin-form-item>\n *\n * </vaadin-form-layout>\n * ```\n *\n * ### Explicit New Row\n *\n * Use the `<br>` line break element to wrap the items on a new row:\n *\n * ```html\n * <vaadin-form-layout>\n *\n *   <vaadin-form-item>\n *     <label slot=\"label\">Email</label>\n *     <input class=\"full-width\">\n *   </vaadin-form-item>\n *\n *   <br>\n *\n *   <vaadin-form-item>\n *     <label slot=\"label\">Confirm Email</label>\n *     <input class=\"full-width\">\n *   </vaadin-form-item>\n *\n * </vaadin-form-layout>\n * ```\n *\n * ### CSS Properties Reference\n *\n * The following custom CSS properties are available on the `<vaadin-form-layout>`\n * element:\n *\n * Custom CSS property | Description | Default\n * ---|---|---\n * `--vaadin-form-layout-column-spacing` | Length of the spacing between columns | `2em`\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nclass FormLayoutElement extends ElementMixin(ThemableMixin(mixinBehaviors([IronResizableBehavior], PolymerElement))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: block;\n        max-width: 100%;\n        animation: 1ms vaadin-form-layout-appear;\n        /* CSS API for host */\n        --vaadin-form-layout-column-spacing: 2em; /* (default) */\n        align-self: stretch;\n      }\n\n      @keyframes vaadin-form-layout-appear {\n        to {\n          opacity: 1 !important; /* stylelint-disable-line keyframe-declaration-no-important */\n        }\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      #layout {\n        display: flex;\n\n        align-items: baseline; /* default \\`stretch\\` is not appropriate */\n\n        flex-wrap: wrap; /* the items should wrap */\n      }\n\n      #layout ::slotted(*) {\n        /* Items should neither grow nor shrink. */\n        flex-grow: 0;\n        flex-shrink: 0;\n\n        /* Margins make spacing between the columns */\n        margin-left: calc(0.5 * var(--vaadin-form-layout-column-spacing));\n        margin-right: calc(0.5 * var(--vaadin-form-layout-column-spacing));\n      }\n\n      #layout ::slotted(br) {\n        display: none;\n      }\n    </style>\n    <div id=\"layout\">\n      <slot id=\"slot\"></slot>\n    </div>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-form-layout';\n  }\n\n  static get version() {\n    return '2.3.0';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * @typedef FormLayoutResponsiveStep\n       * @type {object}\n       * @property {string} minWidth - The threshold value for this step in CSS length units.\n       * @property {number} columns - Number of columns. Only natural numbers are valid.\n       * @property {string} labelsPosition - Labels position option, valid values: `\"aside\"` (default), `\"top\"`.\n       */\n\n      /**\n       * Allows specifying a responsive behavior with the number of columns\n       * and the label position depending on the layout width.\n       *\n       * Format: array of objects, each object defines one responsive step\n       * with `minWidth` CSS length, `columns` number, and optional\n       * `labelsPosition` string of `\"aside\"` or `\"top\"`. At least one item is required.\n       *\n       * #### Examples\n       *\n       * ```javascript\n       * formLayout.responsiveSteps = [{columns: 1}];\n       * // The layout is always a single column, labels aside.\n       * ```\n       *\n       * ```javascript\n       * formLayout.responsiveSteps = [\n       *   {minWidth: 0, columns: 1},\n       *   {minWidth: '40em', columns: 2}\n       * ];\n       * // Sets two responsive steps:\n       * // 1. When the layout width is < 40em, one column, labels aside.\n       * // 2. Width >= 40em, two columns, labels aside.\n       * ```\n       *\n       * ```javascript\n       * formLayout.responsiveSteps = [\n       *   {minWidth: 0, columns: 1, labelsPosition: 'top'},\n       *   {minWidth: '20em', columns: 1},\n       *   {minWidth: '40em', columns: 2}\n       * ];\n       * // Default value. Three responsive steps:\n       * // 1. Width < 20em, one column, labels on top.\n       * // 2. 20em <= width < 40em, one column, labels aside.\n       * // 3. Width >= 40em, two columns, labels aside.\n       * ```\n       *\n       * @type {!Array<!FormLayoutResponsiveStep>}\n       */\n      responsiveSteps: {\n        type: Array,\n        value: function () {\n          return [{\n            minWidth: 0,\n            columns: 1,\n            labelsPosition: 'top'\n          }, {\n            minWidth: '20em',\n            columns: 1\n          }, {\n            minWidth: '40em',\n            columns: 2\n          }];\n        },\n        observer: '_responsiveStepsChanged'\n      },\n\n      /**\n       * Current number of columns in the layout\n       * @private\n       */\n      _columnCount: {\n        type: Number\n      },\n\n      /**\n       * Indicates that labels are on top\n       * @private\n       */\n      _labelsOnTop: {\n        type: Boolean\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_invokeUpdateStyles(_columnCount, _labelsOnTop)'];\n  }\n  /** @protected */\n\n\n  ready() {\n    // Here we create and attach a style element that we use for validating\n    // CSS values in `responsiveSteps`. We cant add this to the `<template>`,\n    // because Polymer will throw it away. We need to create this before\n    // `super.ready()`, because `super.ready()` invokes property observers,\n    // and the observer for `responsiveSteps` does CSS value validation.\n    this._styleElement = document.createElement('style');\n    this.root.appendChild(this._styleElement); // Ensure there is a child text node in the style element\n\n    this._styleElement.textContent = ' ';\n\n    if (window.ShadyDOM) {\n      // With ShadyDOM, setting textContent attaches text content nodes\n      // asynchronously, but we need it right away.\n      window.ShadyDOM.flush();\n    }\n\n    super.ready();\n    this.addEventListener('iron-resize', this._selectResponsiveStep);\n    this.addEventListener('animationend', this.__onAnimationEnd);\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    beforeNextRender(this, this._selectResponsiveStep);\n    beforeNextRender(this, this.updateStyles);\n\n    this._observeChildrenColspanChange();\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    this.__mutationObserver.disconnect();\n\n    this.__childObserver.disconnect();\n  }\n  /** @private */\n\n\n  _observeChildrenColspanChange() {\n    // Observe changes in form items' `colspan` attribute and update styles\n    var mutationObserverConfig = {\n      attributes: true\n    };\n    this.__mutationObserver = new MutationObserver(mutationRecord => {\n      mutationRecord.forEach(mutation => {\n        if (mutation.type === 'attributes' && (mutation.attributeName === 'colspan' || mutation.attributeName === 'hidden')) {\n          this._invokeUpdateStyles();\n        }\n      });\n    });\n    this.__childObserver = new FlattenedNodesObserver(this, info => {\n      var addedNodes = this._getObservableNodes(info.addedNodes);\n\n      var removedNodes = this._getObservableNodes(info.removedNodes);\n\n      addedNodes.forEach(child => {\n        this.__mutationObserver.observe(child, mutationObserverConfig);\n      });\n\n      if (addedNodes.length > 0 || removedNodes.length > 0) {\n        this._invokeUpdateStyles();\n      }\n    });\n  }\n  /** @private */\n\n\n  _getObservableNodes(nodeList) {\n    var ignore = ['template', 'style', 'dom-repeat', 'dom-if'];\n    return Array.from(nodeList).filter(node => node.nodeType === Node.ELEMENT_NODE && ignore.indexOf(node.localName.toLowerCase()) === -1);\n  }\n  /** @private */\n\n\n  _naturalNumberOrOne(n) {\n    if (typeof n === 'number' && n >= 1 && n < Infinity) {\n      return Math.floor(n);\n    }\n\n    return 1;\n  }\n  /** @private */\n\n\n  _isValidCSSLength(value) {\n    // Let us choose a CSS property for validating CSS <length> values:\n    // - `border-spacing` accepts `<length> | inherit`, its the best! But\n    //   it does not disallow invalid values at all in MSIE :-(\n    // - `letter-spacing` and `word-spacing` accept\n    //   `<length> | normal | inherit`, and disallows everything else, like\n    //   `<percentage>`, `auto` and such, good enough.\n    // - `word-spacing` is used since its shorter.\n    // Disallow known keywords allowed as the `word-spacing` value\n    if (value === 'inherit' || value === 'normal') {\n      return false;\n    } // Use the value in a stylesheet and check the parsed value. Invalid\n    // input value results in empty parsed value.\n\n\n    this._styleElement.firstChild.nodeValue = `#styleElement { word-spacing: ${value}; }`;\n\n    if (!this._styleElement.sheet) {\n      // Stylesheet is not ready, probably not attached to the document yet.\n      return true;\n    } // Safari 9 sets invalid CSS rules' value to `null`\n\n\n    return ['', null].indexOf(this._styleElement.sheet.cssRules[0].style.getPropertyValue('word-spacing')) < 0;\n  }\n  /** @private */\n\n\n  _responsiveStepsChanged(responsiveSteps, oldResponsiveSteps) {\n    try {\n      if (!Array.isArray(responsiveSteps)) {\n        throw new Error('Invalid \"responsiveSteps\" type, an Array is required.');\n      }\n\n      if (responsiveSteps.length < 1) {\n        throw new Error('Invalid empty \"responsiveSteps\" array, at least one item is required.');\n      }\n\n      responsiveSteps.forEach(step => {\n        if (this._naturalNumberOrOne(step.columns) !== step.columns) {\n          throw new Error(`Invalid 'columns' value of ${step.columns}, a natural number is required.`);\n        }\n\n        if (step.minWidth !== undefined && !this._isValidCSSLength(step.minWidth)) {\n          throw new Error(`Invalid 'minWidth' value of ${step.minWidth}, a valid CSS length required.`);\n        }\n\n        if (step.labelsPosition !== undefined && ['aside', 'top'].indexOf(step.labelsPosition) === -1) {\n          throw new Error(`Invalid 'labelsPosition' value of ${step.labelsPosition}, 'aside' or 'top' string is required.`);\n        }\n      });\n    } catch (e) {\n      if (oldResponsiveSteps && oldResponsiveSteps !== responsiveSteps) {\n        console.warn(`${e.message} Using previously set 'responsiveSteps' instead.`);\n        this.responsiveSteps = oldResponsiveSteps;\n      } else {\n        console.warn(`${e.message} Using default 'responsiveSteps' instead.`);\n        this.responsiveSteps = [{\n          minWidth: 0,\n          columns: 1,\n          labelsPosition: 'top'\n        }, {\n          minWidth: '20em',\n          columns: 1\n        }, {\n          minWidth: '40em',\n          columns: 2\n        }];\n      }\n    }\n\n    this._selectResponsiveStep();\n  }\n  /** @private */\n\n\n  __onAnimationEnd(e) {\n    if (e.animationName.indexOf('vaadin-form-layout-appear') === 0) {\n      this._selectResponsiveStep();\n    }\n  }\n  /** @private */\n\n\n  _selectResponsiveStep() {\n    // Iterate through responsiveSteps and choose the step\n    var selectedStep;\n    var tmpStyleProp = 'background-position';\n    this.responsiveSteps.forEach(step => {\n      // Convert minWidth to px units for comparison\n      this.$.layout.style.setProperty(tmpStyleProp, step.minWidth);\n      var stepMinWidthPx = parseFloat(getComputedStyle(this.$.layout).getPropertyValue(tmpStyleProp)); // Compare step min-width with the host width, select the passed step\n\n      if (stepMinWidthPx <= this.offsetWidth) {\n        selectedStep = step;\n      }\n    });\n    this.$.layout.style.removeProperty(tmpStyleProp); // Sometimes converting units is not possible, e.g, when element is\n    // not connected. Then the `selectedStep` stays `undefined`.\n\n    if (selectedStep) {\n      // Apply the chosen responsive steps properties\n      this._columnCount = selectedStep.columns;\n      this._labelsOnTop = selectedStep.labelsPosition === 'top';\n    }\n\n    if (/\\b(Edge|Trident)\\//.test(navigator.userAgent)) {\n      if (this.offsetWidth !== this._lastOffsetWidth) {\n        this.updateStyles(); // force breaks sizes update in IE and Edge\n\n        this._lastOffsetWidth = this.offsetWidth;\n      }\n    }\n  }\n  /** @private */\n\n\n  _invokeUpdateStyles() {\n    this.updateStyles();\n  }\n  /**\n   * Set custom CSS property values and update the layout.\n   * @param {Object<string, string>=} properties\n   * @protected\n   */\n\n\n  updateStyles(properties) {\n    super.updateStyles(properties);\n    /*\n      The item width formula:\n           itemWidth = colspan / columnCount * 100% - columnSpacing\n       We have to subtract columnSpacing, because the column spacing space is taken\n      by item margins of 1/2 * spacing on both sides\n    */\n\n    var columnSpacing = window.ShadyCSS ? window.ShadyCSS.getComputedStyleValue(this, '--vaadin-form-layout-column-spacing') : getComputedStyle(this).getPropertyValue('--vaadin-form-layout-column-spacing');\n    var direction = getComputedStyle(this).direction;\n    var marginStartProp = 'margin-' + (direction === 'ltr' ? 'left' : 'right');\n    var marginEndProp = 'margin-' + (direction === 'ltr' ? 'right' : 'left');\n    var containerWidth = this.offsetWidth;\n\n    if (window.ShadyDOM) {\n      window.ShadyDOM.flush(); // `getComputedStyle` below needs that\n    }\n\n    var col = 0;\n    Array.from(this.children).filter(child => child.localName === 'br' || getComputedStyle(child).display !== 'none').forEach((child, index, children) => {\n      if (child.localName === 'br') {\n        // Reset column count on line break\n        col = 0;\n        return;\n      }\n\n      var colspan;\n      colspan = this._naturalNumberOrOne(parseFloat(child.getAttribute('colspan'))); // Never span further than the number of columns\n\n      colspan = Math.min(colspan, this._columnCount);\n      var childRatio = colspan / this._columnCount; // Note: using 99.9% for 100% fixes rounding errors in MS Edge\n      // (< v16), otherwise the items might wrap, resizing is wobbly.\n\n      child.style.width = `calc(${childRatio * 99.9}% - ${1 - childRatio} * ${columnSpacing})`;\n\n      if (col + colspan > this._columnCount) {\n        // Too big to fit on this row, lets wrap it\n        col = 0;\n      } // At the start edge\n\n\n      if (col === 0) {\n        child.style.setProperty(marginStartProp, '0px');\n      } else {\n        child.style.removeProperty(marginStartProp);\n      }\n\n      var nextIndex = index + 1;\n      var nextLineBreak = nextIndex < children.length && children[nextIndex].localName === 'br'; // At the end edge\n\n      if (col + colspan === this._columnCount) {\n        child.style.setProperty(marginEndProp, '0px');\n      } else if (nextLineBreak) {\n        var colspanRatio = (this._columnCount - col - colspan) / this._columnCount;\n        child.style.setProperty(marginEndProp, `calc(${colspanRatio * containerWidth}px + ${colspanRatio} * ${columnSpacing})`);\n      } else {\n        child.style.removeProperty(marginEndProp);\n      } // Move the column counter\n\n\n      col = (col + colspan) % this._columnCount;\n\n      if (child.localName === 'vaadin-form-item') {\n        if (this._labelsOnTop) {\n          child.setAttribute('label-position', 'top');\n        } else {\n          child.removeAttribute('label-position');\n        }\n      }\n    });\n  }\n\n}\n\ncustomElements.define(FormLayoutElement.is, FormLayoutElement);\nexport { FormLayoutElement };"
    },
    {
     "id": 165,
     "name": "../node_modules/@vaadin/vaadin-date-picker/src/vaadin-date-picker.js?babel-target=es6 + 6 modules"
    },
    {
     "id": 167,
     "name": "../node_modules/@vaadin/vaadin-custom-field/src/vaadin-custom-field.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 169,
     "name": "../node_modules/@vaadin/vaadin-text-field/src/vaadin-email-field.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2018 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport '@polymer/polymer/polymer-element.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nimport { TextFieldElement } from './vaadin-text-field.js';\nimport { DomModule } from '@polymer/polymer/lib/elements/dom-module.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"vaadin-email-field-template\">\n  <template>\n    <style>\n      :host([dir=\"rtl\"]) [part=\"input-field\"] {\n        direction: ltr;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"value\"]::placeholder {\n        direction: rtl;\n        text-align: left;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"input-field\"] ::slotted(input)::placeholder {\n        direction: rtl;\n        text-align: left;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"value\"]:-ms-input-placeholder,\n      :host([dir=\"rtl\"]) [part=\"input-field\"] ::slotted(input):-ms-input-placeholder {\n        direction: rtl;\n        text-align: left;\n      }\n    </style>\n  </template>\n  \n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);\nvar memoizedTemplate;\n/**\n * `<vaadin-email-field>` is a Web Component for email field control in forms.\n *\n * ```html\n * <vaadin-email-field label=\"Email\">\n * </vaadin-email-field>\n * ```\n *\n * ### Styling\n *\n * See vaadin-text-field.html for the styling documentation\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends TextFieldElement\n * @demo demo/index.html\n */\n\nclass EmailFieldElement extends TextFieldElement {\n  static get is() {\n    return 'vaadin-email-field';\n  }\n\n  static get version() {\n    return '2.8.2';\n  }\n\n  static get template() {\n    if (!memoizedTemplate) {\n      // Clone the superclass template\n      memoizedTemplate = super.template.cloneNode(true); // Retrieve this element's dom-module template\n\n      var thisTemplate = DomModule.import(this.is + '-template', 'template');\n      var styles = thisTemplate.content.querySelector('style'); // Add the and styles to the text-field template\n\n      memoizedTemplate.content.appendChild(styles);\n    }\n\n    return memoizedTemplate;\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.inputElement.type = 'email';\n    this.inputElement.autocapitalize = 'off';\n  }\n  /** @protected */\n\n\n  _createConstraintsObserver() {\n    // NOTE: pattern needs to be set before constraints observer is initialized\n    this.pattern = this.pattern || '^([a-zA-Z0-9_\\\\.\\\\-+])+@[a-zA-Z0-9-.]+\\\\.[a-zA-Z0-9-]{2,}$';\n\n    super._createConstraintsObserver();\n  }\n\n}\n\ncustomElements.define(EmailFieldElement.is, EmailFieldElement);\nexport { EmailFieldElement };"
    },
    {
     "id": 170,
     "name": "../node_modules/@vaadin/vaadin-combo-box/src/vaadin-combo-box.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport '@vaadin/vaadin-text-field/src/vaadin-text-field.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ComboBoxMixin } from './vaadin-combo-box-mixin.js';\nimport './vaadin-combo-box-dropdown-wrapper.js';\nimport { ComboBoxDataProviderMixin } from './vaadin-combo-box-data-provider-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-combo-box>` is a combo box element combining a dropdown list with an\n * input field for filtering the list of items. If you want to replace the default\n * input field with a custom implementation, you should use the\n * [`<vaadin-combo-box-light>`](#/elements/vaadin-combo-box-light) element.\n *\n * Items in the dropdown list must be provided as a list of `String` values.\n * Defining the items is done using the `items` property, which can be assigned\n * with data-binding, using an attribute or directly with the JavaScript property.\n *\n * ```html\n * <vaadin-combo-box\n *     label=\"Fruit\"\n *     items=\"[[data]]\">\n * </vaadin-combo-box>\n * ```\n *\n * ```js\n * combobox.items = ['apple', 'orange', 'banana'];\n * ```\n *\n * When the selected `value` is changed, a `value-changed` event is triggered.\n *\n * This element can be used within an `iron-form`.\n *\n * ### Item rendering\n *\n * `<vaadin-combo-box>` supports using custom renderer callback function for defining the\n * content of `<vaadin-combo-box-item>`.\n *\n * The renderer function provides `root`, `comboBox`, `model` arguments when applicable.\n * Generate DOM content by using `model` object properties if needed, append it to the `root`\n * element and control the state of the host element by accessing `comboBox`. Before generating new\n * content, users are able to check if there is already content in `root` for reusing it.\n *\n * ```html\n * <vaadin-combo-box id=\"combo-box\"></vaadin-combo-box>\n * ```\n * ```js\n * const comboBox = document.querySelector('#combo-box');\n * comboBox.items = [{'label': 'Hydrogen', 'value': 'H'}];\n * comboBox.renderer = function(root, comboBox, model) {\n *   root.innerHTML = model.index + ': ' +\n *                    model.item.label + ' ' +\n *                    '<b>' + model.item.value + '</b>';\n * };\n * ```\n *\n * Renderer is called on the opening of the combo-box and each time the related model is updated.\n * DOM generated during the renderer call can be reused\n * in the next renderer call and will be provided with the `root` argument.\n * On first call it will be empty.\n *\n * ### Item Template\n *\n * Alternatively, the content of the `<vaadin-combo-box-item>` can be populated by using\n * custom item template provided in the light DOM:\n *\n * ```html\n * <vaadin-combo-box items='[{\"label\": \"Hydrogen\", \"value\": \"H\"}]'>\n *   <template>\n *     [[index]]: [[item.label]] <b>[[item.value]</b>\n *   </template>\n * </vaadin-combo-box>\n * ```\n *\n * The following properties are available for item template bindings:\n *\n * Property name | Type | Description\n * --------------|------|------------\n * `index`| Number | Index of the item in the `items` array\n * `item` | String or Object | The item reference\n * `selected` | Boolean | True when item is selected\n * `focused` | Boolean | True when item is focused\n *\n * ### Lazy Loading with Function Data Provider\n *\n * In addition to assigning an array to the items property, you can alternatively\n * provide the `<vaadin-combo-box>` data through the\n * [`dataProvider`](#/elements/vaadin-combo-box#property-dataProvider) function property.\n * The `<vaadin-combo-box>` calls this function lazily, only when it needs more data\n * to be displayed.\n *\n * See the [`dataProvider`](#/elements/vaadin-combo-box#property-dataProvider) in\n * the API reference below for the detailed data provider arguments description,\n * and the Lazy Loading example on Basics page in the demos.\n *\n * __Note that when using function data providers, the total number of items\n * needs to be set manually. The total number of items can be returned\n * in the second argument of the data provider callback:__\n *\n * ```javascript\n * comboBox.dataProvider = function(params, callback) {\n *   var url = 'https://api.example/data' +\n *       '?page=' + params.page +        // the requested page index\n *       '&per_page=' + params.pageSize; // number of items on the page\n *   var xhr = new XMLHttpRequest();\n *   xhr.onload = function() {\n *     var response = JSON.parse(xhr.responseText);\n *     callback(\n *       response.employees, // requested page of items\n *       response.totalSize  // total number of items\n *     );\n *   };\n *   xhr.open('GET', url, true);\n *   xhr.send();\n * };\n * ```\n *\n * ### Styling\n *\n * The following custom properties are available for styling:\n *\n * Custom property | Description | Default\n * ----------------|-------------|-------------\n * `--vaadin-combo-box-overlay-max-height` | Property that determines the max height of overlay | `65vh`\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ----------------|----------------\n * `text-field` | The text field\n * `toggle-button` | The toggle button\n *\n * See [`<vaadin-overlay>` documentation](https://github.com/vaadin/vaadin-overlay/blob/master/src/vaadin-overlay.html)\n * for `<vaadin-combo-box-overlay>` parts.\n *\n * See [`<vaadin-text-field>` documentation](https://vaadin.com/components/vaadin-text-field/html-api/elements/Vaadin.TextFieldElement)\n * for the text field parts.\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `opened` | Set when the combo box dropdown is open | :host\n * `disabled` | Set to a disabled combo box | :host\n * `readonly` | Set to a read only combo box | :host\n * `has-value` | Set when the element has a value | :host\n * `invalid` | Set when the element is invalid | :host\n * `focused` | Set when the element is focused | :host\n * `focus-ring` | Set when the element is keyboard focused | :host\n * `loading` | Set when new items are expected | :host\n *\n * In addition to `<vaadin-combo-box>` itself, the following internal\n * components are themable:\n *\n * - `<vaadin-text-field>`\n * - `<vaadin-combo-box-overlay>`\n * - `<vaadin-combo-box-item>`\n *\n * Note: the `theme` attribute value set on `<vaadin-combo-box>` is\n * propagated to the internal themable components listed above.\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ControlStateMixin\n * @mixes ComboBoxDataProviderMixin\n * @mixes ComboBoxMixin\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nclass ComboBoxElement extends ElementMixin(ControlStateMixin(ThemableMixin(ComboBoxDataProviderMixin(ComboBoxMixin(PolymerElement))))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      :host([opened]) {\n        pointer-events: auto;\n      }\n\n      [part=\"text-field\"] {\n        width: 100%;\n        min-width: 0;\n      }\n    </style>\n\n    <vaadin-text-field part=\"text-field\" id=\"input\" pattern=\"[[pattern]]\" prevent-invalid-input=\"[[preventInvalidInput]]\" value=\"{{_inputElementValue}}\" autocomplete=\"off\" invalid=\"[[invalid]]\" label=\"[[label]]\" name=\"[[name]]\" placeholder=\"[[placeholder]]\" required=\"[[required]]\" disabled=\"[[disabled]]\" readonly=\"[[readonly]]\" helper-text=\"[[helperText]]\" error-message=\"[[errorMessage]]\" autocapitalize=\"none\" autofocus=\"[[autofocus]]\" on-change=\"_stopPropagation\" on-input=\"_inputValueChanged\" clear-button-visible=\"[[clearButtonVisible]]\" theme\\$=\"[[theme]]\">\n      <slot name=\"prefix\" slot=\"prefix\"></slot>\n      <slot name=\"helper\" slot=\"helper\">[[helperText]]</slot>\n\n      <div part=\"toggle-button\" id=\"toggleButton\" slot=\"suffix\" role=\"button\" aria-label=\"Toggle\"></div>\n\n    </vaadin-text-field>\n\n    <vaadin-combo-box-dropdown-wrapper id=\"overlay\" opened=\"[[opened]]\" renderer=\"[[renderer]]\" position-target=\"[[_getPositionTarget()]]\" _focused-index=\"[[_focusedIndex]]\" _item-id-path=\"[[itemIdPath]]\" _item-label-path=\"[[itemLabelPath]]\" loading=\"[[loading]]\" theme=\"[[theme]]\">\n    </vaadin-combo-box-dropdown-wrapper>\n`;\n  }\n\n  constructor() {\n    super();\n    /**\n     * @property\n     */\n\n    this.theme;\n  }\n\n  static get is() {\n    return 'vaadin-combo-box';\n  }\n\n  static get version() {\n    return '5.4.7';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * The label for this element.\n       */\n      label: {\n        type: String,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Set to true to mark the input as required.\n       * @type {boolean}\n       */\n      required: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Set to true to disable this input.\n       * @type {boolean}\n       */\n      disabled: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Set to true to prevent the user from entering invalid input.\n       * @attr {boolean} prevent-invalid-input\n       */\n      preventInvalidInput: {\n        type: Boolean\n      },\n\n      /**\n       * A pattern to validate the `input` with.\n       */\n      pattern: {\n        type: String\n      },\n\n      /**\n       * The error message to display when the input is invalid.\n       * @attr {string} error-message\n       */\n      errorMessage: {\n        type: String\n      },\n\n      /** @type {boolean} */\n      autofocus: {\n        type: Boolean\n      },\n\n      /**\n       * A placeholder string in addition to the label.\n       * @type {string}\n       */\n      placeholder: {\n        type: String,\n        value: ''\n      },\n\n      /**\n       * String used for the helper text.\n       * @attr {string} helper-text\n       */\n      helperText: {\n        type: String,\n        value: ''\n      },\n\n      /** @type {boolean} */\n      readonly: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Set to true to display the clear icon which clears the input.\n       * @attr {boolean} clear-button-visible\n       * @type {boolean}\n       */\n      clearButtonVisible: {\n        type: Boolean,\n        value: false\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_updateAriaExpanded(opened)'];\n  }\n  /**\n   * @param {string} name\n   * @param {?string} oldValue\n   * @param {?string} newValue\n   * @protected\n   */\n\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    super.attributeChangedCallback(name, oldValue, newValue); // Safari has an issue with repainting shadow root element styles when a host attribute changes.\n    // Need this workaround (toggle any inline css property on and off) until the issue gets fixed.\n\n    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n    if (isSafari && this.root) {\n      Array.prototype.forEach.call(this.root.querySelectorAll('*'), el => {\n        el.style['-webkit-backface-visibility'] = 'visible';\n        el.style['-webkit-backface-visibility'] = '';\n      });\n    }\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this._nativeInput = this.inputElement.focusElement;\n    this._toggleElement = this.$.toggleButton;\n    this._clearElement = this.inputElement.shadowRoot.querySelector('[part=\"clear-button\"]'); // Stop propagation of Esc in capturing phase so that\n    // vaadin-text-field will not handle Esc as a shortcut\n    // to clear the value.\n    // We need to set this listener for \"this.inputElement\"\n    // instead of just \"this\", otherwise keyboard navigation behaviour\n    // breaks a bit on Safari and some related tests fail.\n\n    this.inputElement.addEventListener('keydown', e => {\n      if (this._isEventKey(e, 'esc')) {\n        this._stopPropagation(e); // Trigger _onEscape method of vaadin-combo-box-mixin because\n        // bubbling phase is not reached.\n\n\n        this._onEscape(e);\n      }\n    }, true);\n\n    this._nativeInput.setAttribute('role', 'combobox');\n\n    this._nativeInput.setAttribute('aria-autocomplete', 'list');\n\n    this._updateAriaExpanded();\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    this._preventInputBlur();\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    this._restoreInputBlur();\n  }\n  /** @private */\n\n\n  _getPositionTarget() {\n    return this.$.input;\n  }\n  /** @private */\n\n\n  _updateAriaExpanded() {\n    if (this._nativeInput) {\n      this._nativeInput.setAttribute('aria-expanded', this.opened);\n\n      this._toggleElement.setAttribute('aria-expanded', this.opened);\n    }\n  }\n  /** @return {!TextFieldElement | undefined} */\n\n\n  get inputElement() {\n    return this.$.input;\n  }\n  /**\n   * Focusable element used by vaadin-control-state-mixin\n   * @return {!HTMLElement}\n   */\n\n\n  get focusElement() {\n    // inputElement might not be defined on property changes before ready.\n    return this.inputElement || this;\n  }\n\n}\n\ncustomElements.define(ComboBoxElement.is, ComboBoxElement);\nexport { ComboBoxElement };"
    },
    {
     "id": 171,
     "name": "../node_modules/@vaadin/vaadin-combo-box/src/vaadin-combo-box-mixin.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { flush } from '@polymer/polymer/lib/utils/flush.js';\nimport { templatize } from '@polymer/polymer/lib/utils/templatize.js';\nimport { IronA11yAnnouncer } from '@polymer/iron-a11y-announcer/iron-a11y-announcer.js';\nimport { IronA11yKeysBehavior } from '@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { ComboBoxPlaceholder } from './vaadin-combo-box-placeholder.js';\n/**\n * @polymerMixin\n */\n\nexport var ComboBoxMixin = subclass => class VaadinComboBoxMixinElement extends subclass {\n  static get properties() {\n    return {\n      /**\n       * True if the dropdown is open, false otherwise.\n       * @type {boolean}\n       */\n      opened: {\n        type: Boolean,\n        notify: true,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_openedChanged'\n      },\n\n      /**\n       * Set true to prevent the overlay from opening automatically.\n       * @attr {boolean} auto-open-disabled\n       */\n      autoOpenDisabled: Boolean,\n\n      /**\n       * Set to true to disable this element.\n       * @type {boolean}\n       */\n      disabled: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * When present, it specifies that the element field is read-only.\n       * @type {boolean}\n       */\n      readonly: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Custom function for rendering the content of every item.\n       * Receives three arguments:\n       *\n       * - `root` The `<vaadin-combo-box-item>` internal container DOM element.\n       * - `comboBox` The reference to the `<vaadin-combo-box>` element.\n       * - `model` The object with the properties related with the rendered\n       *   item, contains:\n       *   - `model.index` The index of the rendered item.\n       *   - `model.item` The item.\n       * @type {ComboBoxRenderer | undefined}\n       */\n      renderer: Function,\n\n      /**\n       * A full set of items to filter the visible options from.\n       * The items can be of either `String` or `Object` type.\n       * @type {!Array<!ComboBoxItem | string> | undefined}\n       */\n      items: {\n        type: Array,\n        observer: '_itemsChanged'\n      },\n\n      /**\n       * If `true`, the user can input a value that is not present in the items list.\n       * `value` property will be set to the input value in this case.\n       * Also, when `value` is set programmatically, the input value will be set\n       * to reflect that value.\n       * @attr {boolean} allow-custom-value\n       * @type {boolean}\n       */\n      allowCustomValue: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * A subset of items, filtered based on the user input. Filtered items\n       * can be assigned directly to omit the internal filtering functionality.\n       * The items can be of either `String` or `Object` type.\n       * @type {!Array<!ComboBoxItem | string> | undefined}\n       */\n      filteredItems: {\n        type: Array\n      },\n\n      /**\n       * The `String` value for the selected item of the combo box. Provides\n       * the value for `iron-form`.\n       *\n       * When theres no item selected, the value is an empty string.\n       *\n       * Use `selectedItem` property to get the raw selected item from\n       * the `items` array.\n       * @type {string}\n       */\n      value: {\n        type: String,\n        observer: '_valueChanged',\n        notify: true,\n        value: ''\n      },\n\n      /**\n       * Used to detect user value changes and fire `change` events.\n       * @private\n       */\n      _lastCommittedValue: String,\n\n      /**\n       * When set to `true`, \"loading\" attribute is added to host and the overlay element.\n       * @type {boolean}\n       */\n      loading: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * @type {number}\n       * @protected\n       */\n      _focusedIndex: {\n        type: Number,\n        value: -1\n      },\n\n      /**\n       * Filtering string the user has typed into the input field.\n       * @type {string}\n       */\n      filter: {\n        type: String,\n        value: '',\n        notify: true\n      },\n\n      /**\n       * The selected item from the `items` array.\n       * @type {ComboBoxItem | string | undefined}\n       */\n      selectedItem: {\n        type: Object,\n        notify: true\n      },\n\n      /**\n       * Path for label of the item. If `items` is an array of objects, the\n       * `itemLabelPath` is used to fetch the displayed string label for each\n       * item.\n       *\n       * The item label is also used for matching items when processing user\n       * input, i.e., for filtering and selecting items.\n       *\n       * When using item templates, the property is still needed because it is used\n       * for filtering, and for displaying the selected item value in the input box.\n       * @attr {string} item-label-path\n       * @type {string}\n       */\n      itemLabelPath: {\n        type: String,\n        value: 'label',\n        observer: '_itemLabelPathChanged'\n      },\n\n      /**\n       * Path for the value of the item. If `items` is an array of objects, the\n       * `itemValuePath:` is used to fetch the string value for the selected\n       * item.\n       *\n       * The item value is used in the `value` property of the combo box,\n       * to provide the form value.\n       * @attr {string} item-value-path\n       * @type {string}\n       */\n      itemValuePath: {\n        type: String,\n        value: 'value'\n      },\n\n      /**\n       * Path for the id of the item. If `items` is an array of objects,\n       * the `itemIdPath` is used to compare and identify the same item\n       * in `selectedItem` and `filteredItems` (items given by the\n       * `dataProvider` callback).\n       * @attr {string} item-id-path\n       */\n      itemIdPath: String,\n\n      /**\n       * The name of this element.\n       */\n      name: {\n        type: String\n      },\n\n      /**\n       * Set to true if the value is invalid.\n       * @type {boolean}\n       */\n      invalid: {\n        type: Boolean,\n        reflectToAttribute: true,\n        notify: true,\n        value: false\n      },\n\n      /**\n       * @type {!HTMLElement | undefined}\n       * @protected\n       */\n      _toggleElement: Object,\n\n      /**\n       * @type {!HTMLElement | undefined}\n       * @protected\n       */\n      _clearElement: Object,\n\n      /** @protected */\n      _inputElementValue: String,\n\n      /** @private */\n      _closeOnBlurIsPrevented: Boolean,\n\n      /** @private */\n      _previousDocumentPointerEvents: String,\n\n      /** @private */\n      _itemTemplate: Object\n    };\n  }\n\n  static get observers() {\n    return ['_filterChanged(filter, itemValuePath, itemLabelPath)', '_itemsOrPathsChanged(items.*, itemValuePath, itemLabelPath)', '_filteredItemsChanged(filteredItems.*, itemValuePath, itemLabelPath)', '_templateOrRendererChanged(_itemTemplate, renderer)', '_loadingChanged(loading)', '_selectedItemChanged(selectedItem, itemLabelPath)', '_toggleElementChanged(_toggleElement)'];\n  }\n\n  constructor() {\n    super();\n    this._boundOnFocusout = this._onFocusout.bind(this);\n    this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this);\n    this._boundClose = this.close.bind(this);\n    this._boundOnOpened = this._onOpened.bind(this);\n    this._boundOnKeyDown = this._onKeyDown.bind(this);\n    this._boundOnClick = this._onClick.bind(this);\n    this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this);\n    this._boundOnTouchend = this._onTouchend.bind(this);\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.addEventListener('focusout', this._boundOnFocusout);\n    this._lastCommittedValue = this.value;\n    IronA11yAnnouncer.requestAvailability(); // 2.0 does not support 'overlay.selection-changed' syntax in listeners\n\n    this.$.overlay.addEventListener('selection-changed', this._boundOverlaySelectedItemChanged);\n    this.addEventListener('vaadin-combo-box-dropdown-closed', this._boundClose);\n    this.addEventListener('vaadin-combo-box-dropdown-opened', this._boundOnOpened);\n    this.addEventListener('keydown', this._boundOnKeyDown);\n    this.addEventListener('click', this._boundOnClick);\n    this.$.overlay.addEventListener('vaadin-overlay-touch-action', this._boundOnOverlayTouchAction);\n    this.addEventListener('touchend', this._boundOnTouchend);\n    this._observer = new FlattenedNodesObserver(this, info => {\n      this._setTemplateFromNodes(info.addedNodes);\n    });\n\n    var bringToFrontListener = e => {\n      var overlay = this.$.overlay;\n      var dropdown = overlay && overlay.$.dropdown; // Check dropdown.$ because overlay is lazily instantiated\n\n      if (dropdown && dropdown.$ && this.$.overlay.$.dropdown.$.overlay.bringToFront) {\n        requestAnimationFrame(() => {\n          dropdown.$.overlay.bringToFront();\n        });\n      }\n    };\n\n    this.addEventListener('mousedown', bringToFrontListener);\n    this.addEventListener('touchstart', bringToFrontListener);\n  }\n  /**\n   * Manually invoke existing renderer.\n   */\n\n\n  render() {\n    if (this.$.overlay._selector) {\n      this.$.overlay._selector.querySelectorAll('vaadin-combo-box-item').forEach(item => item._render());\n    }\n  }\n  /** @private */\n\n\n  _setTemplateFromNodes(nodes) {\n    this._itemTemplate = nodes.filter(node => node.localName && node.localName === 'template')[0] || this._itemTemplate;\n  }\n  /** @private */\n\n\n  _removeNewRendererOrTemplate(template, oldTemplate, renderer, oldRenderer) {\n    if (template !== oldTemplate) {\n      this._itemTemplate = undefined;\n    } else if (renderer !== oldRenderer) {\n      this.renderer = undefined;\n    }\n  }\n  /** @private */\n\n\n  _templateOrRendererChanged(template, renderer) {\n    if (template && renderer) {\n      this._removeNewRendererOrTemplate(template, this._oldTemplate, renderer, this._oldRenderer);\n\n      throw new Error('You should only use either a renderer or a template for combo box items');\n    }\n\n    this._oldTemplate = template;\n    this._oldRenderer = renderer;\n  }\n  /**\n   * Opens the dropdown list.\n   */\n\n\n  open() {\n    // Prevent _open() being called when input is disabled or read-only\n    if (!this.disabled && !this.readonly) {\n      this.opened = true;\n    }\n  }\n  /**\n   * Closes the dropdown list.\n   */\n\n\n  close() {\n    this.opened = false;\n  }\n  /** @private */\n\n\n  _openedChanged(value, old) {\n    // Prevent _close() being called when opened is set to its default value (false).\n    if (old === undefined) {\n      return;\n    }\n\n    if (this.opened) {\n      this._openedWithFocusRing = this.hasAttribute('focus-ring') || this.focusElement && this.focusElement.hasAttribute('focus-ring'); // For touch devices, we don't want to popup virtual keyboard unless input is explicitly focused by the user.\n\n      if (!this.hasAttribute('focused') && !this.$.overlay.touchDevice) {\n        this.focus();\n      }\n    } else {\n      this._onClosed();\n\n      if (this._openedWithFocusRing && this.hasAttribute('focused')) {\n        this.focusElement.setAttribute('focus-ring', '');\n      }\n    }\n  }\n  /** @private */\n\n\n  _onOverlayTouchAction(event) {\n    // On touch devices, blur the input on touch start inside the overlay, in order to hide\n    // the virtual keyboard. But don't close the overlay on this blur.\n    this._closeOnBlurIsPrevented = true;\n    this.inputElement.blur();\n    this._closeOnBlurIsPrevented = false;\n  }\n  /** @private */\n\n\n  _onClick(e) {\n    this._closeOnBlurIsPrevented = true;\n    var path = e.composedPath();\n    var isClearElement = path.indexOf(this._clearElement) !== -1 || path[0].getAttribute('part') === 'clear-button';\n\n    if (isClearElement) {\n      this._clear();\n\n      this.focus();\n    } else if (path.indexOf(this.inputElement) !== -1) {\n      if (path.indexOf(this._toggleElement) > -1 && this.opened) {\n        this.close();\n      } else if (path.indexOf(this._toggleElement) > -1 || !this.autoOpenDisabled) {\n        this.open();\n      }\n    }\n\n    this._closeOnBlurIsPrevented = false;\n  }\n  /**\n   * Keyboard navigation\n   * @private\n   */\n\n\n  _onKeyDown(e) {\n    if (this._isEventKey(e, 'down')) {\n      this._closeOnBlurIsPrevented = true;\n\n      this._onArrowDown();\n\n      this._closeOnBlurIsPrevented = false; // prevent caret from moving\n\n      e.preventDefault();\n    } else if (this._isEventKey(e, 'up')) {\n      this._closeOnBlurIsPrevented = true;\n\n      this._onArrowUp();\n\n      this._closeOnBlurIsPrevented = false; // prevent caret from moving\n\n      e.preventDefault();\n    } else if (this._isEventKey(e, 'enter')) {\n      this._onEnter(e);\n    } else if (this._isEventKey(e, 'esc')) {\n      this._onEscape(e);\n    }\n  }\n  /**\n   * @param {!KeyboardEvent} event\n   * @param {string} key\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _isEventKey(event, key) {\n    return IronA11yKeysBehavior.keyboardEventMatchesKeys(event, key);\n  }\n  /** @private */\n\n\n  _getItemLabel(item) {\n    return this.$.overlay.getItemLabel(item);\n  }\n  /** @private */\n\n\n  _getItemValue(item) {\n    var value = item && this.itemValuePath ? this.get(this.itemValuePath, item) : undefined;\n\n    if (value === undefined) {\n      value = item ? item.toString() : '';\n    }\n\n    return value;\n  }\n  /** @private */\n\n\n  _onArrowDown() {\n    if (this.opened) {\n      if (this.$.overlay._items) {\n        this._focusedIndex = Math.min(this.$.overlay._items.length - 1, this._focusedIndex + 1);\n\n        this._prefillFocusedItemLabel();\n      }\n    } else {\n      this.open();\n    }\n  }\n  /** @private */\n\n\n  _onArrowUp() {\n    if (this.opened) {\n      if (this._focusedIndex > -1) {\n        this._focusedIndex = Math.max(0, this._focusedIndex - 1);\n      } else {\n        if (this.$.overlay._items) {\n          this._focusedIndex = this.$.overlay._items.length - 1;\n        }\n      }\n\n      this._prefillFocusedItemLabel();\n    } else {\n      this.open();\n    }\n  }\n  /** @private */\n\n\n  _prefillFocusedItemLabel() {\n    if (this._focusedIndex > -1) {\n      // Reset the input value asyncronously to prevent partial value changes\n      // announce. Makes OSX VoiceOver to announce the complete value instead.\n      this._inputElementValue = ''; // 1ms delay needed for OSX VoiceOver to realise input value was reset\n\n      setTimeout(() => {\n        this._inputElementValue = this._getItemLabel(this.$.overlay._focusedItem);\n\n        this._markAllSelectionRange();\n      }, 1);\n    }\n  }\n  /** @private */\n\n\n  _setSelectionRange(start, end) {\n    // vaadin-text-field does not implement setSelectionRange, hence we need the native input\n    var input = this._nativeInput || this.inputElement; // Setting selection range focuses and/or moves the caret in some browsers,\n    // and there's no need to modify the selection range if the input isn't focused anyway.\n    // This affects Safari. When the overlay is open, and then hiting tab, browser should focus\n    // the next focusable element instead of the combo-box itself.\n    // Checking the focused property here is enough instead of checking the activeElement.\n\n    if (this.hasAttribute('focused') && input && input.setSelectionRange) {\n      try {\n        input.setSelectionRange(start, end);\n      } catch (ignore) {// IE11 randomly fails when running tests in Sauce.\n      }\n    }\n  }\n  /** @private */\n\n\n  _markAllSelectionRange() {\n    if (this._inputElementValue !== undefined) {\n      this._setSelectionRange(0, this._inputElementValue.length);\n    }\n  }\n  /** @private */\n\n\n  _clearSelectionRange() {\n    if (this._inputElementValue !== undefined) {\n      var pos = this._inputElementValue ? this._inputElementValue.length : 0;\n\n      this._setSelectionRange(pos, pos);\n    }\n  }\n  /** @private */\n\n\n  _closeOrCommit() {\n    if (!this.opened && !this.loading) {\n      this._commitValue();\n    } else {\n      this.close();\n    }\n  }\n  /** @private */\n\n\n  _onEnter(e) {\n    // should close on enter when custom values are allowed, input field is cleared, or when an existing\n    // item is focused with keyboard. If auto open is disabled, under the same conditions, commit value.\n    if ((this.opened || this.autoOpenDisabled) && (this.allowCustomValue || this._inputElementValue === '' || this._focusedIndex > -1)) {\n      this._closeOrCommit(); // Do not submit the surrounding form.\n\n\n      e.preventDefault(); // Do not trigger global listeners\n\n      e.stopPropagation();\n    }\n  }\n  /**\n   * @param {!KeyboardEvent} e\n   * @protected\n   */\n\n\n  _onEscape(e) {\n    if (this.autoOpenDisabled) {\n      this._focusedIndex = -1;\n      this.cancel();\n    } else if (this.opened) {\n      this._stopPropagation(e);\n\n      if (this._focusedIndex > -1) {\n        this._focusedIndex = -1;\n\n        this._revertInputValue();\n      } else {\n        this.cancel();\n      }\n    }\n  }\n  /** @private */\n\n\n  _toggleElementChanged(toggleElement) {\n    if (toggleElement) {\n      // Don't blur the input on toggle mousedown\n      toggleElement.addEventListener('mousedown', e => e.preventDefault()); // Unfocus previously focused element if focus is not inside combo box (on touch devices)\n\n      toggleElement.addEventListener('click', e => {\n        if (this.$.overlay.touchDevice && !this.hasAttribute('focused')) {\n          document.activeElement.blur();\n        }\n      });\n    }\n  }\n  /**\n   * Clears the current value.\n   * @protected\n   */\n\n\n  _clear() {\n    this.selectedItem = null;\n\n    if (this.allowCustomValue) {\n      this.value = '';\n    }\n\n    this._detectAndDispatchChange();\n  }\n  /**\n   * Reverts back to original value.\n   */\n\n\n  cancel() {\n    this._revertInputValueToValue(); // In the next _detectAndDispatchChange() call, the change detection should not pass\n\n\n    this._lastCommittedValue = this.value;\n\n    this._closeOrCommit();\n  }\n  /** @private */\n\n\n  _onOpened() {\n    // Pre P2 iron-list used a debouncer to render. Now that we synchronously render items,\n    // we need to flush the DOM to make sure it doesn't get flushed in the middle of _render call\n    // because that will cause problems to say the least.\n    flush(); // With iron-list v1.3.9, calling `notifyResize()` no longer renders\n    // the items synchronously. It is required to have the items rendered\n    // before we update the overlay and the list positions and sizes.\n\n    this.$.overlay.ensureItemsRendered();\n\n    this.$.overlay._selector.toggleScrollListener(true); // Ensure metrics are up-to-date\n\n\n    this.$.overlay.updateViewportBoundaries(); // Force iron-list to create reusable nodes. Otherwise it will only start\n    // doing that in scroll listener, which is especially slow in Edge.\n\n    this.$.overlay._selector._increasePoolIfNeeded();\n\n    setTimeout(() => this._resizeDropdown(), 1); // Defer scroll position adjustment to prevent freeze in Edge\n\n    window.requestAnimationFrame(() => this.$.overlay.adjustScrollPosition()); // _detectAndDispatchChange() should not consider value changes done before opening\n\n    this._lastCommittedValue = this.value;\n  }\n  /** @private */\n\n\n  _onClosed() {\n    // Happens when the overlay is closed by clicking outside\n    if (this.opened) {\n      this.close();\n    }\n\n    if (!this.loading || this.allowCustomValue) {\n      this._commitValue();\n    }\n  }\n  /** @private */\n\n\n  _commitValue() {\n    if (this.$.overlay._items && this._focusedIndex > -1) {\n      var focusedItem = this.$.overlay._items[this._focusedIndex];\n\n      if (this.selectedItem !== focusedItem) {\n        this.selectedItem = focusedItem;\n      } // make sure input field is updated in case value doesn't change (i.e. FOO -> foo)\n\n\n      this._inputElementValue = this._getItemLabel(this.selectedItem);\n    } else if (this._inputElementValue === '' || this._inputElementValue === undefined) {\n      this.selectedItem = null;\n\n      if (this.allowCustomValue) {\n        this.value = '';\n      }\n    } else {\n      var itemsMatchedByLabel = this.filteredItems && this.filteredItems.filter(item => this._getItemLabel(item) === this._inputElementValue) || [];\n\n      if (this.allowCustomValue // to prevent a repetitive input value being saved after pressing ESC and Tab.\n      && !itemsMatchedByLabel.length) {\n        var e = new CustomEvent('custom-value-set', {\n          detail: this._inputElementValue,\n          composed: true,\n          cancelable: true,\n          bubbles: true\n        });\n        this.dispatchEvent(e);\n\n        if (!e.defaultPrevented) {\n          var customValue = this._inputElementValue;\n\n          this._selectItemForValue(customValue);\n\n          this.value = customValue;\n        }\n      } else if (!this.allowCustomValue && !this.opened && itemsMatchedByLabel.length == 1) {\n        this.value = this._getItemValue(itemsMatchedByLabel[0]);\n      } else {\n        this._inputElementValue = this.selectedItem ? this._getItemLabel(this.selectedItem) : this.value || '';\n      }\n    }\n\n    this._detectAndDispatchChange();\n\n    this._clearSelectionRange();\n\n    if (!this.dataProvider) {\n      this.filter = '';\n    }\n  }\n  /**\n   * @return {string}\n   * @protected\n   */\n\n\n  get _propertyForValue() {\n    return 'value';\n  }\n  /**\n   * Filtering and items handling\n   * @param {!Event} e\n   * @protected\n   */\n\n\n  _inputValueChanged(e) {\n    // Handle only input events from our inputElement.\n    if (e.composedPath().indexOf(this.inputElement) !== -1) {\n      this._inputElementValue = this.inputElement[this._propertyForValue];\n\n      this._filterFromInput(e);\n    }\n  }\n  /** @private */\n\n\n  _filterFromInput(e) {\n    if (!this.opened && !e.__fromClearButton && !this.autoOpenDisabled) {\n      this.open();\n    }\n\n    if (this.filter === this._inputElementValue) {\n      // Filter and input value might get out of sync, while keyboard navigating for example.\n      // Afterwards, input value might be changed to the same value as used in filtering.\n      // In situation like these, we need to make sure all the filter changes handlers are run.\n      this._filterChanged(this.filter, this.itemValuePath, this.itemLabelPath);\n    } else {\n      this.filter = this._inputElementValue;\n    }\n  }\n  /** @private */\n\n\n  _itemLabelPathChanged(itemLabelPath, oldItemLabelPath) {\n    if (typeof itemLabelPath !== 'string') {\n      console.error('You should set itemLabelPath to a valid string');\n    }\n  }\n  /** @private */\n\n\n  _filterChanged(filter, itemValuePath, itemLabelPath) {\n    if (filter === undefined) {\n      return;\n    } // Notify the dropdown about filter changing, so to let it skip the\n    // scrolling restore\n\n\n    this.$.overlay.filterChanged = true;\n\n    if (this.items) {\n      this.filteredItems = this._filterItems(this.items, filter);\n    } else {\n      // With certain use cases (e. g., external filtering), `items` are\n      // undefined. Filtering is unnecessary per se, but the filteredItems\n      // observer should still be invoked to update focused item.\n      this._filteredItemsChanged({\n        path: 'filteredItems',\n        value: this.filteredItems\n      }, itemValuePath, itemLabelPath);\n    }\n  }\n  /** @private */\n\n\n  _loadingChanged(loading) {\n    if (loading) {\n      this._focusedIndex = -1;\n    }\n  }\n  /** @protected */\n\n\n  _revertInputValue() {\n    if (this.filter !== '') {\n      this._inputElementValue = this.filter;\n    } else {\n      this._revertInputValueToValue();\n    }\n\n    this._clearSelectionRange();\n  }\n  /** @private */\n\n\n  _revertInputValueToValue() {\n    if (this.allowCustomValue && !this.selectedItem) {\n      this._inputElementValue = this.value;\n    } else {\n      this._inputElementValue = this._getItemLabel(this.selectedItem);\n    }\n  }\n  /** @private */\n\n\n  _resizeDropdown() {\n    this.$.overlay.$.dropdown.notifyResize();\n  }\n  /** @private */\n\n\n  _updateHasValue(hasValue) {\n    if (hasValue) {\n      this.setAttribute('has-value', '');\n    } else {\n      this.removeAttribute('has-value');\n    }\n  }\n  /** @private */\n\n\n  _selectedItemChanged(selectedItem, itemLabelPath) {\n    if (selectedItem === null || selectedItem === undefined) {\n      if (this.filteredItems) {\n        if (!this.allowCustomValue) {\n          this.value = '';\n        }\n\n        this._updateHasValue(this.value !== '');\n\n        this._inputElementValue = this.value;\n      }\n    } else {\n      var value = this._getItemValue(selectedItem);\n\n      if (this.value !== value) {\n        this.value = value;\n\n        if (this.value !== value) {\n          // The value was changed to something else in value-changed listener,\n          // so prevent from resetting it to the previous value.\n          return;\n        }\n      }\n\n      this._updateHasValue(true);\n\n      this._inputElementValue = this._getItemLabel(selectedItem); // Could not be defined in 1.x because ready is called after all prop-setters\n\n      if (this.inputElement) {\n        this.inputElement[this._propertyForValue] = this._inputElementValue;\n      }\n    }\n\n    this.$.overlay._selectedItem = selectedItem;\n\n    if (this.filteredItems && this.$.overlay._items) {\n      this._focusedIndex = this.filteredItems.indexOf(selectedItem);\n    }\n  }\n  /** @private */\n\n\n  _valueChanged(value, oldVal) {\n    if (value === '' && oldVal === undefined) {\n      // initializing, no need to do anything (#554)\n      return;\n    }\n\n    if (this._isValidValue(value)) {\n      var item;\n\n      if (this._getItemValue(this.selectedItem) !== value) {\n        this._selectItemForValue(value);\n      } else {\n        item = this.selectedItem;\n      }\n\n      if (!item && this.allowCustomValue) {\n        this._inputElementValue = value;\n      }\n\n      this._updateHasValue(this.value !== '');\n    } else {\n      this.selectedItem = null;\n    } // In the next _detectAndDispatchChange() call, the change detection should pass\n\n\n    this._lastCommittedValue = undefined;\n  }\n  /** @private */\n\n\n  _detectAndDispatchChange() {\n    if (this.value !== this._lastCommittedValue) {\n      this.dispatchEvent(new CustomEvent('change', {\n        bubbles: true\n      }));\n      this._lastCommittedValue = this.value;\n    }\n  }\n  /** @private */\n\n\n  _itemsChanged(items, oldItems) {\n    this._ensureItemsOrDataProvider(() => {\n      this.items = oldItems;\n    });\n  }\n  /** @private */\n\n\n  _itemsOrPathsChanged(e, itemValuePath, itemLabelPath) {\n    if (e.path === 'items' || e.path === 'items.splices') {\n      if (this.items) {\n        this.filteredItems = this.items.slice(0);\n      } else if (this.__previousItems) {\n        // Only clear filteredItems if the component had items previously but got cleared\n        this.filteredItems = null;\n      }\n\n      var valueIndex = this._indexOfValue(this.value, this.items);\n\n      this._focusedIndex = valueIndex;\n      var item = valueIndex > -1 && this.items[valueIndex];\n\n      if (item) {\n        this.selectedItem = item;\n      }\n    }\n\n    this.__previousItems = e.value;\n  }\n  /** @private */\n\n\n  _filteredItemsChanged(e, itemValuePath, itemLabelPath) {\n    if (e.path === 'filteredItems' || e.path === 'filteredItems.splices') {\n      this._setOverlayItems(this.filteredItems);\n\n      this._focusedIndex = this.opened || this.autoOpenDisabled ? this.$.overlay.indexOfLabel(this.filter) : this._indexOfValue(this.value, this.filteredItems);\n\n      if (this.opened) {\n        this._repositionOverlay();\n      }\n    }\n  }\n  /** @private */\n\n\n  _filterItems(arr, filter) {\n    if (!arr) {\n      return arr;\n    }\n\n    var filteredItems = arr.filter(item => {\n      filter = filter ? filter.toString().toLowerCase() : ''; // Check if item contains input value.\n\n      return this._getItemLabel(item).toString().toLowerCase().indexOf(filter) > -1;\n    });\n    return filteredItems;\n  }\n  /** @private */\n\n\n  _selectItemForValue(value) {\n    var valueIndex = this._indexOfValue(value, this.filteredItems);\n\n    var previouslySelectedItem = this.selectedItem;\n    this.selectedItem = valueIndex >= 0 ? this.filteredItems[valueIndex] : this.dataProvider && this.selectedItem === undefined ? undefined : null;\n\n    if (this.selectedItem === null && previouslySelectedItem === null) {\n      this._selectedItemChanged(this.selectedItem);\n    }\n  }\n  /** @private */\n\n\n  _setOverlayItems(items) {\n    this.$.overlay.set('_items', items);\n  }\n  /** @private */\n\n\n  _repositionOverlay() {\n    // async needed to reposition correctly after filtering\n    // (especially when aligned on top of input)\n    this.__repositionOverlayDebouncer = Debouncer.debounce(this.__repositionOverlayDebouncer, // Long debounce: sizing updates invoke multiple styling rounds,\n    // which is very slow in Edge\n    timeOut.after(500), () => {\n      var selector = this.$.overlay._selector;\n\n      if (!selector._isClientFull()) {\n        // Due to the mismatch of the Y position of the item rendered\n        // at the top of the scrolling list with some specific scroll\n        // position values (2324, 3486, 6972, 60972, 95757 etc.)\n        // iron-list loops the increasing of the pool and adds\n        // too many items to the DOM.\n        // Adjusting scroll position to equal the current scrollTop value\n        // to avoid looping.\n        selector._resetScrollPosition(selector._physicalTop);\n      }\n\n      this._resizeDropdown();\n\n      this.$.overlay.updateViewportBoundaries();\n      this.$.overlay.ensureItemsRendered();\n      selector.notifyResize();\n      flush();\n    });\n  }\n  /** @private */\n\n\n  _indexOfValue(value, items) {\n    if (items && this._isValidValue(value)) {\n      for (var i = 0; i < items.length; i++) {\n        if (this._getItemValue(items[i]) === value) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Checks if the value is supported as an item value in this control.\n   * @private\n   */\n\n\n  _isValidValue(value) {\n    return value !== undefined && value !== null;\n  }\n  /** @private */\n\n\n  _overlaySelectedItemChanged(e) {\n    // stop this private event from leaking outside.\n    e.stopPropagation();\n\n    if (e.detail.item instanceof ComboBoxPlaceholder) {\n      // Placeholder items should not be selectable.\n      return;\n    }\n\n    if (this.opened) {\n      this._focusedIndex = this.filteredItems.indexOf(e.detail.item);\n      this.close();\n    } else if (this.selectedItem !== e.detail.item) {\n      this.selectedItem = e.detail.item;\n\n      this._detectAndDispatchChange();\n    }\n  }\n  /** @private */\n\n\n  _onFocusout(event) {\n    // Fixes the problem with `focusout` happening when clicking on the scroll bar on Edge\n    var dropdown = this.$.overlay.$.dropdown;\n\n    if (dropdown && dropdown.$ && event.relatedTarget === dropdown.$.overlay) {\n      event.composedPath()[0].focus();\n      return;\n    }\n\n    if (!this._closeOnBlurIsPrevented) {\n      this._closeOrCommit();\n    }\n  }\n  /** @private */\n\n\n  _onTouchend(event) {\n    if (!this._clearElement || event.composedPath()[0] !== this._clearElement) {\n      return;\n    }\n\n    event.preventDefault();\n\n    this._clear();\n  }\n  /**\n   * Returns true if `value` is valid, and sets the `invalid` flag appropriately.\n   *\n   * @return {boolean} True if the value is valid and sets the `invalid` flag appropriately\n   */\n\n\n  validate() {\n    return !(this.invalid = !this.checkValidity());\n  }\n  /**\n   * Returns true if the current input value satisfies all constraints (if any)\n   *\n   * You can override the `checkValidity` method for custom validations.\n   * @return {boolean | undefined}\n   */\n\n\n  checkValidity() {\n    if (this.inputElement.validate) {\n      return this.inputElement.validate();\n    }\n  }\n  /** @private */\n\n\n  get _instanceProps() {\n    return {\n      item: true,\n      index: true,\n      selected: true,\n      focused: true\n    };\n  }\n  /** @protected */\n\n\n  _ensureTemplatized() {\n    if (!this._TemplateClass) {\n      var tpl = this._itemTemplate || this._getRootTemplate();\n\n      if (tpl) {\n        this._TemplateClass = templatize(tpl, this, {\n          instanceProps: this._instanceProps,\n          forwardHostProp: function (prop, value) {\n            var items = this.$.overlay._selector.querySelectorAll('vaadin-combo-box-item');\n\n            Array.prototype.forEach.call(items, item => {\n              if (item._itemTemplateInstance) {\n                item._itemTemplateInstance.set(prop, value);\n\n                item._itemTemplateInstance.notifyPath(prop, value, true);\n              }\n            });\n          }\n        });\n      }\n    }\n  }\n  /** @private */\n\n\n  _getRootTemplate() {\n    return Array.prototype.filter.call(this.children, elem => elem.tagName === 'TEMPLATE')[0];\n  }\n  /** @protected */\n\n\n  _preventInputBlur() {\n    if (this._toggleElement) {\n      this._toggleElement.addEventListener('click', this._preventDefault);\n    }\n\n    if (this._clearElement) {\n      this._clearElement.addEventListener('click', this._preventDefault);\n    }\n  }\n  /** @protected */\n\n\n  _restoreInputBlur() {\n    if (this._toggleElement) {\n      this._toggleElement.removeEventListener('click', this._preventDefault);\n    }\n\n    if (this._clearElement) {\n      this._clearElement.removeEventListener('click', this._preventDefault);\n    }\n  }\n  /** @private */\n\n\n  _preventDefault(e) {\n    e.preventDefault();\n  }\n  /**\n   * @param {!Event} e\n   * @protected\n   */\n\n\n  _stopPropagation(e) {\n    e.stopPropagation();\n  }\n  /**\n   * Fired when the value changes.\n   *\n   * @event value-changed\n   * @param {Object} detail\n   *  @param {String} detail.value the combobox value\n   */\n\n  /**\n   * Fired when selected item changes.\n   *\n   * @event selected-item-changed\n   * @param {Object} detail\n   *  @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.\n   */\n\n  /**\n   * Fired when the user sets a custom value.\n   * @event custom-value-set\n   * @param {String} detail the custom value\n   */\n\n  /**\n   * Fired when value changes.\n   * To comply with https://developer.mozilla.org/en-US/docs/Web/Events/change\n   * @event change\n   */\n\n\n};"
    },
    {
     "id": 172,
     "name": "../node_modules/@polymer/iron-scroll-target-behavior/iron-scroll-target-behavior.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\n/**\n * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll\n * events from a designated scroll target.\n *\n * Elements that consume this behavior can override the `_scrollHandler`\n * method to add logic on the scroll event.\n *\n * @demo demo/scrolling-region.html Scrolling Region\n * @demo demo/document.html Document Element\n * @polymerBehavior\n */\n\nexport var IronScrollTargetBehavior = {\n  properties: {\n    /**\n     * Specifies the element that will handle the scroll event\n     * on the behalf of the current element. This is typically a reference to an\n     *element, but there are a few more posibilities:\n     *\n     * ### Elements id\n     *\n     *```html\n     * <div id=\"scrollable-element\" style=\"overflow: auto;\">\n     *  <x-element scroll-target=\"scrollable-element\">\n     *    <!-- Content-->\n     *  </x-element>\n     * </div>\n     *```\n     * In this case, the `scrollTarget` will point to the outer div element.\n     *\n     * ### Document scrolling\n     *\n     * For document scrolling, you can use the reserved word `document`:\n     *\n     *```html\n     * <x-element scroll-target=\"document\">\n     *   <!-- Content -->\n     * </x-element>\n     *```\n     *\n     * ### Elements reference\n     *\n     *```js\n     * appHeader.scrollTarget = document.querySelector('#scrollable-element');\n     *```\n     *\n     * @type {HTMLElement}\n     * @default document\n     */\n    scrollTarget: {\n      type: HTMLElement,\n      value: function () {\n        return this._defaultScrollTarget;\n      }\n    }\n  },\n  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],\n\n  /**\n   * True if the event listener should be installed.\n   */\n  _shouldHaveListener: true,\n  _scrollTargetChanged: function (scrollTarget, isAttached) {\n    var eventTarget;\n\n    if (this._oldScrollTarget) {\n      this._toggleScrollListener(false, this._oldScrollTarget);\n\n      this._oldScrollTarget = null;\n    }\n\n    if (!isAttached) {\n      return;\n    } // Support element id references\n\n\n    if (scrollTarget === 'document') {\n      this.scrollTarget = this._doc;\n    } else if (typeof scrollTarget === 'string') {\n      var domHost = this.domHost;\n      this.scrollTarget = domHost && domHost.$ ? domHost.$[scrollTarget] : dom(this.ownerDocument).querySelector('#' + scrollTarget);\n    } else if (this._isValidScrollTarget()) {\n      this._oldScrollTarget = scrollTarget;\n\n      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);\n    }\n  },\n\n  /**\n   * Runs on every scroll event. Consumer of this behavior may override this\n   * method.\n   *\n   * @protected\n   */\n  _scrollHandler: function scrollHandler() {},\n\n  /**\n   * The default scroll target. Consumers of this behavior may want to customize\n   * the default scroll target.\n   *\n   * @type {Element}\n   */\n  get _defaultScrollTarget() {\n    return this._doc;\n  },\n\n  /**\n   * Shortcut for the document element\n   *\n   * @type {Element}\n   */\n  get _doc() {\n    return this.ownerDocument.documentElement;\n  },\n\n  /**\n   * Gets the number of pixels that the content of an element is scrolled\n   * upward.\n   *\n   * @type {number}\n   */\n  get _scrollTop() {\n    if (this._isValidScrollTarget()) {\n      return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;\n    }\n\n    return 0;\n  },\n\n  /**\n   * Gets the number of pixels that the content of an element is scrolled to the\n   * left.\n   *\n   * @type {number}\n   */\n  get _scrollLeft() {\n    if (this._isValidScrollTarget()) {\n      return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;\n    }\n\n    return 0;\n  },\n\n  /**\n   * Sets the number of pixels that the content of an element is scrolled\n   * upward.\n   *\n   * @type {number}\n   */\n  set _scrollTop(top) {\n    if (this.scrollTarget === this._doc) {\n      window.scrollTo(window.pageXOffset, top);\n    } else if (this._isValidScrollTarget()) {\n      this.scrollTarget.scrollTop = top;\n    }\n  },\n\n  /**\n   * Sets the number of pixels that the content of an element is scrolled to the\n   * left.\n   *\n   * @type {number}\n   */\n  set _scrollLeft(left) {\n    if (this.scrollTarget === this._doc) {\n      window.scrollTo(left, window.pageYOffset);\n    } else if (this._isValidScrollTarget()) {\n      this.scrollTarget.scrollLeft = left;\n    }\n  },\n\n  /**\n   * Scrolls the content to a particular place.\n   *\n   * @method scroll\n   * @param {number|!{left: number, top: number}} leftOrOptions The left position or scroll options\n   * @param {number=} top The top position\n   * @return {void}\n   */\n  scroll: function (leftOrOptions, top) {\n    var left;\n\n    if (typeof leftOrOptions === 'object') {\n      left = leftOrOptions.left;\n      top = leftOrOptions.top;\n    } else {\n      left = leftOrOptions;\n    }\n\n    left = left || 0;\n    top = top || 0;\n\n    if (this.scrollTarget === this._doc) {\n      window.scrollTo(left, top);\n    } else if (this._isValidScrollTarget()) {\n      this.scrollTarget.scrollLeft = left;\n      this.scrollTarget.scrollTop = top;\n    }\n  },\n\n  /**\n   * Gets the width of the scroll target.\n   *\n   * @type {number}\n   */\n  get _scrollTargetWidth() {\n    if (this._isValidScrollTarget()) {\n      return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;\n    }\n\n    return 0;\n  },\n\n  /**\n   * Gets the height of the scroll target.\n   *\n   * @type {number}\n   */\n  get _scrollTargetHeight() {\n    if (this._isValidScrollTarget()) {\n      return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;\n    }\n\n    return 0;\n  },\n\n  /**\n   * Returns true if the scroll target is a valid HTMLElement.\n   *\n   * @return {boolean}\n   */\n  _isValidScrollTarget: function () {\n    return this.scrollTarget instanceof HTMLElement;\n  },\n  _toggleScrollListener: function (yes, scrollTarget) {\n    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;\n\n    if (yes) {\n      if (!this._boundScrollHandler) {\n        this._boundScrollHandler = this._scrollHandler.bind(this);\n        eventTarget.addEventListener('scroll', this._boundScrollHandler);\n      }\n    } else {\n      if (this._boundScrollHandler) {\n        eventTarget.removeEventListener('scroll', this._boundScrollHandler);\n        this._boundScrollHandler = null;\n      }\n    }\n  },\n\n  /**\n   * Enables or disables the scroll event listener.\n   *\n   * @param {boolean} yes True to add the event, False to remove it.\n   */\n  toggleScrollListener: function (yes) {\n    this._shouldHaveListener = yes;\n\n    this._toggleScrollListener(yes, this.scrollTarget);\n  }\n};"
    },
    {
     "id": 173,
     "name": "../node_modules/@vaadin/vaadin-combo-box/src/vaadin-combo-box-data-provider-mixin.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2018 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { ComboBoxPlaceholder } from './vaadin-combo-box-placeholder.js';\n/**\n * @polymerMixin\n */\n\nexport var ComboBoxDataProviderMixin = superClass => class DataProviderMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Number of items fetched at a time from the dataprovider.\n       * @attr {number} page-size\n       * @type {number}\n       */\n      pageSize: {\n        type: Number,\n        value: 50,\n        observer: '_pageSizeChanged'\n      },\n\n      /**\n       * Total number of items.\n       * @type {number | undefined}\n       */\n      size: {\n        type: Number,\n        observer: '_sizeChanged'\n      },\n\n      /**\n       * Function that provides items lazily. Receives arguments `params`, `callback`\n       *\n       * `params.page` Requested page index\n       *\n       * `params.pageSize` Current page size\n       *\n       * `params.filter` Currently applied filter\n       *\n       * `callback(items, size)` Callback function with arguments:\n       *   - `items` Current page of items\n       *   - `size` Total number of items.\n       * @type {ComboBoxDataProvider | undefined}\n       */\n      dataProvider: {\n        type: Object,\n        observer: '_dataProviderChanged'\n      },\n\n      /** @private */\n      _pendingRequests: {\n        value: () => {\n          return {};\n        }\n      },\n\n      /** @private */\n      __placeHolder: {\n        value: new ComboBoxPlaceholder()\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_dataProviderFilterChanged(filter, dataProvider)', '_dataProviderClearFilter(dataProvider, opened, value)', '_warnDataProviderValue(dataProvider, value)', '_ensureFirstPage(opened)'];\n  }\n  /** @private */\n\n\n  _dataProviderClearFilter(dataProvider, opened, value) {\n    // Can't depend on filter in this observer as we don't want\n    // to clear the filter whenever it's set\n    if (dataProvider && !this.loading && this.filter) {\n      this.size = undefined;\n      this._pendingRequests = {};\n      this.filter = '';\n      this.clearCache();\n    }\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.clearCache();\n    this.$.overlay.addEventListener('index-requested', e => {\n      var index = e.detail.index;\n      var currentScrollerPos = e.detail.currentScrollerPos;\n      var allowedIndexRange = Math.floor(this.pageSize * 1.5); // Ignores the indexes, which are being re-sent during scrolling reset,\n      // if the corresponding page is around the current scroller position.\n      // Otherwise, there might be a last pages duplicates, which cause the\n      // loading indicator hanging and blank items\n\n      if (this._shouldSkipIndex(index, allowedIndexRange, currentScrollerPos)) {\n        return;\n      }\n\n      if (index !== undefined) {\n        var page = this._getPageForIndex(index);\n\n        if (this._shouldLoadPage(page)) {\n          this._loadPage(page);\n        }\n      }\n    });\n  }\n  /** @private */\n\n\n  _dataProviderFilterChanged() {\n    if (!this._shouldFetchData()) {\n      return;\n    }\n\n    this.size = undefined;\n    this._pendingRequests = {};\n    this.clearCache();\n  }\n  /** @private */\n\n\n  _shouldFetchData() {\n    if (!this.dataProvider) {\n      return false;\n    }\n\n    return this.opened || this.filter && this.filter.length;\n  }\n  /** @private */\n\n\n  _ensureFirstPage(opened) {\n    if (opened && this._shouldLoadPage(0)) {\n      this._loadPage(0);\n    }\n  }\n  /** @private */\n\n\n  _shouldSkipIndex(index, allowedIndexRange, currentScrollerPos) {\n    return currentScrollerPos !== 0 && index >= currentScrollerPos - allowedIndexRange && index <= currentScrollerPos + allowedIndexRange;\n  }\n  /** @private */\n\n\n  _shouldLoadPage(page) {\n    if (!this.filteredItems || this._forceNextRequest) {\n      this._forceNextRequest = false;\n      return true;\n    }\n\n    var loadedItem = this.filteredItems[page * this.pageSize];\n\n    if (loadedItem !== undefined) {\n      return loadedItem instanceof ComboBoxPlaceholder;\n    } else {\n      return this.size === undefined;\n    }\n  }\n  /** @private */\n\n\n  _loadPage(page) {\n    // make sure same page isn't requested multiple times.\n    if (!this._pendingRequests[page] && this.dataProvider) {\n      this.loading = true;\n      var params = {\n        page,\n        pageSize: this.pageSize,\n        filter: this.filter\n      };\n\n      var callback = (items, size) => {\n        if (this._pendingRequests[page] === callback) {\n          if (!this.filteredItems) {\n            var filteredItems = [];\n            filteredItems.splice(params.page * params.pageSize, items.length, ...items);\n            this.filteredItems = filteredItems;\n          } else {\n            this.splice('filteredItems', params.page * params.pageSize, items.length, ...items);\n          } // Update selectedItem from filteredItems if value is set\n\n\n          if (this._isValidValue(this.value) && this._getItemValue(this.selectedItem) !== this.value) {\n            this._selectItemForValue(this.value);\n          }\n\n          if (!this.opened && !this.hasAttribute('focused')) {\n            this._commitValue();\n          }\n\n          this.size = size;\n          delete this._pendingRequests[page];\n\n          if (Object.keys(this._pendingRequests).length === 0) {\n            this.loading = false;\n          }\n\n          if (page === 0 && this.__repositionOverlayDebouncer && items.length > (this.__maxRenderedItems || 0)) {\n            setTimeout(() => this.__repositionOverlayDebouncer.flush());\n            this.__maxRenderedItems = items.length;\n          }\n        }\n      };\n\n      if (!this._pendingRequests[page]) {\n        // Don't request page if it's already being requested\n        this._pendingRequests[page] = callback;\n        this.dataProvider(params, callback);\n      }\n    }\n  }\n  /** @private */\n\n\n  _getPageForIndex(index) {\n    return Math.floor(index / this.pageSize);\n  }\n  /**\n   * Clears the cached pages and reloads data from dataprovider when needed.\n   */\n\n\n  clearCache() {\n    if (!this.dataProvider) {\n      return;\n    }\n\n    this._pendingRequests = {};\n    var filteredItems = [];\n\n    for (var i = 0; i < (this.size || 0); i++) {\n      filteredItems.push(this.__placeHolder);\n    }\n\n    this.filteredItems = filteredItems;\n\n    if (this._shouldFetchData()) {\n      this._loadPage(0);\n    } else {\n      this._forceNextRequest = true;\n    }\n  }\n  /** @private */\n\n\n  _sizeChanged(size = 0) {\n    var filteredItems = (this.filteredItems || []).slice(0, size);\n\n    for (var i = 0; i < size; i++) {\n      filteredItems[i] = filteredItems[i] !== undefined ? filteredItems[i] : this.__placeHolder;\n    }\n\n    this.filteredItems = filteredItems; // Cleans up the redundant pending requests for pages > size\n    // Refers to https://github.com/vaadin/vaadin-flow-components/issues/229\n\n    this._flushPendingRequests(size);\n  }\n  /** @private */\n\n\n  _pageSizeChanged(pageSize, oldPageSize) {\n    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {\n      this.pageSize = oldPageSize;\n      throw new Error('`pageSize` value must be an integer > 0');\n    }\n\n    this.clearCache();\n  }\n  /** @private */\n\n\n  _dataProviderChanged(dataProvider, oldDataProvider) {\n    this._ensureItemsOrDataProvider(() => {\n      this.dataProvider = oldDataProvider;\n    });\n  }\n  /** @private */\n\n\n  _ensureItemsOrDataProvider(restoreOldValueCallback) {\n    if (this.items !== undefined && this.dataProvider !== undefined) {\n      restoreOldValueCallback();\n      throw new Error('Using `items` and `dataProvider` together is not supported');\n    } else if (this.dataProvider && !this.filteredItems) {\n      this.filteredItems = [];\n    }\n  }\n  /** @private */\n\n\n  _warnDataProviderValue(dataProvider, value) {\n    if (dataProvider && value !== '' && (this.selectedItem === undefined || this.selectedItem === null)) {\n      var valueIndex = this._indexOfValue(value, this.filteredItems);\n\n      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {\n        /* eslint-disable no-console */\n        console.warn('Warning: unable to determine the label for the provided `value`. ' + 'Nothing to display in the text field. This usually happens when ' + 'setting an initial `value` before any items are returned from ' + 'the `dataProvider` callback. Consider setting `selectedItem` ' + 'instead of `value`');\n        /* eslint-enable no-console */\n      }\n    }\n  }\n  /**\n   * This method cleans up the page callbacks which refers to the\n   * non-existing pages, i.e. which item indexes are greater than the\n   * changed size.\n   * This case is basically happens when:\n   * 1. Users scroll fast to the bottom and combo box generates the\n   * redundant page request/callback\n   * 2. Server side uses undefined size lazy loading and suddenly reaches\n   * the exact size which is on the range edge\n   * (for default page size = 50, it will be 100, 200, 300, ...).\n   * @param size the new size of items\n   * @private\n   */\n\n\n  _flushPendingRequests(size) {\n    if (this._pendingRequests) {\n      var lastPage = Math.ceil(size / this.pageSize);\n      var pendingRequestsKeys = Object.keys(this._pendingRequests);\n\n      for (var reqIdx = 0; reqIdx < pendingRequestsKeys.length; reqIdx++) {\n        var page = parseInt(pendingRequestsKeys[reqIdx]);\n\n        if (page >= lastPage) {\n          this._pendingRequests[page]([], size);\n        }\n      }\n    }\n  }\n\n};"
    },
    {
     "id": 174,
     "name": "../node_modules/@vaadin/vaadin-date-picker/src/vaadin-date-picker-text-field.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2019 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { TextFieldElement } from '@vaadin/vaadin-text-field/src/vaadin-text-field.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<dom-module id=\"vaadin-date-picker-text-field-styles\" theme-for=\"vaadin-date-picker-text-field\">\n  <template>\n    <style>\n      :host([dir=\"rtl\"]) [part=\"input-field\"] {\n        direction: ltr;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"value\"]::placeholder {\n        direction: rtl;\n        text-align: left;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"input-field\"] ::slotted(input)::placeholder {\n        direction: rtl;\n        text-align: left;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"value\"]:-ms-input-placeholder,\n      :host([dir=\"rtl\"]) [part=\"input-field\"] ::slotted(input):-ms-input-placeholder {\n        direction: rtl;\n        text-align: left;\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);\n/**\n  * The text-field element for date input.\n  *\n  * ### Styling\n  *\n  * See [`<vaadin-text-field>` documentation](https://github.com/vaadin/vaadin-text-field/blob/master/src/vaadin-text-field.html)\n  * for `<vaadin-date-picker-text-field>` parts and available slots (prefix, suffix etc.)\n  *\n  * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n  *\n  * @extends PolymerElement\n  */\n\nclass DatePickerTextFieldElement extends TextFieldElement {\n  static get is() {\n    return 'vaadin-date-picker-text-field';\n  }\n\n}\n\ncustomElements.define(DatePickerTextFieldElement.is, DatePickerTextFieldElement);"
    },
    {
     "id": 175,
     "name": "../node_modules/@vaadin/vaadin-list-mixin/vaadin-list-mixin.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { DirHelper } from '@vaadin/vaadin-element-mixin/vaadin-dir-helper.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\n/**\n * A mixin for `nav` elements, facilitating navigation and selection of childNodes.\n *\n * @polymerMixin\n */\n\nexport var ListMixin = superClass => class VaadinListMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Used for mixin detection because `instanceof` does not work with mixins.\n       * @type {boolean}\n       */\n      _hasVaadinListMixin: {\n        value: true\n      },\n\n      /**\n       * The index of the item selected in the items array.\n       * Note: Not updated when used in `multiple` selection mode.\n       */\n      selected: {\n        type: Number,\n        reflectToAttribute: true,\n        notify: true\n      },\n\n      /**\n       * Define how items are disposed in the dom.\n       * Possible values are: `horizontal|vertical`.\n       * It also changes navigation keys from left/right to up/down.\n       * @type {!ListOrientation}\n       */\n      orientation: {\n        type: String,\n        reflectToAttribute: true,\n        value: ''\n      },\n\n      /**\n       * The list of items from which a selection can be made.\n       * It is populated from the elements passed to the light DOM,\n       * and updated dynamically when adding or removing items.\n       *\n       * The item elements must implement `Vaadin.ItemMixin`.\n       *\n       * Note: unlike `<vaadin-combo-box>`, this property is read-only,\n       * so if you want to provide items by iterating array of data,\n       * you have to use `dom-repeat` and place it to the light DOM.\n       * @type {!Array<!Element> | undefined}\n       */\n      items: {\n        type: Array,\n        readOnly: true,\n        notify: true\n      },\n\n      /**\n       * The search buffer for the keyboard selection feature.\n       * @private\n       */\n      _searchBuf: {\n        type: String,\n        value: ''\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_enhanceItems(items, orientation, selected, disabled)'];\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.addEventListener('keydown', e => this._onKeydown(e));\n    this.addEventListener('click', e => this._onClick(e));\n    this._observer = new FlattenedNodesObserver(this, info => {\n      this._setItems(this._filterItems(Array.from(this.children)));\n    });\n  }\n  /** @private */\n\n\n  _enhanceItems(items, orientation, selected, disabled) {\n    if (!disabled) {\n      if (items) {\n        this.setAttribute('aria-orientation', orientation || 'vertical');\n        this.items.forEach(item => {\n          orientation ? item.setAttribute('orientation', orientation) : item.removeAttribute('orientation');\n          item.updateStyles();\n        });\n\n        this._setFocusable(selected);\n\n        var itemToSelect = items[selected];\n        items.forEach(item => item.selected = item === itemToSelect);\n\n        if (itemToSelect && !itemToSelect.disabled) {\n          this._scrollToItem(selected);\n        }\n      }\n    }\n  }\n  /**\n   * @return {Element}\n   */\n\n\n  get focused() {\n    return this.getRootNode().activeElement;\n  }\n  /**\n   * @param {!Array<!Element>} array\n   * @return {!Array<!Element>}\n   * @protected\n   */\n\n\n  _filterItems(array) {\n    return array.filter(e => e._hasVaadinItemMixin);\n  }\n  /**\n   * @param {!MouseEvent} event\n   * @protected\n   */\n\n\n  _onClick(event) {\n    if (event.metaKey || event.shiftKey || event.ctrlKey || event.defaultPrevented) {\n      return;\n    }\n\n    var item = this._filterItems(event.composedPath())[0];\n\n    var idx;\n\n    if (item && !item.disabled && (idx = this.items.indexOf(item)) >= 0) {\n      this.selected = idx;\n    }\n  }\n  /**\n   * @param {number} currentIdx\n   * @param {string} key\n   * @return {number}\n   * @protected\n   */\n\n\n  _searchKey(currentIdx, key) {\n    this._searchReset = Debouncer.debounce(this._searchReset, timeOut.after(500), () => this._searchBuf = '');\n    this._searchBuf += key.toLowerCase();\n    var increment = 1;\n\n    var condition = item => !(item.disabled || this._isItemHidden(item)) && item.textContent.replace(/[^a-zA-Z0-9]/g, '').toLowerCase().indexOf(this._searchBuf) === 0;\n\n    if (!this.items.some(item => item.textContent.replace(/[^a-zA-Z0-9]/g, '').toLowerCase().indexOf(this._searchBuf) === 0)) {\n      this._searchBuf = key.toLowerCase();\n    }\n\n    var idx = this._searchBuf.length === 1 ? currentIdx + 1 : currentIdx;\n    return this._getAvailableIndex(idx, increment, condition);\n  }\n  /**\n   * @return {boolean}\n   * @protected\n   */\n\n\n  get _isRTL() {\n    return !this._vertical && this.getAttribute('dir') === 'rtl';\n  }\n  /**\n   * @param {!KeyboardEvent} event\n   * @protected\n   */\n\n\n  _onKeydown(event) {\n    if (event.metaKey || event.ctrlKey) {\n      return;\n    } // IE names for arrows do not include the Arrow prefix\n\n\n    var key = event.key.replace(/^Arrow/, '');\n    var currentIdx = this.items.indexOf(this.focused);\n\n    if (/[a-zA-Z0-9]/.test(key) && key.length === 1) {\n      var _idx = this._searchKey(currentIdx, key);\n\n      if (_idx >= 0) {\n        this._focus(_idx);\n      }\n\n      return;\n    }\n\n    var condition = item => !(item.disabled || this._isItemHidden(item));\n\n    var idx, increment;\n    var dirIncrement = this._isRTL ? -1 : 1;\n\n    if (this._vertical && key === 'Up' || !this._vertical && key === 'Left') {\n      increment = -dirIncrement;\n      idx = currentIdx - dirIncrement;\n    } else if (this._vertical && key === 'Down' || !this._vertical && key === 'Right') {\n      increment = dirIncrement;\n      idx = currentIdx + dirIncrement;\n    } else if (key === 'Home') {\n      increment = 1;\n      idx = 0;\n    } else if (key === 'End') {\n      increment = -1;\n      idx = this.items.length - 1;\n    }\n\n    idx = this._getAvailableIndex(idx, increment, condition);\n\n    if (idx >= 0) {\n      this._focus(idx);\n\n      event.preventDefault();\n    }\n  }\n  /**\n   * @param {number} idx\n   * @param {number} increment\n   * @param {function(!Element):boolean} condition\n   * @return {number}\n   * @protected\n   */\n\n\n  _getAvailableIndex(idx, increment, condition) {\n    var totalItems = this.items.length;\n\n    for (var i = 0; typeof idx == 'number' && i < totalItems; i++, idx += increment || 1) {\n      if (idx < 0) {\n        idx = totalItems - 1;\n      } else if (idx >= totalItems) {\n        idx = 0;\n      }\n\n      var item = this.items[idx];\n\n      if (condition(item)) {\n        return idx;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * @param {!Element} item\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _isItemHidden(item) {\n    return getComputedStyle(item).display === 'none';\n  }\n  /**\n   * @param {number} idx\n   * @protected\n   */\n\n\n  _setFocusable(idx) {\n    idx = this._getAvailableIndex(idx, 1, item => !item.disabled);\n    var item = this.items[idx] || this.items[0];\n    this.items.forEach(e => e.tabIndex = e === item ? 0 : -1);\n  }\n  /**\n   * @param {number} idx\n   * @protected\n   */\n\n\n  _focus(idx) {\n    var item = this.items[idx];\n    this.items.forEach(e => e.focused = e === item);\n\n    this._setFocusable(idx);\n\n    this._scrollToItem(idx);\n\n    item.focus();\n  }\n\n  focus() {\n    // In initialisation (e.g vaadin-select) observer might not been run yet.\n    this._observer && this._observer.flush();\n    var firstItem = this.querySelector('[tabindex=\"0\"]') || (this.items ? this.items[0] : null);\n    firstItem && firstItem.focus();\n  }\n  /**\n   * @return {!HTMLElement}\n   * @protected\n   */\n\n\n  get _scrollerElement() {// Returning scroller element of the component\n  }\n  /**\n   * Scroll the container to have the next item by the edge of the viewport.\n   * @param {number} idx\n   * @protected\n   */\n\n\n  _scrollToItem(idx) {\n    var item = this.items[idx];\n\n    if (!item) {\n      return;\n    }\n\n    var props = this._vertical ? ['top', 'bottom'] : this._isRTL ? ['right', 'left'] : ['left', 'right'];\n\n    var scrollerRect = this._scrollerElement.getBoundingClientRect();\n\n    var nextItemRect = (this.items[idx + 1] || item).getBoundingClientRect();\n    var prevItemRect = (this.items[idx - 1] || item).getBoundingClientRect();\n    var scrollDistance = 0;\n\n    if (!this._isRTL && nextItemRect[props[1]] >= scrollerRect[props[1]] || this._isRTL && nextItemRect[props[1]] <= scrollerRect[props[1]]) {\n      scrollDistance = nextItemRect[props[1]] - scrollerRect[props[1]];\n    } else if (!this._isRTL && prevItemRect[props[0]] <= scrollerRect[props[0]] || this._isRTL && prevItemRect[props[0]] >= scrollerRect[props[0]]) {\n      scrollDistance = prevItemRect[props[0]] - scrollerRect[props[0]];\n    }\n\n    this._scroll(scrollDistance);\n  }\n  /**\n   * @return {boolean}\n   * @protected\n   */\n\n\n  get _vertical() {\n    return this.orientation !== 'horizontal';\n  }\n  /**\n   * @param {number} pixels\n   * @protected\n   */\n\n\n  _scroll(pixels) {\n    if (this._vertical) {\n      this._scrollerElement['scrollTop'] += pixels;\n    } else {\n      var scrollType = DirHelper.detectScrollType();\n      var scrollLeft = DirHelper.getNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', this._scrollerElement) + pixels;\n      DirHelper.setNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', this._scrollerElement, scrollLeft);\n    }\n  }\n  /**\n   * Fired when the selection is changed.\n   * Not fired when used in `multiple` selection mode.\n   *\n   * @event selected-changed\n   * @param {Object} detail\n   * @param {Object} detail.value the index of the item selected in the items array.\n   */\n\n\n};"
    },
    {
     "id": 176,
     "name": "../node_modules/@vaadin/vaadin-upload/src/vaadin-upload-icons.js?babel-target=es6",
     "source": "import '@polymer/polymer/lib/elements/custom-style.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<custom-style>\n  <style>\n    @font-face {\n      font-family: 'vaadin-upload-icons';\n      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAasAAsAAAAABmAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIF5mNtYXAAAAFoAAAAVAAAAFQXVtKMZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAfQAAAH0bBJxYWhlYWQAAAO4AAAANgAAADYPD267aGhlYQAAA/AAAAAkAAAAJAfCA8tobXR4AAAEFAAAACgAAAAoHgAAx2xvY2EAAAQ8AAAAFgAAABYCSgHsbWF4cAAABFQAAAAgAAAAIAAOADVuYW1lAAAEdAAAAhYAAAIWmmcHf3Bvc3QAAAaMAAAAIAAAACAAAwAAAAMDtwGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QUDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkF//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAgAA/8AEAAPAABkAMgAAEz4DMzIeAhczLgMjIg4CBycRIScFIRcOAyMiLgInIx4DMzI+AjcXphZGWmo6SH9kQwyADFiGrmJIhXJbIEYBAFoDWv76YBZGXGw8Rn5lRQyADFmIrWBIhHReIkYCWjJVPSIyVnVDXqN5RiVEYTxG/wBa2loyVT0iMlZ1Q16jeUYnRWE5RgAAAAABAIAAAAOAA4AAAgAAExEBgAMAA4D8gAHAAAAAAwAAAAAEAAOAAAIADgASAAAJASElIiY1NDYzMhYVFAYnETMRAgD+AAQA/gAdIyMdHSMjXYADgPyAgCMdHSMjHR0jwAEA/wAAAQANADMD5gNaAAUAACUBNwUBFwHT/jptATMBppMzAU2a4AIgdAAAAAEAOv/6A8YDhgALAAABJwkBBwkBFwkBNwEDxoz+xv7GjAFA/sCMAToBOoz+wAL6jP7AAUCM/sb+xowBQP7AjAE6AAAAAwAA/8AEAAPAAAcACwASAAABFSE1IREhEQEjNTMJAjMRIRECwP6A/sAEAP0AgIACQP7A/sDAAQABQICA/oABgP8AgAHAAUD+wP6AAYAAAAABAAAAAQAAdhiEdV8PPPUACwQAAAAAANX4FR8AAAAA1fgVHwAA/8AEAAPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAQAAAEAAAAAAAAAAAAAAAAAAAAKBAAAAAAAAAAAAAAAAgAAAAQAAAAEAACABAAAAAQAAA0EAAA6BAAAAAAAAAAACgAUAB4AagB4AJwAsADSAPoAAAABAAAACgAzAAMAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEAEwAAAAEAAAAAAAIABwDMAAEAAAAAAAMAEwBaAAEAAAAAAAQAEwDhAAEAAAAAAAUACwA5AAEAAAAAAAYAEwCTAAEAAAAAAAoAGgEaAAMAAQQJAAEAJgATAAMAAQQJAAIADgDTAAMAAQQJAAMAJgBtAAMAAQQJAAQAJgD0AAMAAQQJAAUAFgBEAAMAAQQJAAYAJgCmAAMAAQQJAAoANAE0dmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzUmVndWxhcgBSAGUAZwB1AGwAYQBydmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==) format('woff');\n      font-weight: normal;\n      font-style: normal;\n    }\n  </style>\n</custom-style>`;\ndocument.head.appendChild($_documentContainer.content);\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\n\n;"
    },
    {
     "id": 186,
     "name": "../node_modules/@vaadin/vaadin-progress-bar/src/vaadin-progress-bar.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 188,
     "name": "../node_modules/@vaadin/vaadin-item/theme/lumo/vaadin-item.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 190,
     "name": "../node_modules/@vaadin/vaadin-button/theme/lumo/vaadin-button-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-button\" theme-for=\"vaadin-button\">\n  <template>\n    <style>\n      :host {\n        /* Sizing */\n        --lumo-button-size: var(--lumo-size-m);\n        min-width: calc(var(--lumo-button-size) * 2);\n        height: var(--lumo-button-size);\n        padding: 0 calc(var(--lumo-button-size) / 3 + var(--lumo-border-radius) / 2);\n        margin: var(--lumo-space-xs) 0;\n        box-sizing: border-box;\n        /* Style */\n        font-family: var(--lumo-font-family);\n        font-size: var(--lumo-font-size-m);\n        font-weight: 500;\n        color: var(--_lumo-button-color, var(--lumo-primary-text-color));\n        background-color: var(--_lumo-button-background-color, var(--lumo-contrast-5pct));\n        border-radius: var(--lumo-border-radius);\n        cursor: default;\n        -webkit-tap-highlight-color: transparent;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n      }\n\n      /* Set only for the internal parts so we dont affect the host vertical alignment */\n      [part=\"label\"],\n      [part=\"prefix\"],\n      [part=\"suffix\"] {\n        line-height: var(--lumo-line-height-xs);\n      }\n\n      [part=\"label\"] {\n        padding: calc(var(--lumo-button-size) / 6) 0;\n      }\n\n      :host([theme~=\"small\"]) {\n        font-size: var(--lumo-font-size-s);\n        --lumo-button-size: var(--lumo-size-s);\n      }\n\n      :host([theme~=\"large\"]) {\n        font-size: var(--lumo-font-size-l);\n        --lumo-button-size: var(--lumo-size-l);\n      }\n\n      /* This needs to be the last selector for it to take priority */\n      :host([disabled][disabled]) {\n        pointer-events: none;\n        color: var(--lumo-disabled-text-color);\n        background-color: var(--lumo-contrast-5pct);\n      }\n\n      /* For interaction states */\n      :host::before,\n      :host::after {\n        content: \"\";\n        /* We rely on the host always being relative */\n        position: absolute;\n        z-index: 1;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        background-color: currentColor;\n        border-radius: inherit;\n        opacity: 0;\n        transition: opacity 0.2s;\n        pointer-events: none;\n      }\n\n      /* Hover */\n\n      :host(:hover)::before {\n        opacity: 0.05;\n      }\n\n      /* Disable hover for touch devices */\n      @media (pointer: coarse) {\n        :host(:not([active]):hover)::before {\n          opacity: 0;\n        }\n      }\n\n      /* Active */\n\n      :host::after {\n        transition: opacity 1.4s, transform 0.1s;\n        filter: blur(8px);\n      }\n\n      :host([active])::before {\n        opacity: 0.1;\n        transition-duration: 0s;\n      }\n\n      :host([active])::after {\n        opacity: 0.1;\n        transition-duration: 0s, 0s;\n        transform: scale(0);\n      }\n\n      /* Keyboard focus */\n\n      :host([focus-ring]) {\n        box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);\n      }\n\n      /* Types (primary, tertiary, tertiary-inline */\n\n      :host([theme~=\"tertiary\"]),\n      :host([theme~=\"tertiary-inline\"]) {\n        background-color: transparent !important;\n        transition: opacity 0.2s;\n        min-width: 0;\n      }\n\n      :host([theme~=\"tertiary\"])::before,\n      :host([theme~=\"tertiary-inline\"])::before {\n        display: none;\n      }\n\n      :host([theme~=\"tertiary\"]) {\n        padding: 0 calc(var(--lumo-button-size) / 6);\n      }\n\n      @media (hover: hover) {\n        :host([theme*=\"tertiary\"]:not([active]):hover) {\n          opacity: 0.8;\n        }\n      }\n\n      :host([theme~=\"tertiary\"][active]),\n      :host([theme~=\"tertiary-inline\"][active]) {\n        opacity: 0.5;\n        transition-duration: 0s;\n      }\n\n      :host([theme~=\"tertiary-inline\"]) {\n        margin: 0;\n        height: auto;\n        padding: 0;\n        line-height: inherit;\n        font-size: inherit;\n      }\n\n      :host([theme~=\"tertiary-inline\"]) [part=\"label\"] {\n        padding: 0;\n        overflow: visible;\n        line-height: inherit;\n      }\n\n      :host([theme~=\"primary\"]) {\n        background-color: var(--_lumo-button-primary-background-color, var(--lumo-primary-color));\n        color: var(--_lumo-button-primary-color, var(--lumo-primary-contrast-color));\n        font-weight: 600;\n        min-width: calc(var(--lumo-button-size) * 2.5);\n      }\n\n      :host([theme~=\"primary\"][disabled]) {\n        background-color: var(--lumo-primary-color-50pct);\n        color: var(--lumo-primary-contrast-color);\n      }\n\n      :host([theme~=\"primary\"]:hover)::before {\n        opacity: 0.1;\n      }\n\n      :host([theme~=\"primary\"][active])::before {\n        background-color: var(--lumo-shade-20pct);\n      }\n\n      @media (pointer: coarse) {\n        :host([theme~=\"primary\"][active])::before {\n          background-color: var(--lumo-shade-60pct);\n        }\n\n        :host([theme~=\"primary\"]:not([active]):hover)::before {\n          opacity: 0;\n        }\n      }\n\n      :host([theme~=\"primary\"][active])::after {\n        opacity: 0.2;\n      }\n\n      /* Colors (success, error, contrast) */\n\n      :host([theme~=\"success\"]) {\n        color: var(--lumo-success-text-color);\n      }\n\n      :host([theme~=\"success\"][theme~=\"primary\"]) {\n        background-color: var(--lumo-success-color);\n        color: var(--lumo-success-contrast-color);\n      }\n\n      :host([theme~=\"success\"][theme~=\"primary\"][disabled]) {\n        background-color: var(--lumo-success-color-50pct);\n      }\n\n      :host([theme~=\"error\"]) {\n        color: var(--lumo-error-text-color);\n      }\n\n      :host([theme~=\"error\"][theme~=\"primary\"]) {\n        background-color: var(--lumo-error-color);\n        color: var(--lumo-error-contrast-color);\n      }\n\n      :host([theme~=\"error\"][theme~=\"primary\"][disabled]) {\n        background-color: var(--lumo-error-color-50pct);\n      }\n\n      :host([theme~=\"contrast\"]) {\n        color: var(--lumo-contrast);\n      }\n\n      :host([theme~=\"contrast\"][theme~=\"primary\"]) {\n        background-color: var(--lumo-contrast);\n        color: var(--lumo-base-color);\n      }\n\n      :host([theme~=\"contrast\"][theme~=\"primary\"][disabled]) {\n        background-color: var(--lumo-contrast-50pct);\n      }\n\n      /* Icons */\n\n      [part] ::slotted(iron-icon) {\n        display: inline-block;\n        width: var(--lumo-icon-size-m);\n        height: var(--lumo-icon-size-m);\n      }\n\n      /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */\n      [part] ::slotted(iron-icon[icon^=\"vaadin:\"]) {\n        padding: 0.25em;\n        box-sizing: border-box !important;\n      }\n\n      [part=\"prefix\"] {\n        margin-left: -0.25em;\n        margin-right: 0.25em;\n      }\n\n      [part=\"suffix\"] {\n        margin-left: 0.25em;\n        margin-right: -0.25em;\n      }\n\n      /* Icon-only */\n\n      :host([theme~=\"icon\"]:not([theme~=\"tertiary-inline\"])) {\n        min-width: var(--lumo-button-size);\n        padding-left: calc(var(--lumo-button-size) / 4);\n        padding-right: calc(var(--lumo-button-size) / 4);\n      }\n\n      :host([theme~=\"icon\"]) [part=\"prefix\"],\n      :host([theme~=\"icon\"]) [part=\"suffix\"] {\n        margin-left: 0;\n        margin-right: 0;\n      }\n\n      /* RTL specific styles */\n\n      :host([dir=\"rtl\"]) [part=\"prefix\"] {\n        margin-left: 0.25em;\n        margin-right: -0.25em;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"suffix\"] {\n        margin-left: -0.25em;\n        margin-right: 0.25em;\n      }\n\n      :host([dir=\"rtl\"][theme~=\"icon\"]) [part=\"prefix\"],\n      :host([dir=\"rtl\"][theme~=\"icon\"]) [part=\"suffix\"] {\n        margin-left: 0;\n        margin-right: 0;\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 191,
     "name": "../node_modules/@vaadin/vaadin-item/src/vaadin-item.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { DirMixin } from '@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js';\nimport { ItemMixin } from './vaadin-item-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-item>` is a Web Component providing layout for items in tabs and menus.\n *\n * ```\n *   <vaadin-item>\n *     Item content\n *   </vaadin-item>\n * ```\n *\n * ### Selectable\n *\n * `<vaadin-item>` has the `selected` property and the corresponding state attribute.\n * Currently, the component sets the `selected` to false, when `disabled` property is set to true.\n * But other than that, the `<vaadin-item>` does not switch selection by itself.\n * In general, it is the wrapper component, like `<vaadin-list-box>`, which should update\n * the `selected` property on the items, e. g. on mousedown or when Enter / Spacebar is pressed.\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ---|---\n * `content` | The element that wraps the slot\n *\n * The following state attributes are available for styling:\n *\n * Attribute  | Description | Part name\n * -----------|-------------|------------\n * `disabled` | Set to a disabled item | :host\n * `focused` | Set when the element is focused | :host\n * `focus-ring` | Set when the element is keyboard focused | :host\n * `selected` | Set when the item is selected | :host\n * `active` | Set when mousedown or enter/spacebar pressed | :host\n *\n * @extends PolymerElement\n * @mixes ItemMixin\n * @mixes ThemableMixin\n * @mixes DirMixin\n */\n\nclass ItemElement extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n    </style>\n    <div part=\"content\">\n      <slot></slot>\n    </div>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-item';\n  }\n\n  static get version() {\n    return '2.3.0';\n  }\n\n  constructor() {\n    super();\n    /**\n     * Submittable string value. The default value is the trimmed text content of the element.\n     * @type {string}\n     */\n\n    this.value;\n  }\n\n}\n\ncustomElements.define(ItemElement.is, ItemElement);\nexport { ItemElement };"
    },
    {
     "id": 194,
     "name": "../node_modules/@vaadin/vaadin-date-picker/theme/lumo/vaadin-date-picker.js?babel-target=es6 + 6 modules"
    },
    {
     "id": 196,
     "name": "../node_modules/@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-layout.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 197,
     "name": "../node_modules/@vaadin/vaadin-custom-field/theme/lumo/vaadin-custom-field.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 200,
     "name": "../node_modules/@polymer/iron-icon/iron-icon.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 202,
     "name": "../node_modules/@polymer/polymer/lib/elements/dom-if.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { templatize } from '../utils/templatize.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\n\nexport class DomIf extends PolymerElement {\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() {\n    return 'dom-if';\n  }\n\n  static get template() {\n    return null;\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Fired whenever DOM is added or removed/hidden by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n\n      /**\n       * A boolean indicating whether this template should stamp.\n       */\n      if: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n\n      /**\n       * When true, elements will be removed from DOM and discarded when `if`\n       * becomes false and re-created and added back to the DOM when `if`\n       * becomes true.  By default, stamped elements will be hidden but left\n       * in the DOM when `if` becomes false, which is generally results\n       * in better performance.\n       */\n      restamp: {\n        type: Boolean,\n        observer: '__debounceRender'\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.__renderDebouncer = null;\n    this.__invalidProps = null;\n    this.__instance = null;\n    this._lastIf = false;\n    this.__ctor = null;\n    this.__hideTemplateChildren__ = false;\n  }\n\n  __debounceRender() {\n    // Render is async for 2 reasons:\n    // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n    //    same turn. This was more common in 1.x where a compound computed\n    //    property could result in the result changing multiple times, but is\n    //    mitigated to a large extent by batched property processing in 2.x.\n    // 2. To avoid double object propagation when a bag including values bound\n    //    to the `if` property as well as one or more hostProps could enqueue\n    //    the <dom-if> to flush before the <template>'s host property\n    //    forwarding. In that scenario creating an instance would result in\n    //    the host props being set once, and then the enqueued changes on the\n    //    template would set properties a second time, potentially causing an\n    //    object to be set to an instance more than once.  Creating the\n    //    instance async from flushing data ensures this doesn't happen. If\n    //    we wanted a sync option in the future, simply having <dom-if> flush\n    //    (or clear) its template's pending host properties before creating\n    //    the instance would also avoid the problem.\n    this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, microTask, () => this.__render());\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n  /**\n   * @override\n   * @return {void}\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    var parent = wrap(this).parentNode;\n\n    if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !wrap(parent).host) {\n      this.__teardownInstance();\n    }\n  }\n  /**\n   * @override\n   * @return {void}\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.style.display = 'none';\n\n    if (this.if) {\n      this.__debounceRender();\n    }\n  }\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   * @return {void}\n   */\n\n\n  render() {\n    flush();\n  }\n\n  __render() {\n    if (this.if) {\n      if (!this.__ensureInstance()) {\n        // No template found yet\n        return;\n      }\n\n      this._showHideChildren();\n    } else if (this.restamp) {\n      this.__teardownInstance();\n    }\n\n    if (!this.restamp && this.__instance) {\n      this._showHideChildren();\n    }\n\n    if (this.if != this._lastIf) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      this._lastIf = this.if;\n    }\n  }\n\n  __ensureInstance() {\n    var parentNode = wrap(this).parentNode; // Guard against element being detached while render was queued\n\n    if (parentNode) {\n      if (!this.__ctor) {\n        var template =\n        /** @type {HTMLTemplateElement} */\n        wrap(this).querySelector('template');\n\n        if (!template) {\n          // Wait until childList changes and template should be there by then\n          var observer = new MutationObserver(() => {\n            if (wrap(this).querySelector('template')) {\n              observer.disconnect();\n\n              this.__render();\n            } else {\n              throw new Error('dom-if requires a <template> child');\n            }\n          });\n          observer.observe(this, {\n            childList: true\n          });\n          return false;\n        }\n\n        this.__ctor = templatize(template, this, {\n          // dom-if templatizer instances require `mutable: true`, as\n          // `__syncHostProperties` relies on that behavior to sync objects\n          mutableData: true,\n\n          /**\n           * @param {string} prop Property to forward\n           * @param {*} value Value of property\n           * @this {DomIf}\n           */\n          forwardHostProp: function (prop, value) {\n            if (this.__instance) {\n              if (this.if) {\n                this.__instance.forwardHostProp(prop, value);\n              } else {\n                // If we have an instance but are squelching host property\n                // forwarding due to if being false, note the invalidated\n                // properties so `__syncHostProperties` can sync them the next\n                // time `if` becomes true\n                this.__invalidProps = this.__invalidProps || Object.create(null);\n                this.__invalidProps[root(prop)] = true;\n              }\n            }\n          }\n        });\n      }\n\n      if (!this.__instance) {\n        this.__instance = new this.__ctor();\n        wrap(parentNode).insertBefore(this.__instance.root, this);\n      } else {\n        this.__syncHostProperties();\n\n        var c$ = this.__instance.children;\n\n        if (c$ && c$.length) {\n          // Detect case where dom-if was re-attached in new position\n          var lastChild = wrap(this).previousSibling;\n\n          if (lastChild !== c$[c$.length - 1]) {\n            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\n              wrap(parentNode).insertBefore(n, this);\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  __syncHostProperties() {\n    var props = this.__invalidProps;\n\n    if (props) {\n      for (var prop in props) {\n        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n      }\n\n      this.__invalidProps = null;\n\n      this.__instance._flushProperties();\n    }\n  }\n\n  __teardownInstance() {\n    if (this.__instance) {\n      var c$ = this.__instance.children;\n\n      if (c$ && c$.length) {\n        // use first child parent, for case when dom-if may have been detached\n        var parent = wrap(c$[0]).parentNode; // Instance children may be disconnected from parents when dom-if\n        // detaches if a tree was innerHTML'ed\n\n        if (parent) {\n          parent = wrap(parent);\n\n          for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\n            parent.removeChild(n);\n          }\n        }\n      }\n\n      this.__instance = null;\n      this.__invalidProps = null;\n    }\n  }\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @return {void}\n   * @protected\n   * @suppress {visibility}\n   */\n\n\n  _showHideChildren() {\n    var hidden = this.__hideTemplateChildren__ || !this.if;\n\n    if (this.__instance) {\n      this.__instance._showHideChildren(hidden);\n    }\n  }\n\n}\ncustomElements.define(DomIf.is, DomIf);"
    },
    {
     "id": 203,
     "name": "../node_modules/@vaadin/vaadin-combo-box/theme/lumo/vaadin-combo-box-dropdown-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-overlay/theme/lumo/vaadin-overlay.js';\nimport '@vaadin/vaadin-lumo-styles/mixins/menu-overlay.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-combo-box-overlay\" theme-for=\"vaadin-combo-box-overlay\">\n  <template>\n    <style include=\"lumo-overlay lumo-menu-overlay-core\">\n      [part=\"content\"] {\n        padding: 0;\n      }\n\n      :host {\n        /* TODO: using a legacy mixin (unsupported) */\n        --iron-list-items-container: {\n          border-width: var(--lumo-space-xs);\n          border-style: solid;\n          border-color: transparent;\n        };\n      }\n\n      /* TODO: workaround ShadyCSS issue when using inside of the dom-if */\n      :host([opened]) {\n        --iron-list-items-container_-_border-width: var(--lumo-space-xs);\n        --iron-list-items-container_-_border-style: solid;\n        --iron-list-items-container_-_border-color: transparent;\n      }\n\n      /* Loading state */\n\n      /* When items are empty, the sinner needs some room */\n      :host(:not([closing])) [part~=\"content\"] {\n        min-height: calc(2 * var(--lumo-space-s) + var(--lumo-icon-size-s));\n      }\n\n      [part~=\"overlay\"] {\n        position: relative;\n      }\n\n      :host([loading]) [part~=\"loader\"] {\n        box-sizing: border-box;\n        width: var(--lumo-icon-size-s);\n        height: var(--lumo-icon-size-s);\n        position: absolute;\n        z-index: 1;\n        left: var(--lumo-space-s);\n        right: var(--lumo-space-s);\n        top: var(--lumo-space-s);\n        margin-left: auto;\n        margin-inline-start: auto;\n        margin-inline-end: 0;\n        border: 2px solid transparent;\n        border-color:\n          var(--lumo-primary-color-50pct)\n          var(--lumo-primary-color-50pct)\n          var(--lumo-primary-color)\n          var(--lumo-primary-color);\n        border-radius: calc(0.5 * var(--lumo-icon-size-s));\n        opacity: 0;\n        animation:\n          1s linear infinite lumo-combo-box-loader-rotate,\n          .3s .1s lumo-combo-box-loader-fade-in both;\n        pointer-events: none;\n      }\n\n      @keyframes lumo-combo-box-loader-fade-in {\n        0% {\n          opacity: 0;\n        }\n\n        100% {\n          opacity: 1;\n        }\n      }\n\n      @keyframes lumo-combo-box-loader-rotate {\n        0% {\n          transform: rotate(0deg);\n        }\n\n        100% {\n          transform: rotate(360deg);\n        }\n      }\n\n      /* RTL specific styles */\n\n      :host([loading][dir=\"rtl\"]) [part~=\"loader\"] {\n        left: auto;\n        margin-left: 0;\n        margin-right: auto;\n        margin-inline-start: 0;\n        margin-inline-end: auto;\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 204,
     "name": "../node_modules/@vaadin/vaadin-combo-box/theme/lumo/vaadin-combo-box-item-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-item/theme/lumo/vaadin-item.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-combo-box-item\" theme-for=\"vaadin-combo-box-item\">\n  <template>\n    <style include=\"lumo-item\">\n      /* TODO partly duplicated from vaadin-list-box styles. Should find a way to make it DRY */\n\n      :host {\n        cursor: default;\n        -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);\n        padding-left: calc(var(--lumo-border-radius) / 4);\n        padding-right: calc(var(--lumo-space-l) + var(--lumo-border-radius) / 4);\n        transition: background-color 100ms;\n        border-radius: var(--lumo-border-radius);\n        overflow: hidden;\n        --_lumo-item-selected-icon-display: block;\n      }\n\n      /* ShadyCSS workaround (show the selected item checkmark) */\n      :host::before {\n        display: block;\n      }\n\n      :host(:hover) {\n        background-color: var(--lumo-primary-color-10pct);\n      }\n\n      :host([focused]:not([disabled])) {\n        box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);\n      }\n\n      @media (pointer: coarse) {\n        :host(:hover) {\n          background-color: transparent;\n        }\n\n        :host([focused]:not([disabled])) {\n          box-shadow: none;\n        }\n      }\n\n      /* RTL specific styles */\n      :host([dir=\"rtl\"]) {\n        padding-right: calc(var(--lumo-border-radius) / 4);\n        padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius) / 4);\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 205,
     "name": "../node_modules/@polymer/iron-list/iron-list.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js';\nimport { IronResizableBehavior } from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport { IronScrollTargetBehavior } from '@polymer/iron-scroll-target-behavior/iron-scroll-target-behavior.js';\nimport { OptionalMutableDataBehavior } from '@polymer/polymer/lib/legacy/mutable-data-behavior.js';\nimport { Polymer } from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport { Templatizer } from '@polymer/polymer/lib/legacy/templatizer-behavior.js';\nimport { animationFrame, idlePeriod, microTask } from '@polymer/polymer/lib/utils/async.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { enqueueDebouncer, flush } from '@polymer/polymer/lib/utils/flush.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { matches, translate } from '@polymer/polymer/lib/utils/path.js';\nimport { TemplateInstanceBase } from '@polymer/polymer/lib/utils/templatize.js';\nvar IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/);\nvar IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nvar DEFAULT_PHYSICAL_COUNT = 3;\nvar HIDDEN_Y = '-10000px';\nvar SECRET_TABINDEX = -100;\n/**\n\n`iron-list` displays a virtual, 'infinite' list. The template inside\nthe iron-list element represents the DOM to create for each list item.\nThe `items` property specifies an array of list item data.\n\nFor performance reasons, not every item in the list is rendered at once;\ninstead a small subset of actual template elements *(enough to fill the\nviewport)* are rendered and reused as the user scrolls. As such, it is important\nthat all state of the list template is bound to the model driving it, since the\nview may be reused with a new model at any time. Particularly, any state that\nmay change as the result of a user interaction with the list item must be bound\nto the model to avoid view state inconsistency.\n\n### Sizing iron-list\n\n`iron-list` must either be explicitly sized, or delegate scrolling to an\nexplicitly sized parent. By \"explicitly sized\", we mean it either has an\nexplicit CSS `height` property set via a class or inline style, or else is sized\nby other layout means (e.g. the `flex` or `fit` classes).\n\n#### Flexbox - [jsbin](https://jsbin.com/vejoni/edit?html,output)\n\n```html\n<template is=\"x-list\">\n  <style>\n    :host {\n      display: block;\n      height: 100vh;\n      display: flex;\n      flex-direction: column;\n    }\n\n    iron-list {\n      flex: 1 1 auto;\n    }\n  </style>\n  <app-toolbar>App name</app-toolbar>\n  <iron-list items=\"[[items]]\">\n    <template>\n      <div>\n        ...\n      </div>\n    </template>\n  </iron-list>\n</template>\n```\n#### Explicit size - [jsbin](https://jsbin.com/vopucus/edit?html,output)\n```html\n<template is=\"x-list\">\n  <style>\n    :host {\n      display: block;\n    }\n\n    iron-list {\n      height: 100vh; /* don't use % values unless the parent element is sized.\n*\\/\n    }\n  </style>\n  <iron-list items=\"[[items]]\">\n    <template>\n      <div>\n        ...\n      </div>\n    </template>\n  </iron-list>\n</template>\n```\n#### Main document scrolling -\n[jsbin](https://jsbin.com/wevirow/edit?html,output)\n```html\n<head>\n  <style>\n    body {\n      height: 100vh;\n      margin: 0;\n      display: flex;\n      flex-direction: column;\n    }\n\n    app-toolbar {\n      position: fixed;\n      top: 0;\n      left: 0;\n      right: 0;\n    }\n\n    iron-list {\n      /* add padding since the app-toolbar is fixed at the top *\\/\n      padding-top: 64px;\n    }\n  </style>\n</head>\n<body>\n  <app-toolbar>App name</app-toolbar>\n  <iron-list scroll-target=\"document\">\n    <template>\n      <div>\n        ...\n      </div>\n    </template>\n  </iron-list>\n</body>\n```\n\n`iron-list` must be given a `<template>` which contains exactly one element. In\nthe examples above we used a `<div>`, but you can provide any element (including\ncustom elements).\n\n### Template model\n\nList item templates should bind to template models of the following structure:\n\n```js\n{\n  index: 0,        // index in the item array\n  selected: false, // true if the current item is selected\n  tabIndex: -1,    // a dynamically generated tabIndex for focus management\n  item: {}         // user data corresponding to items[index]\n}\n```\n\nAlternatively, you can change the property name used as data index by changing\nthe `indexAs` property. The `as` property defines the name of the variable to\nadd to the binding scope for the array.\n\nFor example, given the following `data` array:\n\n##### data.json\n\n```js\n[\n  {\"name\": \"Bob\"},\n  {\"name\": \"Tim\"},\n  {\"name\": \"Mike\"}\n]\n```\n\nThe following code would render the list (note the name property is bound from\nthe model object provided to the template scope):\n\n```html\n<iron-ajax url=\"data.json\" last-response=\"{{data}}\" auto></iron-ajax>\n<iron-list items=\"[[data]]\" as=\"item\">\n  <template>\n    <div>\n      Name: [[item.name]]\n    </div>\n  </template>\n</iron-list>\n```\n\n### Grid layout\n\n`iron-list` supports a grid layout in addition to linear layout by setting\nthe `grid` attribute.  In this case, the list template item must have both fixed\nwidth and height (e.g. via CSS). Based on this, the number of items\nper row are determined automatically based on the size of the list viewport.\n\n### Accessibility\n\n`iron-list` automatically manages the focus state for the items. It also\nprovides a `tabIndex` property within the template scope that can be used for\nkeyboard navigation. For example, users can press the up and down keys to move\nto previous and next items in the list:\n\n```html\n<iron-list items=\"[[data]]\" as=\"item\">\n  <template>\n    <div tabindex$=\"[[tabIndex]]\">\n      Name: [[item.name]]\n    </div>\n  </template>\n</iron-list>\n```\n\n### Styling\n\nYou can use the `--iron-list-items-container` mixin to style the container of\nitems:\n\n```css\niron-list {\n --iron-list-items-container: {\n    margin: auto;\n  };\n}\n```\n\n### Resizing\n\n`iron-list` lays out the items when it receives a notification via the\n`iron-resize` event. This event is fired by any element that implements\n`IronResizableBehavior`.\n\nBy default, elements such as `iron-pages`, `paper-tabs` or `paper-dialog` will\ntrigger this event automatically. If you hide the list manually (e.g. you use\n`display: none`) you might want to implement `IronResizableBehavior` or fire\nthis event manually right after the list became visible again. For example:\n\n```js\ndocument.querySelector('iron-list').fire('iron-resize');\n```\n\n### When should `<iron-list>` be used?\n\n`iron-list` should be used when a page has significantly more DOM nodes than the\nones visible on the screen. e.g. the page has 500 nodes, but only 20 are visible\nat a time. This is why we refer to it as a `virtual` list. In this case, a\n`dom-repeat` will still create 500 nodes which could slow down the web app, but\n`iron-list` will only create 20.\n\nHowever, having an `iron-list` does not mean that you can load all the data at\nonce. Say you have a million records in the database, you want to split the data\ninto pages so you can bring in a page at the time. The page could contain 500\nitems, and iron-list will only render 20.\n\n@element iron-list\n@demo demo/index.html\n\n*/\n\nPolymer({\n  /** @override */\n  _template: html`\n    <style>\n      :host {\n        display: block;\n      }\n\n      @media only screen and (-webkit-max-device-pixel-ratio: 1) {\n        :host {\n          will-change: transform;\n        }\n      }\n\n      #items {\n        @apply --iron-list-items-container;\n        position: relative;\n      }\n\n      :host(:not([grid])) #items > ::slotted(*) {\n        width: 100%;\n      }\n\n      #items > ::slotted(*) {\n        box-sizing: border-box;\n        margin: 0;\n        position: absolute;\n        top: 0;\n        will-change: transform;\n      }\n    </style>\n\n    <array-selector id=\"selector\" items=\"{{items}}\" selected=\"{{selectedItems}}\" selected-item=\"{{selectedItem}}\"></array-selector>\n\n    <div id=\"items\">\n      <slot></slot>\n    </div>\n`,\n  is: 'iron-list',\n  properties: {\n    /**\n     * An array containing items determining how many instances of the template\n     * to stamp and that that each template instance should bind to.\n     */\n    items: {\n      type: Array\n    },\n\n    /**\n     * The name of the variable to add to the binding scope for the array\n     * element associated with a given template instance.\n     */\n    as: {\n      type: String,\n      value: 'item'\n    },\n\n    /**\n     * The name of the variable to add to the binding scope with the index\n     * for the row.\n     */\n    indexAs: {\n      type: String,\n      value: 'index'\n    },\n\n    /**\n     * The name of the variable to add to the binding scope to indicate\n     * if the row is selected.\n     */\n    selectedAs: {\n      type: String,\n      value: 'selected'\n    },\n\n    /**\n     * When true, the list is rendered as a grid. Grid items must have\n     * fixed width and height set via CSS. e.g.\n     *\n     * ```html\n     * <iron-list grid>\n     *   <template>\n     *      <div style=\"width: 100px; height: 100px;\"> 100x100 </div>\n     *   </template>\n     * </iron-list>\n     * ```\n     */\n    grid: {\n      type: Boolean,\n      value: false,\n      reflectToAttribute: true,\n      observer: '_gridChanged'\n    },\n\n    /**\n     * When true, tapping a row will select the item, placing its data model\n     * in the set of selected items retrievable via the selection property.\n     *\n     * Note that tapping focusable elements within the list item will not\n     * result in selection, since they are presumed to have their * own action.\n     */\n    selectionEnabled: {\n      type: Boolean,\n      value: false\n    },\n\n    /**\n     * When `multiSelection` is false, this is the currently selected item, or\n     * `null` if no item is selected.\n     */\n    selectedItem: {\n      type: Object,\n      notify: true\n    },\n\n    /**\n     * When `multiSelection` is true, this is an array that contains the\n     * selected items.\n     */\n    selectedItems: {\n      type: Object,\n      notify: true\n    },\n\n    /**\n     * When `true`, multiple items may be selected at once (in this case,\n     * `selected` is an array of currently selected items).  When `false`,\n     * only one item may be selected at a time.\n     */\n    multiSelection: {\n      type: Boolean,\n      value: false\n    },\n\n    /**\n     * The offset top from the scrolling element to the iron-list element.\n     * This value can be computed using the position returned by\n     * `getBoundingClientRect()` although it's preferred to use a constant value\n     * when possible.\n     *\n     * This property is useful when an external scrolling element is used and\n     * there's some offset between the scrolling element and the list. For\n     * example: a header is placed above the list.\n     */\n    scrollOffset: {\n      type: Number,\n      value: 0\n    }\n  },\n  observers: ['_itemsChanged(items.*)', '_selectionEnabledChanged(selectionEnabled)', '_multiSelectionChanged(multiSelection)', '_setOverflow(scrollTarget, scrollOffset)'],\n  behaviors: [Templatizer, IronResizableBehavior, IronScrollTargetBehavior, OptionalMutableDataBehavior],\n\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n\n  /**\n   * The currently focused physical item.\n   */\n  _focusedItem: null,\n\n  /**\n   * The virtual index of the focused item.\n   */\n  _focusedVirtualIndex: -1,\n\n  /**\n   * The physical index of the focused item.\n   */\n  _focusedPhysicalIndex: -1,\n\n  /**\n   * The the item that is focused if it is moved offscreen.\n   * @private {?HTMLElement}\n   */\n  _offscreenFocusedItem: null,\n\n  /**\n   * The item that backfills the `_offscreenFocusedItem` in the physical items\n   * list when that item is moved offscreen.\n   * @type {?HTMLElement}\n   */\n  _focusBackfillItem: null,\n\n  /**\n   * The maximum items per row\n   */\n  _itemsPerRow: 1,\n\n  /**\n   * The width of each grid item\n   */\n  _itemWidth: 0,\n\n  /**\n   * The height of the row in grid layout.\n   */\n  _rowHeight: 0,\n\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n\n  /**\n   * Needed to pass event.model property to declarative event handlers -\n   * see polymer/polymer#4339.\n   */\n  _parentModel: true,\n\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    var size = this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;\n    return size - this._viewportHeight;\n  },\n\n  /**\n   * The parent node for the _userTemplate.\n   */\n  get _itemsParent() {\n    return dom(dom(this._userTemplate).parentNode);\n  },\n\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    var virtualCount = this._convertIndexToCompleteRow(this._virtualCount);\n\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n\n    if (this.grid) {\n      val = val - val % this._itemsPerRow;\n    }\n\n    this._virtualStartVal = val;\n  },\n\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val = val % this._physicalCount;\n\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n\n    if (this.grid) {\n      val = val - val % this._itemsPerRow;\n    }\n\n    this._physicalStartVal = val;\n  },\n\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    var idx = this._firstVisibleIndexVal;\n\n    if (idx == null) {\n      var physicalOffset = this._physicalTop + this._scrollOffset;\n      idx = this._iterateItems(function (pidx, vidx) {\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n\n        if (physicalOffset > this._scrollPosition) {\n          return this.grid ? vidx - vidx % this._itemsPerRow : vidx;\n        } // Handle a partially rendered final row in grid mode\n\n\n        if (this.grid && this._virtualCount - 1 === vidx) {\n          return vidx - vidx % this._itemsPerRow;\n        }\n      }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n\n    return idx;\n  },\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    var idx = this._lastVisibleIndexVal;\n\n    if (idx == null) {\n      if (this.grid) {\n        idx = Math.min(this._virtualCount, this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow - 1);\n      } else {\n        var physicalOffset = this._physicalTop + this._scrollOffset;\n\n        this._iterateItems(function (pidx, vidx) {\n          if (physicalOffset < this._scrollBottom) {\n            idx = vidx;\n          }\n\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n        });\n      }\n\n      this._lastVisibleIndexVal = idx;\n    }\n\n    return idx;\n  },\n\n  get _defaultScrollTarget() {\n    return this;\n  },\n\n  get _virtualRowCount() {\n    return Math.ceil(this._virtualCount / this._itemsPerRow);\n  },\n\n  get _estRowsInView() {\n    return Math.ceil(this._viewportHeight / this._rowHeight);\n  },\n\n  get _physicalRows() {\n    return Math.ceil(this._physicalCount / this._itemsPerRow);\n  },\n\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n\n  /** @override */\n  ready: function () {\n    this.addEventListener('focus', this._didFocus.bind(this), true);\n  },\n\n  /** @override */\n  attached: function () {\n    this._debounce('_render', this._render, animationFrame); // `iron-resize` is fired when the list is attached if the event is added\n    // before attached causing unnecessary work.\n\n\n    this.listen(this, 'iron-resize', '_resizeHandler');\n    this.listen(this, 'keydown', '_keydownHandler');\n  },\n\n  /** @override */\n  detached: function () {\n    this.unlisten(this, 'iron-resize', '_resizeHandler');\n    this.unlisten(this, 'keydown', '_keydownHandler');\n  },\n\n  /**\n   * Set the overflow property if this element has its own scrolling region\n   */\n  _setOverflow: function (scrollTarget) {\n    this.style.webkitOverflowScrolling = scrollTarget === this ? 'touch' : '';\n    this.style.overflowY = scrollTarget === this ? 'auto' : ''; // Clear cache.\n\n    this._lastVisibleIndexVal = null;\n    this._firstVisibleIndexVal = null;\n\n    this._debounce('_render', this._render, animationFrame);\n  },\n\n  /**\n   * Invoke this method if you dynamically update the viewport's\n   * size or CSS padding.\n   *\n   * @method updateViewportBoundaries\n   */\n  updateViewportBoundaries: function () {\n    var styles = window.getComputedStyle(this);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.$.items.offsetWidth;\n    this._viewportHeight = this._scrollTargetHeight;\n    this.grid && this._updateGridMetrics();\n  },\n\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler: function () {\n    var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    var delta = scrollTop - this._scrollPosition;\n    var isScrollingDown = delta >= 0; // Track the current scroll position.\n\n    this._scrollPosition = scrollTop; // Clear indexes for first and last visible indexes.\n\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null; // Random access.\n\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta = delta - this._scrollOffset;\n\n      var idxAdjustment = Math.round(delta / this._physicalAverage) * this._itemsPerRow;\n\n      this._virtualStart = this._virtualStart + idxAdjustment;\n      this._physicalStart = this._physicalStart + idxAdjustment; // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n\n      this._physicalTop = Math.min(Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage, this._scrollPosition);\n\n      this._update();\n    } else if (this._physicalCount > 0) {\n      var reusables = this._getReusables(isScrollingDown);\n\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart = this._virtualStart + reusables.indexes.length;\n        this._physicalStart = this._physicalStart + reusables.indexes.length;\n      } else {\n        this._virtualStart = this._virtualStart - reusables.indexes.length;\n        this._physicalStart = this._physicalStart - reusables.indexes.length;\n      }\n\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), microTask);\n    }\n  },\n\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables: function (fromTop) {\n    var ith, lastIth, offsetContent, physicalItemHeight;\n    var idxs = [];\n    var protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    var virtualStart = this._virtualStart;\n    var virtualEnd = this._virtualEnd;\n    var physicalCount = this._physicalCount;\n    var top = this._physicalTop + this._scrollOffset;\n    var bottom = this._physicalBottom + this._scrollOffset; // This may be called outside of a scrollHandler, so use last cached position\n\n    var scrollTop = this._scrollPosition;\n    var scrollBottom = this._scrollBottom;\n\n    if (fromTop) {\n      ith = this._physicalStart;\n      lastIth = this._physicalEnd;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      lastIth = this._physicalStart;\n      offsetContent = bottom - scrollBottom;\n    }\n\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent = offsetContent - physicalItemHeight;\n\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        } // Check that the index is not visible.\n\n\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n\n        idxs.push(ith);\n        top = top + physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        } // Check that the index is not visible.\n\n\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n\n        idxs.push(ith);\n        top = top - physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n\n    return {\n      indexes: idxs,\n      physicalTop: top - this._scrollOffset\n    };\n  },\n\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update: function (itemSet, movingUp) {\n    if (itemSet && itemSet.length === 0 || this._physicalCount === 0) {\n      return;\n    }\n\n    this._manageFocus();\n\n    this._assignModels(itemSet);\n\n    this._updateMetrics(itemSet); // Adjust offset after measuring.\n\n\n    if (movingUp) {\n      while (movingUp.length) {\n        var idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n\n    this._positionItems();\n\n    this._updateScrollerSize();\n  },\n\n  /**\n   * Creates a pool of DOM elements and attaches them to the local dom.\n   *\n   * @param {number} size Size of the pool\n   */\n  _createPool: function (size) {\n    this._ensureTemplatized();\n\n    var i, inst;\n    var physicalItems = new Array(size);\n\n    for (i = 0; i < size; i++) {\n      inst = this.stamp(null); // TODO(blasten):\n      // First element child is item; Safari doesn't support children[0]\n      // on a doc fragment. Test this to see if it still matters.\n\n      physicalItems[i] = inst.root.querySelector('*');\n\n      this._itemsParent.appendChild(inst.root);\n    }\n\n    return physicalItems;\n  },\n  _isClientFull: function () {\n    return this._scrollBottom != 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;\n  },\n\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded: function (count) {\n    var nextPhysicalCount = this._clamp(this._physicalCount + count, DEFAULT_PHYSICAL_COUNT, this._virtualCount - this._virtualStart);\n\n    nextPhysicalCount = this._convertIndexToCompleteRow(nextPhysicalCount);\n\n    if (this.grid) {\n      var correction = nextPhysicalCount % this._itemsPerRow;\n\n      if (correction && nextPhysicalCount - correction <= this._physicalCount) {\n        nextPhysicalCount += this._itemsPerRow;\n      }\n\n      nextPhysicalCount -= correction;\n    }\n\n    var delta = nextPhysicalCount - this._physicalCount;\n    var nextIncrease = Math.round(this._physicalCount * 0.5);\n\n    if (delta < 0) {\n      return;\n    }\n\n    if (delta > 0) {\n      var ts = window.performance.now(); // Concat arrays in place.\n\n      [].push.apply(this._physicalItems, this._createPool(delta)); // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n\n      for (var i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n\n      this._physicalCount = this._physicalCount + delta; // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n\n      if (this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd) {\n        this._physicalStart = this._physicalStart + delta;\n      }\n\n      this._update();\n\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    } // The upper bounds is not fixed when dealing with a grid that doesn't\n    // fill it's last row with the exact number of items per row.\n\n\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {// Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)), idlePeriod);\n    }\n  },\n\n  /**\n   * Renders the a new list.\n   */\n  _render: function () {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n\n    if (this._physicalCount !== 0) {\n      var reusables = this._getReusables(true);\n\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart = this._virtualStart + reusables.indexes.length;\n      this._physicalStart = this._physicalStart + reusables.indexes.length;\n\n      this._update(reusables.indexes);\n\n      this._update();\n\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n\n  /**\n   * Templetizes the user template.\n   */\n  _ensureTemplatized: function () {\n    if (this.ctor) {\n      return;\n    }\n\n    this._userTemplate =\n    /** @type {!HTMLTemplateElement} */\n    this.queryEffectiveChildren('template');\n\n    if (!this._userTemplate) {\n      console.warn('iron-list requires a template to be provided in light-dom');\n    }\n\n    var instanceProps = {};\n    instanceProps.__key__ = true;\n    instanceProps[this.as] = true;\n    instanceProps[this.indexAs] = true;\n    instanceProps[this.selectedAs] = true;\n    instanceProps.tabIndex = true;\n    this._instanceProps = instanceProps;\n    this.templatize(this._userTemplate, this.mutableData);\n  },\n  _gridChanged: function (newGrid, oldGrid) {\n    if (typeof oldGrid === 'undefined') return;\n    this.notifyResize();\n    flush();\n    newGrid && this._updateGridMetrics();\n  },\n\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged: function (change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      this._physicalCount = this._physicalCount || 0;\n      this._physicalItems = this._physicalItems || [];\n      this._physicalSizes = this._physicalSizes || [];\n      this._physicalStart = 0;\n\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n\n      this._removeFocusedItem();\n\n      this._debounce('_render', this._render, animationFrame);\n    } else if (change.path === 'items.splices') {\n      this._adjustVirtualIndex(change.value.indexSplices);\n\n      this._virtualCount = this.items ? this.items.length : 0; // Only blur if at least one item is added or removed.\n\n      var itemAddedOrRemoved = change.value.indexSplices.some(function (splice) {\n        return splice.addedCount > 0 || splice.removed.length > 0;\n      });\n\n      if (itemAddedOrRemoved) {\n        // Only blur activeElement if it is a descendant of the list (#505,\n        // #507).\n        var activeElement = this._getActiveElement();\n\n        if (this.contains(activeElement)) {\n          activeElement.blur();\n        }\n      } // Render only if the affected index is rendered.\n\n\n      var affectedIndexRendered = change.value.indexSplices.some(function (splice) {\n        return splice.index + splice.addedCount >= this._virtualStart && splice.index <= this._virtualEnd;\n      }, this);\n\n      if (!this._isClientFull() || affectedIndexRendered) {\n        this._debounce('_render', this._render, animationFrame);\n      }\n    } else if (change.path !== 'items.length') {\n      this._forwardItemPath(change.path, change.value);\n    }\n  },\n  _forwardItemPath: function (path, value) {\n    path = path.slice(6); // 'items.'.length == 6\n\n    var dot = path.indexOf('.');\n\n    if (dot === -1) {\n      dot = path.length;\n    }\n\n    var isIndexRendered;\n    var pidx;\n    var inst;\n    var offscreenInstance = this.modelForElement(this._offscreenFocusedItem);\n    var vidx = parseInt(path.substring(0, dot), 10);\n    isIndexRendered = this._isIndexRendered(vidx);\n\n    if (isIndexRendered) {\n      pidx = this._getPhysicalIndex(vidx);\n      inst = this.modelForElement(this._physicalItems[pidx]);\n    } else if (offscreenInstance) {\n      inst = offscreenInstance;\n    }\n\n    if (!inst || inst[this.indexAs] !== vidx) {\n      return;\n    }\n\n    path = path.substring(dot + 1);\n    path = this.as + (path ? '.' + path : '');\n\n    inst._setPendingPropertyOrPath(path, value, false, true);\n\n    inst._flushProperties && inst._flushProperties(); // TODO(blasten): V1 doesn't do this and it's a bug\n\n    if (isIndexRendered) {\n      this._updateMetrics([pidx]);\n\n      this._positionItems();\n\n      this._updateScrollerSize();\n    }\n  },\n\n  /**\n   * @param {!Array<!Object>} splices\n   */\n  _adjustVirtualIndex: function (splices) {\n    splices.forEach(function (splice) {\n      // deselect removed items\n      splice.removed.forEach(this._removeItem, this); // We only need to care about changes happening above the current position\n\n      if (splice.index < this._virtualStart) {\n        var delta = Math.max(splice.addedCount - splice.removed.length, splice.index - this._virtualStart);\n        this._virtualStart = this._virtualStart + delta;\n\n        if (this._focusedVirtualIndex >= 0) {\n          this._focusedVirtualIndex = this._focusedVirtualIndex + delta;\n        }\n      }\n    }, this);\n  },\n  _removeItem: function (item) {\n    this.$.selector.deselect(item); // remove the current focused item\n\n    if (this._focusedItem && this.modelForElement(this._focusedItem)[this.as] === item) {\n      this._removeFocusedItem();\n    }\n  },\n\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems: function (fn, itemSet) {\n    var pidx, vidx, rtn, i;\n\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx: function (pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n\n  /**\n   * Assigns the data models to a given set of items.\n   * @param {!Array<number>=} itemSet\n   */\n  _assignModels: function (itemSet) {\n    this._iterateItems(function (pidx, vidx) {\n      var el = this._physicalItems[pidx];\n      var item = this.items && this.items[vidx];\n\n      if (item != null) {\n        var inst = this.modelForElement(el);\n        inst.__key__ = null;\n\n        this._forwardProperty(inst, this.as, item);\n\n        this._forwardProperty(inst, this.selectedAs, this.$.selector.isSelected(item));\n\n        this._forwardProperty(inst, this.indexAs, vidx);\n\n        this._forwardProperty(inst, 'tabIndex', this._focusedVirtualIndex === vidx ? 0 : -1);\n\n        this._physicalIndexForKey[inst.__key__] = pidx;\n        inst._flushProperties && inst._flushProperties(true);\n        el.removeAttribute('hidden');\n      } else {\n        el.setAttribute('hidden', '');\n      }\n    }, itemSet);\n  },\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics: function (itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n    var newPhysicalSize = 0;\n    var oldPhysicalSize = 0;\n    var prevAvgCount = this._physicalAverageCount;\n    var prevPhysicalAvg = this._physicalAverage;\n\n    this._iterateItems(function (pidx, vidx) {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    if (this.grid) {\n      this._updateGridMetrics();\n\n      this._physicalSize = Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n    } else {\n      oldPhysicalSize = this._itemsPerRow === 1 ? oldPhysicalSize : Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n      this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n      this._itemsPerRow = 1;\n    } // Update the average if it measured something.\n\n\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round((prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount);\n    }\n  },\n  _updateGridMetrics: function () {\n    this._itemWidth = this._physicalCount > 0 ? this._physicalItems[0].getBoundingClientRect().width : 200;\n    this._rowHeight = this._physicalCount > 0 ? this._physicalItems[0].offsetHeight : 200;\n    this._itemsPerRow = this._itemWidth ? Math.floor(this._viewportWidth / this._itemWidth) : this._itemsPerRow;\n  },\n\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems: function () {\n    this._adjustScrollPosition();\n\n    var y = this._physicalTop;\n\n    if (this.grid) {\n      var totalItemWidth = this._itemsPerRow * this._itemWidth;\n      var rowOffset = (this._viewportWidth - totalItemWidth) / 2;\n\n      this._iterateItems(function (pidx, vidx) {\n        var modulus = vidx % this._itemsPerRow;\n        var x = Math.floor(modulus * this._itemWidth + rowOffset);\n\n        if (this._isRTL) {\n          x = x * -1;\n        }\n\n        this.translate3d(x + 'px', y + 'px', 0, this._physicalItems[pidx]);\n\n        if (this._shouldRenderNextRow(vidx)) {\n          y += this._rowHeight;\n        }\n      });\n    } else {\n      var order = [];\n\n      this._iterateItems(function (pidx, vidx) {\n        var item = this._physicalItems[pidx];\n        this.translate3d(0, y + 'px', 0, item);\n        y += this._physicalSizes[pidx];\n        var itemId = item.id;\n\n        if (itemId) {\n          order.push(itemId);\n        }\n      });\n\n      if (order.length) {\n        this.setAttribute('aria-owns', order.join(' '));\n      }\n    }\n  },\n  _getPhysicalSizeIncrement: function (pidx) {\n    if (!this.grid) {\n      return this._physicalSizes[pidx];\n    }\n\n    if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {\n      return 0;\n    }\n\n    return this._rowHeight;\n  },\n\n  /**\n   * Returns, based on the current index,\n   * whether or not the next index will need\n   * to be rendered on a new row.\n   *\n   * @param {number} vidx Virtual index\n   * @return {boolean}\n   */\n  _shouldRenderNextRow: function (vidx) {\n    return vidx % this._itemsPerRow === this._itemsPerRow - 1;\n  },\n\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition: function () {\n    var deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0); // Note: the delta can be positive or negative.\n\n    if (deltaHeight !== 0) {\n      this._physicalTop = this._physicalTop - deltaHeight; // This may be called outside of a scrollHandler, so use last cached position\n\n      var scrollTop = this._scrollPosition; // juking scroll position during interial scrolling on iOS is no bueno\n\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition: function (pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize: function (forceUpdate) {\n    if (this.grid) {\n      this._estScrollHeight = this._virtualRowCount * this._rowHeight;\n    } else {\n      this._estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n    }\n\n    forceUpdate = forceUpdate || this._scrollHeight === 0;\n    forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;\n    forceUpdate = forceUpdate || this.grid && this.$.items.style.height < this._estScrollHeight; // Amortize height adjustment, so it won't trigger large repaints too often.\n\n    if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._viewportHeight) {\n      this.$.items.style.height = this._estScrollHeight + 'px';\n      this._scrollHeight = this._estScrollHeight;\n    }\n  },\n\n  /**\n   * Scroll to a specific item in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToItem\n   * @param {(Object)} item The item to be scrolled to\n   */\n  scrollToItem: function (item) {\n    return this.scrollToIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex: function (idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n\n    flush(); // Items should have been rendered prior scrolling to an index.\n\n    if (this._physicalCount === 0) {\n      return;\n    }\n\n    idx = this._clamp(idx, 0, this._virtualCount - 1); // Update the virtual start only when needed.\n\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = this.grid ? idx - this._itemsPerRow * 2 : idx - 1;\n    }\n\n    this._manageFocus();\n\n    this._assignModels();\n\n    this._updateMetrics(); // Estimate new physical offset.\n\n\n    this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;\n    var currentTopItem = this._physicalStart;\n    var currentVirtualItem = this._virtualStart;\n    var targetOffsetTop = 0;\n    var hiddenContentSize = this._hiddenContentSize; // scroll to the item as much as we can.\n\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem++;\n    }\n\n    this._updateScrollerSize(true);\n\n    this._positionItems();\n\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n\n    this._increasePoolIfNeeded(0); // clear cached visible index.\n\n\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage: function () {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler: function () {\n    this._debounce('_render', function () {\n      // clear cached visible index.\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n\n      if (this._isVisible) {\n        this.updateViewportBoundaries(); // Reinstall the scroll event listener.\n\n        this.toggleScrollListener(true);\n\n        this._resetAverage();\n\n        this._render();\n      } else {\n        // Uninstall the scroll event listener.\n        this.toggleScrollListener(false);\n      }\n    }, animationFrame);\n  },\n\n  /**\n   * Selects the given item.\n   *\n   * @method selectItem\n   * @param {Object} item The item instance.\n   */\n  selectItem: function (item) {\n    return this.selectIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Selects the item at the given index in the items array.\n   *\n   * @method selectIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  selectIndex: function (index) {\n    if (index < 0 || index >= this._virtualCount) {\n      return;\n    }\n\n    if (!this.multiSelection && this.selectedItem) {\n      this.clearSelection();\n    }\n\n    if (this._isIndexRendered(index)) {\n      var model = this.modelForElement(this._physicalItems[this._getPhysicalIndex(index)]);\n\n      if (model) {\n        model[this.selectedAs] = true;\n      }\n\n      this.updateSizeForIndex(index);\n    }\n\n    this.$.selector.selectIndex(index);\n  },\n\n  /**\n   * Deselects the given item.\n   *\n   * @method deselect\n   * @param {Object} item The item instance.\n   */\n  deselectItem: function (item) {\n    return this.deselectIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Deselects the item at the given index in the items array.\n   *\n   * @method deselectIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  deselectIndex: function (index) {\n    if (index < 0 || index >= this._virtualCount) {\n      return;\n    }\n\n    if (this._isIndexRendered(index)) {\n      var model = this.modelForElement(this._physicalItems[this._getPhysicalIndex(index)]);\n      model[this.selectedAs] = false;\n      this.updateSizeForIndex(index);\n    }\n\n    this.$.selector.deselectIndex(index);\n  },\n\n  /**\n   * Selects or deselects a given item depending on whether the item\n   * has already been selected.\n   *\n   * @method toggleSelectionForItem\n   * @param {Object} item The item object.\n   */\n  toggleSelectionForItem: function (item) {\n    return this.toggleSelectionForIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Selects or deselects the item at the given index in the items array\n   * depending on whether the item has already been selected.\n   *\n   * @method toggleSelectionForIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  toggleSelectionForIndex: function (index) {\n    var isSelected = this.$.selector.isIndexSelected ? this.$.selector.isIndexSelected(index) : this.$.selector.isSelected(this.items[index]);\n    isSelected ? this.deselectIndex(index) : this.selectIndex(index);\n  },\n\n  /**\n   * Clears the current selection in the list.\n   *\n   * @method clearSelection\n   */\n  clearSelection: function () {\n    this._iterateItems(function (pidx, vidx) {\n      this.modelForElement(this._physicalItems[pidx])[this.selectedAs] = false;\n    });\n\n    this.$.selector.clearSelection();\n  },\n\n  /**\n   * Add an event listener to `tap` if `selectionEnabled` is true,\n   * it will remove the listener otherwise.\n   */\n  _selectionEnabledChanged: function (selectionEnabled) {\n    var handler = selectionEnabled ? this.listen : this.unlisten;\n    handler.call(this, this, 'tap', '_selectionHandler');\n  },\n\n  /**\n   * Select an item from an event object.\n   */\n  _selectionHandler: function (e) {\n    var model = this.modelForElement(e.target);\n\n    if (!model) {\n      return;\n    }\n\n    var modelTabIndex, activeElTabIndex;\n    var target = dom(e).path[0];\n\n    var activeEl = this._getActiveElement();\n\n    var physicalItem = this._physicalItems[this._getPhysicalIndex(model[this.indexAs])]; // Safari does not focus certain form controls via mouse\n    // https://bugs.webkit.org/show_bug.cgi?id=118043\n\n\n    if (target.localName === 'input' || target.localName === 'button' || target.localName === 'select') {\n      return;\n    } // Set a temporary tabindex\n\n\n    modelTabIndex = model.tabIndex;\n    model.tabIndex = SECRET_TABINDEX;\n    activeElTabIndex = activeEl ? activeEl.tabIndex : -1;\n    model.tabIndex = modelTabIndex; // Only select the item if the tap wasn't on a focusable child\n    // or the element bound to `tabIndex`\n\n    if (activeEl && physicalItem !== activeEl && physicalItem.contains(activeEl) && activeElTabIndex !== SECRET_TABINDEX) {\n      return;\n    }\n\n    this.toggleSelectionForItem(model[this.as]);\n  },\n  _multiSelectionChanged: function (multiSelection) {\n    this.clearSelection();\n    this.$.selector.multi = multiSelection;\n  },\n\n  /**\n   * Updates the size of a given list item.\n   *\n   * @method updateSizeForItem\n   * @param {Object} item The item instance.\n   */\n  updateSizeForItem: function (item) {\n    return this.updateSizeForIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Updates the size of the item at the given index in the items array.\n   *\n   * @method updateSizeForIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  updateSizeForIndex: function (index) {\n    if (!this._isIndexRendered(index)) {\n      return null;\n    }\n\n    this._updateMetrics([this._getPhysicalIndex(index)]);\n\n    this._positionItems();\n\n    return null;\n  },\n\n  /**\n   * Creates a temporary backfill item in the rendered pool of physical items\n   * to replace the main focused item. The focused item has tabIndex = 0\n   * and might be currently focused by the user.\n   *\n   * This dynamic replacement helps to preserve the focus state.\n   */\n  _manageFocus: function () {\n    var fidx = this._focusedVirtualIndex;\n\n    if (fidx >= 0 && fidx < this._virtualCount) {\n      // if it's a valid index, check if that index is rendered\n      // in a physical item.\n      if (this._isIndexRendered(fidx)) {\n        this._restoreFocusedItem();\n      } else {\n        this._createFocusBackfillItem();\n      }\n    } else if (this._virtualCount > 0 && this._physicalCount > 0) {\n      // otherwise, assign the initial focused index.\n      this._focusedPhysicalIndex = this._physicalStart;\n      this._focusedVirtualIndex = this._virtualStart;\n      this._focusedItem = this._physicalItems[this._physicalStart];\n    }\n  },\n\n  /**\n   * Converts a random index to the index of the item that completes it's row.\n   * Allows for better order and fill computation when grid == true.\n   */\n  _convertIndexToCompleteRow: function (idx) {\n    // when grid == false _itemPerRow can be unset.\n    this._itemsPerRow = this._itemsPerRow || 1;\n    return this.grid ? Math.ceil(idx / this._itemsPerRow) * this._itemsPerRow : idx;\n  },\n  _isIndexRendered: function (idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n  _isIndexVisible: function (idx) {\n    return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;\n  },\n  _getPhysicalIndex: function (vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n  focusItem: function (idx) {\n    this._focusPhysicalItem(idx);\n  },\n  _focusPhysicalItem: function (idx) {\n    if (idx < 0 || idx >= this._virtualCount) {\n      return;\n    }\n\n    this._restoreFocusedItem(); // scroll to index to make sure it's rendered\n\n\n    if (!this._isIndexRendered(idx)) {\n      this.scrollToIndex(idx);\n    }\n\n    var physicalItem = this._physicalItems[this._getPhysicalIndex(idx)];\n\n    var model = this.modelForElement(physicalItem);\n    var focusable; // set a secret tab index\n\n    model.tabIndex = SECRET_TABINDEX; // check if focusable element is the physical item\n\n    if (physicalItem.tabIndex === SECRET_TABINDEX) {\n      focusable = physicalItem;\n    } // search for the element which tabindex is bound to the secret tab index\n\n\n    if (!focusable) {\n      focusable = dom(physicalItem).querySelector('[tabindex=\"' + SECRET_TABINDEX + '\"]');\n    } // restore the tab index\n\n\n    model.tabIndex = 0; // focus the focusable element\n\n    this._focusedVirtualIndex = idx;\n    focusable && focusable.focus();\n  },\n  _removeFocusedItem: function () {\n    if (this._offscreenFocusedItem) {\n      this._itemsParent.removeChild(this._offscreenFocusedItem);\n    }\n\n    this._offscreenFocusedItem = null;\n    this._focusBackfillItem = null;\n    this._focusedItem = null;\n    this._focusedVirtualIndex = -1;\n    this._focusedPhysicalIndex = -1;\n  },\n  _createFocusBackfillItem: function () {\n    var fpidx = this._focusedPhysicalIndex;\n\n    if (this._offscreenFocusedItem || this._focusedVirtualIndex < 0) {\n      return;\n    }\n\n    if (!this._focusBackfillItem) {\n      // Create a physical item.\n      var inst = this.stamp(null);\n      this._focusBackfillItem =\n      /** @type {!HTMLElement} */\n      inst.root.querySelector('*');\n\n      this._itemsParent.appendChild(inst.root);\n    } // Set the offcreen focused physical item.\n\n\n    this._offscreenFocusedItem = this._physicalItems[fpidx];\n    this.modelForElement(this._offscreenFocusedItem).tabIndex = 0;\n    this._physicalItems[fpidx] = this._focusBackfillItem;\n    this._focusedPhysicalIndex = fpidx; // Hide the focused physical.\n\n    this.translate3d(0, HIDDEN_Y, 0, this._offscreenFocusedItem);\n  },\n  _restoreFocusedItem: function () {\n    if (!this._offscreenFocusedItem || this._focusedVirtualIndex < 0) {\n      return;\n    } // Assign models to the focused index.\n\n\n    this._assignModels(); // Get the new physical index for the focused index.\n\n\n    var fpidx = this._focusedPhysicalIndex = this._getPhysicalIndex(this._focusedVirtualIndex);\n\n    var onScreenItem = this._physicalItems[fpidx];\n\n    if (!onScreenItem) {\n      return;\n    }\n\n    var onScreenInstance = this.modelForElement(onScreenItem);\n    var offScreenInstance = this.modelForElement(this._offscreenFocusedItem); // Restores the physical item only when it has the same model\n    // as the offscreen one. Use key for comparison since users can set\n    // a new item via set('items.idx').\n\n    if (onScreenInstance[this.as] === offScreenInstance[this.as]) {\n      // Flip the focus backfill.\n      this._focusBackfillItem = onScreenItem;\n      onScreenInstance.tabIndex = -1; // Restore the focused physical item.\n\n      this._physicalItems[fpidx] = this._offscreenFocusedItem; // Hide the physical item that backfills.\n\n      this.translate3d(0, HIDDEN_Y, 0, this._focusBackfillItem);\n    } else {\n      this._removeFocusedItem();\n\n      this._focusBackfillItem = null;\n    }\n\n    this._offscreenFocusedItem = null;\n  },\n  _didFocus: function (e) {\n    var targetModel = this.modelForElement(e.target);\n    var focusedModel = this.modelForElement(this._focusedItem);\n    var hasOffscreenFocusedItem = this._offscreenFocusedItem !== null;\n    var fidx = this._focusedVirtualIndex;\n\n    if (!targetModel) {\n      return;\n    }\n\n    if (focusedModel === targetModel) {\n      // If the user focused the same item, then bring it into view if it's not\n      // visible.\n      if (!this._isIndexVisible(fidx)) {\n        this.scrollToIndex(fidx);\n      }\n    } else {\n      this._restoreFocusedItem(); // Restore tabIndex for the currently focused item.\n\n\n      if (focusedModel) {\n        focusedModel.tabIndex = -1;\n      } // Set the tabIndex for the next focused item.\n\n\n      targetModel.tabIndex = 0;\n      fidx = targetModel[this.indexAs];\n      this._focusedVirtualIndex = fidx;\n      this._focusedPhysicalIndex = this._getPhysicalIndex(fidx);\n      this._focusedItem = this._physicalItems[this._focusedPhysicalIndex];\n\n      if (hasOffscreenFocusedItem && !this._offscreenFocusedItem) {\n        this._update();\n      }\n    }\n  },\n  _keydownHandler: function (e) {\n    switch (e.keyCode) {\n      case\n      /* ARROW_DOWN */\n      40:\n        if (this._focusedVirtualIndex < this._virtualCount - 1) e.preventDefault();\n\n        this._focusPhysicalItem(this._focusedVirtualIndex + (this.grid ? this._itemsPerRow : 1));\n\n        break;\n\n      case\n      /* ARROW_RIGHT */\n      39:\n        if (this.grid) this._focusPhysicalItem(this._focusedVirtualIndex + (this._isRTL ? -1 : 1));\n        break;\n\n      case\n      /* ARROW_UP */\n      38:\n        if (this._focusedVirtualIndex > 0) e.preventDefault();\n\n        this._focusPhysicalItem(this._focusedVirtualIndex - (this.grid ? this._itemsPerRow : 1));\n\n        break;\n\n      case\n      /* ARROW_LEFT */\n      37:\n        if (this.grid) this._focusPhysicalItem(this._focusedVirtualIndex + (this._isRTL ? 1 : -1));\n        break;\n\n      case\n      /* ENTER */\n      13:\n        this._focusPhysicalItem(this._focusedVirtualIndex);\n\n        if (this.selectionEnabled) this._selectionHandler(e);\n        break;\n    }\n  },\n  _clamp: function (v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n  _debounce: function (name, cb, asyncModule) {\n    this._debouncers = this._debouncers || {};\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  },\n  _forwardProperty: function (inst, name, value) {\n    inst._setPendingProperty(name, value);\n  },\n\n  /* Templatizer bindings for v2 */\n  _forwardHostPropV2: function (prop, value) {\n    (this._physicalItems || []).concat([this._offscreenFocusedItem, this._focusBackfillItem]).forEach(function (item) {\n      if (item) {\n        this.modelForElement(item).forwardHostProp(prop, value);\n      }\n    }, this);\n  },\n  _notifyInstancePropV2: function (inst, prop, value) {\n    if (matches(this.as, prop)) {\n      var idx = inst[this.indexAs];\n\n      if (prop == this.as) {\n        this.items[idx] = value;\n      }\n\n      this.notifyPath(translate(this.as, 'items.' + idx, prop), value);\n    }\n  },\n\n  /* Templatizer bindings for v1 */\n  _getStampedChildren: function () {\n    return this._physicalItems;\n  },\n  _forwardInstancePath: function (inst, path, value) {\n    if (path.indexOf(this.as + '.') === 0) {\n      this.notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);\n    }\n  },\n  _forwardParentPath: function (path, value) {\n    (this._physicalItems || []).concat([this._offscreenFocusedItem, this._focusBackfillItem]).forEach(function (item) {\n      if (item) {\n        this.modelForElement(item).notifyPath(path, value);\n      }\n    }, this);\n  },\n  _forwardParentProp: function (prop, value) {\n    (this._physicalItems || []).concat([this._offscreenFocusedItem, this._focusBackfillItem]).forEach(function (item) {\n      if (item) {\n        this.modelForElement(item)[prop] = value;\n      }\n    }, this);\n  },\n\n  /* Gets the activeElement of the shadow root/host that contains the list. */\n  _getActiveElement: function () {\n    var itemsHost = this._itemsParent.node.domHost;\n    return dom(itemsHost ? itemsHost.root : document).activeElement;\n  }\n});"
    },
    {
     "id": 206,
     "name": "../node_modules/@polymer/iron-iconset-svg/iron-iconset-svg.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { IronMeta } from '@polymer/iron-meta/iron-meta.js';\nimport { Polymer } from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\n/**\n * The `iron-iconset-svg` element allows users to define their own icon sets\n * that contain svg icons. The svg icon elements should be children of the\n * `iron-iconset-svg` element. Multiple icons should be given distinct id's.\n *\n * Using svg elements to create icons has a few advantages over traditional\n * bitmap graphics like jpg or png. Icons that use svg are vector based so\n * they are resolution independent and should look good on any device. They\n * are stylable via css. Icons can be themed, colorized, and even animated.\n *\n * Example:\n *\n *     <iron-iconset-svg name=\"my-svg-icons\" size=\"24\">\n *       <svg>\n *         <defs>\n *           <g id=\"shape\">\n *             <rect x=\"12\" y=\"0\" width=\"12\" height=\"24\" />\n *             <circle cx=\"12\" cy=\"12\" r=\"12\" />\n *           </g>\n *         </defs>\n *       </svg>\n *     </iron-iconset-svg>\n *\n * This will automatically register the icon set \"my-svg-icons\" to the iconset\n * database.  To use these icons from within another element, make a\n * `iron-iconset` element and call the `byId` method\n * to retrieve a given iconset. To apply a particular icon inside an\n * element use the `applyIcon` method. For example:\n *\n *     iconset.applyIcon(iconNode, 'car');\n *\n * @element iron-iconset-svg\n * @demo demo/index.html\n * @implements {Polymer.Iconset}\n */\n\nPolymer({\n  is: 'iron-iconset-svg',\n  properties: {\n    /**\n     * The name of the iconset.\n     */\n    name: {\n      type: String,\n      observer: '_nameChanged'\n    },\n\n    /**\n     * The size of an individual icon. Note that icons must be square.\n     */\n    size: {\n      type: Number,\n      value: 24\n    },\n\n    /**\n     * Set to true to enable mirroring of icons where specified when they are\n     * stamped. Icons that should be mirrored should be decorated with a\n     * `mirror-in-rtl` attribute.\n     *\n     * NOTE: For performance reasons, direction will be resolved once per\n     * document per iconset, so moving icons in and out of RTL subtrees will\n     * not cause their mirrored state to change.\n     */\n    rtlMirroring: {\n      type: Boolean,\n      value: false\n    },\n\n    /**\n     * Set to true to measure RTL based on the dir attribute on the body or\n     * html elements (measured on document.body or document.documentElement as\n     * available).\n     */\n    useGlobalRtlAttribute: {\n      type: Boolean,\n      value: false\n    }\n  },\n  created: function () {\n    this._meta = new IronMeta({\n      type: 'iconset',\n      key: null,\n      value: null\n    });\n  },\n  attached: function () {\n    this.style.display = 'none';\n  },\n\n  /**\n   * Construct an array of all icon names in this iconset.\n   *\n   * @return {!Array} Array of icon names.\n   */\n  getIconNames: function () {\n    this._icons = this._createIconMap();\n    return Object.keys(this._icons).map(function (n) {\n      return this.name + ':' + n;\n    }, this);\n  },\n\n  /**\n   * Applies an icon to the given element.\n   *\n   * An svg icon is prepended to the element's shadowRoot if it exists,\n   * otherwise to the element itself.\n   *\n   * If RTL mirroring is enabled, and the icon is marked to be mirrored in\n   * RTL, the element will be tested (once and only once ever for each\n   * iconset) to determine the direction of the subtree the element is in.\n   * This direction will apply to all future icon applications, although only\n   * icons marked to be mirrored will be affected.\n   *\n   * @method applyIcon\n   * @param {Element} element Element to which the icon is applied.\n   * @param {string} iconName Name of the icon to apply.\n   * @return {?Element} The svg element which renders the icon.\n   */\n  applyIcon: function (element, iconName) {\n    // Remove old svg element\n    this.removeIcon(element); // install new svg element\n\n    var svg = this._cloneIcon(iconName, this.rtlMirroring && this._targetIsRTL(element));\n\n    if (svg) {\n      // insert svg element into shadow root, if it exists\n      var pde = dom(element.root || element);\n      pde.insertBefore(svg, pde.childNodes[0]);\n      return element._svgIcon = svg;\n    }\n\n    return null;\n  },\n\n  /**\n   * Remove an icon from the given element by undoing the changes effected\n   * by `applyIcon`.\n   *\n   * @param {Element} element The element from which the icon is removed.\n   */\n  removeIcon: function (element) {\n    // Remove old svg element\n    if (element._svgIcon) {\n      dom(element.root || element).removeChild(element._svgIcon);\n      element._svgIcon = null;\n    }\n  },\n\n  /**\n   * Measures and memoizes the direction of the element. Note that this\n   * measurement is only done once and the result is memoized for future\n   * invocations.\n   */\n  _targetIsRTL: function (target) {\n    if (this.__targetIsRTL == null) {\n      if (this.useGlobalRtlAttribute) {\n        var globalElement = document.body && document.body.hasAttribute('dir') ? document.body : document.documentElement;\n        this.__targetIsRTL = globalElement.getAttribute('dir') === 'rtl';\n      } else {\n        if (target && target.nodeType !== Node.ELEMENT_NODE) {\n          target = target.host;\n        }\n\n        this.__targetIsRTL = target && window.getComputedStyle(target)['direction'] === 'rtl';\n      }\n    }\n\n    return this.__targetIsRTL;\n  },\n\n  /**\n   *\n   * When name is changed, register iconset metadata\n   *\n   */\n  _nameChanged: function () {\n    this._meta.value = null;\n    this._meta.key = this.name;\n    this._meta.value = this;\n    this.async(function () {\n      this.fire('iron-iconset-added', this, {\n        node: window\n      });\n    });\n  },\n\n  /**\n   * Create a map of child SVG elements by id.\n   *\n   * @return {!Object} Map of id's to SVG elements.\n   */\n  _createIconMap: function () {\n    // Objects chained to Object.prototype (`{}`) have members. Specifically,\n    // on FF there is a `watch` method that confuses the icon map, so we\n    // need to use a null-based object here.\n    var icons = Object.create(null);\n    dom(this).querySelectorAll('[id]').forEach(function (icon) {\n      icons[icon.id] = icon;\n    });\n    return icons;\n  },\n\n  /**\n   * Produce installable clone of the SVG element matching `id` in this\n   * iconset, or `undefined` if there is no matching element.\n   *\n   * @return {Element} Returns an installable clone of the SVG element\n   * matching `id`.\n   */\n  _cloneIcon: function (id, mirrorAllowed) {\n    // create the icon map on-demand, since the iconset itself has no discrete\n    // signal to know when it's children are fully parsed\n    this._icons = this._icons || this._createIconMap();\n    return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);\n  },\n\n  /**\n   * @param {Element} sourceSvg\n   * @param {number} size\n   * @param {Boolean} mirrorAllowed\n   * @return {Element}\n   */\n  _prepareSvgClone: function (sourceSvg, size, mirrorAllowed) {\n    if (sourceSvg) {\n      var content = sourceSvg.cloneNode(true),\n          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),\n          viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,\n          cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';\n\n      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {\n        cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);transform-origin:center;';\n      }\n\n      svg.setAttribute('viewBox', viewBox);\n      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n      svg.setAttribute('focusable', 'false'); // TODO(dfreedm): `pointer-events: none` works around\n      // https://crbug.com/370136\n      // TODO(sjmiles): inline style may not be ideal, but avoids requiring a\n      // shadow-root\n\n      svg.style.cssText = cssText;\n      svg.appendChild(content).removeAttribute('id');\n      return svg;\n    }\n\n    return null;\n  }\n});"
    },
    {
     "id": 207,
     "name": "../node_modules/@vaadin/vaadin-upload/src/vaadin-upload-file.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport '@vaadin/vaadin-progress-bar/src/vaadin-progress-bar.js';\nimport './vaadin-upload-icons.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-upload-file>` element represents a file in the file list of `<vaadin-upload>`.\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ---|---\n * `row` | File container\n * `info` | Container for file status icon, file name, status and error messages\n * `done-icon` | File done status icon\n * `warning-icon` | File warning status icon\n * `meta` | Container for file name, status and error messages\n * `name` | File name\n * `error` | Error message, shown when error happens\n * `status` | Status message\n * `commands` | Container for file command icons\n * `start-button` | Start file upload button\n * `retry-button` | Retry file upload button\n * `clear-button` | Clear file button\n * `progress`| Progress bar\n *\n * The following state attributes are available for styling:\n *\n * Attribute | Description | Part name\n * ---|---|---\n * `error` | An error has happened during uploading | `:host`\n * `indeterminate` | Uploading is in progress, but the progress value is unknown | `:host`\n * `uploading` | Uploading is in progress | `:host`\n * `complete` | Uploading has finished successfully | `:host`\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nclass UploadFileElement extends ThemableMixin(PolymerElement) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: block;\n      }\n\n      [hidden] {\n        display: none;\n      }\n    </style>\n\n    <div part=\"row\">\n      <div part=\"info\">\n        <div part=\"done-icon\" hidden\\$=\"[[!file.complete]]\"></div>\n        <div part=\"warning-icon\" hidden\\$=\"[[!file.error]]\"></div>\n\n        <div part=\"meta\">\n          <div part=\"name\" id=\"name\">[[file.name]]</div>\n          <div part=\"status\" hidden\\$=\"[[!file.status]]\" id=\"status\">[[file.status]]</div>\n          <div part=\"error\" id=\"error\" hidden\\$=\"[[!file.error]]\">[[file.error]]</div>\n        </div>\n      </div>\n      <div part=\"commands\">\n        <div part=\"start-button\" file-event=\"file-start\" on-click=\"_fireFileEvent\" hidden\\$=\"[[!file.held]]\"></div>\n        <div part=\"retry-button\" file-event=\"file-retry\" on-click=\"_fireFileEvent\" hidden\\$=\"[[!file.error]]\"></div>\n        <div part=\"clear-button\" file-event=\"file-abort\" on-click=\"_fireFileEvent\"></div>\n      </div>\n    </div>\n\n    <vaadin-progress-bar part=\"progress\" id=\"progress\" value\\$=\"[[_formatProgressValue(file.progress)]]\" error\\$=\"[[file.error]]\" indeterminate\\$=\"[[file.indeterminate]]\" uploading\\$=\"[[file.uploading]]\" complete\\$=\"[[file.complete]]\">\n    </vaadin-progress-bar>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-upload-file';\n  }\n\n  static get properties() {\n    return {\n      file: Object\n    };\n  }\n\n  static get observers() {\n    return ['_fileAborted(file.abort)', '_toggleHostAttribute(file.error, \"error\")', '_toggleHostAttribute(file.indeterminate, \"indeterminate\")', '_toggleHostAttribute(file.uploading, \"uploading\")', '_toggleHostAttribute(file.complete, \"complete\")'];\n  }\n\n  _fileAborted(abort) {\n    if (abort) {\n      this._remove();\n    }\n  }\n\n  _remove() {\n    this.dispatchEvent(new CustomEvent('file-remove', {\n      detail: {\n        file: this.file\n      },\n      bubbles: true,\n      composed: true\n    }));\n  }\n\n  _formatProgressValue(progress) {\n    return progress / 100;\n  }\n\n  _fireFileEvent(e) {\n    e.preventDefault();\n    return this.dispatchEvent(new CustomEvent(e.target.getAttribute('file-event'), {\n      detail: {\n        file: this.file\n      },\n      bubbles: true,\n      composed: true\n    }));\n  }\n\n  _toggleHostAttribute(value, attributeName) {\n    var shouldHave = Boolean(value);\n    var has = this.hasAttribute(attributeName);\n\n    if (has !== shouldHave) {\n      if (shouldHave) {\n        this.setAttribute(attributeName, '');\n      } else {\n        this.removeAttribute(attributeName);\n      }\n    }\n  }\n  /**\n  * Fired when the retry button is pressed. It is listened by `vaadin-upload`\n  * which will start a new upload process of this file.\n  *\n  * @event file-retry\n  * @param {Object} detail\n  * @param {Object} detail.file file to retry upload of\n  */\n\n  /**\n  * Fired when the start button is pressed. It is listened by `vaadin-upload`\n  * which will start a new upload process of this file.\n  *\n  * @event file-start\n  * @param {Object} detail\n  * @param {Object} detail.file file to start upload of\n  */\n\n  /**\n   * Fired when abort button is pressed. It is listened by `vaadin-upload` which\n   * will abort the upload in progress, but will not remove the file from the list\n   * to allow the animation to hide the element to be run.\n   *\n   * @event file-abort\n   * @param {Object} detail\n   * @param {Object} detail.file file to abort upload of\n   */\n\n  /**\n   * Fired after the animation to hide the element has finished. It is listened\n   * by `vaadin-upload` which will actually remove the file from the upload\n   * file list.\n   *\n   * @event file-remove\n   * @param {Object} detail\n   * @param {Object} detail.file file to remove from the  upload of\n   */\n\n\n}\n\ncustomElements.define(UploadFileElement.is, UploadFileElement);\nexport { UploadFileElement };"
    },
    {
     "id": 216,
     "name": "../node_modules/@vaadin/vaadin-combo-box/src/vaadin-combo-box-dropdown-wrapper.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 218,
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-email-field.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 219,
     "name": "../node_modules/@vaadin/vaadin-combo-box/theme/lumo/vaadin-combo-box.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 222,
     "name": "../node_modules/@vaadin/vaadin-progress-bar/theme/lumo/vaadin-progress-bar.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 224,
     "name": "../node_modules/@vaadin/vaadin-overlay/theme/lumo/vaadin-overlay.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 232,
     "name": "../target/frontend/generated-flow-imports.js?babel-target=es6 + 31 modules"
    }
   ]
  },
  {
   "id": 3,
   "names": [],
   "files": [
    "build/vaadin-3-5b81b9c7e94af8d244f7.cache.js"
   ],
   "hash": "24df71fc570c6652a823",
   "modules": [
    {
     "id": 235,
     "name": "../node_modules/highcharts/js/es-modules/parts/Globals.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n/* global win, window */\n// glob is a temporary fix to allow our es-modules to work.\n\nvar glob = typeof win === 'undefined' ? window : win,\n    doc = glob.document,\n    SVG_NS = 'http://www.w3.org/2000/svg',\n    userAgent = glob.navigator && glob.navigator.userAgent || '',\n    svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n    isMS = /(edge|msie|trident)/i.test(userAgent) && !glob.opera,\n    isFirefox = userAgent.indexOf('Firefox') !== -1,\n    isChrome = userAgent.indexOf('Chrome') !== -1,\n    hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4 // issue #38\n;\nvar Highcharts = glob.Highcharts ? glob.Highcharts.error(16, true) : {\n  product: '@product.name@',\n  version: '@product.version@',\n  deg2rad: Math.PI * 2 / 360,\n  doc: doc,\n  hasBidiBug: hasBidiBug,\n  hasTouch: doc && doc.documentElement.ontouchstart !== undefined,\n  isMS: isMS,\n  isWebKit: userAgent.indexOf('AppleWebKit') !== -1,\n  isFirefox: isFirefox,\n  isChrome: isChrome,\n  isSafari: !isChrome && userAgent.indexOf('Safari') !== -1,\n  isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),\n  SVG_NS: SVG_NS,\n  chartCount: 0,\n  seriesTypes: {},\n  symbolSizes: {},\n  svg: svg,\n  win: glob,\n  marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n  noop: function noop() {\n    return undefined;\n  },\n\n  /**\n   * An array containing the current chart objects in the page. A chart's\n   * position in the array is preserved throughout the page's lifetime. When\n   * a chart is destroyed, the array item becomes `undefined`.\n   *\n   * @name Highcharts.charts\n   * @type {Array<Highcharts.Chart>}\n   */\n  charts: []\n};\nexport default Highcharts;"
    },
    {
     "id": 237,
     "name": "../node_modules/highcharts/js/es-modules/parts/Utilities.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Reference to the global SVGElement class as a workaround for a name conflict\n * in the Highcharts namespace.\n *\n * @typedef {global.SVGElement} GlobalSVGElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n\n/**\n * An animation configuration. Animation configurations can also be defined as\n * booleans, where `false` turns off animation and `true` defaults to a duration\n * of 500ms.\n *\n * @typedef Highcharts.AnimationOptionsObject\n *\n * @property {number} duration\n *           The animation duration in milliseconds.\n *\n * @property {string} [easing]\n *           The name of an easing function as defined on the `Math` object.\n *\n * @property {Function} [complete]\n *           A callback function to exectute when the animation finishes.\n *\n * @property {Function} [step]\n *           A callback function to execute on each step of each attribute or\n *           CSS property that's being animated. The first argument contains\n *           information about the animation and progress.\n */\n\n/**\n * A style object with camel case property names to define visual appearance of\n * a SVG element or HTML element. The properties can be whatever styles are\n * supported on the given SVG or HTML element.\n *\n * @example\n * {\n *    fontFamily: 'monospace',\n *    fontSize: '1.2em'\n * }\n *\n * @typedef Highcharts.CSSObject\n *\n * @property {boolean|number|string|undefined} [key:string]\n *\n * @property {string} [background]\n *           Background style for the element.\n *\n * @property {Highcharts.ColorString} [backgroundColor]\n *           Background color of the element.\n *\n * @property {string} [border]\n *           Border style for the element.\n *\n * @property {number} [borderRadius]\n *           Radius of the element border.\n *\n * @property {\"contrast\"|Highcharts.ColorString} [color]\n *           Color used in the element. The \"contrast\" option is a Highcharts\n *           custom property that results in black or white, depending on the\n *           background of the element.\n *\n * @property {string} [cursor]\n *           Style of the mouse cursor when resting over the element.\n *\n * @property {string} [fontFamily]\n *           Font family of the element text. Multiple values have to be in\n *           decreasing preference order and separated by comma.\n *\n * @property {string} [fontSize]\n *           Font size of the element text.\n *\n * @property {string} [fontWeight]\n *           Font weight of the element text.\n *\n * @property {number} [height]\n *           Height of the element.\n *\n * @property {number} [lineWidth]\n *           Width of the element border.\n *\n * @property {number} [opacity]\n *           Opacity of the element.\n *\n * @property {string} [padding]\n *           Space around the element content.\n *\n * @property {string} [pointerEvents]\n *           Behaviour of the element when the mouse cursor rests over it.\n *\n * @property {string} [position]\n *           Positioning of the element.\n *\n * @property {string} [textAlign]\n *           Alignment of the element text.\n *\n * @property {string} [textOutline]\n *           Outline style of the element text.\n *\n * @property {string} [textDecoration]\n *           Additional decoration of the element text.\n *\n * @property {string} [textOverflow]\n *           Line break style of the element text. Highcharts SVG elements\n *           support `ellipsis` when a `width` is set.\n *\n * @property {string} [transition]\n *           Animated transition of selected element properties.\n *\n * @property {string} [top]\n *           Top spacing of the element relative to the parent element.\n *\n * @property {string} [whiteSpace]\n *           Line break style of the element text.\n *\n * @property {number} [width]\n *           Width of the element.\n */\n\n/**\n * Generic dictionary in TypeScript notation.\n *\n * @typedef Highcharts.Dictionary<T>\n *\n * @property {T} [key:string]\n */\n\n/**\n * An object of key-value pairs for HTML attributes.\n *\n * @typedef {Highcharts.Dictionary<boolean|number|string>} Highcharts.HTMLAttributes\n */\n\n/**\n * The iterator callback.\n *\n * @callback Highcharts.EachCallbackFunction<T>\n *\n * @param {T} item\n *        The array item.\n *\n * @param {number} index\n *        The item's index in the array.\n *\n * @param {Array<T>} arr\n *        The array that each is being applied to.\n */\n\n/**\n * The function callback to execute when the event is fired. The `this` context\n * contains the instance, that fired the event.\n *\n * @callback Highcharts.EventCallbackFunction\n *\n * @param {Highcharts.Dictionary<*>} [eventArguments]\n *        Event arguments.\n */\n\n/**\n * Formats data as a string. Usually the data is accessible throught the `this`\n * keyword.\n *\n * @callback Highcharts.FormatterCallbackFunction\n *\n * @return {string}\n */\n\n/**\n * An HTML DOM element. The type is a reference to the regular SVGElement in the\n * global scope.\n *\n * @typedef {global.HTMLElement} Highcharts.HTMLDOMElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n */\n\n/**\n * The iterator callback.\n *\n * @callback Highcharts.ObjectEachCallbackFunction\n *\n * @param {*} value\n *        The property value.\n *\n * @param {string} key\n *        The property key.\n *\n * @param {*} obj\n *        The object that objectEach is being applied to.\n */\n\n/**\n * An object containing `left` and `top` properties for the position in the\n * page.\n *\n * @typedef Highcharts.OffsetObject\n *\n * @property {number} left\n *           Left distance to the page border.\n *\n * @property {number} top\n *           Top distance to the page border.\n */\n\n/**\n * An object containing `x` and `y` properties for the position of an element.\n *\n * @typedef Highcharts.PositionObject\n *\n * @property {number} x\n *           X position of the element.\n *\n * @property {number} y\n *           Y position of the element.\n */\n\n/**\n * If a number is given, it defines the pixel length. If a percentage string is\n * given, like for example `'50%'`, the setting defines a length relative to a\n * base size, for example the size of a container.\n *\n * @typedef {number|string} Highcharts.RelativeSize\n */\n\n/**\n * An object of key-value pairs for SVG attributes. Attributes in Highcharts\n * elements for the most parts correspond to SVG, but some are specific to\n * Highcharts, like `zIndex`, `rotation`, `rotationOriginX`,\n * `rotationOriginY`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG\n * attributes containing a hyphen are _not_ camel-cased, they should be\n * quoted to preserve the hyphen.\n *\n * @example\n * {\n *     'stroke': '#ff0000', // basic\n *     'stroke-width': 2, // hyphenated\n *     'rotation': 45 // custom\n *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format\n * }\n *\n * @typedef Highcharts.SVGAttributes\n *\n * @property {boolean|number|string|Array<any>|undefined} [key:string]\n *\n * @property {string|Highcharts.SVGPathArray} [d]\n *\n * @property {boolean} [inverted]\n *\n * @property {Array<number>} [matrix]\n *\n * @property {Highcharts.ColorString} [stroke]\n *\n * @property {string} [rotation]\n *\n * @property {number} [rotationOriginX]\n *\n * @property {number} [rotationOriginY]\n *\n * @property {number} [scaleX]\n *\n * @property {number} [scaleY]\n *\n * @property {number} [translateX]\n *\n * @property {number} [translateY]\n *\n * @property {number} [zIndex]\n */\n\n/**\n * An SVG DOM element. The type is a reference to the regular SVGElement in the\n * global scope.\n *\n * @typedef {global.GlobalSVGElement} Highcharts.SVGDOMElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n\n/**\n * Array of path commands, that will go into the `d` attribute of an SVG\n * element.\n *\n * @typedef {Array<number|Highcharts.SVGPathCommand>} Highcharts.SVGPathArray\n */\n\n/**\n * Possible path commands in a SVG path array.\n *\n * @typedef {string} Highcharts.SVGPathCommand\n * @validvalue [\"a\",\"c\",\"h\",\"l\",\"m\",\"q\",\"s\",\"t\",\"v\",\"z\",\"A\",\"C\",\"H\",\"L\",\"M\",\"Q\",\"S\",\"T\",\"V\",\"Z\"]\n */\n'use strict';\n\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport H from './Globals.js';\n/**\n * The Highcharts object is the placeholder for all other members, and various\n * utility functions. The most important member of the namespace would be the\n * chart constructor.\n *\n * @example\n * var chart = Highcharts.chart('container', { ... });\n *\n * @namespace Highcharts\n */\n\nH.timers = [];\nvar charts = H.charts,\n    doc = H.doc,\n    win = H.win;\n/**\n * Provide error messages for debugging, with links to online explanation. This\n * function can be overridden to provide custom error handling.\n *\n * @sample highcharts/chart/highcharts-error/\n *         Custom error handler\n *\n * @function Highcharts.error\n *\n * @param {number|string} code\n *        The error code. See\n *        [errors.xml]{@link https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}\n *        for available codes. If it is a string, the error message is printed\n *        directly in the console.\n *\n * @param {boolean} [stop=false]\n *        Whether to throw an error or just log a warning in the console.\n */\n\nH.error = function (code, stop) {\n  var msg = H.isNumber(code) ? 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code : code;\n\n  if (stop) {\n    throw new Error(msg);\n  } // else ...\n\n\n  if (win.console) {\n    console.log(msg); // eslint-disable-line no-console\n  }\n};\n/**\n * An animator object used internally. One instance applies to one property\n * (attribute or style prop) on one element. Animation is always initiated\n * through {@link SVGElement#animate}.\n *\n * @example\n * var rect = renderer.rect(0, 0, 10, 10).add();\n * rect.animate({ width: 100 });\n *\n * @private\n * @class Highcharts.Fx\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem\n *        The element to animate.\n *\n * @param {Highcharts.AnimationOptionsObject} options\n *        Animation options.\n *\n * @param {string} prop\n *        The single attribute or CSS property to animate.\n */\n\n\nH.Fx = function (elem, options, prop) {\n  this.options = options;\n  this.elem = elem;\n  this.prop = prop;\n};\n\nH.Fx.prototype = {\n  /**\n   * Set the current step of a path definition on SVGElement.\n   *\n   * @function Highcharts.Fx#dSetter\n   */\n  dSetter: function dSetter() {\n    var start = this.paths[0],\n        end = this.paths[1],\n        ret = [],\n        now = this.now,\n        i = start.length,\n        startVal; // Land on the final path without adjustment points appended in the ends\n\n    if (now === 1) {\n      ret = this.toD;\n    } else if (i === end.length && now < 1) {\n      while (i--) {\n        startVal = parseFloat(start[i]);\n        ret[i] = isNaN(startVal) ? // a letter instruction like M or L\n        end[i] : now * parseFloat(end[i] - startVal) + startVal;\n      } // If animation is finished or length not matching, land on right value\n\n    } else {\n      ret = end;\n    }\n\n    this.elem.attr('d', ret, null, true);\n  },\n\n  /**\n   * Update the element with the current animation step.\n   *\n   * @function Highcharts.Fx#update\n   */\n  update: function update() {\n    var elem = this.elem,\n        prop = this.prop,\n        // if destroyed, it is null\n    now = this.now,\n        step = this.options.step; // Animation setter defined from outside\n\n    if (this[prop + 'Setter']) {\n      this[prop + 'Setter'](); // Other animations on SVGElement\n    } else if (elem.attr) {\n      if (elem.element) {\n        elem.attr(prop, now, null, true);\n      } // HTML styles, raw HTML content like container size\n\n    } else {\n      elem.style[prop] = now + this.unit;\n    }\n\n    if (step) {\n      step.call(elem, now, this);\n    }\n  },\n\n  /**\n   * Run an animation.\n   *\n   * @function Highcharts.Fx#run\n   *\n   * @param {number} from\n   *        The current value, value to start from.\n   *\n   * @param {number} to\n   *        The end value, value to land on.\n   *\n   * @param {string} [unit]\n   *        The property unit, for example `px`.\n   */\n  run: function run(from, to, unit) {\n    var self = this,\n        options = self.options,\n        timer = function timer(gotoEnd) {\n      return timer.stopped ? false : self.step(gotoEnd);\n    },\n        requestAnimationFrame = win.requestAnimationFrame || function (step) {\n      setTimeout(step, 13);\n    },\n        step = function step() {\n      for (var i = 0; i < H.timers.length; i++) {\n        if (!H.timers[i]()) {\n          H.timers.splice(i--, 1);\n        }\n      }\n\n      if (H.timers.length) {\n        requestAnimationFrame(step);\n      }\n    };\n\n    if (from === to && !this.elem['forceAnimate:' + this.prop]) {\n      delete options.curAnim[this.prop];\n\n      if (options.complete && H.keys(options.curAnim).length === 0) {\n        options.complete.call(this.elem);\n      }\n    } else {\n      // #7166\n      this.startTime = +new Date();\n      this.start = from;\n      this.end = to;\n      this.unit = unit;\n      this.now = this.start;\n      this.pos = 0;\n      timer.elem = this.elem;\n      timer.prop = this.prop;\n\n      if (timer() && H.timers.push(timer) === 1) {\n        requestAnimationFrame(step);\n      }\n    }\n  },\n\n  /**\n   * Run a single step in the animation.\n   *\n   * @function Highcharts.Fx#step\n   *\n   * @param {boolean} [gotoEnd]\n   *        Whether to go to the endpoint of the animation after abort.\n   *\n   * @return {boolean}\n   *         Returns `true` if animation continues.\n   */\n  step: function step(gotoEnd) {\n    var t = +new Date(),\n        ret,\n        done,\n        options = this.options,\n        elem = this.elem,\n        complete = options.complete,\n        duration = options.duration,\n        curAnim = options.curAnim;\n\n    if (elem.attr && !elem.element) {\n      // #2616, element is destroyed\n      ret = false;\n    } else if (gotoEnd || t >= duration + this.startTime) {\n      this.now = this.end;\n      this.pos = 1;\n      this.update();\n      curAnim[this.prop] = true;\n      done = true;\n      H.objectEach(curAnim, function (val) {\n        if (val !== true) {\n          done = false;\n        }\n      });\n\n      if (done && complete) {\n        complete.call(elem);\n      }\n\n      ret = false;\n    } else {\n      this.pos = options.easing((t - this.startTime) / duration);\n      this.now = this.start + (this.end - this.start) * this.pos;\n      this.update();\n      ret = true;\n    }\n\n    return ret;\n  },\n\n  /**\n   * Prepare start and end values so that the path can be animated one to one.\n   *\n   * @function Highcharts.Fx#initPath\n   *\n   * @param {Highcharts.SVGElement} elem\n   *        The SVGElement item.\n   *\n   * @param {string} fromD\n   *        Starting path definition.\n   *\n   * @param {Highcharts.SVGPathArray} toD\n   *        Ending path definition.\n   *\n   * @return {Array<Highcharts.SVGPathArray>}\n   *         An array containing start and end paths in array form so that\n   *         they can be animated in parallel.\n   */\n  initPath: function initPath(elem, fromD, toD) {\n    fromD = fromD || '';\n    var shift,\n        startX = elem.startX,\n        endX = elem.endX,\n        bezier = fromD.indexOf('C') > -1,\n        numParams = bezier ? 7 : 3,\n        fullLength,\n        slice,\n        i,\n        start = fromD.split(' '),\n        end = toD.slice(),\n        // copy\n    isArea = elem.isArea,\n        positionFactor = isArea ? 2 : 1,\n        reverse;\n    /**\n     * In splines make moveTo and lineTo points have six parameters like\n     * bezier curves, to allow animation one-to-one.\n     */\n\n    function sixify(arr) {\n      var isOperator, nextIsOperator;\n      i = arr.length;\n\n      while (i--) {\n        // Fill in dummy coordinates only if the next operator comes\n        // three places behind (#5788)\n        isOperator = arr[i] === 'M' || arr[i] === 'L';\n        nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);\n\n        if (isOperator && nextIsOperator) {\n          arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);\n        }\n      }\n    }\n    /**\n     * Insert an array at the given position of another array\n     */\n\n\n    function insertSlice(arr, subArr, index) {\n      [].splice.apply(arr, [index, 0].concat(subArr));\n    }\n    /**\n     * If shifting points, prepend a dummy point to the end path.\n     */\n\n\n    function prepend(arr, other) {\n      while (arr.length < fullLength) {\n        // Move to, line to or curve to?\n        arr[0] = other[fullLength - arr.length]; // Prepend a copy of the first point\n\n        insertSlice(arr, arr.slice(0, numParams), 0); // For areas, the bottom path goes back again to the left, so we\n        // need to append a copy of the last point.\n\n        if (isArea) {\n          insertSlice(arr, arr.slice(arr.length - numParams), arr.length);\n          i--;\n        }\n      }\n\n      arr[0] = 'M';\n    }\n    /**\n     * Copy and append last point until the length matches the end length.\n     */\n\n\n    function append(arr, other) {\n      var i = (fullLength - arr.length) / numParams;\n\n      while (i > 0 && i--) {\n        // Pull out the slice that is going to be appended or inserted.\n        // In a line graph, the positionFactor is 1, and the last point\n        // is sliced out. In an area graph, the positionFactor is 2,\n        // causing the middle two points to be sliced out, since an area\n        // path starts at left, follows the upper path then turns and\n        // follows the bottom back.\n        slice = arr.slice().splice(arr.length / positionFactor - numParams, numParams * positionFactor); // Move to, line to or curve to?\n\n        slice[0] = other[fullLength - numParams - i * numParams]; // Disable first control point\n\n        if (bezier) {\n          slice[numParams - 6] = slice[numParams - 2];\n          slice[numParams - 5] = slice[numParams - 1];\n        } // Now insert the slice, either in the middle (for areas) or at\n        // the end (for lines)\n\n\n        insertSlice(arr, slice, arr.length / positionFactor);\n\n        if (isArea) {\n          i--;\n        }\n      }\n    }\n\n    if (bezier) {\n      sixify(start);\n      sixify(end);\n    } // For sideways animation, find out how much we need to shift to get the\n    // start path Xs to match the end path Xs.\n\n\n    if (startX && endX) {\n      for (i = 0; i < startX.length; i++) {\n        // Moving left, new points coming in on right\n        if (startX[i] === endX[0]) {\n          shift = i;\n          break; // Moving right\n        } else if (startX[0] === endX[endX.length - startX.length + i]) {\n          shift = i;\n          reverse = true;\n          break;\n        }\n      }\n\n      if (shift === undefined) {\n        start = [];\n      }\n    }\n\n    if (start.length && H.isNumber(shift)) {\n      // The common target length for the start and end array, where both\n      // arrays are padded in opposite ends\n      fullLength = end.length + shift * positionFactor * numParams;\n\n      if (!reverse) {\n        prepend(end, start);\n        append(start, end);\n      } else {\n        prepend(start, end);\n        append(end, start);\n      }\n    }\n\n    return [start, end];\n  },\n\n  /**\n   * Handle animation of the color attributes directly.\n   *\n   * @function Highcharts.Fx#fillSetter\n   */\n  fillSetter: function fillSetter() {\n    H.Fx.prototype.strokeSetter.apply(this, arguments);\n  },\n\n  /**\n   * Handle animation of the color attributes directly.\n   *\n   * @function Highcharts.Fx#strokeSetter\n   */\n  strokeSetter: function strokeSetter() {\n    this.elem.attr(this.prop, H.color(this.start).tweenTo(H.color(this.end), this.pos), null, true);\n  }\n}; // End of Fx prototype\n\n/**\n * Utility function to deep merge two or more objects and return a third object.\n * The merge function can also be used with a single object argument to create a\n * deep copy of an object.\n *\n * @function Highcharts.merge\n *\n * @param {*} a\n *        The first object to extend. When only this is given, the function\n *        returns a deep copy.\n *\n * @param {*} [n]\n *        An object to merge into the previous one.\n *\n * @return {*}\n *         The merged object. If the first argument is true, the return is the\n *         same as the second argument.\n */\n\n/**\n* Utility function to deep merge two or more objects and return a third object.\n* If the first argument is true, the contents of the second object is copied\n* into the first object. The merge function can also be used with a single\n* object argument to create a deep copy of an object.\n*\n* @function Highcharts.merge\n*\n* @param {boolean} extend\n*        Whether to extend the left-side object (a) or return a whole new\n*        object.\n*\n* @param {*} a\n*        The first object to extend. When only this is given, the function\n*        returns a deep copy.\n*\n* @param {*} [n]\n*        An object to merge into the previous one.\n*\n* @return {*}\n*         The merged object. If the first argument is true, the return is the\n*         same as the second argument.\n*/\n\nH.merge = function () {\n  var i,\n      args = arguments,\n      len,\n      ret = {},\n      doCopy = function doCopy(copy, original) {\n    // An object is replacing a primitive\n    if (_typeof(copy) !== 'object') {\n      copy = {};\n    }\n\n    H.objectEach(original, function (value, key) {\n      // Copy the contents of objects, but not arrays or DOM nodes\n      if (H.isObject(value, true) && !H.isClass(value) && !H.isDOMElement(value)) {\n        copy[key] = doCopy(copy[key] || {}, value); // Primitives and arrays are copied over directly\n      } else {\n        copy[key] = original[key];\n      }\n    });\n    return copy;\n  }; // If first argument is true, copy into the existing object. Used in\n  // setOptions.\n\n\n  if (args[0] === true) {\n    ret = args[1];\n    args = Array.prototype.slice.call(args, 2);\n  } // For each argument, extend the return\n\n\n  len = args.length;\n\n  for (i = 0; i < len; i++) {\n    ret = doCopy(ret, args[i]);\n  }\n\n  return ret;\n};\n/**\n * Shortcut for parseInt\n *\n * @private\n * @function Highcharts.pInt\n *\n * @param {*} s\n *\n * @param {number} mag\n *        Magnitude\n *\n * @return {number}\n */\n\n\nH.pInt = function (s, mag) {\n  return parseInt(s, mag || 10);\n};\n/**\n * Utility function to check for string type.\n *\n * @function Highcharts.isString\n *\n * @param {*} s\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is a string.\n */\n\n\nH.isString = function (s) {\n  return typeof s === 'string';\n};\n/**\n * Utility function to check if an item is an array.\n *\n * @function Highcharts.isArray\n *\n * @param {*} obj\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is an array.\n */\n\n\nH.isArray = function (obj) {\n  var str = Object.prototype.toString.call(obj);\n  return str === '[object Array]' || str === '[object Array Iterator]';\n};\n/**\n * Utility function to check if an item is of type object.\n *\n * @function Highcharts.isObject\n *\n * @param {*} obj\n *        The item to check.\n *\n * @param {boolean} [strict=false]\n *        Also checks that the object is not an array.\n *\n * @return {boolean}\n *         True if the argument is an object.\n */\n\n\nH.isObject = function (obj, strict) {\n  return !!obj && _typeof(obj) === 'object' && (!strict || !H.isArray(obj));\n};\n/**\n * Utility function to check if an Object is a HTML Element.\n *\n * @function Highcharts.isDOMElement\n *\n * @param {*} obj\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is a HTML Element.\n */\n\n\nH.isDOMElement = function (obj) {\n  return H.isObject(obj) && typeof obj.nodeType === 'number';\n};\n/**\n * Utility function to check if an Object is an class.\n *\n * @function Highcharts.isClass\n *\n * @param {*} obj\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is an class.\n */\n\n\nH.isClass = function (obj) {\n  var c = obj && obj.constructor;\n  return !!(H.isObject(obj, true) && !H.isDOMElement(obj) && c && c.name && c.name !== 'Object');\n};\n/**\n * Utility function to check if an item is a number and it is finite (not NaN,\n * Infinity or -Infinity).\n *\n * @function Highcharts.isNumber\n *\n * @param {*} n\n *        The item to check.\n *\n * @return {boolean}\n *         True if the item is a finite number\n */\n\n\nH.isNumber = function (n) {\n  return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity;\n};\n/**\n * Remove the last occurence of an item from an array.\n *\n * @function Highcharts.erase\n *\n * @param {Array} arr\n *        The array.\n *\n * @param {*} item\n *        The item to remove.\n */\n\n\nH.erase = function (arr, item) {\n  var i = arr.length;\n\n  while (i--) {\n    if (arr[i] === item) {\n      arr.splice(i, 1);\n      break;\n    }\n  }\n};\n/**\n * Check if an object is null or undefined.\n *\n * @function Highcharts.defined\n *\n * @param {*} obj\n *        The object to check.\n *\n * @return {boolean}\n *         False if the object is null or undefined, otherwise true.\n */\n\n\nH.defined = function (obj) {\n  return obj !== undefined && obj !== null;\n};\n/**\n * Set or get an attribute or an object of attributes. To use as a setter, pass\n * a key and a value, or let the second argument be a collection of keys and\n * values. To use as a getter, pass only a string as the second argument.\n *\n * @function Highcharts.attr\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} elem\n *        The DOM element to receive the attribute(s).\n *\n * @param {string|Highcharts.HTMLAttributes|Highcharts.SVGAttributes} [prop]\n *        The property or an object of key-value pairs.\n *\n * @param {string} [value]\n *        The value if a single property is set.\n *\n * @return {*}\n *         When used as a getter, return the value.\n */\n\n\nH.attr = function (elem, prop, value) {\n  var ret; // if the prop is a string\n\n  if (H.isString(prop)) {\n    // set the value\n    if (H.defined(value)) {\n      elem.setAttribute(prop, value); // get the value\n    } else if (elem && elem.getAttribute) {\n      ret = elem.getAttribute(prop); // IE7 and below cannot get class through getAttribute (#7850)\n\n      if (!ret && prop === 'class') {\n        ret = elem.getAttribute(prop + 'Name');\n      }\n    } // else if prop is defined, it is a hash of key/value pairs\n\n  } else if (H.defined(prop) && H.isObject(prop)) {\n    H.objectEach(prop, function (val, key) {\n      elem.setAttribute(key, val);\n    });\n  }\n\n  return ret;\n};\n/**\n * Check if an element is an array, and if not, make it into an array.\n *\n * @function Highcharts.splat\n *\n * @param {*} obj\n *        The object to splat.\n *\n * @return {Array}\n *         The produced or original array.\n */\n\n\nH.splat = function (obj) {\n  return H.isArray(obj) ? obj : [obj];\n};\n/**\n * Set a timeout if the delay is given, otherwise perform the function\n * synchronously.\n *\n * @function Highcharts.syncTimeout\n *\n * @param {Function} fn\n *        The function callback.\n *\n * @param {number} delay\n *        Delay in milliseconds.\n *\n * @param {*} [context]\n *        The context.\n *\n * @return {number}\n *         An identifier for the timeout that can later be cleared with\n *         Highcharts.clearTimeout.\n */\n\n\nH.syncTimeout = function (fn, delay, context) {\n  if (delay) {\n    return setTimeout(fn, delay, context);\n  }\n\n  fn.call(0, context);\n};\n/**\n * Internal clear timeout. The function checks that the `id` was not removed\n * (e.g. by `chart.destroy()`). For the details see\n * [issue #7901](https://github.com/highcharts/highcharts/issues/7901).\n *\n * @function Highcharts.clearTimeout\n *\n * @param {number} id\n *        Id of a timeout.\n */\n\n\nH.clearTimeout = function (id) {\n  if (H.defined(id)) {\n    clearTimeout(id);\n  }\n};\n/**\n * Utility function to extend an object with the members of another.\n *\n * @function Highcharts.extend\n *\n * @param {Highcharts.Dictionary<*>} a\n *        The object to be extended.\n *\n * @param {Highcharts.Dictionary<*>} b\n *        The object to add to the first one.\n *\n * @return {Highcharts.Dictionary<*>}\n *         Object a, the original object.\n */\n\n\nH.extend = function (a, b) {\n  var n;\n\n  if (!a) {\n    a = {};\n  }\n\n  for (n in b) {\n    a[n] = b[n];\n  }\n\n  return a;\n};\n/**\n * Return the first value that is not null or undefined.\n *\n * @function Highcharts.pick\n *\n * @param {...*} items\n *        Variable number of arguments to inspect.\n *\n * @return {*}\n *         The value of the first argument that is not null or undefined.\n */\n\n\nH.pick = function () {\n  var args = arguments,\n      i,\n      arg,\n      length = args.length;\n\n  for (i = 0; i < length; i++) {\n    arg = args[i];\n\n    if (arg !== undefined && arg !== null) {\n      return arg;\n    }\n  }\n};\n/**\n * Set CSS on a given element.\n *\n * @function Highcharts.css\n *\n * @param {Highcharts.HTMLDOMElement} el\n *        An HTML DOM element.\n *\n * @param {Highcharts.CSSObject} styles\n *        Style object with camel case property names.\n */\n\n\nH.css = function (el, styles) {\n  if (H.isMS && !H.svg) {\n    // #2686\n    if (styles && styles.opacity !== undefined) {\n      styles.filter = 'alpha(opacity=' + styles.opacity * 100 + ')';\n    }\n  }\n\n  H.extend(el.style, styles);\n};\n/**\n * Utility function to create an HTML element with attributes and styles.\n *\n * @function Highcharts.createElement\n *\n * @param {string} tag\n *        The HTML tag.\n *\n * @param {Highcharts.HTMLAttributes} [attribs]\n *        Attributes as an object of key-value pairs.\n *\n * @param {Highcharts.CSSObject} [styles]\n *        Styles as an object of key-value pairs.\n *\n * @param {Highcharts.HTMLDOMElement} [parent]\n *        The parent HTML object.\n *\n * @param {boolean} [nopad=false]\n *        If true, remove all padding, border and margin.\n *\n * @return {Highcharts.HTMLDOMElement}\n *         The created DOM element.\n */\n\n\nH.createElement = function (tag, attribs, styles, parent, nopad) {\n  var el = doc.createElement(tag),\n      css = H.css;\n\n  if (attribs) {\n    H.extend(el, attribs);\n  }\n\n  if (nopad) {\n    css(el, {\n      padding: 0,\n      border: 'none',\n      margin: 0\n    });\n  }\n\n  if (styles) {\n    css(el, styles);\n  }\n\n  if (parent) {\n    parent.appendChild(el);\n  }\n\n  return el;\n};\n/**\n * Extend a prototyped class by new members.\n *\n * @function Highcharts.extendClass\n *\n * @param {*} parent\n *        The parent prototype to inherit.\n *\n * @param {Highcharts.Dictionary<*>} members\n *        A collection of prototype members to add or override compared to the\n *        parent prototype.\n *\n * @return {*}\n *         A new prototype.\n */\n\n\nH.extendClass = function (parent, members) {\n  var object = function object() {};\n\n  object.prototype = new parent(); // eslint-disable-line new-cap\n\n  H.extend(object.prototype, members);\n  return object;\n};\n/**\n * Left-pad a string to a given length by adding a character repetetively.\n *\n * @function Highcharts.pad\n *\n * @param {number} number\n *        The input string or number.\n *\n * @param {number} length\n *        The desired string length.\n *\n * @param {string} [padder=0]\n *        The character to pad with.\n *\n * @return {string}\n *         The padded string.\n */\n\n\nH.pad = function (number, length, padder) {\n  return new Array((length || 2) + 1 - String(number).replace('-', '').length).join(padder || 0) + number;\n};\n/**\n * Return a length based on either the integer value, or a percentage of a base.\n *\n * @function Highcharts.relativeLength\n *\n * @param {Highcharts.RelativeSize} value\n *        A percentage string or a number.\n *\n * @param {number} base\n *        The full length that represents 100%.\n *\n * @param {number} [offset=0]\n *        A pixel offset to apply for percentage values. Used internally in\n *        axis positioning.\n *\n * @return {number}\n *         The computed length.\n */\n\n\nH.relativeLength = function (value, base, offset) {\n  return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset || 0) : parseFloat(value);\n};\n/**\n * Wrap a method with extended functionality, preserving the original function.\n *\n * @function Highcharts.wrap\n *\n * @param {*} obj\n *        The context object that the method belongs to. In real cases, this is\n *        often a prototype.\n *\n * @param {string} method\n *        The name of the method to extend.\n *\n * @param {Function} func\n *        A wrapper function callback. This function is called with the same\n *        arguments as the original function, except that the original function\n *        is unshifted and passed as the first argument.\n */\n\n\nH.wrap = function (obj, method, func) {\n  var proceed = obj[method];\n\n  obj[method] = function () {\n    var args = Array.prototype.slice.call(arguments),\n        outerArgs = arguments,\n        ctx = this,\n        ret;\n\n    ctx.proceed = function () {\n      proceed.apply(ctx, arguments.length ? arguments : outerArgs);\n    };\n\n    args.unshift(proceed);\n    ret = func.apply(this, args);\n    ctx.proceed = null;\n    return ret;\n  };\n};\n/**\n * Format a single variable. Similar to sprintf, without the % prefix.\n *\n * @example\n * formatSingle('.2f', 5); // => '5.00'.\n *\n * @function Highcharts.formatSingle\n *\n * @param {string} format\n *        The format string.\n *\n * @param {*} val\n *        The value.\n *\n * @param {Highcharts.Time} [time]\n *        A `Time` instance that determines the date formatting, for example\n *        for applying time zone corrections to the formatted date.\n *\n * @return {string}\n *         The formatted representation of the value.\n */\n\n\nH.formatSingle = function (format, val, time) {\n  var floatRegex = /f$/,\n      decRegex = /\\.([0-9])/,\n      lang = H.defaultOptions.lang,\n      decimals;\n\n  if (floatRegex.test(format)) {\n    // float\n    decimals = format.match(decRegex);\n    decimals = decimals ? decimals[1] : -1;\n\n    if (val !== null) {\n      val = H.numberFormat(val, decimals, lang.decimalPoint, format.indexOf(',') > -1 ? lang.thousandsSep : '');\n    }\n  } else {\n    val = (time || H.time).dateFormat(format, val);\n  }\n\n  return val;\n};\n/**\n * Format a string according to a subset of the rules of Python's String.format\n * method.\n *\n * @example\n * var s = Highcharts.format(\n *     'The {color} fox was {len:.2f} feet long',\n *     { color: 'red', len: Math.PI }\n * );\n * // => The red fox was 3.14 feet long\n *\n * @function Highcharts.format\n *\n * @param {string} str\n *        The string to format.\n *\n * @param {*} ctx\n *        The context, a collection of key-value pairs where each key is\n *        replaced by its value.\n *\n * @param {Highcharts.Time} [time]\n *        A `Time` instance that determines the date formatting, for example\n *        for applying time zone corrections to the formatted date.\n *\n * @return {string}\n *         The formatted string.\n */\n\n\nH.format = function (str, ctx, time) {\n  var splitter = '{',\n      isInside = false,\n      segment,\n      valueAndFormat,\n      path,\n      i,\n      len,\n      ret = [],\n      val,\n      index;\n\n  while (str) {\n    index = str.indexOf(splitter);\n\n    if (index === -1) {\n      break;\n    }\n\n    segment = str.slice(0, index);\n\n    if (isInside) {\n      // we're on the closing bracket looking back\n      valueAndFormat = segment.split(':');\n      path = valueAndFormat.shift().split('.'); // get first and leave\n\n      len = path.length;\n      val = ctx; // Assign deeper paths\n\n      for (i = 0; i < len; i++) {\n        if (val) {\n          val = val[path[i]];\n        }\n      } // Format the replacement\n\n\n      if (valueAndFormat.length) {\n        val = H.formatSingle(valueAndFormat.join(':'), val, time);\n      } // Push the result and advance the cursor\n\n\n      ret.push(val);\n    } else {\n      ret.push(segment);\n    }\n\n    str = str.slice(index + 1); // the rest\n\n    isInside = !isInside; // toggle\n\n    splitter = isInside ? '}' : '{'; // now look for next matching bracket\n  }\n\n  ret.push(str);\n  return ret.join('');\n};\n/**\n * Get the magnitude of a number.\n *\n * @function Highcharts.getMagnitude\n *\n * @param {number} number\n *        The number.\n *\n * @return {number}\n *         The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2 etc.\n */\n\n\nH.getMagnitude = function (num) {\n  return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));\n};\n/**\n * Take an interval and normalize it to multiples of round numbers.\n *\n * @deprecated\n * @function Highcharts.normalizeTickInterval\n *\n * @param {number} interval\n *        The raw, un-rounded interval.\n *\n * @param {Array} [multiples]\n *        Allowed multiples.\n *\n * @param {number} [magnitude]\n *        The magnitude of the number.\n *\n * @param {boolean} [allowDecimals]\n *        Whether to allow decimals.\n *\n * @param {boolean} [hasTickAmount]\n *        If it has tickAmount, avoid landing on tick intervals lower than\n *        original.\n *\n * @return {number}\n *         The normalized interval.\n *\n * @todo\n * Move this function to the Axis prototype. It is here only for historical\n * reasons.\n */\n\n\nH.normalizeTickInterval = function (interval, multiples, magnitude, allowDecimals, hasTickAmount) {\n  var normalized,\n      i,\n      retInterval = interval; // round to a tenfold of 1, 2, 2.5 or 5\n\n  magnitude = H.pick(magnitude, 1);\n  normalized = interval / magnitude; // multiples for a linear scale\n\n  if (!multiples) {\n    multiples = hasTickAmount ? // Finer grained ticks when the tick amount is hard set, including\n    // when alignTicks is true on multiple axes (#4580).\n    [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : // Else, let ticks fall on rounder numbers\n    [1, 2, 2.5, 5, 10]; // the allowDecimals option\n\n    if (allowDecimals === false) {\n      if (magnitude === 1) {\n        multiples = H.grep(multiples, function (num) {\n          return num % 1 === 0;\n        });\n      } else if (magnitude <= 0.1) {\n        multiples = [1 / magnitude];\n      }\n    }\n  } // normalize the interval to the nearest multiple\n\n\n  for (i = 0; i < multiples.length; i++) {\n    retInterval = multiples[i]; // only allow tick amounts smaller than natural\n\n    if (hasTickAmount && retInterval * magnitude >= interval || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {\n      break;\n    }\n  } // Multiply back to the correct magnitude. Correct floats to appropriate\n  // precision (#6085).\n\n\n  retInterval = H.correctFloat(retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10));\n  return retInterval;\n};\n/**\n * Sort an object array and keep the order of equal items. The ECMAScript\n * standard does not specify the behaviour when items are equal.\n *\n * @function Highcharts.stableSort\n *\n * @param {Array} arr\n *        The array to sort.\n *\n * @param {Function} sortFunction\n *        The function to sort it with, like with regular Array.prototype.sort.\n */\n\n\nH.stableSort = function (arr, sortFunction) {\n  var length = arr.length,\n      sortValue,\n      i; // Add index to each item\n\n  for (i = 0; i < length; i++) {\n    arr[i].safeI = i; // stable sort index\n  }\n\n  arr.sort(function (a, b) {\n    sortValue = sortFunction(a, b);\n    return sortValue === 0 ? a.safeI - b.safeI : sortValue;\n  }); // Remove index from items\n\n  for (i = 0; i < length; i++) {\n    delete arr[i].safeI; // stable sort index\n  }\n};\n/**\n * Non-recursive method to find the lowest member of an array. `Math.min` raises\n * a maximum call stack size exceeded error in Chrome when trying to apply more\n * than 150.000 points. This method is slightly slower, but safe.\n *\n * @function Highcharts.arrayMin\n *\n * @param {Array} data\n *        An array of numbers.\n *\n * @return {number}\n *         The lowest number.\n */\n\n\nH.arrayMin = function (data) {\n  var i = data.length,\n      min = data[0];\n\n  while (i--) {\n    if (data[i] < min) {\n      min = data[i];\n    }\n  }\n\n  return min;\n};\n/**\n * Non-recursive method to find the lowest member of an array. `Math.max` raises\n * a maximum call stack size exceeded error in Chrome when trying to apply more\n * than 150.000 points. This method is slightly slower, but safe.\n *\n * @function Highcharts.arrayMax\n *\n * @param {Array} data\n *        An array of numbers.\n *\n * @return {number}\n *         The highest number.\n */\n\n\nH.arrayMax = function (data) {\n  var i = data.length,\n      max = data[0];\n\n  while (i--) {\n    if (data[i] > max) {\n      max = data[i];\n    }\n  }\n\n  return max;\n};\n/**\n * Utility method that destroys any SVGElement instances that are properties on\n * the given object. It loops all properties and invokes destroy if there is a\n * destroy method. The property is then delete.\n *\n * @function Highcharts.destroyObjectProperties\n *\n * @param {*} obj\n *        The object to destroy properties on.\n *\n * @param {*} [except]\n *        Exception, do not destroy this property, only delete it.\n */\n\n\nH.destroyObjectProperties = function (obj, except) {\n  H.objectEach(obj, function (val, n) {\n    // If the object is non-null and destroy is defined\n    if (val && val !== except && val.destroy) {\n      // Invoke the destroy\n      val.destroy();\n    } // Delete the property from the object.\n\n\n    delete obj[n];\n  });\n};\n/**\n * Discard a HTML element by moving it to the bin and delete.\n *\n * @function Highcharts.discardElement\n *\n * @param {Highcharts.HTMLDOMElement} element\n *        The HTML node to discard.\n */\n\n\nH.discardElement = function (element) {\n  var garbageBin = H.garbageBin; // create a garbage bin element, not part of the DOM\n\n  if (!garbageBin) {\n    garbageBin = H.createElement('div');\n  } // move the node and empty bin\n\n\n  if (element) {\n    garbageBin.appendChild(element);\n  }\n\n  garbageBin.innerHTML = '';\n};\n/**\n * Fix JS round off float errors.\n *\n * @function Highcharts.correctFloat\n *\n * @param {number} num\n *        A float number to fix.\n *\n * @param {number} [prec=14]\n *        The precision.\n *\n * @return {number}\n *         The corrected float number.\n */\n\n\nH.correctFloat = function (num, prec) {\n  return parseFloat(num.toPrecision(prec || 14));\n};\n/**\n * Set the global animation to either a given value, or fall back to the given\n * chart's animation option.\n *\n * @function Highcharts.setAnimation\n *\n * @param {boolean|Highcharts.AnimationOptionsObject} animation\n *        The animation object.\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @todo\n * This function always relates to a chart, and sets a property on the renderer,\n * so it should be moved to the SVGRenderer.\n */\n\n\nH.setAnimation = function (animation, chart) {\n  chart.renderer.globalAnimation = H.pick(animation, chart.options.chart.animation, true);\n};\n/**\n * Get the animation in object form, where a disabled animation is always\n * returned as `{ duration: 0 }`.\n *\n * @function Highcharts.animObject\n *\n * @param {boolean|Highcharts.AnimationOptionsObject} animation\n *        An animation setting. Can be an object with duration, complete and\n *        easing properties, or a boolean to enable or disable.\n *\n * @return {Highcharts.AnimationOptionsObject}\n *         An object with at least a duration property.\n */\n\n\nH.animObject = function (animation) {\n  return H.isObject(animation) ? H.merge(animation) : {\n    duration: animation ? 500 : 0\n  };\n};\n/**\n * The time unit lookup\n *\n * @ignore\n */\n\n\nH.timeUnits = {\n  millisecond: 1,\n  second: 1000,\n  minute: 60000,\n  hour: 3600000,\n  day: 24 * 3600000,\n  week: 7 * 24 * 3600000,\n  month: 28 * 24 * 3600000,\n  year: 364 * 24 * 3600000\n};\n/**\n * Format a number and return a string based on input settings.\n *\n * @sample highcharts/members/highcharts-numberformat/\n *         Custom number format\n *\n * @function Highcharts.numberFormat\n *\n * @param {number} number\n *        The input number to format.\n *\n * @param {number} decimals\n *        The amount of decimals. A value of -1 preserves the amount in the\n *        input number.\n *\n * @param {string} [decimalPoint]\n *        The decimal point, defaults to the one given in the lang options, or\n *        a dot.\n *\n * @param {string} [thousandsSep]\n *        The thousands separator, defaults to the one given in the lang\n *        options, or a space character.\n *\n * @return {string}\n *         The formatted number.\n */\n\nH.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {\n  number = +number || 0;\n  decimals = +decimals;\n  var lang = H.defaultOptions.lang,\n      origDec = (number.toString().split('.')[1] || '').split('e')[0].length,\n      strinteger,\n      thousands,\n      ret,\n      roundedNumber,\n      exponent = number.toString().split('e'),\n      fractionDigits;\n\n  if (decimals === -1) {\n    // Preserve decimals. Not huge numbers (#3793).\n    decimals = Math.min(origDec, 20);\n  } else if (!H.isNumber(decimals)) {\n    decimals = 2;\n  } else if (decimals && exponent[1] && exponent[1] < 0) {\n    // Expose decimals from exponential notation (#7042)\n    fractionDigits = decimals + +exponent[1];\n\n    if (fractionDigits >= 0) {\n      // remove too small part of the number while keeping the notation\n      exponent[0] = (+exponent[0]).toExponential(fractionDigits).split('e')[0];\n      decimals = fractionDigits;\n    } else {\n      // fractionDigits < 0\n      exponent[0] = exponent[0].split('.')[0] || 0;\n\n      if (decimals < 20) {\n        // use number instead of exponential notation (#7405)\n        number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals);\n      } else {\n        // or zero\n        number = 0;\n      }\n\n      exponent[1] = 0;\n    }\n  } // Add another decimal to avoid rounding errors of float numbers. (#4573)\n  // Then use toFixed to handle rounding.\n\n\n  roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals); // A string containing the positive integer component of the number\n\n  strinteger = String(H.pInt(roundedNumber)); // Leftover after grouping into thousands. Can be 0, 1 or 2.\n\n  thousands = strinteger.length > 3 ? strinteger.length % 3 : 0; // Language\n\n  decimalPoint = H.pick(decimalPoint, lang.decimalPoint);\n  thousandsSep = H.pick(thousandsSep, lang.thousandsSep); // Start building the return\n\n  ret = number < 0 ? '-' : ''; // Add the leftover after grouping into thousands. For example, in the\n  // number 42 000 000, this line adds 42.\n\n  ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : ''; // Add the remaining thousands groups, joined by the thousands separator\n\n  ret += strinteger.substr(thousands).replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep); // Add the decimal point and the decimal component\n\n  if (decimals) {\n    // Get the decimal component\n    ret += decimalPoint + roundedNumber.slice(-decimals);\n  }\n\n  if (exponent[1] && +ret !== 0) {\n    ret += 'e' + exponent[1];\n  }\n\n  return ret;\n};\n/**\n * Easing definition\n *\n * @private\n * @function Math.easeInOutSine\n *\n * @param {number} pos\n *        Current position, ranging from 0 to 1.\n *\n * @return {number}\n */\n\n\nMath.easeInOutSine = function (pos) {\n  return -0.5 * (Math.cos(Math.PI * pos) - 1);\n};\n/**\n * Get the computed CSS value for given element and property, only for numerical\n * properties. For width and height, the dimension of the inner box (excluding\n * padding) is returned. Used for fitting the chart within the container.\n *\n * @function Highcharts.getStyle\n *\n * @param {Highcharts.HTMLDOMElement} el\n *        An HTML element.\n *\n * @param {string} prop\n *        The property name.\n *\n * @param {boolean} [toInt=true]\n *        Parse to integer.\n *\n * @return {number}\n *         The numeric value.\n */\n\n\nH.getStyle = function (el, prop, toInt) {\n  var style; // For width and height, return the actual inner pixel size (#4913)\n\n  if (prop === 'width') {\n    return Math.max(0, // #8377\n    Math.min(el.offsetWidth, el.scrollWidth) - H.getStyle(el, 'padding-left') - H.getStyle(el, 'padding-right'));\n  } else if (prop === 'height') {\n    return Math.max(0, // #8377\n    Math.min(el.offsetHeight, el.scrollHeight) - H.getStyle(el, 'padding-top') - H.getStyle(el, 'padding-bottom'));\n  }\n\n  if (!win.getComputedStyle) {\n    // SVG not supported, forgot to load oldie.js?\n    H.error(27, true);\n  } // Otherwise, get the computed style\n\n\n  style = win.getComputedStyle(el, undefined);\n\n  if (style) {\n    style = style.getPropertyValue(prop);\n\n    if (H.pick(toInt, prop !== 'opacity')) {\n      style = H.pInt(style);\n    }\n  }\n\n  return style;\n};\n/**\n * Search for an item in an array.\n *\n * @function Highcharts.inArray\n *\n * @param {*} item\n *        The item to search for.\n *\n * @param {Array} arr\n *        The array or node collection to search in.\n *\n * @param {number} [fromIndex=0]\n *        The index to start searching from.\n *\n * @return {number}\n *         The index within the array, or -1 if not found.\n */\n\n\nH.inArray = function (item, arr, fromIndex) {\n  return (H.indexOfPolyfill || Array.prototype.indexOf).call(arr, item, fromIndex);\n};\n/**\n * Filter an array by a callback.\n *\n * @function Highcharts.grep\n *\n * @param {Array} arr\n *        The array to filter.\n *\n * @param {Function} callback\n *        The callback function. The function receives the item as the first\n *        argument. Return `true` if the item is to be preserved.\n *\n * @return {Array}\n *         A new, filtered array.\n */\n\n\nH.grep = function (arr, callback) {\n  return (H.filterPolyfill || Array.prototype.filter).call(arr, callback);\n};\n/**\n * Return the value of the first element in the array that satisfies the\n * provided testing function.\n *\n * @function Highcharts.find\n *\n * @param {Array} arr\n *        The array to test.\n *\n * @param {Function} callback\n *        The callback function. The function receives the item as the first\n *        argument. Return `true` if this item satisfies the condition.\n *\n * @return {*}\n *         The value of the element.\n */\n\n\nH.find = Array.prototype.find ? function (arr, callback) {\n  return arr.find(callback);\n} : // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.\nfunction (arr, fn) {\n  var i,\n      length = arr.length;\n\n  for (i = 0; i < length; i++) {\n    if (fn(arr[i], i)) {\n      return arr[i];\n    }\n  }\n};\n/**\n * Test whether at least one element in the array passes the test implemented by\n * the provided function.\n *\n * @function Highcharts.some\n *\n * @param {Array} arr\n *        The array to test\n *\n * @param {Function} fn\n *        The function to run on each item. Return truty to pass the test.\n *        Receives arguments `currentValue`, `index` and `array`.\n *\n * @param {*} ctx\n *        The context.\n *\n * @return {boolean}\n */\n\nH.some = function (arr, fn, ctx) {\n  return (H.somePolyfill || Array.prototype.some).call(arr, fn, ctx);\n};\n/**\n * Map an array by a callback.\n *\n * @function Highcharts.map\n *\n * @param {Array} arr\n *        The array to map.\n *\n * @param {Function} fn\n *        The callback function. Return the new value for the new array.\n *\n * @return {Array}\n *         A new array item with modified items.\n */\n\n\nH.map = function (arr, fn) {\n  var results = [],\n      i = 0,\n      len = arr.length;\n\n  for (; i < len; i++) {\n    results[i] = fn.call(arr[i], arr[i], i, arr);\n  }\n\n  return results;\n};\n/**\n * Returns an array of a given object's own properties.\n *\n * @function Highcharts.keys\n *\n * @param {*} obj\n *        The object of which the properties are to be returned.\n *\n * @return {Array<string>}\n *         An array of strings that represents all the properties.\n */\n\n\nH.keys = function (obj) {\n  return (H.keysPolyfill || Object.keys).call(undefined, obj);\n};\n/**\n * Reduce an array to a single value.\n *\n * @function Highcharts.reduce\n *\n * @param {Array<*>} arr\n *        The array to reduce.\n *\n * @param {Function} fn\n *        The callback function. Return the reduced value. Receives 4\n *        arguments: Accumulated/reduced value, current value, current array\n *        index, and the array.\n *\n * @param {*} initialValue\n *        The initial value of the accumulator.\n *\n * @return {*}\n *         The reduced value.\n */\n\n\nH.reduce = function (arr, func, initialValue) {\n  var fn = H.reducePolyfill || Array.prototype.reduce;\n  return fn.apply(arr, arguments.length > 2 ? [func, initialValue] : [func]);\n};\n/**\n * Get the element's offset position, corrected for `overflow: auto`.\n *\n * @function Highcharts.offset\n *\n * @param {Highcharts.HTMLDOMElement} el\n *        The HTML element.\n *\n * @return {Highcharts.OffsetObject}\n *         An object containing `left` and `top` properties for the position in\n *         the page.\n */\n\n\nH.offset = function (el) {\n  var docElem = doc.documentElement,\n      box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : {\n    top: 0,\n    left: 0\n  };\n  return {\n    top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n    left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n  };\n};\n/**\n * Stop running animation.\n *\n * @function Highcharts.stop\n *\n * @param {Highcharts.SVGElement} el\n *        The SVGElement to stop animation on.\n *\n * @param {string} [prop]\n *        The property to stop animating. If given, the stop method will stop a\n *        single property from animating, while others continue.\n *\n * @todo\n * A possible extension to this would be to stop a single property, when\n * we want to continue animating others. Then assign the prop to the timer\n * in the Fx.run method, and check for the prop here. This would be an\n * improvement in all cases where we stop the animation from .attr. Instead of\n * stopping everything, we can just stop the actual attributes we're setting.\n */\n\n\nH.stop = function (el, prop) {\n  var i = H.timers.length; // Remove timers related to this element (#4519)\n\n  while (i--) {\n    if (H.timers[i].elem === el && (!prop || prop === H.timers[i].prop)) {\n      H.timers[i].stopped = true; // #4667\n    }\n  }\n};\n/**\n * Iterate over an array.\n *\n * @function Highcharts.each<T>\n *\n * @param {Array<T>} arr\n *        The array to iterate over.\n *\n * @param {Highcharts.EachCallbackFunction<T>} fn\n *        The iterator callback. It passes three arguments:\n *        * item - The array item.\n *        * index - The item's index in the array.\n *        * arr - The array that each is being applied to.\n *\n * @param {*} [ctx]\n *        The context.\n */\n\n\nH.each = function (arr, fn, ctx) {\n  // modern browsers\n  return (H.forEachPolyfill || Array.prototype.forEach).call(arr, fn, ctx);\n};\n/**\n * Iterate over object key pairs in an object.\n *\n * @function Highcharts.objectEach\n *\n * @param {*} obj\n *        The object to iterate over.\n *\n * @param {Highcharts.ObjectEachCallbackFunction} fn\n *        The iterator callback. It passes three arguments:\n *        * value - The property value.\n *        * key - The property key.\n *        * obj - The object that objectEach is being applied to.\n *\n * @param {*} [ctx]\n *        The context.\n */\n\n\nH.objectEach = function (obj, fn, ctx) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn.call(ctx || obj[key], obj[key], key, obj);\n    }\n  }\n};\n/**\n * Add an event listener.\n *\n * @function Highcharts.addEvent\n *\n * @param {*} el\n *        The element or object to add a listener to. It can be a\n *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.\n *\n * @param {string} type\n *        The event type.\n *\n * @param {Highcharts.EventCallbackFunction} fn\n *        The function callback to execute when the event is fired.\n *\n * @param {Highcharts.Dictionary<*>} options\n *        Event options\n *\n * @param {number} options.order\n *        The order the event handler should be called. This opens for having\n *        one handler be called before another, independent of in which order\n *        they were added.\n *\n * @return {Function}\n *         A callback function to remove the added event.\n */\n\n\nH.addEvent = function (el, type, fn, options) {\n  var events,\n      addEventListener = el.addEventListener || H.addEventListenerPolyfill; // If we're setting events directly on the constructor, use a separate\n  // collection, `protoEvents` to distinguish it from the item events in\n  // `hcEvents`.\n\n  if (typeof el === 'function' && el.prototype) {\n    events = el.prototype.protoEvents = el.prototype.protoEvents || {};\n  } else {\n    events = el.hcEvents = el.hcEvents || {};\n  } // Allow click events added to points, otherwise they will be prevented by\n  // the TouchPointer.pinch function after a pinch zoom operation (#7091).\n\n\n  if (H.Point && el instanceof H.Point && el.series && el.series.chart) {\n    el.series.chart.runTrackerClick = true;\n  } // Handle DOM events\n\n\n  if (addEventListener) {\n    addEventListener.call(el, type, fn, false);\n  }\n\n  if (!events[type]) {\n    events[type] = [];\n  }\n\n  events[type].push(fn); // Order the calls\n\n  if (options && H.isNumber(options.order)) {\n    fn.order = options.order;\n    events[type].sort(function (a, b) {\n      return a.order - b.order;\n    });\n  } // Return a function that can be called to remove this event.\n\n\n  return function () {\n    H.removeEvent(el, type, fn);\n  };\n};\n/**\n * Remove an event that was added with {@link Highcharts#addEvent}.\n *\n * @function Highcharts.removeEvent\n *\n * @param {*} el\n *        The element to remove events on.\n *\n * @param {string} [type]\n *        The type of events to remove. If undefined, all events are removed\n *        from the element.\n *\n * @param {Function} [fn]\n *        The specific callback to remove. If undefined, all events that match\n *        the element and optionally the type are removed.\n */\n\n\nH.removeEvent = function (el, type, fn) {\n  var events, index;\n\n  function removeOneEvent(type, fn) {\n    var removeEventListener = el.removeEventListener || H.removeEventListenerPolyfill;\n\n    if (removeEventListener) {\n      removeEventListener.call(el, type, fn, false);\n    }\n  }\n\n  function removeAllEvents(eventCollection) {\n    var types, len;\n\n    if (!el.nodeName) {\n      return; // break on non-DOM events\n    }\n\n    if (type) {\n      types = {};\n      types[type] = true;\n    } else {\n      types = eventCollection;\n    }\n\n    H.objectEach(types, function (val, n) {\n      if (eventCollection[n]) {\n        len = eventCollection[n].length;\n\n        while (len--) {\n          removeOneEvent(n, eventCollection[n][len]);\n        }\n      }\n    });\n  }\n\n  H.each(['protoEvents', 'hcEvents'], function (coll) {\n    var eventCollection = el[coll];\n\n    if (eventCollection) {\n      if (type) {\n        events = eventCollection[type] || [];\n\n        if (fn) {\n          index = H.inArray(fn, events);\n\n          if (index > -1) {\n            events.splice(index, 1);\n            eventCollection[type] = events;\n          }\n\n          removeOneEvent(type, fn);\n        } else {\n          removeAllEvents(eventCollection);\n          eventCollection[type] = [];\n        }\n      } else {\n        removeAllEvents(eventCollection);\n        el[coll] = {};\n      }\n    }\n  });\n};\n/**\n * Fire an event that was registered with {@link Highcharts#addEvent}.\n *\n * @function Highcharts.fireEvent\n *\n * @param {*} el\n *        The object to fire the event on. It can be a {@link HTMLDOMElement},\n *        an {@link SVGElement} or any other object.\n *\n * @param {string} type\n *        The type of event.\n *\n * @param {Highcharts.Dictionary<*>} [eventArguments]\n *        Custom event arguments that are passed on as an argument to the event\n *        handler.\n *\n * @param {Function} [defaultFunction]\n *        The default function to execute if the other listeners haven't\n *        returned false.\n */\n\n\nH.fireEvent = function (el, type, eventArguments, defaultFunction) {\n  var e, events, len, i, fn;\n  eventArguments = eventArguments || {};\n\n  if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {\n    e = doc.createEvent('Events');\n    e.initEvent(type, true, true);\n    H.extend(e, eventArguments);\n\n    if (el.dispatchEvent) {\n      el.dispatchEvent(e);\n    } else {\n      el.fireEvent(type, e);\n    }\n  } else {\n    H.each(['protoEvents', 'hcEvents'], function (coll) {\n      if (el[coll]) {\n        events = el[coll][type] || [];\n        len = events.length;\n\n        if (!eventArguments.target) {\n          // We're running a custom event\n          H.extend(eventArguments, {\n            // Attach a simple preventDefault function to skip\n            // default handler if called. The built-in\n            // defaultPrevented property is not overwritable (#5112)\n            preventDefault: function preventDefault() {\n              eventArguments.defaultPrevented = true;\n            },\n            // Setting target to native events fails with clicking\n            // the zoom-out button in Chrome.\n            target: el,\n            // If the type is not set, we're running a custom event\n            // (#2297). If it is set, we're running a browser event,\n            // and setting it will cause en error in IE8 (#2465).\n            type: type\n          });\n        }\n\n        for (i = 0; i < len; i++) {\n          fn = events[i]; // If the event handler return false, prevent the default\n          // handler from executing\n\n          if (fn && fn.call(el, eventArguments) === false) {\n            eventArguments.preventDefault();\n          }\n        }\n      }\n    });\n  } // Run the default if not prevented\n\n\n  if (defaultFunction && !eventArguments.defaultPrevented) {\n    defaultFunction.call(el, eventArguments);\n  }\n};\n/**\n * The global animate method, which uses Fx to create individual animators.\n *\n * @function Highcharts.animate\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} el\n *        The element to animate.\n *\n * @param {Highcharts.HTMLAttributes|Highcharts.SVGAttributes} params\n *        An object containing key-value pairs of the properties to animate.\n *        Supports numeric as pixel-based CSS properties for HTML objects and\n *        attributes for SVGElements.\n *\n * @param {Highcharts.AnimationOptionsObject} [opt]\n *        Animation options.\n */\n\n\nH.animate = function (el, params, opt) {\n  var start,\n      unit = '',\n      end,\n      fx,\n      args;\n\n  if (!H.isObject(opt)) {\n    // Number or undefined/null\n    args = arguments;\n    opt = {\n      duration: args[2],\n      easing: args[3],\n      complete: args[4]\n    };\n  }\n\n  if (!H.isNumber(opt.duration)) {\n    opt.duration = 400;\n  }\n\n  opt.easing = typeof opt.easing === 'function' ? opt.easing : Math[opt.easing] || Math.easeInOutSine;\n  opt.curAnim = H.merge(params);\n  H.objectEach(params, function (val, prop) {\n    // Stop current running animation of this property\n    H.stop(el, prop);\n    fx = new H.Fx(el, opt, prop);\n    end = null;\n\n    if (prop === 'd') {\n      fx.paths = fx.initPath(el, el.d, params.d);\n      fx.toD = params.d;\n      start = 0;\n      end = 1;\n    } else if (el.attr) {\n      start = el.attr(prop);\n    } else {\n      start = parseFloat(H.getStyle(el, prop)) || 0;\n\n      if (prop !== 'opacity') {\n        unit = 'px';\n      }\n    }\n\n    if (!end) {\n      end = val;\n    }\n\n    if (end && end.match && end.match('px')) {\n      end = end.replace(/px/g, ''); // #4351\n    }\n\n    fx.run(start, end, unit);\n  });\n};\n/**\n * Factory to create new series prototypes.\n *\n * @function Highcharts.seriesType\n *\n * @param {string} type\n *        The series type name.\n *\n * @param {string} parent\n *        The parent series type name. Use `line` to inherit from the basic\n *        {@link Series} object.\n *\n * @param {*} options\n *        The additional default options that is merged with the parent's\n *        options.\n *\n * @param {*} props\n *        The properties (functions and primitives) to set on the new\n *        prototype.\n *\n * @param {*} [pointProps]\n *        Members for a series-specific extension of the {@link Point}\n *        prototype if needed.\n *\n * @return {Highcharts.Series}\n *         The newly created prototype as extended from {@link Series} or its\n *         derivatives.\n */\n// docs: add to API + extending Highcharts\n\n\nH.seriesType = function (type, parent, options, props, pointProps) {\n  var defaultOptions = H.getOptions(),\n      seriesTypes = H.seriesTypes; // Merge the options\n\n  defaultOptions.plotOptions[type] = H.merge(defaultOptions.plotOptions[parent], options); // Create the class\n\n  seriesTypes[type] = H.extendClass(seriesTypes[parent] || function () {}, props);\n  seriesTypes[type].prototype.type = type; // Create the point class if needed\n\n  if (pointProps) {\n    seriesTypes[type].prototype.pointClass = H.extendClass(H.Point, pointProps);\n  }\n\n  return seriesTypes[type];\n};\n/**\n * Get a unique key for using in internal element id's and pointers. The key is\n * composed of a random hash specific to this Highcharts instance, and a\n * counter.\n *\n * @example\n * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'\n *\n * @function Highcharts.uniqueKey\n *\n * @return {string}\n *         A unique key.\n */\n\n\nH.uniqueKey = function () {\n  var uniqueKeyHash = Math.random().toString(36).substring(2, 9),\n      idCounter = 0;\n  return function () {\n    return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;\n  };\n}(); // Register Highcharts as a plugin in jQuery\n\n\nif (win.jQuery) {\n  /**\n   * Highcharts-extended JQuery.\n   *\n   * @external JQuery\n   */\n\n  /**\n   * Factory function to create a chart in the current JQuery selector\n   * element.\n   *\n   * @function external:JQuery#highcharts\n   *\n   * @param {\"Chart\"|\"Map\"|\"StockChart\"|string} [className]\n   *        Name of the factory class in the Highcharts namespace.\n   *\n   * @param {Highcharts.Options} options\n   *        The chart options structure.\n   *\n   * @param {Highcharts.ChartCallbackFunction} [callback]\n   *        Function to run when the chart has loaded and and all external\n   *        images are loaded. Defining a [chart.event.load\n   *        ](https://api.highcharts.com/highcharts/chart.events.load) handler\n   *        is equivalent.\n   *\n   * @return {JQuery}\n   *         The current JQuery selector.\n   */\n  win.jQuery.fn.highcharts = function () {\n    var args = [].slice.call(arguments);\n\n    if (this[0]) {\n      // this[0] is the renderTo div\n      // Create the chart\n      if (args[0]) {\n        new H[// eslint-disable-line no-new\n        // Constructor defaults to Chart\n        H.isString(args[0]) ? args.shift() : 'Chart'](this[0], args[0], args[1]);\n        return this;\n      } // When called without parameters or with the return argument,\n      // return an existing chart\n\n\n      return charts[H.attr(this[0], 'data-highcharts-chart')];\n    }\n  };\n}"
    },
    {
     "id": 239,
     "name": "../node_modules/highcharts/js/es-modules/parts/Series.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Translation and scale for the plot area of a series.\n *\n * @typedef Highcharts.SeriesPlotBoxObject\n *\n * @property {number} translateX\n *\n * @property {number} translateY\n *\n * @property {number} scaleX\n *\n * @property {number} scaleY\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Options.js';\nimport './Legend.js';\nimport './Point.js';\nimport './SvgRenderer.js';\nvar addEvent = H.addEvent,\n    animObject = H.animObject,\n    arrayMax = H.arrayMax,\n    arrayMin = H.arrayMin,\n    correctFloat = H.correctFloat,\n    defaultOptions = H.defaultOptions,\n    defaultPlotOptions = H.defaultPlotOptions,\n    defined = H.defined,\n    each = H.each,\n    erase = H.erase,\n    extend = H.extend,\n    fireEvent = H.fireEvent,\n    grep = H.grep,\n    isArray = H.isArray,\n    isNumber = H.isNumber,\n    isString = H.isString,\n    LegendSymbolMixin = H.LegendSymbolMixin,\n    // @todo add as a requirement\nmerge = H.merge,\n    objectEach = H.objectEach,\n    pick = H.pick,\n    Point = H.Point,\n    // @todo  add as a requirement\nremoveEvent = H.removeEvent,\n    splat = H.splat,\n    SVGElement = H.SVGElement,\n    syncTimeout = H.syncTimeout,\n    win = H.win;\n/**\n * This is the base series prototype that all other series types inherit from.\n * A new series is initialized either through the\n * {@link https://api.highcharts.com/highcharts/series|series}\n * option structure, or after the chart is initialized, through\n * {@link Highcharts.Chart#addSeries}.\n *\n * The object can be accessed in a number of ways. All series and point event\n * handlers give a reference to the `series` object. The chart object has a\n * {@link Highcharts.Chart.series|series} property that is a collection of all\n * the chart's series. The point objects and axis objects also have the same\n * reference.\n *\n * Another way to reference the series programmatically is by `id`. Add an id\n * in the series configuration options, and get the series object by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the series are given in three levels. Options for\n * all series in a chart are given in the\n * {@link https://api.highcharts.com/highcharts/plotOptions.series|\n * plotOptions.series} object. Then options for all series of a specific type\n * are given in the plotOptions of that type, for example `plotOptions.line`.\n * Next, options for one single series are given in the series array, or as\n * arguements to `chart.addSeries`.\n *\n * The data in the series is stored in various arrays.\n *\n * - First, `series.options.data` contains all the original config options for\n *   each point whether added by options or methods like `series.addPoint`.\n *\n * - Next, `series.data` contains those values converted to points, but in case\n *   the series data length exceeds the `cropThreshold`, or if the data is\n *   grouped, `series.data` doesn't contain all the points. It only contains the\n *   points that have been created on demand.\n *\n * - Then there's `series.points` that contains all currently visible point\n *   objects. In case of cropping, the cropped-away points are not part of this\n *   array. The `series.points` array starts at `series.cropStart` compared to\n *   `series.data` and `series.options.data`. If however the series data is\n *   grouped, these can't be correlated one to one.\n *\n * - `series.xData` and `series.processedXData` contain clean x values,\n *   equivalent to `series.data` and `series.points`.\n *\n * - `series.yData` and `series.processedYData` contain clean y values,\n *   equivalent to `series.data` and `series.points`.\n *\n * @class\n * @name Highcharts.Series\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @param {Highcharts.PlotSeriesOptions} options\n *        The series options.\n */\n\n/**\n* The line series is the base type and is therefor the series base prototype.\n*\n* @private\n* @class\n* @name Highcharts.seriesTypes.line\n*\n* @augments Highcharts.Series\n*/\n\nH.Series = H.seriesType('line', null\n/**\n * General options for all series types.\n *\n * @optionparent plotOptions.series\n */\n, {\n  // base series options\n\n  /**\n   * For some series, there is a limit that shuts down initial animation\n   * by default when the total number of points in the chart is too high.\n   * For example, for a column chart and its derivatives, animation doesn't\n   * run if there is more than 250 points totally. To disable this cap, set\n   * `animationLimit` to `Infinity`.\n   *\n   * @type      {number}\n   * @apioption plotOptions.series.animationLimit\n   */\n\n  /**\n   * Allow this series' points to be selected by clicking on the graphic\n   * (columns, point markers, pie slices, map areas etc).\n   *\n   * @see {@link Highcharts.Chart#getSelectedPoints}.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/\n   *         Line\n   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/\n   *         Column\n   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/\n   *         Pie\n   * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n   *         Map area\n   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/\n   *         Map bubble\n   *\n   * @since 1.2.0\n   */\n  allowPointSelect: false,\n\n  /**\n   * If true, a checkbox is displayed next to the legend item to allow\n   * selecting the series. The state of the checkbox is determined by\n   * the `selected` option.\n   *\n   * @productdesc {highmaps}\n   * Note that if a `colorAxis` is defined, the color axis is represented in\n   * the legend, not the series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/\n   *         Show select box\n   *\n   * @since 1.2.0\n   */\n  showCheckbox: false,\n\n  /**\n   * Enable or disable the initial animation when a series is displayed.\n   * The animation can also be set as a configuration object. Please\n   * note that this option only applies to the initial animation of the\n   * series itself. For other animations, see [chart.animation](\n   * #chart.animation) and the animation parameter under the API methods. The\n   * following properties are supported:\n   *\n   * <dl>\n   *\n   * <dt>duration</dt>\n   *\n   * <dd>The duration of the animation in milliseconds.</dd>\n   *\n   * <dt>easing</dt>\n   *\n   * <dd>Can be a string reference to an easing function set on the `Math`\n   * object or a function. See the _Custom easing function_ demo below.</dd>\n   *\n   * </dl>\n   *\n   * Due to poor performance, animation is disabled in old IE browsers\n   * for several chart types.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/\n   *         Animation disabled\n   * @sample {highcharts} highcharts/plotoptions/series-animation-slower/\n   *         Slower animation\n   * @sample {highcharts} highcharts/plotoptions/series-animation-easing/\n   *         Custom easing function\n   * @sample {highstock} stock/plotoptions/animation-slower/\n   *         Slower animation\n   * @sample {highstock} stock/plotoptions/animation-easing/\n   *         Custom easing function\n   * @sample {highmaps} maps/plotoptions/series-animation-true/\n   *         Animation enabled on map series\n   * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/\n   *         Disabled on mapbubble series\n   *\n   * @type    {boolean|Highcharts.AnimationOptionsObject}\n   * @default {highcharts} true\n   * @default {highstock} true\n   * @default {highmaps} false\n   */\n  animation: {\n    /**\n     * @type      {number}\n     * @default   1000\n     * @apioption plotOptions.series.animation.duration\n     */\n    duration: 1000\n  },\n\n  /**\n   * An additional class name to apply to the series' graphical elements. This\n   * option does not replace default class names of the graphical element.\n   *\n   * @type      {string}\n   * @since     5.0.0\n   * @apioption plotOptions.series.className\n   */\n\n  /**\n   * Disable this option to allow series rendering in the whole plotting\n   * area.\n   *\n   * **Note:** Clipping should be always enabled when\n   * [chart.zoomType](#chart.zoomType) is set\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-clip/\n   *         Disabled clipping\n   *\n   * @default   true\n   * @type      {boolean}\n   * @since     3.0.0\n   * @apioption plotOptions.series.clip\n   */\n\n  /**\n   * The main color of the series. In line type series it applies to the\n   * line and the point markers unless otherwise specified. In bar type\n   * series it applies to the bars unless a color is specified per point.\n   * The default value is pulled from the `options.colors` array.\n   *\n   * In styled mode, the color can be defined by the\n   * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series\n   * color can be set with the `.highcharts-series`, `.highcharts-color-{n}`,\n   * `.highcharts-{type}-series` or `.highcharts-series-{n}` class, or\n   * individual classes given by the `className` option.\n   *\n   * @productdesc {highmaps}\n   * In maps, the series color is rarely used, as most choropleth maps use the\n   * color to denote the value of each point. The series color can however be\n   * used in a map with multiple series holding categorized data.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-color-general/\n   *         General plot option\n   * @sample {highcharts} highcharts/plotoptions/series-color-specific/\n   *         One specific series\n   * @sample {highcharts} highcharts/plotoptions/series-color-area/\n   *         Area color\n   * @sample {highcharts} highcharts/series/infographic/\n   *         Pattern fill\n   * @sample {highmaps} maps/demo/category-map/\n   *         Category map by multiple series\n   *\n   * @type      {Highcharts.ColorString}\n   * @apioption plotOptions.series.color\n   */\n\n  /**\n   * Styled mode only. A specific color index to use for the series, so its\n   * graphic representations are given the class name `highcharts-color-{n}`.\n   *\n   * @type      {number}\n   * @since     5.0.0\n   * @apioption plotOptions.series.colorIndex\n   */\n\n  /**\n   * Whether to connect a graph line across null points, or render a gap\n   * between the two points on either side of the null.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/\n   *         False by default\n   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/\n   *         True\n   *\n   * @type      {boolean}\n   * @default   false\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.connectNulls\n   */\n\n  /**\n   * You can set the cursor to \"pointer\" if you have click events attached\n   * to the series, to signal to the user that the points and lines can\n   * be clicked.\n   *\n   * In styled mode, the series cursor can be set with the same classes\n   * as listed under [series.color](#plotOptions.series.color).\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-cursor-line/\n   *         On line graph\n   * @sample {highcharts} highcharts/plotoptions/series-cursor-column/\n   *         On columns\n   * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/\n   *         On scatter markers\n   * @sample {highstock} stock/plotoptions/cursor/\n   *         Pointer on a line graph\n   * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n   *         Map area\n   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/\n   *         Map bubble\n   *\n   * @type       {string}\n   * @validvalue [\"crosshair\",\"default\",\"help\",\"none\",\"pointer\"]\n   * @apioption  plotOptions.series.cursor\n   */\n\n  /**\n   * A name for the dash style to use for the graph, or for some series types\n   * the outline of each shape.\n   *\n   * In styled mode, the [stroke dash-array](https://jsfiddle.net/gh/get/\n   * library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/\n   * series-dashstyle/) can be set with the same classes as listed under\n   * [series.color](#plotOptions.series.color).\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/\n   *         Possible values demonstrated\n   * @sample {highcharts} highcharts/plotoptions/series-dashstyle/\n   *         Chart suitable for printing in black and white\n   * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/\n   *         Possible values demonstrated\n   * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/\n   *         Possible values demonstrated\n   * @sample {highmaps} maps/plotoptions/series-dashstyle/\n   *         Dotted borders on a map\n   *\n   * @type       {string}\n   * @default    Solid\n   * @since      2.1\n   * @validvalue [\"Dash\",\"DashDot\",\"Dot\",\"LongDash\",\"LongDashDot\",\n   *             \"LongDashDotDot\",\"ShortDash\",\"ShortDashDot\",\n   *             \"ShortDashDotDot\",\"ShortDot\",\"Solid\"]\n   * @apioption  plotOptions.series.dashStyle\n   */\n\n  /**\n   * Requires the Accessibility module.\n   *\n   * A description of the series to add to the screen reader information\n   * about the series.\n   *\n   * @type      {string}\n   * @since     5.0.0\n   * @apioption plotOptions.series.description\n   */\n\n  /**\n   * Enable or disable the mouse tracking for a specific series. This\n   * includes point tooltips and click events on graphs and points. For\n   * large datasets it improves performance.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/\n   *         No mouse tracking\n   * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/\n   *         No mouse tracking\n   *\n   * @type      {boolean}\n   * @default   true\n   * @apioption plotOptions.series.enableMouseTracking\n   */\n\n  /**\n   * By default, series are exposed to screen readers as regions. By enabling\n   * this option, the series element itself will be exposed in the same\n   * way as the data points. This is useful if the series is not used\n   * as a grouping entity in the chart, but you still want to attach a\n   * description to the series.\n   *\n   * Requires the Accessibility module.\n   *\n   * @sample highcharts/accessibility/art-grants/\n   *         Accessible data visualization\n   *\n   * @type      {boolean}\n   * @since     5.0.12\n   * @apioption plotOptions.series.exposeElementToA11y\n   */\n\n  /**\n   * Whether to use the Y extremes of the total chart width or only the\n   * zoomed area when zooming in on parts of the X axis. By default, the\n   * Y axis adjusts to the min and max of the visible data. Cartesian\n   * series only.\n   *\n   * @type      {boolean}\n   * @default   false\n   * @since     4.1.6\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.getExtremesFromAll\n   */\n\n  /**\n   * An array specifying which option maps to which key in the data point\n   * array. This makes it convenient to work with unstructured data arrays\n   * from different sources.\n   *\n   * @see [series.data](#series.line.data)\n   *\n   * @sample {highcharts|highstock} highcharts/series/data-keys/\n   *         An extended data array with keys\n   * @sample {highcharts|highstock} highcharts/series/data-nested-keys/\n   *         Nested keys used to access object properties\n   *\n   * @type      {Array<string>}\n   * @since     4.1.6\n   * @apioption plotOptions.series.keys\n   */\n\n  /**\n   * The line cap used for line ends and line joins on the graph.\n   *\n   * @type       {string}\n   * @product    highcharts highstock\n   * @validvalue [\"round\", \"square\"]\n   * @apioption  plotOptions.series.linecap\n   */\n\n  /**\n   * The [id](#series.id) of another series to link to. Additionally,\n   * the value can be \":previous\" to link to the previous series. When\n   * two series are linked, only the first one appears in the legend.\n   * Toggling the visibility of this also toggles the linked series.\n   *\n   * @sample {highcharts|highstock} highcharts/demo/arearange-line/\n   *         Linked series\n   *\n   * @type      {string}\n   * @since     3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.linkedTo\n   */\n\n  /**\n   * Options for the corresponding navigator series if `showInNavigator`\n   * is `true` for this series. Available options are the same as any\n   * series, documented at [plotOptions](#plotOptions.series) and\n   * [series](#series).\n   *\n   * These options are merged with options in [navigator.series](\n   * #navigator.series), and will take precedence if the same option is\n   * defined both places.\n   *\n   * @see [navigator.series](#navigator.series)\n   *\n   * @type      {*}\n   * @since     5.0.0\n   * @product   highstock\n   * @apioption plotOptions.series.navigatorOptions\n   */\n\n  /**\n   * The color for the parts of the graph or points that are below the\n   * [threshold](#plotOptions.series.threshold).\n   *\n   * @see In styled mode, a negative color is applied by setting this option\n   *      to `true` combined with the `.highcharts-negative` class name.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-negative-color/\n   *         Spline, area and column\n   * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/\n   *         Arearange\n   * @sample {highcharts} highcharts/css/series-negative-color/\n   *         Styled mode\n   * @sample {highstock} highcharts/plotoptions/series-negative-color/\n   *         Spline, area and column\n   * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/\n   *         Arearange\n   * @sample {highmaps} highcharts/plotoptions/series-negative-color/\n   *         Spline, area and column\n   * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/\n   *         Arearange\n   *\n   * @type      {Highcharts.ColorString}\n   * @since     3.0\n   * @apioption plotOptions.series.negativeColor\n   */\n\n  /**\n   * Same as [accessibility.pointDescriptionFormatter](\n   * #accessibility.pointDescriptionFormatter), but for an individual series.\n   * Overrides the chart wide configuration.\n   *\n   * @type      {Function}\n   * @since     5.0.12\n   * @apioption plotOptions.series.pointDescriptionFormatter\n   */\n\n  /**\n   * If no x values are given for the points in a series, `pointInterval`\n   * defines the interval of the x values. For example, if a series contains\n   * one value every decade starting from year 0, set `pointInterval` to\n   * `10`. In true `datetime` axes, the `pointInterval` is set in\n   * milliseconds.\n   *\n   * It can be also be combined with `pointIntervalUnit` to draw irregular\n   * time intervals.\n   *\n   * Please note that this options applies to the _series data_, not the\n   * interval of the axis ticks, which is independent.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/\n   *         Datetime X axis\n   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/\n   *         Using pointStart and pointInterval\n   *\n   * @type      {number}\n   * @default   1\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.pointInterval\n   */\n\n  /**\n   * On datetime series, this allows for setting the\n   * [pointInterval](#plotOptions.series.pointInterval) to irregular time\n   * units, `day`, `month` and `year`. A day is usually the same as 24 hours,\n   * but `pointIntervalUnit` also takes the DST crossover into consideration\n   * when dealing with local time. Combine this option with `pointInterval`\n   * to draw weeks, quarters, 6 months, 10 years etc.\n   *\n   * Please note that this options applies to the _series data_, not the\n   * interval of the axis ticks, which is independent.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/\n   *         One point a month\n   * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/\n   *         One point a month\n   *\n   * @type       {string}\n   * @since      4.1.0\n   * @product    highcharts highstock\n   * @validvalue [\"day\", \"month\", \"year\"]\n   * @apioption  plotOptions.series.pointIntervalUnit\n   */\n\n  /**\n   * Possible values: `\"on\"`, `\"between\"`, `number`.\n   *\n   * In a column chart, when pointPlacement is `\"on\"`, the point will\n   * not create any padding of the X axis. In a polar column chart this\n   * means that the first column points directly north. If the pointPlacement\n   * is `\"between\"`, the columns will be laid out between ticks. This\n   * is useful for example for visualising an amount between two points\n   * in time or in a certain sector of a polar chart.\n   *\n   * Since Highcharts 3.0.2, the point placement can also be numeric,\n   * where 0 is on the axis value, -0.5 is between this value and the\n   * previous, and 0.5 is between this value and the next. Unlike the\n   * textual options, numeric point placement options won't affect axis\n   * padding.\n   *\n   * Note that pointPlacement needs a [pointRange](\n   * #plotOptions.series.pointRange) to work. For column series this is\n   * computed, but for line-type series it needs to be set.\n   *\n   * Defaults to `undefined` in cartesian charts, `\"between\"` in polar charts.\n   *\n   * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)\n   *\n   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/\n   *         Between in a column chart\n   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/\n   *         Numeric placement for custom layout\n   *\n   * @type      {string|number}\n   * @since     2.3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.pointPlacement\n   */\n\n  /**\n   * If no x values are given for the points in a series, pointStart defines\n   * on what value to start. For example, if a series contains one yearly\n   * value starting from 1945, set pointStart to 1945.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/\n   *         Linear\n   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/\n   *         Datetime\n   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/\n   *         Using pointStart and pointInterval\n   *\n   * @type      {number}\n   * @default   0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.pointStart\n   */\n\n  /**\n   * Whether to select the series initially. If `showCheckbox` is true,\n   * the checkbox next to the series name in the legend will be checked for a\n   * selected series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-selected/\n   *         One out of two series selected\n   *\n   * @type      {boolean}\n   * @default   false\n   * @since     1.2.0\n   * @apioption plotOptions.series.selected\n   */\n\n  /**\n   * Whether to apply a drop shadow to the graph line. Since 2.3 the shadow\n   * can be an object configuration containing `color`, `offsetX`, `offsetY`,\n   * `opacity` and `width`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-shadow/\n   *         Shadow enabled\n   *\n   * @type      {boolean|Highcharts.ShadowOptionsObject}\n   * @default   false\n   * @apioption plotOptions.series.shadow\n   */\n\n  /**\n   * Whether to display this particular series or series type in the legend.\n   * The default value is `true` for standalone series, `false` for linked\n   * series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-showinlegend/\n   *         One series in the legend, one hidden\n   *\n   * @type      {boolean}\n   * @default   true\n   * @apioption plotOptions.series.showInLegend\n   */\n\n  /**\n   * Whether or not to show the series in the navigator. Takes precedence\n   * over [navigator.baseSeries](#navigator.baseSeries) if defined.\n   *\n   * @type      {boolean}\n   * @since     5.0.0\n   * @product   highstock\n   * @apioption plotOptions.series.showInNavigator\n   */\n\n  /**\n   * If set to `true`, the accessibility module will skip past the points\n   * in this series for keyboard navigation.\n   *\n   * @type      {boolean}\n   * @since     5.0.12\n   * @apioption plotOptions.series.skipKeyboardNavigation\n   */\n\n  /**\n   * Whether to stack the values of each series on top of each other. Possible\n   * values are `undefined` to disable, `\"normal\"` to stack by value or\n   * `\"percent\"`. When stacking is enabled, data must be sorted in ascending\n   * X order. A special stacking option is with the streamgraph series type,\n   * where the stacking option is set to `\"stream\"`.\n   *\n   * @see [yAxis.reversedStacks](#yAxis.reversedStacks)\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-line/\n   *         Line\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-column/\n   *         Column\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/\n   *         Bar\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-area/\n   *         Area\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/\n   *         Line\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/\n   *         Column\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/\n   *         Bar\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/\n   *         Area\n   * @sample {highstock} stock/plotoptions/stacking/\n   *         Area\n   *\n   * @type       {string}\n   * @product    highcharts highstock\n   * @validvalue [\"normal\", \"percent\"]\n   * @apioption  plotOptions.series.stacking\n   */\n\n  /**\n   * Whether to apply steps to the line. Possible values are `left`, `center`\n   * and `right`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/line-step/\n   *         Different step line options\n   * @sample {highcharts} highcharts/plotoptions/area-step/\n   *         Stepped, stacked area\n   * @sample {highstock} stock/plotoptions/line-step/\n   *         Step line\n   *\n   * @type       {string}\n   * @since      1.2.5\n   * @product    highcharts highstock\n   * @validvalue [\"left\", \"center\", \"right\"]\n   * @apioption  plotOptions.series.step\n   */\n\n  /**\n   * The threshold, also called zero level or base level. For line type\n   * series this is only used in conjunction with\n   * [negativeColor](#plotOptions.series.negativeColor).\n   *\n   * @see [softThreshold](#plotOptions.series.softThreshold).\n   *\n   * @type      {number}\n   * @default   0\n   * @since     3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.threshold\n   */\n\n  /**\n   * Set the initial visibility of the series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-visible/\n   *         Two series, one hidden and one visible\n   * @sample {highstock} stock/plotoptions/series-visibility/\n   *         Hidden series\n   *\n   * @type      {boolean}\n   * @default   true\n   * @apioption plotOptions.series.visible\n   */\n\n  /**\n   * Defines the Axis on which the zones are applied.\n   *\n   * @see [zones](#plotOptions.series.zones)\n   *\n   * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/\n   *         Zones on the X-Axis\n   * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/\n   *         Zones on the X-Axis\n   *\n   * @type      {string}\n   * @default   y\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zoneAxis\n   */\n\n  /**\n   * General event handlers for the series items. These event hooks can also\n   * be attached to the series at run time using the `Highcharts.addEvent`\n   * function.\n   */\n  events: {},\n\n  /**\n   * Fires after the series has finished its initial animation, or in\n   * case animation is disabled, immediately as the series is displayed.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/\n   *         Show label after animate\n   * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/\n   *         Show label after animate\n   *\n   * @type      {Function}\n   * @since     4.0\n   * @product   highcharts highstock\n   * @context   Series\n   * @apioption plotOptions.series.events.afterAnimate\n   */\n\n  /**\n   * Fires when the checkbox next to the series' name in the legend is\n   * clicked. One parameter, `event`, is passed to the function. The state\n   * of the checkbox is found by `event.checked`. The checked item is\n   * found by `event.item`. Return `false` to prevent the default action\n   * which is to toggle the select state of the series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/\n   *         Alert checkbox status\n   *\n   * @type      {Function}\n   * @since     1.2.0\n   * @context   Series\n   * @apioption plotOptions.series.events.checkboxClick\n   */\n\n  /**\n   * Fires when the series is clicked. One parameter, `event`, is passed to\n   * the function, containing common event information. Additionally,\n   * `event.point` holds a pointer to the nearest point on the graph.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-click/\n   *         Alert click info\n   * @sample {highstock} stock/plotoptions/series-events-click/\n   *         Alert click info\n   * @sample {highmaps} maps/plotoptions/series-events-click/\n   *         Display click info in subtitle\n   *\n   * @type      {Function}\n   * @context   Series\n   * @apioption plotOptions.series.events.click\n   */\n\n  /**\n   * Fires when the series is hidden after chart generation time, either\n   * by clicking the legend item or by calling `.hide()`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-hide/\n   *         Alert when the series is hidden by clicking the legend item\n   *\n   * @type      {Function}\n   * @since     1.2.0\n   * @context   Series\n   * @apioption plotOptions.series.events.hide\n   */\n\n  /**\n   * Fires when the legend item belonging to the series is clicked. One\n   * parameter, `event`, is passed to the function. The default action\n   * is to toggle the visibility of the series. This can be prevented\n   * by returning `false` or calling `event.preventDefault()`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-legenditemclick/\n   *         Confirm hiding and showing\n   *\n   * @type      {Function}\n   * @context   Series\n   * @apioption plotOptions.series.events.legendItemClick\n   */\n\n  /**\n   * Fires when the mouse leaves the graph. One parameter, `event`, is\n   * passed to the function, containing common event information. If the\n   * [stickyTracking](#plotOptions.series) option is true, `mouseOut`\n   * doesn't happen before the mouse enters another graph or leaves the\n   * plot area.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/\n   *         With sticky tracking by default\n   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/\n   *         Without sticky tracking\n   *\n   * @type      {Function}\n   * @context   Series\n   * @apioption plotOptions.series.events.mouseOut\n   */\n\n  /**\n   * Fires when the mouse enters the graph. One parameter, `event`, is\n   * passed to the function, containing common event information.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/\n   *         With sticky tracking by default\n   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/\n   *         Without sticky tracking\n   *\n   * @type      {Function}\n   * @context   Series\n   * @apioption plotOptions.series.events.mouseOver\n   */\n\n  /**\n   * Fires when the series is shown after chart generation time, either\n   * by clicking the legend item or by calling `.show()`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-show/\n   *         Alert when the series is shown by clicking the legend item.\n   *\n   * @type      {Function}\n   * @since     1.2.0\n   * @context   Series\n   * @apioption plotOptions.series.events.show\n   */\n\n  /**\n   * Options for the point markers of line-like series. Properties like\n   * `fillColor`, `lineColor` and `lineWidth` define the visual appearance\n   * of the markers. Other series types, like column series, don't have\n   * markers, but have visual options on the series level instead.\n   *\n   * In styled mode, the markers can be styled with the `.highcharts-point`,\n   * `.highcharts-point-hover` and `.highcharts-point-select`\n   * class names.\n   */\n  marker: {\n    /**\n     * Enable or disable the point marker. If `undefined`, the markers are\n     * hidden when the data is dense, and shown for more widespread data\n     * points.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/\n     *         Disabled markers\n     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/\n     *         Disabled in normal state but enabled on hover\n     * @sample {highstock} stock/plotoptions/series-marker/\n     *         Enabled markers\n     *\n     * @type      {boolean}\n     * @default   {highcharts} undefined\n     * @default   {highstock} false\n     * @apioption plotOptions.series.marker.enabled\n     */\n\n    /**\n     * Image markers only. Set the image width explicitly. When using this\n     * option, a `width` must also be set.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/\n     *         Fixed width and height\n     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/\n     *         Fixed width and height\n     *\n     * @type      {number}\n     * @since     4.0.4\n     * @apioption plotOptions.series.marker.height\n     */\n\n    /**\n     * A predefined shape or symbol for the marker. When undefined, the\n     * symbol is pulled from options.symbols. Other possible values are\n     * \"circle\", \"square\", \"diamond\", \"triangle\" and \"triangle-down\".\n     *\n     * Additionally, the URL to a graphic can be given on this form:\n     * \"url(graphic.png)\". Note that for the image to be applied to exported\n     * charts, its URL needs to be accessible by the export server.\n     *\n     * Custom callbacks for symbol path generation can also be added to\n     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n     * used by its method name, as shown in the demo.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/\n     *         Predefined, graphic and custom markers\n     * @sample {highstock} highcharts/plotoptions/series-marker-symbol/\n     *         Predefined, graphic and custom markers\n     *\n     * @type      {string}\n     * @apioption plotOptions.series.marker.symbol\n     */\n\n    /**\n     * The threshold for how dense the point markers should be before they\n     * are hidden, given that `enabled` is not defined. The number indicates\n     * the horizontal distance between the two closest points in the series,\n     * as multiples of the `marker.radius`. In other words, the default\n     * value of 2 means points are hidden if overlapping horizontally.\n     *\n     * @sample highcharts/plotoptions/series-marker-enabledthreshold\n     *         A higher threshold\n     *\n     * @since 6.0.5\n     */\n    enabledThreshold: 2,\n\n    /**\n     * The radius of the point marker.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-radius/\n     *         Bigger markers\n     */\n    radius: 4,\n\n    /**\n     * Image markers only. Set the image width explicitly. When using this\n     * option, a `height` must also be set.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/\n     *         Fixed width and height\n     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/\n     *         Fixed width and height\n     *\n     * @type      {number}\n     * @since     4.0.4\n     * @apioption plotOptions.series.marker.width\n     */\n\n    /**\n     * States for a single point marker.\n     */\n    states: {\n      /**\n       * The normal state of a single point marker. Currently only used\n       * for setting animation when returning to normal state from hover.\n       */\n      normal: {\n        /**\n         * Animation when returning to normal state after hovering.\n         *\n         * @type {boolean|Highcharts.AnimationOptionsObject}\n         */\n        animation: true\n      },\n\n      /**\n       * The hover state for a single point marker.\n       */\n      hover: {\n        /**\n         * Animation when hovering over the marker.\n         *\n         * @type {boolean|Highcharts.AnimationOptionsObject}\n         */\n        animation: {\n          duration: 50\n        },\n\n        /**\n         * Enable or disable the point marker.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/\n         *         Disabled hover state\n         */\n        enabled: true,\n\n        /**\n         * The fill color of the marker in hover state. When\n         * `undefined`, the series' or point's fillColor for normal\n         * state is used.\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption plotOptions.series.marker.states.hover.fillColor\n         */\n\n        /**\n         * The color of the point marker's outline. When `undefined`,\n         * the series' or point's lineColor for normal state is used.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/\n         *         White fill color, black line color\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption plotOptions.series.marker.states.hover.lineColor\n         */\n\n        /**\n         * The width of the point marker's outline. When `undefined`,\n         * the series' or point's lineWidth for normal state is used.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/\n         *         3px line width\n         *\n         * @type      {number}\n         * @apioption plotOptions.series.marker.states.hover.lineWidth\n         */\n\n        /**\n         * The radius of the point marker. In hover state, it defaults\n         * to the normal state's radius + 2 as per the [radiusPlus](\n         * #plotOptions.series.marker.states.hover.radiusPlus)\n         * option.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/\n         *         10px radius\n         *\n         * @type      {number}\n         * @apioption plotOptions.series.marker.states.hover.radius\n         */\n\n        /**\n         * The number of pixels to increase the radius of the hovered\n         * point.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/\n         *         5 pixels greater radius on hover\n         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/\n         *         5 pixels greater radius on hover\n         *\n         * @since 4.0.3\n         */\n        radiusPlus: 2\n      }\n    }\n  },\n\n  /**\n   * Properties for each single point.\n   */\n  point: {\n    /**\n     * Fires when a point is clicked. One parameter, `event`, is passed\n     * to the function, containing common event information.\n     *\n     * If the `series.allowPointSelect` option is true, the default\n     * action for the point's click event is to toggle the point's\n     * select state. Returning `false` cancels this action.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-click/\n     *         Click marker to alert values\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/\n     *         Click column\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/\n     *         Go to URL\n     * @sample {highmaps} maps/plotoptions/series-point-events-click/\n     *         Click marker to display values\n     * @sample {highmaps} maps/plotoptions/series-point-events-click-url/\n     *         Go to URL\n     *\n     * @type      {Function}\n     * @context   Point\n     * @apioption plotOptions.series.point.events.click\n     */\n\n    /**\n     * Fires when the mouse leaves the area close to the point. One\n     * parameter, `event`, is passed to the function, containing common\n     * event information.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/\n     *         Show values in the chart's corner on mouse over\n     *\n     * @type      {Function}\n     * @context   Point\n     * @apioption plotOptions.series.point.events.mouseOut\n     */\n\n    /**\n     * Fires when the mouse enters the area close to the point. One\n     * parameter, `event`, is passed to the function, containing common\n     * event information.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/\n     *         Show values in the chart's corner on mouse over\n     *\n     * @type      {Function}\n     * @context   Point\n     * @apioption plotOptions.series.point.events.mouseOver\n     */\n\n    /**\n     * Fires when the point is removed using the `.remove()` method. One\n     * parameter, `event`, is passed to the function. Returning `false`\n     * cancels the operation.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/\n     *         Remove point and confirm\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Point\n     * @apioption plotOptions.series.point.events.remove\n     */\n\n    /**\n     * Fires when the point is selected either programmatically or\n     * following a click on the point. One parameter, `event`, is passed\n     * to the function. Returning `false` cancels the operation.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-select/\n     *         Report the last selected point\n     * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n     *         Report select and unselect\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Point\n     * @apioption plotOptions.series.point.events.select\n     */\n\n    /**\n     * Fires when the point is unselected either programmatically or\n     * following a click on the point. One parameter, `event`, is passed\n     * to the function.\n     *  Returning `false` cancels the operation.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/\n     *         Report the last unselected point\n     * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n     *         Report select and unselect\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Point\n     * @apioption plotOptions.series.point.events.unselect\n     */\n\n    /**\n     * Fires when the point is updated programmatically through the\n     * `.update()` method. One parameter, `event`, is passed to the\n     * function. The new point options can be accessed through\n     * `event.options`. Returning `false` cancels the operation.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-update/\n     *         Confirm point updating\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Point\n     * @apioption plotOptions.series.point.events.update\n     */\n\n    /**\n     * Events for each single point.\n     */\n    events: {}\n  },\n\n  /**\n   * Options for the series data labels, appearing next to each data point.\n   *\n   * In styled mode, the data labels can be styled with the\n   * `.highcharts-data-label-box` and `.highcharts-data-label` class names\n   * ([see example](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-datalabels)).\n   */\n  dataLabels: {\n    /**\n     * The alignment of the data label compared to the point. If `right`,\n     * the right side of the label should be touching the point. For\n     * points with an extent, like columns, the alignments also dictates\n     * how to align it inside the box, as given with the\n     * [inside](#plotOptions.column.dataLabels.inside) option. Can be one of\n     * `left`, `center` or `right`.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/\n     *         Left aligned\n     *\n     * @validvalue [\"left\", \"center\", \"right\"]\n     */\n    align: 'center',\n\n    /**\n     * Whether to allow data labels to overlap. To make the labels less\n     * sensitive for overlapping, the [dataLabels.padding](\n     * #plotOptions.series.dataLabels.padding) can be set to 0.\n     *\n     * @sample highcharts/plotoptions/series-datalabels-allowoverlap-false/\n     *         Don't allow overlap\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     4.1.0\n     * @apioption plotOptions.series.dataLabels.allowOverlap\n     */\n\n    /**\n     * The border radius in pixels for the data label.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     * @sample {highstock} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     * @sample {highmaps} maps/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     *\n     * @type      {number}\n     * @default   0\n     * @since     2.2.1\n     * @apioption plotOptions.series.dataLabels.borderRadius\n     */\n\n    /**\n     * The border width in pixels for the data label.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     * @sample {highstock} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     *\n     * @type      {number}\n     * @default   0\n     * @since     2.2.1\n     * @apioption plotOptions.series.dataLabels.borderWidth\n     */\n\n    /**\n     * A class name for the data label. Particularly in styled mode, this\n     * can be used to give each series' or point's data label unique\n     * styling. In addition to this option, a default color class name is\n     * added so that we can give the labels a\n     * [contrast text shadow](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/data-label-contrast/).\n     *\n     * @sample {highcharts} highcharts/css/series-datalabels/\n     *         Styling by CSS\n     * @sample {highstock} highcharts/css/series-datalabels/\n     *         Styling by CSS\n     * @sample {highmaps} highcharts/css/series-datalabels/\n     *         Styling by CSS\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption plotOptions.series.dataLabels.className\n     */\n\n    /**\n     * The text color for the data labels. Defaults to `undefined`. For\n     * certain series types, like column or map, the data labels can be\n     * drawn inside the points. In this case the data label will be drawn\n     * with maximum contrast by default. Additionally, it will be given a\n     * `text-outline` style with the opposite color, to further increase the\n     * contrast. This can be overridden by setting the `text-outline` style\n     * to `none` in the `dataLabels.style` option.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/\n     *         Red data labels\n     * @sample {highmaps} maps/demo/color-axis/\n     *         White data labels\n     *\n     * @type      {Highcharts.ColorString}\n     * @apioption plotOptions.series.dataLabels.color\n     */\n\n    /**\n     * Whether to hide data labels that are outside the plot area. By\n     * default, the data label is moved inside the plot area according to\n     * the [overflow](#plotOptions.series.dataLabels.overflow) option.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     2.3.3\n     * @apioption plotOptions.series.dataLabels.crop\n     */\n\n    /**\n     * Whether to defer displaying the data labels until the initial series\n     * animation has finished.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.dataLabels.defer\n     */\n\n    /**\n     * Enable or disable the data labels.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/\n     *         Data labels enabled\n     * @sample {highmaps} maps/demo/color-axis/\n     *         Data labels enabled\n     *\n     * @type      {boolean}\n     * @default   false\n     * @apioption plotOptions.series.dataLabels.enabled\n     */\n\n    /**\n     * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)\n     * for the data label. Available variables are the same as for\n     * `formatter`.\n     *\n     * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-format/\n     *         Add a unit\n     * @sample {highmaps} maps/plotoptions/series-datalabels-format/\n     *         Formatted value in the data label\n     *\n     * @type      {string}\n     * @default   {highcharts} {y}\n     * @default   {highstock} {y}\n     * @default   {highmaps} {point.value}\n     * @since     3.0\n     * @apioption plotOptions.series.dataLabels.format\n     */\n\n    /**\n     * Callback JavaScript function to format the data label. Note that if a\n     * `format` is defined, the format takes precedence and the formatter is\n     * ignored. Available data are:\n     *\n     * <table>\n     *\n     * <tbody>\n     *\n     * <tr>\n     *\n     * <td>`this.percentage`</td>\n     *\n     * <td>Stacked series and pies only. The point's percentage of the\n     * total.</td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.point`</td>\n     *\n     * <td>The point object. The point name, if defined, is available\n     * through `this.point.name`.</td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.series`:</td>\n     *\n     * <td>The series object. The series name is available through\n     * `this.series.name`.</td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.total`</td>\n     *\n     * <td>Stacked series only. The total value at this point's x value.\n     * </td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.x`:</td>\n     *\n     * <td>The x value.</td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.y`:</td>\n     *\n     * <td>The y value.</td>\n     *\n     * </tr>\n     *\n     * </tbody>\n     *\n     * </table>\n     *\n     * @sample {highmaps} maps/plotoptions/series-datalabels-format/\n     *         Formatted value\n     *\n     * @type    {Highcharts.FormatterCallbackFunction}\n     * @default function () { return this.y; }\n     */\n    formatter: function formatter() {\n      return this.y === null ? '' : H.numberFormat(this.y, -1);\n    },\n\n    /**\n     * For points with an extent, like columns or map areas, whether to\n     * align the data label inside the box or to the actual value point.\n     * Defaults to `false` in most cases, `true` in stacked columns.\n     *\n     * @type      {boolean}\n     * @since     3.0\n     * @apioption plotOptions.series.dataLabels.inside\n     */\n\n    /**\n     * How to handle data labels that flow outside the plot area. The\n     * default is `\"justify\"`, which aligns them inside the plot area. For\n     * columns and bars, this means it will be moved inside the bar. To\n     * display data labels outside the plot area, set `crop` to `false` and\n     * `overflow` to `\"allow\"`.\n     *\n     * @type       {string}\n     * @default    justify\n     * @since      3.0.6\n     * @validvalue [\"allow\", \"justify\"]\n     * @apioption  plotOptions.series.dataLabels.overflow\n     */\n\n    /**\n     * Text rotation in degrees. Note that due to a more complex structure,\n     * backgrounds, borders and padding will be lost on a rotated data\n     * label.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/\n     *         Vertical labels\n     *\n     * @type      {number}\n     * @default   0\n     * @apioption plotOptions.series.dataLabels.rotation\n     */\n\n    /**\n     * Whether to\n     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)\n     * to render the labels.\n     *\n     * @type      {boolean}\n     * @default   false\n     * @apioption plotOptions.series.dataLabels.useHTML\n     */\n\n    /**\n     * The vertical alignment of a data label. Can be one of `top`, `middle`\n     * or `bottom`. The default value depends on the data, for instance\n     * in a column chart, the label is above positive values and below\n     * negative values.\n     *\n     * @since      2.3.3\n     * @validvalue [\"top\", \"middle\", \"bottom\"]\n     */\n    verticalAlign: 'bottom',\n    // above singular point\n\n    /**\n     * The x position offset of the label relative to the point in pixels.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/\n     *         Vertical and positioned\n     */\n    x: 0,\n\n    /**\n     * The y position offset of the label relative to the point in pixels.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/\n     *         Vertical and positioned\n     */\n    y: 0,\n\n    /**\n     * When either the `borderWidth` or the `backgroundColor` is set,\n     * this is the padding within the box.\n     *\n     * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     * @sample {highmaps} maps/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     *\n     * @default {highcharts} 5\n     * @default {highstock} 5\n     * @default {highmaps} 0\n     * @since   2.2.1\n     */\n    padding: 5\n  },\n\n  /**\n   * When the series contains less points than the crop threshold, all\n   * points are drawn, even if the points fall outside the visible plot\n   * area at the current zoom. The advantage of drawing all points (including\n   * markers and columns), is that animation is performed on updates.\n   * On the other hand, when the series contains more points than the\n   * crop threshold, the series data is cropped to only contain points\n   * that fall within the plot area. The advantage of cropping away invisible\n   * points is to increase performance on large series.\n   *\n   * @since   2.2\n   * @product highcharts highstock\n   */\n  cropThreshold: 300,\n\n  /**\n   * The width of each point on the x axis. For example in a column chart\n   * with one value each day, the pointRange would be 1 day (= 24 * 3600\n   * * 1000 milliseconds). This is normally computed automatically, but\n   * this option can be used to override the automatic value.\n   *\n   * @product highstock\n   */\n  pointRange: 0,\n\n  /**\n   * When this is true, the series will not cause the Y axis to cross\n   * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n   * unless the data actually crosses the plane.\n   *\n   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n   * 3 will make the Y axis show negative values according to the `minPadding`\n   * option. If `softThreshold` is `true`, the Y axis starts at 0.\n   *\n   * @since   4.1.9\n   * @product highcharts highstock\n   */\n  softThreshold: true,\n\n  /**\n   * A wrapper object for all the series options in specific states.\n   */\n  states: {\n    /**\n     * The normal state of a series, or for point items in column, pie and\n     * similar series. Currently only used for setting animation when\n     * returning to normal state from hover.\n     */\n    normal: {\n      /**\n       * Animation when returning to normal state after hovering.\n       *\n       * @type {boolean|Highcharts.AnimationOptionsObject}\n       */\n      animation: true\n    },\n\n    /**\n     * Options for the hovered series. These settings override the normal\n     * state options when a series is moused over or touched.\n     */\n    hover: {\n      /**\n       * Enable separate styles for the hovered series to visualize that\n       * the user hovers either the series itself or the legend. .\n       *\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/\n       *         Line\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/\n       *         Column\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/\n       *         Pie\n       *\n       * @type      {boolean}\n       * @default   true\n       * @since     1.2\n       * @apioption plotOptions.series.states.hover.enabled\n       */\n\n      /**\n       * Animation setting for hovering the graph in line-type series.\n       *\n       * @type    {boolean|Highcharts.AnimationOptionsObject}\n       * @since   5.0.8\n       * @product highcharts\n       */\n      animation: {\n        /**\n         * The duration of the hover animation in milliseconds. By\n         * default the hover state animates quickly in, and slowly back\n         * to normal.\n         */\n        duration: 50\n      },\n\n      /**\n       * Pixel width of the graph line. By default this property is\n       * undefined, and the `lineWidthPlus` property dictates how much\n       * to increase the linewidth from normal state.\n       *\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/\n       *         5px line on hover\n       *\n       * @type      {number}\n       * @product   highcharts highstock\n       * @apioption plotOptions.series.states.hover.lineWidth\n       */\n\n      /**\n       * The additional line width for the graph of a hovered series.\n       *\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/\n       *         5 pixels wider\n       * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/\n       *         5 pixels wider\n       *\n       * @since   4.0.3\n       * @product highcharts highstock\n       */\n      lineWidthPlus: 1,\n\n      /**\n       * In Highcharts 1.0, the appearance of all markers belonging to the\n       * hovered series. For settings on the hover state of the individual\n       * point, see\n       * [marker.states.hover](#plotOptions.series.marker.states.hover).\n       *\n       * @deprecated\n       *\n       * @extends plotOptions.series.marker\n       * @product highcharts highstock\n       */\n      marker: {// lineWidth: base + 1,\n        // radius: base + 1\n      },\n\n      /**\n       * Options for the halo appearing around the hovered point in line-\n       * type series as well as outside the hovered slice in pie charts.\n       * By default the halo is filled by the current point or series\n       * color with an opacity of 0.25\\. The halo can be disabled by\n       * setting the `halo` option to `false`.\n       *\n       * In styled mode, the halo is styled with the `.highcharts-halo`\n       * class, with colors inherited from `.highcharts-color-{n}`.\n       *\n       * @sample {highcharts} highcharts/plotoptions/halo/\n       *         Halo options\n       * @sample {highstock} highcharts/plotoptions/halo/\n       *         Halo options\n       *\n       * @since   4.0\n       * @product highcharts highstock\n       */\n      halo: {\n        /**\n         * A collection of SVG attributes to override the appearance of\n         * the halo, for example `fill`, `stroke` and `stroke-width`.\n         *\n         * @type      {Highcharts.SVGAttributes}\n         * @since     4.0\n         * @product   highcharts highstock\n         * @apioption plotOptions.series.states.hover.halo.attributes\n         */\n\n        /**\n         * The pixel size of the halo. For point markers this is the\n         * radius of the halo. For pie slices it is the width of the\n         * halo outside the slice. For bubbles it defaults to 5 and is\n         * the width of the halo outside the bubble.\n         *\n         * @since   4.0\n         * @product highcharts highstock\n         */\n        size: 10\n      }\n    },\n\n    /**\n     * Specific options for point in selected states, after being selected\n     * by [allowPointSelect](#plotOptions.series.allowPointSelect) or\n     * programmatically.\n     *\n     * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n     *         Allow point select demo\n     *\n     * @extends   plotOptions.series.states.hover\n     * @excluding brightness\n     * @product   highmaps\n     */\n    select: {// marker: {}\n    }\n  },\n\n  /**\n   * Sticky tracking of mouse events. When true, the `mouseOut` event\n   * on a series isn't triggered until the mouse moves over another series,\n   * or out of the plot area. When false, the `mouseOut` event on a\n   * series is triggered when the mouse leaves the area around the series'\n   * graph or markers. This also implies the tooltip when not shared. When\n   * `stickyTracking` is false and `tooltip.shared` is false, the tooltip will\n   * be hidden when moving the mouse between series. Defaults to true for line\n   * and area type series, but to false for columns, pies etc.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/\n   *         True by default\n   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/\n   *         False\n   *\n   * @default {highcharts} true\n   * @default {highstock} true\n   * @default {highmaps} false\n   * @since   2.0\n   */\n  stickyTracking: true,\n\n  /**\n   * A configuration object for the tooltip rendering of each single series.\n   * Properties are inherited from [tooltip](#tooltip), but only the\n   * following properties can be defined on a series level.\n   *\n   * @since     2.3\n   * @extends   tooltip\n   * @excluding animation,backgroundColor,borderColor,borderRadius,\n   *            borderWidth,crosshairs,enabled,formatter,positioner,shadow,\n   *            shared,shape,snap,style,useHTML\n   * @apioption plotOptions.series.tooltip\n   */\n\n  /**\n   * When a series contains a data array that is longer than this, only\n   * one dimensional arrays of numbers, or two dimensional arrays with\n   * x and y values are allowed. Also, only the first point is tested,\n   * and the rest are assumed to be the same format. This saves expensive\n   * data checking and indexing in long series. Set it to `0` disable.\n   *\n   * @since   2.2\n   * @product highcharts highstock\n   */\n  turboThreshold: 1000,\n\n  /**\n   * An array defining zones within a series. Zones can be applied to\n   * the X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`\n   * option. The zone definitions have to be in ascending order regarding to\n   * the value.\n   *\n   * In styled mode, the color zones are styled with the\n   * `.highcharts-zone-{n}` class, or custom classed from the `className`\n   * option\n   * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).\n   *\n   * @see [zoneAxis](#plotOptions.series.zoneAxis)\n   *\n   * @sample {highcharts} highcharts/series/color-zones-simple/\n   *         Color zones\n   * @sample {highstock} highcharts/series/color-zones-simple/\n   *         Color zones\n   *\n   * @type      {Array<*>}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones\n   */\n\n  /**\n   * Styled mode only. A custom class name for the zone.\n   *\n   * @sample highcharts/css/color-zones/\n   *         Zones styled by class name\n   *\n   * @type      {string}\n   * @since     5.0.0\n   * @apioption plotOptions.series.zones.className\n   */\n\n  /**\n   * Defines the color of the series.\n   *\n   * @see [series color](#plotOptions.series.color)\n   *\n   * @type      {Highcharts.ColorString}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones.color\n   */\n\n  /**\n   * A name for the dash style to use for the graph.\n   *\n   * @see [series.dashStyle](#plotOptions.series.dashStyle)\n   *\n   * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/\n   *         Dashed line indicates prognosis\n   *\n   * @type      {string}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones.dashStyle\n   */\n\n  /**\n   * Defines the fill color for the series (in area type series)\n   *\n   * @see [fillColor](#plotOptions.area.fillColor)\n   *\n   * @type      {Highcharts.ColorString}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones.fillColor\n   */\n\n  /**\n   * The value up to where the zone extends, if undefined the zones stretches\n   * to the last value in the series.\n   *\n   * @type      {number}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones.value\n   */\n\n  /**\n   * Determines whether the series should look for the nearest point\n   * in both dimensions or just the x-dimension when hovering the series.\n   * Defaults to `'xy'` for scatter series and `'x'` for most other\n   * series. If the data has duplicate x-values, it is recommended to\n   * set this to `'xy'` to allow hovering over all points.\n   *\n   * Applies only to series types using nearest neighbor search (not\n   * direct hover) for tooltip.\n   *\n   * @sample {highcharts} highcharts/series/findnearestpointby/\n   *         Different hover behaviors\n   * @sample {highstock} highcharts/series/findnearestpointby/\n   *         Different hover behaviors\n   * @sample {highmaps} highcharts/series/findnearestpointby/\n   *         Different hover behaviors\n   *\n   * @since      5.0.10\n   * @validvalue [\"x\", \"xy\"]\n   */\n  findNearestPointBy: 'x'\n},\n/** @lends Highcharts.Series.prototype */\n{\n  /**\n   * Series options for specific data and the data itself. In TypeScript you\n   * have to cast the series options to specific series types, to get all\n   * possible options for a series.\n   *\n   * @example\n   * // TypeScript example\n   * Highcharts.chart('container', {\n   *     series: [{\n   *         color: '#06C',\n   *         data: [[0, 1], [2, 3]]\n   *     } as Highcharts.SeriesLineOptions ]\n   * });\n   *\n   *\n   * @type      {Array<*>}\n   * @apioption series\n   */\n\n  /**\n   * An id for the series. This can be used after render time to get a pointer\n   * to the series object through `chart.get()`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-id/\n   *         Get series by id\n   *\n   * @type      {string}\n   * @since     1.2.0\n   * @apioption series.id\n   */\n\n  /**\n   * The index of the series in the chart, affecting the internal index in the\n   * `chart.series` array, the visible Z index as well as the order in the\n   * legend.\n   *\n   * @type      {number}\n   * @since     2.3.0\n   * @apioption series.index\n   */\n\n  /**\n   * The sequential index of the series in the legend.\n   *\n   * @see [legend.reversed](#legend.reversed),\n   *      [yAxis.reversedStacks](#yAxis.reversedStacks)\n   *\n   * @sample {highcharts|highstock} highcharts/series/legendindex/\n   *         Legend in opposite order\n   *\n   * @type      {number}\n   * @apioption series.legendIndex\n   */\n\n  /**\n   * The name of the series as shown in the legend, tooltip etc.\n   *\n   * @sample {highcharts} highcharts/series/name/\n   *         Series name\n   * @sample {highmaps} maps/demo/category-map/\n   *         Series name\n   *\n   * @type      {string}\n   * @apioption series.name\n   */\n\n  /**\n   * This option allows grouping series in a stacked chart. The stack option\n   * can be a string or anything else, as long as the grouped series' stack\n   * options match each other after conversion into a string.\n   *\n   * @sample {highcharts} highcharts/series/stack/\n   *         Stacked and grouped columns\n   *\n   * @type      {string|*}\n   * @since     2.1\n   * @product   highcharts highstock\n   * @apioption series.stack\n   */\n\n  /**\n   * The type of series, for example `line` or `column`. By default, the\n   * series type is inherited from [chart.type](#chart.type), so unless the\n   * chart is a combination of series types, there is no need to set it on the\n   * series level.\n   *\n   * @sample {highcharts} highcharts/series/type/\n   *         Line and column in the same chart\n   * @sample {highmaps} maps/demo/mapline-mappoint/\n   *         Multiple types in the same map\n   *\n   * @type      {string}\n   * @apioption series.type\n   */\n\n  /**\n   * When using dual or multiple x axes, this number defines which xAxis the\n   * particular series is connected to. It refers to either the\n   * {@link #xAxis.id|axis id}\n   * or the index of the axis in the xAxis array, with 0 being the first.\n   *\n   * @type      {number|string}\n   * @default   0\n   * @product   highcharts highstock\n   * @apioption series.xAxis\n   */\n\n  /**\n   * When using dual or multiple y axes, this number defines which yAxis the\n   * particular series is connected to. It refers to either the\n   * {@link #yAxis.id|axis id}\n   * or the index of the axis in the yAxis array, with 0 being the first.\n   *\n   * @sample {highcharts} highcharts/series/yaxis/\n   *         Apply the column series to the secondary Y axis\n   *\n   * @type      {number|string}\n   * @default   0\n   * @product   highcharts highstock\n   * @apioption series.yAxis\n   */\n\n  /**\n   * Define the visual z index of the series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-zindex-default/\n   *         With no z index, the series defined last are on top\n   * @sample {highcharts} highcharts/plotoptions/series-zindex/\n   *         With a z index, the series with the highest z index is on top\n   * @sample {highstock} highcharts/plotoptions/series-zindex-default/\n   *         With no z index, the series defined last are on top\n   * @sample {highstock} highcharts/plotoptions/series-zindex/\n   *         With a z index, the series with the highest z index is on top\n   *\n   * @type      {number}\n   * @product   highcharts highstock\n   * @apioption series.zIndex\n   */\n  isCartesian: true,\n  pointClass: Point,\n  sorted: true,\n  // requires the data to be sorted\n  requireSorting: true,\n  directTouch: false,\n  axisTypes: ['xAxis', 'yAxis'],\n  colorCounter: 0,\n  // each point's x and y values are stored in this.xData and this.yData\n  parallelArrays: ['x', 'y'],\n  coll: 'series',\n  init: function init(chart, options) {\n    var series = this,\n        events,\n        chartSeries = chart.series,\n        lastSeries;\n    /**\n     * Read only. The chart that the series belongs to.\n     *\n     * @name Highcharts.Series#chart\n     * @type {Highcharts.Chart}\n     */\n\n    series.chart = chart;\n    /**\n     * Read only. The series' type, like \"line\", \"area\", \"column\" etc. The\n     * type in the series options anc can be altered using {@link\n     * Series#update}.\n     *\n     * @name Highcharts.Series#type\n     * @type {string}\n     */\n\n    /**\n     * Read only. The series' current options. To update, use {@link\n     * Series#update}.\n     *\n     * @name Highcharts.Series#options\n     * @type {Highcharts.PlotSeriesOptions}\n     */\n\n    series.options = options = series.setOptions(options);\n    series.linkedSeries = []; // bind the axes\n\n    series.bindAxes(); // set some variables\n\n    extend(series, {\n      /**\n       * The series name as given in the options. Defaults to\n       * \"Series {n}\".\n       *\n       * @name Highcharts.Series#name\n       * @type {string}\n       */\n      name: options.name,\n      state: '',\n\n      /**\n       * Read only. The series' visibility state as set by {@link\n       * Series#show}, {@link Series#hide}, or in the initial\n       * configuration.\n       *\n       * @name Highcharts.Series#visible\n       * @type {boolean}\n       */\n      visible: options.visible !== false,\n      // true by default\n\n      /**\n       * Read only. The series' selected state as set by {@link\n       * Highcharts.Series#select}.\n       *\n       * @name Highcharts.Series#selected\n       * @type {boolean}\n       */\n      selected: options.selected === true // false by default\n\n    }); // register event listeners\n\n    events = options.events;\n    objectEach(events, function (event, eventType) {\n      addEvent(series, eventType, event);\n    });\n\n    if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {\n      chart.runTrackerClick = true;\n    }\n\n    series.getColor();\n    series.getSymbol(); // Set the data\n\n    each(series.parallelArrays, function (key) {\n      series[key + 'Data'] = [];\n    });\n    series.setData(options.data, false); // Mark cartesian\n\n    if (series.isCartesian) {\n      chart.hasCartesianSeries = true;\n    } // Get the index and register the series in the chart. The index is one\n    // more than the current latest series index (#5960).\n\n\n    if (chartSeries.length) {\n      lastSeries = chartSeries[chartSeries.length - 1];\n    }\n\n    series._i = pick(lastSeries && lastSeries._i, -1) + 1; // Insert the series and re-order all series above the insertion point.\n\n    chart.orderSeries(this.insert(chartSeries));\n    fireEvent(this, 'afterInit');\n  },\n\n  /**\n   * Insert the series in a collection with other series, either the chart\n   * series or yAxis series, in the correct order according to the index\n   * option. Used internally when adding series.\n   *\n   * @private\n   * @function Highcharts.Series#insert\n   *\n   * @param {Array<Highcharts.Series>} collection\n   *        A collection of series, like `chart.series` or `xAxis.series`.\n   *\n   * @return {number}\n   *         The index of the series in the collection.\n   */\n  insert: function insert(collection) {\n    var indexOption = this.options.index,\n        i; // Insert by index option\n\n    if (isNumber(indexOption)) {\n      i = collection.length;\n\n      while (i--) {\n        // Loop down until the interted element has higher index\n        if (indexOption >= pick(collection[i].options.index, collection[i]._i)) {\n          collection.splice(i + 1, 0, this);\n          break;\n        }\n      }\n\n      if (i === -1) {\n        collection.unshift(this);\n      }\n\n      i = i + 1; // Or just push it to the end\n    } else {\n      collection.push(this);\n    }\n\n    return pick(i, collection.length - 1);\n  },\n\n  /**\n   * Set the xAxis and yAxis properties of cartesian series, and register the\n   * series in the `axis.series` array.\n   *\n   * @private\n   * @function Highcharts.Series#bindAxes\n   *\n   * @exception 18\n   */\n  bindAxes: function bindAxes() {\n    var series = this,\n        seriesOptions = series.options,\n        chart = series.chart,\n        axisOptions; // repeat for xAxis and yAxis\n\n    each(series.axisTypes || [], function (AXIS) {\n      // loop through the chart's axis objects\n      each(chart[AXIS], function (axis) {\n        axisOptions = axis.options; // apply if the series xAxis or yAxis option mathches the number\n        // of the axis, or if undefined, use the first axis\n\n        if (seriesOptions[AXIS] === axisOptions.index || seriesOptions[AXIS] !== undefined && seriesOptions[AXIS] === axisOptions.id || seriesOptions[AXIS] === undefined && axisOptions.index === 0) {\n          // register this series in the axis.series lookup\n          series.insert(axis.series); // set this series.xAxis or series.yAxis reference\n\n          /**\n           * Read only. The unique xAxis object associated with the\n           * series.\n           *\n           * @name Highcharts.Series#xAxis\n           * @type {Highcharts.Axis}\n           */\n\n          /**\n           * Read only. The unique yAxis object associated with the\n           * series.\n           *\n           * @name Highcharts.Series#yAxis\n           * @type {Highcharts.Axis}\n           */\n\n          series[AXIS] = axis; // mark dirty for redraw\n\n          axis.isDirty = true;\n        }\n      }); // The series needs an X and an Y axis\n\n      if (!series[AXIS] && series.optionalAxis !== AXIS) {\n        H.error(18, true);\n      }\n    });\n  },\n\n  /**\n   * For simple series types like line and column, the data values are held in\n   * arrays like xData and yData for quick lookup to find extremes and more.\n   * For multidimensional series like bubble and map, this can be extended\n   * with arrays like zData and valueData by adding to the\n   * `series.parallelArrays` array.\n   *\n   * @private\n   * @function Highcharts.Series#updateParallelArrays\n   *\n   * @param {Highcharts.Point} point\n   *\n   * @param {number|string} i\n   */\n  updateParallelArrays: function updateParallelArrays(point, i) {\n    var series = point.series,\n        args = arguments,\n        fn = isNumber(i) ? // Insert the value in the given position\n    function (key) {\n      var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n      series[key + 'Data'][i] = val;\n    } : // Apply the method specified in i with the following arguments\n    // as arguments\n    function (key) {\n      Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n    };\n    each(series.parallelArrays, fn);\n  },\n\n  /**\n   * Return an auto incremented x value based on the pointStart and\n   * pointInterval options. This is only used if an x value is not given for\n   * the point that calls autoIncrement.\n   *\n   * @private\n   * @function Highcharts.Series#autoIncrement\n   *\n   * @return {number}\n   */\n  autoIncrement: function autoIncrement() {\n    var options = this.options,\n        xIncrement = this.xIncrement,\n        date,\n        pointInterval,\n        pointIntervalUnit = options.pointIntervalUnit,\n        time = this.chart.time;\n    xIncrement = pick(xIncrement, options.pointStart, 0);\n    this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1); // Added code for pointInterval strings\n\n    if (pointIntervalUnit) {\n      date = new time.Date(xIncrement);\n\n      if (pointIntervalUnit === 'day') {\n        time.set('Date', date, time.get('Date', date) + pointInterval);\n      } else if (pointIntervalUnit === 'month') {\n        time.set('Month', date, time.get('Month', date) + pointInterval);\n      } else if (pointIntervalUnit === 'year') {\n        time.set('FullYear', date, time.get('FullYear', date) + pointInterval);\n      }\n\n      pointInterval = date.getTime() - xIncrement;\n    }\n\n    this.xIncrement = xIncrement + pointInterval;\n    return xIncrement;\n  },\n\n  /**\n   * Set the series options by merging from the options tree. Called\n   * internally on initiating and updating series. This function will not\n   * redraw the series. For API usage, use {@link Series#update}.\n   *\n   * @function Highcharts.Series#setOptions\n   *\n   * @param {Highcharts.PlotSeriesOptions} itemOptions\n   *        The series options.\n   *\n   * @return {Highcharts.PlotSeriesOptions}\n   *\n   * @fires Highcharts.Series#event:afterSetOptions\n   */\n  setOptions: function setOptions(itemOptions) {\n    var chart = this.chart,\n        chartOptions = chart.options,\n        plotOptions = chartOptions.plotOptions,\n        userOptions = chart.userOptions || {},\n        userPlotOptions = userOptions.plotOptions || {},\n        typeOptions = plotOptions[this.type],\n        options,\n        zones;\n    this.userOptions = itemOptions; // General series options take precedence over type options because\n    // otherwise, default type options like column.animation would be\n    // overwritten by the general option. But issues have been raised here\n    // (#3881), and the solution may be to distinguish between default\n    // option and userOptions like in the tooltip below.\n\n    options = merge(typeOptions, plotOptions.series, itemOptions); // The tooltip options are merged between global and series specific\n    // options. Importance order asscendingly:\n    // globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]\n    // init userOptions with possible later updates: 4-6 like 1-3 and\n    // (7)this series options\n\n    this.tooltipOptions = merge(defaultOptions.tooltip, // 1\n    defaultOptions.plotOptions.series && defaultOptions.plotOptions.series.tooltip, // 2\n    defaultOptions.plotOptions[this.type].tooltip, // 3\n    chartOptions.tooltip.userOptions, // 4\n    plotOptions.series && plotOptions.series.tooltip, // 5\n    plotOptions[this.type].tooltip, // 6\n    itemOptions.tooltip // 7\n    ); // When shared tooltip, stickyTracking is true by default,\n    // unless user says otherwise.\n\n    this.stickyTracking = pick(itemOptions.stickyTracking, userPlotOptions[this.type] && userPlotOptions[this.type].stickyTracking, userPlotOptions.series && userPlotOptions.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking); // Delete marker object if not allowed (#1125)\n\n    if (typeOptions.marker === null) {\n      delete options.marker;\n    } // Handle color zones\n\n\n    this.zoneAxis = options.zoneAxis;\n    zones = this.zones = (options.zones || []).slice();\n\n    if ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n      zones.push({\n        value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n        className: 'highcharts-negative'\n      });\n    }\n\n    if (zones.length) {\n      // Push one extra zone for the rest\n      if (defined(zones[zones.length - 1].value)) {\n        zones.push({});\n      }\n    }\n\n    fireEvent(this, 'afterSetOptions', {\n      options: options\n    });\n    return options;\n  },\n\n  /**\n   * Return series name in \"Series {Number}\" format or the one defined by a\n   * user. This method can be simply overridden as series name format can\n   * vary (e.g. technical indicators).\n   *\n   * @function Highcharts.Series#getName\n   *\n   * @return {string}\n   *         The series name.\n   */\n  getName: function getName() {\n    return this.name || 'Series ' + (this.index + 1);\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Series#getCyclic\n   *\n   * @param {string} prop\n   *\n   * @param {*} value\n   *\n   * @param {*} [defaults]\n   */\n  getCyclic: function getCyclic(prop, value, defaults) {\n    var i,\n        chart = this.chart,\n        userOptions = this.userOptions,\n        indexName = prop + 'Index',\n        counterName = prop + 'Counter',\n        len = defaults ? defaults.length : pick(chart.options.chart[prop + 'Count'], chart[prop + 'Count']),\n        setting;\n\n    if (!value) {\n      // Pick up either the colorIndex option, or the _colorIndex after\n      // Series.update()\n      setting = pick(userOptions[indexName], userOptions['_' + indexName]);\n\n      if (defined(setting)) {\n        // after Series.update()\n        i = setting;\n      } else {\n        // #6138\n        if (!chart.series.length) {\n          chart[counterName] = 0;\n        }\n\n        userOptions['_' + indexName] = i = chart[counterName] % len;\n        chart[counterName] += 1;\n      }\n\n      if (defaults) {\n        value = defaults[i];\n      }\n    } // Set the colorIndex\n\n\n    if (i !== undefined) {\n      this[indexName] = i;\n    }\n\n    this[prop] = value;\n  },\n\n  /**\n   * Get the series' color based on either the options or pulled from global\n   * options.\n   *\n   * @function Highcharts.Series#getColor\n   */\n  getColor: function getColor() {\n    this.getCyclic('color');\n  },\n\n  /**\n   * Get the series' symbol based on either the options or pulled from global\n   * options.\n   *\n   * @function Highcharts.Series#getSymbol\n   */\n  getSymbol: function getSymbol() {\n    var seriesMarkerOption = this.options.marker;\n    this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n  },\n\n  /**\n   * @private\n   * @borrows LegendSymbolMixin.drawLineMarker as Highcharts.Series#drawLegendSymbol\n   */\n  drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n  /**\n   * Internal function called from setData. If the point count is the same as\n   * is was, or if there are overlapping X values, just run Point.update which\n   * is cheaper, allows animation, and keeps references to points. This also\n   * allows adding or removing points if the X-es don't match.\n   *\n   * @private\n   * @function Highcharts.Series#updateData\n   *\n   * @param {Array<*>} data\n   *\n   * @return {boolean}\n   */\n  updateData: function updateData(data) {\n    var options = this.options,\n        oldData = this.points,\n        pointsToAdd = [],\n        hasUpdatedByKey,\n        i,\n        point,\n        lastIndex,\n        requireSorting = this.requireSorting; // Iterate the new data\n\n    each(data, function (pointOptions) {\n      var x, pointIndex; // Get the x of the new data point\n\n      x = H.defined(pointOptions) && this.pointClass.prototype.optionsToObject.call({\n        series: this\n      }, pointOptions).x;\n\n      if (isNumber(x)) {\n        // Search for the same X in the existing data set\n        pointIndex = H.inArray(x, this.xData, lastIndex); // Matching X not found\n        // or used already due to ununique x values (#8995),\n        // add point (but later)\n\n        if (pointIndex === -1 || oldData[pointIndex].touched) {\n          pointsToAdd.push(pointOptions); // Matching X found, update\n        } else if (pointOptions !== options.data[pointIndex]) {\n          oldData[pointIndex].update(pointOptions, false, null, false); // Mark it touched, below we will remove all points that\n          // are not touched.\n\n          oldData[pointIndex].touched = true; // Speed optimize by only searching after last known index.\n          // Performs ~20% bettor on large data sets.\n\n          if (requireSorting) {\n            lastIndex = pointIndex + 1;\n          } // Point exists, no changes, don't remove it\n\n        } else if (oldData[pointIndex]) {\n          oldData[pointIndex].touched = true;\n        }\n\n        hasUpdatedByKey = true;\n      }\n    }, this); // Remove points that don't exist in the updated data set\n\n    if (hasUpdatedByKey) {\n      i = oldData.length;\n\n      while (i--) {\n        point = oldData[i];\n\n        if (!point.touched) {\n          point.remove(false);\n        }\n\n        point.touched = false;\n      } // If we did not find keys (x-values), and the length is the same,\n      // update one-to-one\n\n    } else if (data.length === oldData.length) {\n      each(data, function (point, i) {\n        // .update doesn't exist on a linked, hidden series (#3709)\n        if (oldData[i].update && point !== options.data[i]) {\n          oldData[i].update(point, false, null, false);\n        }\n      }); // Did not succeed in updating data\n    } else {\n      return false;\n    } // Add new points\n\n\n    each(pointsToAdd, function (point) {\n      this.addPoint(point, false);\n    }, this);\n    return true;\n  },\n\n  /**\n   * Apply a new set of data to the series and optionally redraw it. The new\n   * data array is passed by reference (except in case of `updatePoints`), and\n   * may later be mutated when updating the chart data.\n   *\n   * Note the difference in behaviour when setting the same amount of points,\n   * or a different amount of points, as handled by the `updatePoints`\n   * parameter.\n   *\n   * @sample highcharts/members/series-setdata/\n   *         Set new data from a button\n   * @sample highcharts/members/series-setdata-pie/\n   *         Set data in a pie\n   * @sample stock/members/series-setdata/\n   *         Set new data in Highstock\n   * @sample maps/members/series-setdata/\n   *         Set new data in Highmaps\n   *\n   * @function Highcharts.Series#setData\n   *\n   * @param {Array<*>} data\n   *        Takes an array of data in the same format as described under\n   *        `series.{type}.data` for the given series type, for example a\n   *        line series would take data in the form described under\n   *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart after the series is altered. If doing\n   *        more operations on the chart, it is a good idea to set redraw to\n   *        false and call {@link Chart#redraw} after.\n   *\n   * @param {Highcharts.AnimationOptionsObject} [animation]\n   *        When the updated data is the same length as the existing data,\n   *        points will be updated by default, and animation visualizes how\n   *        the points are changed. Set false to disable animation, or a\n   *        configuration object to set duration or easing.\n   *\n   * @param {boolean} [updatePoints=true]\n   *        When the updated data is the same length as the existing data, or\n   *        points can be matched by X values, points will be updated instead\n   *        of replaced. This allows updating with animation and performs\n   *        better. In this case, the original array is not passed by\n   *        reference. Set `false` to prevent.\n   */\n  setData: function setData(data, redraw, animation, updatePoints) {\n    var series = this,\n        oldData = series.points,\n        oldDataLength = oldData && oldData.length || 0,\n        dataLength,\n        options = series.options,\n        chart = series.chart,\n        firstPoint = null,\n        xAxis = series.xAxis,\n        i,\n        turboThreshold = options.turboThreshold,\n        pt,\n        xData = this.xData,\n        yData = this.yData,\n        pointArrayMap = series.pointArrayMap,\n        valueCount = pointArrayMap && pointArrayMap.length,\n        updatedData;\n    data = data || [];\n    dataLength = data.length;\n    redraw = pick(redraw, true); // If the point count is the same as is was, just run Point.update which\n    // is cheaper, allows animation, and keeps references to points.\n\n    if (updatePoints !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && // Soft updating has no benefit in boost, and causes JS error\n    // (#8355)\n    !series.isSeriesBoosting) {\n      updatedData = this.updateData(data);\n    }\n\n    if (!updatedData) {\n      // Reset properties\n      series.xIncrement = null;\n      series.colorCounter = 0; // for series with colorByPoint (#1547)\n      // Update parallel arrays\n\n      each(this.parallelArrays, function (key) {\n        series[key + 'Data'].length = 0;\n      }); // In turbo mode, only one- or twodimensional arrays of numbers are\n      // allowed. The first value is tested, and we assume that all the\n      // rest are defined the same way. Although the 'for' loops are\n      // similar, they are repeated inside each if-else conditional for\n      // max performance.\n\n      if (turboThreshold && dataLength > turboThreshold) {\n        // find the first non-null point\n        i = 0;\n\n        while (firstPoint === null && i < dataLength) {\n          firstPoint = data[i];\n          i++;\n        }\n\n        if (isNumber(firstPoint)) {\n          // assume all points are numbers\n          for (i = 0; i < dataLength; i++) {\n            xData[i] = this.autoIncrement();\n            yData[i] = data[i];\n          } // Assume all points are arrays when first point is\n\n        } else if (isArray(firstPoint)) {\n          if (valueCount) {\n            // [x, low, high] or [x, o, h, l, c]\n            for (i = 0; i < dataLength; i++) {\n              pt = data[i];\n              xData[i] = pt[0];\n              yData[i] = pt.slice(1, valueCount + 1);\n            }\n          } else {\n            // [x, y]\n            for (i = 0; i < dataLength; i++) {\n              pt = data[i];\n              xData[i] = pt[0];\n              yData[i] = pt[1];\n            }\n          }\n        } else {\n          // Highcharts expects configs to be numbers or arrays in\n          // turbo mode\n          H.error(12);\n        }\n      } else {\n        for (i = 0; i < dataLength; i++) {\n          if (data[i] !== undefined) {\n            // stray commas in oldIE\n            pt = {\n              series: series\n            };\n            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n            series.updateParallelArrays(pt, i);\n          }\n        }\n      } // Forgetting to cast strings to numbers is a common caveat when\n      // handling CSV or JSON\n\n\n      if (yData && isString(yData[0])) {\n        H.error(14, true);\n      }\n\n      series.data = [];\n      series.options.data = series.userOptions.data = data; // destroy old points\n\n      i = oldDataLength;\n\n      while (i--) {\n        if (oldData[i] && oldData[i].destroy) {\n          oldData[i].destroy();\n        }\n      } // reset minRange (#878)\n\n\n      if (xAxis) {\n        xAxis.minRange = xAxis.userMinRange;\n      } // redraw\n\n\n      series.isDirty = chart.isDirtyBox = true;\n      series.isDirtyData = !!oldData;\n      animation = false;\n    } // Typically for pie series, points need to be processed and generated\n    // prior to rendering the legend\n\n\n    if (options.legendType === 'point') {\n      this.processData();\n      this.generatePoints();\n    }\n\n    if (redraw) {\n      chart.redraw(animation);\n    }\n  },\n\n  /**\n   * Internal function to process the data by cropping away unused data points\n   * if the series is longer than the crop threshold. This saves computing\n   * time for large series. In Highstock, this function is extended to\n   * provide data grouping.\n   *\n   * @private\n   * @function Highcharts.Series#processData\n   *\n   * @param {boolean} force\n   *        Force data grouping.\n   *\n   * @return {boolean|undefined}\n   */\n  processData: function processData(force) {\n    var series = this,\n        processedXData = series.xData,\n        // copied during slice operation\n    processedYData = series.yData,\n        dataLength = processedXData.length,\n        croppedData,\n        cropStart = 0,\n        cropped,\n        distance,\n        closestPointRange,\n        xAxis = series.xAxis,\n        i,\n        // loop variable\n    options = series.options,\n        cropThreshold = options.cropThreshold,\n        getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll,\n        // #4599\n    isCartesian = series.isCartesian,\n        xExtremes,\n        val2lin = xAxis && xAxis.val2lin,\n        isLog = xAxis && xAxis.isLog,\n        throwOnUnsorted = series.requireSorting,\n        min,\n        max; // If the series data or axes haven't changed, don't go through this.\n    // Return false to pass the message on to override methods like in data\n    // grouping.\n\n    if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n      return false;\n    }\n\n    if (xAxis) {\n      xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n\n      min = xExtremes.min;\n      max = xExtremes.max;\n    } // optionally filter out points outside the plot area\n\n\n    if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n      // it's outside current extremes\n      if (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n        processedXData = [];\n        processedYData = []; // only crop if it's actually spilling out\n      } else if (series.yData && (processedXData[0] < min || processedXData[dataLength - 1] > max)) {\n        croppedData = this.cropData(series.xData, series.yData, min, max);\n        processedXData = croppedData.xData;\n        processedYData = croppedData.yData;\n        cropStart = croppedData.start;\n        cropped = true;\n      }\n    } // Find the closest distance between processed points\n\n\n    i = processedXData.length || 1;\n\n    while (--i) {\n      distance = isLog ? val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) : processedXData[i] - processedXData[i - 1];\n\n      if (distance > 0 && (closestPointRange === undefined || distance < closestPointRange)) {\n        closestPointRange = distance; // Unsorted data is not supported by the line tooltip, as well as\n        // data grouping and navigation in Stock charts (#725) and width\n        // calculation of columns (#1900)\n      } else if (distance < 0 && throwOnUnsorted) {\n        H.error(15);\n        throwOnUnsorted = false; // Only once\n      }\n    } // Record the properties\n\n\n    series.cropped = cropped; // undefined or true\n\n    series.cropStart = cropStart;\n    series.processedXData = processedXData;\n    series.processedYData = processedYData;\n    series.closestPointRange = closestPointRange;\n  },\n\n  /**\n   * Iterate over xData and crop values between min and max. Returns object\n   * containing crop start/end cropped xData with corresponding part of yData,\n   * dataMin and dataMax within the cropped range.\n   *\n   * @private\n   * @function Highcharts.Series#cropData\n   *\n   * @param {Array<number>} xData\n   *\n   * @param {Array<number>} yData\n   *\n   * @param {number} min\n   *\n   * @param {number} max\n   *\n   * @param {number} [cropShoulder]\n   *\n   * @return {*}\n   */\n  cropData: function cropData(xData, yData, min, max, cropShoulder) {\n    var dataLength = xData.length,\n        cropStart = 0,\n        cropEnd = dataLength,\n        i,\n        j; // line-type series need one point outside\n\n    cropShoulder = pick(cropShoulder, this.cropShoulder, 1); // iterate up to find slice start\n\n    for (i = 0; i < dataLength; i++) {\n      if (xData[i] >= min) {\n        cropStart = Math.max(0, i - cropShoulder);\n        break;\n      }\n    } // proceed to find slice end\n\n\n    for (j = i; j < dataLength; j++) {\n      if (xData[j] > max) {\n        cropEnd = j + cropShoulder;\n        break;\n      }\n    }\n\n    return {\n      xData: xData.slice(cropStart, cropEnd),\n      yData: yData.slice(cropStart, cropEnd),\n      start: cropStart,\n      end: cropEnd\n    };\n  },\n\n  /**\n   * Generate the data point after the data has been processed by cropping\n   * away unused points and optionally grouped in Highcharts Stock.\n   *\n   * @private\n   * @function Highcharts.Series#generatePoints\n   */\n  generatePoints: function generatePoints() {\n    var series = this,\n        options = series.options,\n        dataOptions = options.data,\n        data = series.data,\n        dataLength,\n        processedXData = series.processedXData,\n        processedYData = series.processedYData,\n        PointClass = series.pointClass,\n        processedDataLength = processedXData.length,\n        cropStart = series.cropStart || 0,\n        cursor,\n        hasGroupedData = series.hasGroupedData,\n        keys = options.keys,\n        point,\n        points = [],\n        i;\n\n    if (!data && !hasGroupedData) {\n      var arr = [];\n      arr.length = dataOptions.length;\n      data = series.data = arr;\n    }\n\n    if (keys && hasGroupedData) {\n      // grouped data has already applied keys (#6590)\n      series.options.keys = false;\n    }\n\n    for (i = 0; i < processedDataLength; i++) {\n      cursor = cropStart + i;\n\n      if (!hasGroupedData) {\n        point = data[cursor];\n\n        if (!point && dataOptions[cursor] !== undefined) {\n          // #970\n          data[cursor] = point = new PointClass().init(series, dataOptions[cursor], processedXData[i]);\n        }\n      } else {\n        // splat the y data in case of ohlc data array\n        point = new PointClass().init(series, [processedXData[i]].concat(splat(processedYData[i])));\n        /**\n         * Highstock only. If a point object is created by data\n         * grouping, it doesn't reflect actual points in the raw data.\n         * In this case, the `dataGroup` property holds information\n         * that points back to the raw data.\n         *\n         * - `dataGroup.start` is the index of the first raw data point\n         * in the group.\n         * - `dataGroup.length` is the amount of points in the group.\n         *\n         * @name Highcharts.Point#dataGroup\n         * @type {Highcharts.SVGElement|undefined}\n         *\n         * @product highstock\n         */\n\n        point.dataGroup = series.groupMap[i];\n\n        if (point.dataGroup.options) {\n          point.options = point.dataGroup.options;\n          extend(point, point.dataGroup.options);\n        }\n      }\n\n      if (point) {\n        // #6279\n        point.index = cursor; // For faster access in Point.update\n\n        points[i] = point;\n      }\n    } // restore keys options (#6590)\n\n\n    series.options.keys = keys; // Hide cropped-away points - this only runs when the number of points\n    // is above cropThreshold, or when swithching view from non-grouped\n    // data to grouped data (#637)\n\n    if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n      for (i = 0; i < dataLength; i++) {\n        // when has grouped data, clear all points\n        if (i === cropStart && !hasGroupedData) {\n          i += processedDataLength;\n        }\n\n        if (data[i]) {\n          data[i].destroyElements();\n          data[i].plotX = undefined; // #1003\n        }\n      }\n    }\n    /**\n     * Read only. An array containing those values converted to points.\n     * In case the series data length exceeds the `cropThreshold`, or if the\n     * data is grouped, `series.data` doesn't contain all the points. Also,\n     * in case a series is hidden, the `data` array may be empty. To access\n     * raw values, `series.options.data` will always be up to date.\n     * `Series.data` only contains the points that have been created on\n     * demand. To modify the data, use {@link Highcharts.Series#setData} or\n     * {@link Highcharts.Point#update}.\n     *\n     * @see Series.points\n     *\n     * @name Highcharts.Series#data\n     * @type {Array<Point>}\n     */\n\n\n    series.data = data;\n    /**\n     * An array containing all currently visible point objects. In case of\n     * cropping, the cropped-away points are not part of this array. The\n     * `series.points` array starts at `series.cropStart` compared to\n     * `series.data` and `series.options.data`. If however the series data\n     * is grouped, these can't be correlated one to one. To\n     * modify the data, use {@link Highcharts.Series#setData} or {@link\n     * Highcharts.Point#update}.\n     *\n     * @name Highcharts.Series#points\n     * @type {Array<Highcharts.Point>}\n     */\n\n    series.points = points;\n  },\n\n  /**\n   * Calculate Y extremes for the visible data. The result is set as\n   * `dataMin` and `dataMax` on the Series item.\n   *\n   * @function Highcharts.Series#getExtremes\n   *\n   * @param {Array<number>} [yData]\n   *        The data to inspect. Defaults to the current data within the\n   *        visible range.\n   */\n  getExtremes: function getExtremes(yData) {\n    var xAxis = this.xAxis,\n        yAxis = this.yAxis,\n        xData = this.processedXData,\n        yDataLength,\n        activeYData = [],\n        activeCounter = 0,\n        // #2117, need to compensate for log X axis\n    xExtremes = xAxis.getExtremes(),\n        xMin = xExtremes.min,\n        xMax = xExtremes.max,\n        validValue,\n        withinRange,\n        // Handle X outside the viewed area. This does not work with non-\n    // sorted data like scatter (#7639).\n    shoulder = this.requireSorting ? 1 : 0,\n        x,\n        y,\n        i,\n        j;\n    yData = yData || this.stackedYData || this.processedYData || [];\n    yDataLength = yData.length;\n\n    for (i = 0; i < yDataLength; i++) {\n      x = xData[i];\n      y = yData[i]; // For points within the visible range, including the first point\n      // outside the visible range (#7061), consider y extremes.\n\n      validValue = (isNumber(y, true) || isArray(y)) && (!yAxis.positiveValuesOnly || y.length || y > 0);\n      withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax;\n\n      if (validValue && withinRange) {\n        j = y.length;\n\n        if (j) {\n          // array, like ohlc or range data\n          while (j--) {\n            if (typeof y[j] === 'number') {\n              // #7380\n              activeYData[activeCounter++] = y[j];\n            }\n          }\n        } else {\n          activeYData[activeCounter++] = y;\n        }\n      }\n    }\n\n    this.dataMin = arrayMin(activeYData);\n    this.dataMax = arrayMax(activeYData);\n  },\n\n  /**\n   * Translate data points from raw data values to chart specific positioning\n   * data needed later in the `drawPoints` and `drawGraph` functions. This\n   * function can be overridden in plugins and custom series type\n   * implementations.\n   *\n   * @function Highcharts.Series#translate\n   *\n   * @todo\n   * Make events official: Fires the event `afterTranslate`.\n   */\n  translate: function translate() {\n    if (!this.processedXData) {\n      // hidden series\n      this.processData();\n    }\n\n    this.generatePoints();\n    var series = this,\n        options = series.options,\n        stacking = options.stacking,\n        xAxis = series.xAxis,\n        categories = xAxis.categories,\n        yAxis = series.yAxis,\n        points = series.points,\n        dataLength = points.length,\n        hasModifyValue = !!series.modifyValue,\n        i,\n        pointPlacement = options.pointPlacement,\n        dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),\n        threshold = options.threshold,\n        stackThreshold = options.startFromThreshold ? threshold : 0,\n        plotX,\n        plotY,\n        lastPlotX,\n        stackIndicator,\n        closestPointRangePx = Number.MAX_VALUE;\n    /*\n     * Plotted coordinates need to be within a limited range. Drawing too\n     * far outside the viewport causes various rendering issues (#3201,\n     * #3923, #7555).\n     */\n\n    function limitedRange(val) {\n      return Math.min(Math.max(-1e5, val), 1e5);\n    } // Point placement is relative to each series pointRange (#5889)\n\n\n    if (pointPlacement === 'between') {\n      pointPlacement = 0.5;\n    }\n\n    if (isNumber(pointPlacement)) {\n      pointPlacement *= pick(options.pointRange || xAxis.pointRange);\n    } // Translate each point\n\n\n    for (i = 0; i < dataLength; i++) {\n      var point = points[i],\n          xValue = point.x,\n          yValue = point.y,\n          yBottom = point.low,\n          stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],\n          pointStack,\n          stackValues; // Discard disallowed y values for log axes (#3434)\n\n      if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {\n        point.isNull = true;\n      } // Get the plotX translation\n\n\n      point.plotX = plotX = correctFloat( // #5236\n      limitedRange(xAxis.translate( // #3923\n      xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')) // #3923\n      ); // Calculate the bottom y value for stacked series\n\n      if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {\n        stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);\n        pointStack = stack[xValue];\n        stackValues = pointStack.points[stackIndicator.key];\n        yBottom = stackValues[0];\n        yValue = stackValues[1];\n\n        if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {\n          yBottom = pick(isNumber(threshold) && threshold, yAxis.min);\n        }\n\n        if (yAxis.positiveValuesOnly && yBottom <= 0) {\n          // #1200, #1232\n          yBottom = null;\n        }\n\n        point.total = point.stackTotal = pointStack.total;\n        point.percentage = pointStack.total && point.y / pointStack.total * 100;\n        point.stackY = yValue; // Place the stack label\n\n        pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);\n      } // Set translated yBottom or remove it\n\n\n      point.yBottom = defined(yBottom) ? limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) : null; // general hook, used for Highstock compare mode\n\n      if (hasModifyValue) {\n        yValue = series.modifyValue(yValue, point);\n      } // Set the the plotY value, reset it for redraws\n\n\n      point.plotY = plotY = typeof yValue === 'number' && yValue !== Infinity ? limitedRange(yAxis.translate(yValue, 0, 1, 0, 1)) : // #3201\n      undefined;\n      point.isInside = plotY !== undefined && plotY >= 0 && plotY <= yAxis.len && // #3519\n      plotX >= 0 && plotX <= xAxis.len; // Set client related positions for mouse tracking\n\n      point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)) : plotX; // #1514, #5383, #5518\n\n      point.negative = point.y < (threshold || 0); // some API data\n\n      point.category = categories && categories[point.x] !== undefined ? categories[point.x] : point.x; // Determine auto enabling of markers (#3635, #5099)\n\n      if (!point.isNull) {\n        if (lastPlotX !== undefined) {\n          closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));\n        }\n\n        lastPlotX = plotX;\n      } // Find point zone\n\n\n      point.zone = this.zones.length && point.getZone();\n    }\n\n    series.closestPointRangePx = closestPointRangePx;\n    fireEvent(this, 'afterTranslate');\n  },\n\n  /**\n   * Return the series points with null points filtered out.\n   *\n   * @param {Array<Highcharts.Point>} [points]\n   *        The points to inspect, defaults to {@link Series.points}.\n   *\n   * @param {boolean} [insideOnly=false]\n   *        Whether to inspect only the points that are inside the visible\n   *        view.\n   *\n   * @return {Array<Highcharts.Point>}\n   *         The valid points.\n   */\n  getValidPoints: function getValidPoints(points, insideOnly) {\n    var chart = this.chart; // #3916, #5029, #5085\n\n    return grep(points || this.points || [], function isValidPoint(point) {\n      if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, chart.inverted)) {\n        return false;\n      }\n\n      return !point.isNull;\n    });\n  },\n\n  /**\n   * Set the clipping for the series. For animated series it is called twice,\n   * first to initiate animating the clip then the second time without the\n   * animation to set the final clip.\n   *\n   * @private\n   * @function Highcharts.Series#setClip\n   *\n   * @param {boolean} [animation]\n   */\n  setClip: function setClip(animation) {\n    var chart = this.chart,\n        options = this.options,\n        renderer = chart.renderer,\n        inverted = chart.inverted,\n        seriesClipBox = this.clipBox,\n        clipBox = seriesClipBox || chart.clipBox,\n        sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','),\n        // #4526\n    clipRect = chart[sharedClipKey],\n        markerClipRect = chart[sharedClipKey + 'm']; // If a clipping rectangle with the same properties is currently present\n    // in the chart, use that.\n\n    if (!clipRect) {\n      // When animation is set, prepare the initial positions\n      if (animation) {\n        clipBox.width = 0;\n\n        if (inverted) {\n          clipBox.x = chart.plotSizeX;\n        }\n\n        chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect( // include the width of the first marker\n        inverted ? chart.plotSizeX + 99 : -99, inverted ? -chart.plotLeft : -chart.plotTop, 99, inverted ? chart.chartWidth : chart.chartHeight);\n      }\n\n      chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox); // Create hashmap for series indexes\n\n      clipRect.count = {\n        length: 0\n      };\n    }\n\n    if (animation) {\n      if (!clipRect.count[this.index]) {\n        clipRect.count[this.index] = true;\n        clipRect.count.length += 1;\n      }\n    }\n\n    if (options.clip !== false) {\n      this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n      this.markerGroup.clip(markerClipRect);\n      this.sharedClipKey = sharedClipKey;\n    } // Remove the shared clipping rectangle when all series are shown\n\n\n    if (!animation) {\n      if (clipRect.count[this.index]) {\n        delete clipRect.count[this.index];\n        clipRect.count.length -= 1;\n      }\n\n      if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {\n        if (!seriesClipBox) {\n          chart[sharedClipKey] = chart[sharedClipKey].destroy();\n        }\n\n        if (chart[sharedClipKey + 'm']) {\n          chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n        }\n      }\n    }\n  },\n\n  /**\n   * Animate in the series. Called internally twice. First with the `init`\n   * parameter set to true, which sets up the initial state of the animation.\n   * Then when ready, it is called with the `init` parameter undefined, in\n   * order to perform the actual animation. After the second run, the function\n   * is removed.\n   *\n   * @function Highcharts.Series#animate\n   *\n   * @param {boolean} init\n   *        Initialize the animation.\n   */\n  animate: function animate(init) {\n    var series = this,\n        chart = series.chart,\n        clipRect,\n        animation = animObject(series.options.animation),\n        sharedClipKey; // Initialize the animation. Set up the clipping rectangle.\n\n    if (init) {\n      series.setClip(animation); // Run the animation\n    } else {\n      sharedClipKey = this.sharedClipKey;\n      clipRect = chart[sharedClipKey];\n\n      if (clipRect) {\n        clipRect.animate({\n          width: chart.plotSizeX,\n          x: 0\n        }, animation);\n      }\n\n      if (chart[sharedClipKey + 'm']) {\n        chart[sharedClipKey + 'm'].animate({\n          width: chart.plotSizeX + 99,\n          x: 0\n        }, animation);\n      } // Delete this function to allow it only once\n\n\n      series.animate = null;\n    }\n  },\n\n  /**\n   * This runs after animation to land on the final plot clipping.\n   *\n   * @private\n   * @function Highcharts.Series#afterAnimate\n   *\n   * @todo\n   * Make events official: Fires the event `afterAnimate`.\n   */\n  afterAnimate: function afterAnimate() {\n    this.setClip();\n    fireEvent(this, 'afterAnimate');\n    this.finishedAnimating = true;\n  },\n\n  /**\n   * Draw the markers for line-like series types, and columns or other\n   * graphical representation for {@link Point} objects for other series\n   * types. The resulting element is typically stored as {@link\n   * Point.graphic}, and is created on the first call and updated and moved on\n   * subsequent calls.\n   *\n   * @function Highcharts.Series#drawPoints\n   */\n  drawPoints: function drawPoints() {\n    var series = this,\n        points = series.points,\n        chart = series.chart,\n        i,\n        point,\n        symbol,\n        graphic,\n        options = series.options,\n        seriesMarkerOptions = options.marker,\n        pointMarkerOptions,\n        hasPointMarker,\n        enabled,\n        isInside,\n        markerGroup = series[series.specialGroup] || series.markerGroup,\n        xAxis = series.xAxis,\n        markerAttribs,\n        globallyEnabled = pick(seriesMarkerOptions.enabled, xAxis.isRadial ? true : null, // Use larger or equal as radius is null in bubbles (#6321)\n    series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius);\n\n    if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n      for (i = 0; i < points.length; i++) {\n        point = points[i];\n        graphic = point.graphic;\n        pointMarkerOptions = point.marker || {};\n        hasPointMarker = !!point.marker;\n        enabled = globallyEnabled && pointMarkerOptions.enabled === undefined || pointMarkerOptions.enabled;\n        isInside = point.isInside; // only draw the point if y is defined\n\n        if (enabled && !point.isNull) {\n          // Shortcuts\n          symbol = pick(pointMarkerOptions.symbol, series.symbol);\n          markerAttribs = series.markerAttribs(point, point.selected && 'select');\n\n          if (graphic) {\n            // update\n            // Since the marker group isn't clipped, each individual\n            // marker must be toggled\n            graphic[isInside ? 'show' : 'hide'](true).animate(markerAttribs);\n          } else if (isInside && (markerAttribs.width > 0 || point.hasImage)) {\n            /**\n             * The graphic representation of the point. Typically\n             * this is a simple shape, like a `rect` for column\n             * charts or `path` for line markers, but for some\n             * complex series types like boxplot or 3D charts, the\n             * graphic may be a `g` element containing other shapes.\n             * The graphic is generated the first time {@link\n             * Series#drawPoints} runs, and updated and moved on\n             * subsequent runs.\n             *\n             * @memberof Point\n             * @name graphic\n             * @type {SVGElement}\n             */\n            point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);\n          }\n\n          if (graphic) {\n            graphic.addClass(point.getClassName(), true);\n          }\n        } else if (graphic) {\n          point.graphic = graphic.destroy(); // #1269\n        }\n      }\n    }\n  },\n\n  /**\n   * Get non-presentational attributes for a point. Used internally for both\n   * styled mode and classic. Can be overridden for different series types.\n   *\n   * @see Series#pointAttribs\n   *\n   * @param {Highcharts.Point} point\n   *        The Point to inspect.\n   *\n   * @param {string} [state]\n   *        The state, can be either `hover`, `select` or undefined.\n   *\n   * @return {Highcharts.SVGAttributes}\n   *         A hash containing those attributes that are not settable from\n   *         CSS.\n   */\n  markerAttribs: function markerAttribs(point, state) {\n    var seriesMarkerOptions = this.options.marker,\n        seriesStateOptions,\n        pointMarkerOptions = point.marker || {},\n        symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol,\n        pointStateOptions,\n        radius = pick(pointMarkerOptions.radius, seriesMarkerOptions.radius),\n        attribs; // Handle hover and select states\n\n    if (state) {\n      seriesStateOptions = seriesMarkerOptions.states[state];\n      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];\n      radius = pick(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0));\n    }\n\n    point.hasImage = symbol && symbol.indexOf('url') === 0;\n\n    if (point.hasImage) {\n      radius = 0; // and subsequently width and height is not set\n    }\n\n    attribs = {\n      x: Math.floor(point.plotX) - radius,\n      // Math.floor for #1843\n      y: point.plotY - radius\n    };\n\n    if (radius) {\n      attribs.width = attribs.height = 2 * radius;\n    }\n\n    return attribs;\n  },\n\n  /**\n   * Clear DOM objects and free up memory.\n   *\n   * @private\n   * @function Highcharts.Series#destroy\n   *\n   * @todo\n   * Make events official: Fires the event `destroy`.\n   */\n  destroy: function destroy() {\n    var series = this,\n        chart = series.chart,\n        issue134 = /AppleWebKit\\/533/.test(win.navigator.userAgent),\n        destroy,\n        i,\n        data = series.data || [],\n        point,\n        axis; // add event hook\n\n    fireEvent(series, 'destroy'); // remove all events\n\n    removeEvent(series); // erase from axes\n\n    each(series.axisTypes || [], function (AXIS) {\n      axis = series[AXIS];\n\n      if (axis && axis.series) {\n        erase(axis.series, series);\n        axis.isDirty = axis.forceRedraw = true;\n      }\n    }); // remove legend items\n\n    if (series.legendItem) {\n      series.chart.legend.destroyItem(series);\n    } // destroy all points with their elements\n\n\n    i = data.length;\n\n    while (i--) {\n      point = data[i];\n\n      if (point && point.destroy) {\n        point.destroy();\n      }\n    }\n\n    series.points = null; // Clear the animation timeout if we are destroying the series during\n    // initial animation\n\n    H.clearTimeout(series.animationTimeout); // Destroy all SVGElements associated to the series\n\n    objectEach(series, function (val, prop) {\n      // Survive provides a hook for not destroying\n      if (val instanceof SVGElement && !val.survive) {\n        // issue 134 workaround\n        destroy = issue134 && prop === 'group' ? 'hide' : 'destroy';\n        val[destroy]();\n      }\n    }); // remove from hoverSeries\n\n    if (chart.hoverSeries === series) {\n      chart.hoverSeries = null;\n    }\n\n    erase(chart.series, series);\n    chart.orderSeries(); // clear all members\n\n    objectEach(series, function (val, prop) {\n      delete series[prop];\n    });\n  },\n\n  /**\n   * Get the graph path.\n   *\n   * @private\n   * @function Highcharts.Series#getGraphPath\n   *\n   * @param {Array<*>} points\n   *\n   * @param {boolean} nullsAsZeroes\n   *\n   * @param {boolean} connectCliffs\n   *\n   * @return {Array<number|string>}\n   */\n  getGraphPath: function getGraphPath(points, nullsAsZeroes, connectCliffs) {\n    var series = this,\n        options = series.options,\n        step = options.step,\n        reversed,\n        graphPath = [],\n        xMap = [],\n        gap;\n    points = points || series.points; // Bottom of a stack is reversed\n\n    reversed = points.reversed;\n\n    if (reversed) {\n      points.reverse();\n    } // Reverse the steps (#5004)\n\n\n    step = {\n      right: 1,\n      center: 2\n    }[step] || step && 3;\n\n    if (step && reversed) {\n      step = 4 - step;\n    } // Remove invalid points, especially in spline (#5015)\n\n\n    if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {\n      points = this.getValidPoints(points);\n    } // Build the line\n\n\n    each(points, function (point, i) {\n      var plotX = point.plotX,\n          plotY = point.plotY,\n          lastPoint = points[i - 1],\n          pathToPoint; // the path to this point from the previous\n\n      if ((point.leftCliff || lastPoint && lastPoint.rightCliff) && !connectCliffs) {\n        gap = true; // ... and continue\n      } // Line series, nullsAsZeroes is not handled\n\n\n      if (point.isNull && !defined(nullsAsZeroes) && i > 0) {\n        gap = !options.connectNulls; // Area series, nullsAsZeroes is set\n      } else if (point.isNull && !nullsAsZeroes) {\n        gap = true;\n      } else {\n        if (i === 0 || gap) {\n          pathToPoint = ['M', point.plotX, point.plotY]; // Generate the spline as defined in the SplineSeries object\n        } else if (series.getPointSpline) {\n          pathToPoint = series.getPointSpline(points, point, i);\n        } else if (step) {\n          if (step === 1) {\n            // right\n            pathToPoint = ['L', lastPoint.plotX, plotY];\n          } else if (step === 2) {\n            // center\n            pathToPoint = ['L', (lastPoint.plotX + plotX) / 2, lastPoint.plotY, 'L', (lastPoint.plotX + plotX) / 2, plotY];\n          } else {\n            pathToPoint = ['L', plotX, lastPoint.plotY];\n          }\n\n          pathToPoint.push('L', plotX, plotY);\n        } else {\n          // normal line to next point\n          pathToPoint = ['L', plotX, plotY];\n        } // Prepare for animation. When step is enabled, there are two\n        // path nodes for each x value.\n\n\n        xMap.push(point.x);\n\n        if (step) {\n          xMap.push(point.x);\n\n          if (step === 2) {\n            // step = center (#8073)\n            xMap.push(point.x);\n          }\n        }\n\n        graphPath.push.apply(graphPath, pathToPoint);\n        gap = false;\n      }\n    });\n    graphPath.xMap = xMap;\n    series.graphPath = graphPath;\n    return graphPath;\n  },\n\n  /**\n   * Draw the graph. Called internally when rendering line-like series types.\n   * The first time it generates the `series.graph` item and optionally other\n   * series-wide items like `series.area` for area charts. On subsequent calls\n   * these items are updated with new positions and attributes.\n   *\n   * @function Highcharts.Series#drawGraph\n   */\n  drawGraph: function drawGraph() {\n    var series = this,\n        options = this.options,\n        graphPath = (this.gappedPath || this.getGraphPath).call(this),\n        props = [['graph', 'highcharts-graph']];\n    props = series.getZonesGraphs(props); // Draw the graph\n\n    each(props, function (prop, i) {\n      var graphKey = prop[0],\n          graph = series[graphKey],\n          attribs;\n\n      if (graph) {\n        graph.endX = series.preventGraphAnimation ? null : graphPath.xMap;\n        graph.animate({\n          d: graphPath\n        });\n      } else if (graphPath.length) {\n        // #1487\n        series[graphKey] = series.chart.renderer.path(graphPath).addClass(prop[1]).attr({\n          zIndex: 1\n        }) // #1069\n        .add(series.group);\n      } // Helpers for animation\n\n\n      if (graph) {\n        graph.startX = graphPath.xMap;\n        graph.isArea = graphPath.isArea; // For arearange animation\n      }\n    });\n  },\n\n  /**\n   * Get zones properties for building graphs.\n   * Extendable by series with multiple lines within one series.\n   *\n   * @private\n   * @function Highcharts.Series#getZonesGraphs\n   *\n   * @param {Array<Array<string>>} props\n   *\n   * @return {Array<Array<string>>}\n   */\n  getZonesGraphs: function getZonesGraphs(props) {\n    // Add the zone properties if any\n    each(this.zones, function (zone, i) {\n      props.push(['zone-graph-' + i, 'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || '')]);\n    }, this);\n    return props;\n  },\n\n  /**\n   * Clip the graphs into zones for colors and styling.\n   *\n   * @private\n   * @function Highcharts.Series#applyZones\n   */\n  applyZones: function applyZones() {\n    var series = this,\n        chart = this.chart,\n        renderer = chart.renderer,\n        zones = this.zones,\n        translatedFrom,\n        translatedTo,\n        clips = this.clips || [],\n        clipAttr,\n        graph = this.graph,\n        area = this.area,\n        chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),\n        axis = this[(this.zoneAxis || 'y') + 'Axis'],\n        extremes,\n        reversed,\n        inverted = chart.inverted,\n        horiz,\n        pxRange,\n        pxPosMin,\n        pxPosMax,\n        ignoreZones = false;\n\n    if (zones.length && (graph || area) && axis && axis.min !== undefined) {\n      reversed = axis.reversed;\n      horiz = axis.horiz; // The use of the Color Threshold assumes there are no gaps\n      // so it is safe to hide the original graph and area\n      // unless it is not waterfall series, then use showLine property to\n      // set lines between columns to be visible (#7862)\n\n      if (graph && !this.showLine) {\n        graph.hide();\n      }\n\n      if (area) {\n        area.hide();\n      } // Create the clips\n\n\n      extremes = axis.getExtremes();\n      each(zones, function (threshold, i) {\n        translatedFrom = reversed ? horiz ? chart.plotWidth : 0 : horiz ? 0 : axis.toPixels(extremes.min);\n        translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);\n        translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);\n\n        if (ignoreZones) {\n          translatedFrom = translatedTo = axis.toPixels(extremes.max);\n        }\n\n        pxRange = Math.abs(translatedFrom - translatedTo);\n        pxPosMin = Math.min(translatedFrom, translatedTo);\n        pxPosMax = Math.max(translatedFrom, translatedTo);\n\n        if (axis.isXAxis) {\n          clipAttr = {\n            x: inverted ? pxPosMax : pxPosMin,\n            y: 0,\n            width: pxRange,\n            height: chartSizeMax\n          };\n\n          if (!horiz) {\n            clipAttr.x = chart.plotHeight - clipAttr.x;\n          }\n        } else {\n          clipAttr = {\n            x: 0,\n            y: inverted ? pxPosMax : pxPosMin,\n            width: chartSizeMax,\n            height: pxRange\n          };\n\n          if (horiz) {\n            clipAttr.y = chart.plotWidth - clipAttr.y;\n          }\n        }\n\n        if (clips[i]) {\n          clips[i].animate(clipAttr);\n        } else {\n          clips[i] = renderer.clipRect(clipAttr);\n\n          if (graph) {\n            series['zone-graph-' + i].clip(clips[i]);\n          }\n\n          if (area) {\n            series['zone-area-' + i].clip(clips[i]);\n          }\n        } // if this zone extends out of the axis, ignore the others\n\n\n        ignoreZones = threshold.value > extremes.max; // Clear translatedTo for indicators\n\n        if (series.resetZones && translatedTo === 0) {\n          translatedTo = undefined;\n        }\n      });\n      this.clips = clips;\n    }\n  },\n\n  /**\n   * Initialize and perform group inversion on series.group and\n   * series.markerGroup.\n   *\n   * @private\n   * @function Highcharts.Series#invertGroups\n   *\n   * @param {boolean} inverted\n   */\n  invertGroups: function invertGroups(inverted) {\n    var series = this,\n        chart = series.chart,\n        remover;\n\n    function setInvert() {\n      each(['group', 'markerGroup'], function (groupName) {\n        if (series[groupName]) {\n          // VML/HTML needs explicit attributes for flipping\n          if (chart.renderer.isVML) {\n            series[groupName].attr({\n              width: series.yAxis.len,\n              height: series.xAxis.len\n            });\n          }\n\n          series[groupName].width = series.yAxis.len;\n          series[groupName].height = series.xAxis.len;\n          series[groupName].invert(inverted);\n        }\n      });\n    } // Pie, go away (#1736)\n\n\n    if (!series.xAxis) {\n      return;\n    } // A fixed size is needed for inversion to work\n\n\n    remover = addEvent(chart, 'resize', setInvert);\n    addEvent(series, 'destroy', remover); // Do it now\n\n    setInvert(inverted); // do it now\n    // On subsequent render and redraw, just do setInvert without setting up\n    // events again\n\n    series.invertGroups = setInvert;\n  },\n\n  /**\n   * General abstraction for creating plot groups like series.group,\n   * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the\n   * group will only be adjusted to the updated plot size.\n   *\n   * @private\n   * @function Highcharts.Series#plotGroup\n   *\n   * @param {string} prop\n   *\n   * @param {string} name\n   *\n   * @param {string} visibility\n   *\n   * @param {number} zIndex\n   *\n   * @param {Highcharts.SVGElement} parent\n   *\n   * @return {Highcharts.SVGElement}\n   */\n  plotGroup: function plotGroup(prop, name, visibility, zIndex, parent) {\n    var group = this[prop],\n        isNew = !group; // Generate it on first call\n\n    if (isNew) {\n      this[prop] = group = this.chart.renderer.g().attr({\n        zIndex: zIndex || 0.1 // IE8 and pointer logic use this\n\n      }).add(parent);\n    } // Add the class names, and replace existing ones as response to\n    // Series.update (#6660)\n\n\n    group.addClass('highcharts-' + name + ' highcharts-series-' + this.index + ' highcharts-' + this.type + '-series ' + (defined(this.colorIndex) ? 'highcharts-color-' + this.colorIndex + ' ' : '') + (this.options.className || '') + (group.hasClass('highcharts-tracker') ? ' highcharts-tracker' : ''), true); // Place it on first and subsequent (redraw) calls\n\n    group.attr({\n      visibility: visibility\n    })[isNew ? 'attr' : 'animate'](this.getPlotBox());\n    return group;\n  },\n\n  /**\n   * Get the translation and scale for the plot area of this series.\n   *\n   * @function Highcharts.Series#getPlotBox\n   *\n   * @return {Highcharts.SeriesPlotBoxObject}\n   */\n  getPlotBox: function getPlotBox() {\n    var chart = this.chart,\n        xAxis = this.xAxis,\n        yAxis = this.yAxis; // Swap axes for inverted (#2339)\n\n    if (chart.inverted) {\n      xAxis = yAxis;\n      yAxis = this.xAxis;\n    }\n\n    return {\n      translateX: xAxis ? xAxis.left : chart.plotLeft,\n      translateY: yAxis ? yAxis.top : chart.plotTop,\n      scaleX: 1,\n      // #1623\n      scaleY: 1\n    };\n  },\n\n  /**\n   * Render the graph and markers. Called internally when first rendering and\n   * later when redrawing the chart. This function can be extended in plugins,\n   * but normally shouldn't be called directly.\n   *\n   * @function Highcharts.Series#render\n   *\n   * @todo\n   * Make events official: Fires the event `afterRender`.\n   */\n  render: function render() {\n    var series = this,\n        chart = series.chart,\n        group,\n        options = series.options,\n        // Animation doesn't work in IE8 quirks when the group div is\n    // hidden, and looks bad in other oldIE\n    animDuration = !!series.animate && chart.renderer.isSVG && animObject(options.animation).duration,\n        visibility = series.visible ? 'inherit' : 'hidden',\n        // #2597\n    zIndex = options.zIndex,\n        hasRendered = series.hasRendered,\n        chartSeriesGroup = chart.seriesGroup,\n        inverted = chart.inverted; // the group\n\n    group = series.plotGroup('group', 'series', visibility, zIndex, chartSeriesGroup);\n    series.markerGroup = series.plotGroup('markerGroup', 'markers', visibility, zIndex, chartSeriesGroup); // initiate the animation\n\n    if (animDuration) {\n      series.animate(true);\n    } // SVGRenderer needs to know this before drawing elements (#1089, #1795)\n\n\n    group.inverted = series.isCartesian ? inverted : false; // draw the graph if any\n\n    if (series.drawGraph) {\n      series.drawGraph();\n      series.applyZones();\n    }\n    /*        each(series.points, function (point) {\n                if (point.redraw) {\n                    point.redraw();\n                }\n            });*/\n    // draw the data labels (inn pies they go before the points)\n\n\n    if (series.drawDataLabels) {\n      series.drawDataLabels();\n    } // draw the points\n\n\n    if (series.visible) {\n      series.drawPoints();\n    } // draw the mouse tracking area\n\n\n    if (series.drawTracker && series.options.enableMouseTracking !== false) {\n      series.drawTracker();\n    } // Handle inverted series and tracker groups\n\n\n    series.invertGroups(inverted); // Initial clipping, must be defined after inverting groups for VML.\n    // Applies to columns etc. (#3839).\n\n    if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n      group.clip(chart.clipRect);\n    } // Run the animation\n\n\n    if (animDuration) {\n      series.animate();\n    } // Call the afterAnimate function on animation complete (but don't\n    // overwrite the animation.complete option which should be available to\n    // the user).\n\n\n    if (!hasRendered) {\n      series.animationTimeout = syncTimeout(function () {\n        series.afterAnimate();\n      }, animDuration);\n    }\n\n    series.isDirty = false; // means data is in accordance with what you see\n    // (See #322) series.isDirty = series.isDirtyData = false; // means\n    // data is in accordance with what you see\n\n    series.hasRendered = true;\n    fireEvent(series, 'afterRender');\n  },\n\n  /**\n   * Redraw the series. This function is called internally from `chart.redraw`\n   * and normally shouldn't be called directly.\n   *\n   * @private\n   * @function Highcharts.Series#redraw\n   */\n  redraw: function redraw() {\n    var series = this,\n        chart = series.chart,\n        // cache it here as it is set to false in render, but used after\n    wasDirty = series.isDirty || series.isDirtyData,\n        group = series.group,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis; // reposition on resize\n\n    if (group) {\n      if (chart.inverted) {\n        group.attr({\n          width: chart.plotWidth,\n          height: chart.plotHeight\n        });\n      }\n\n      group.animate({\n        translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n        translateY: pick(yAxis && yAxis.top, chart.plotTop)\n      });\n    }\n\n    series.translate();\n    series.render();\n\n    if (wasDirty) {\n      // #3868, #3945\n      delete this.kdTree;\n    }\n  },\n  kdAxisArray: ['clientX', 'plotY'],\n\n  /**\n   * @private\n   * @function Highcharts.Series#searchPoint\n   *\n   * @param {*} e\n   *\n   * @param {*} compareX\n   *\n   * @return {Highcharts.Point}\n   */\n  searchPoint: function searchPoint(e, compareX) {\n    var series = this,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis,\n        inverted = series.chart.inverted;\n    return this.searchKDTree({\n      clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n      plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n    }, compareX);\n  },\n\n  /**\n   * Build the k-d-tree that is used by mouse and touch interaction to get the\n   * closest point. Line-like series typically have a one-dimensional tree\n   * where points are searched along the X axis, while scatter-like series\n   * typically search in two dimensions, X and Y.\n   *\n   * @private\n   * @function Highcharts.Series#buildKDTree\n   */\n  buildKDTree: function buildKDTree() {\n    // Prevent multiple k-d-trees from being built simultaneously (#6235)\n    this.buildingKdTree = true;\n    var series = this,\n        dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ? 2 : 1; // Internal function\n\n    function _kdtree(points, depth, dimensions) {\n      var axis,\n          median,\n          length = points && points.length;\n\n      if (length) {\n        // alternate between the axis\n        axis = series.kdAxisArray[depth % dimensions]; // sort point array\n\n        points.sort(function (a, b) {\n          return a[axis] - b[axis];\n        });\n        median = Math.floor(length / 2); // build and return nod\n\n        return {\n          point: points[median],\n          left: _kdtree(points.slice(0, median), depth + 1, dimensions),\n          right: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n        };\n      }\n    } // Start the recursive build process with a clone of the points array\n    // and null points filtered out (#3873)\n\n\n    function startRecursive() {\n      series.kdTree = _kdtree(series.getValidPoints(null, // For line-type series restrict to plot area, but\n      // column-type series not (#3916, #4511)\n      !series.directTouch), dimensions, dimensions);\n      series.buildingKdTree = false;\n    }\n\n    delete series.kdTree; // For testing tooltips, don't build async\n\n    syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Series#searchKDTree\n   *\n   * @param {*} point\n   *\n   * @param {*} compareX\n   *\n   * @return {Highcharts.Point}\n   */\n  searchKDTree: function searchKDTree(point, compareX) {\n    var series = this,\n        kdX = this.kdAxisArray[0],\n        kdY = this.kdAxisArray[1],\n        kdComparer = compareX ? 'distX' : 'dist',\n        kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ? 2 : 1; // Set the one and two dimensional distance on the point object\n\n    function setDistance(p1, p2) {\n      var x = defined(p1[kdX]) && defined(p2[kdX]) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,\n          y = defined(p1[kdY]) && defined(p2[kdY]) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,\n          r = (x || 0) + (y || 0);\n      p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n      p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n    }\n\n    function _search(search, tree, depth, dimensions) {\n      var point = tree.point,\n          axis = series.kdAxisArray[depth % dimensions],\n          tdist,\n          sideA,\n          sideB,\n          ret = point,\n          nPoint1,\n          nPoint2;\n      setDistance(search, point); // Pick side based on distance to splitting point\n\n      tdist = search[axis] - point[axis];\n      sideA = tdist < 0 ? 'left' : 'right';\n      sideB = tdist < 0 ? 'right' : 'left'; // End of tree\n\n      if (tree[sideA]) {\n        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n        ret = nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point;\n      }\n\n      if (tree[sideB]) {\n        // compare distance to current best to splitting point to decide\n        // wether to check side B or not\n        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n          nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n          ret = nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret;\n        }\n      }\n\n      return ret;\n    }\n\n    if (!this.kdTree && !this.buildingKdTree) {\n      this.buildKDTree();\n    }\n\n    if (this.kdTree) {\n      return _search(point, this.kdTree, kdDimensions, kdDimensions);\n    }\n  }\n}); // end Series prototype\n\n/**\n * A line series displays information as a series of data points connected by\n * straight line segments.\n *\n * @sample {highcharts} highcharts/demo/line-basic/\n *         Line chart\n * @sample {highstock} stock/demo/basic-line/\n *         Line chart\n *\n * @extends   plotOptions.series\n * @product   highcharts highstock\n * @apioption plotOptions.line\n */\n\n/**\n * A `line` series. If the [type](#series.line.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.line\n * @excluding dataParser,dataURL\n * @product   highcharts highstock\n * @apioption series.line\n */\n\n/**\n * An array of data points for the series. For the `line` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 1],\n *         [1, 2],\n *         [2, 8]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.line.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 6,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<number|string|Date>|*>}\n * @apioption series.line.data\n */\n\n/**\n * An additional, individual class name for the data point's graphic\n * representation.\n *\n * @type      {string}\n * @since     5.0.0\n * @product   highcharts\n * @apioption series.line.data.className\n */\n\n/**\n * Individual color for the point. By default the color is pulled from\n * the global `colors` array.\n *\n * In styled mode, the `color` option doesn't take effect. Instead, use\n * `colorIndex`.\n *\n * @sample {highcharts} highcharts/point/color/\n *         Mark the highest point\n *\n * @type      {Highcharts.ColorString}\n * @product   highcharts highstock\n * @apioption series.line.data.color\n */\n\n/**\n * A specific color index to use for the point, so its graphic representations\n * are given the class name `highcharts-color-{n}`. In styled mode this will\n * change the color of the graphic. In non-styled mode, the color by is set by\n * the `fill` attribute, so the change in class name won't have a visual effect\n * by default.\n *\n * @type      {number}\n * @since     5.0.0\n * @product   highcharts\n * @apioption series.line.data.colorIndex\n */\n\n/**\n * Individual data label for each point. The options are the same as\n * the ones for [plotOptions.series.dataLabels](\n * #plotOptions.series.dataLabels).\n *\n * @sample highcharts/point/datalabels/\n *         Show a label for the last value\n *\n * @type      {Highcharts.PlotSeriesDataLabelsOptions}\n * @product   highcharts highstock\n * @apioption series.line.data.dataLabels\n */\n\n/**\n * A description of the point to add to the screen reader information\n * about the point. Requires the Accessibility module.\n *\n * @type      {string}\n * @since     5.0.0\n * @apioption series.line.data.description\n */\n\n/**\n * An id for the point. This can be used after render time to get a\n * pointer to the point object through `chart.get()`.\n *\n * @sample {highcharts} highcharts/point/id/\n *         Remove an id'd point\n *\n * @type      {string}\n * @since     1.2.0\n * @product   highcharts highstock\n * @apioption series.line.data.id\n */\n\n/**\n * The rank for this point's data label in case of collision. If two\n * data labels are about to overlap, only the one with the highest `labelrank`\n * will be drawn.\n *\n * @type      {number}\n * @apioption series.line.data.labelrank\n */\n\n/**\n * The name of the point as shown in the legend, tooltip, dataLabel\n * etc.\n *\n * @see [xAxis.uniqueNames](#xAxis.uniqueNames)\n *\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Point names\n *\n * @type      {string}\n * @apioption series.line.data.name\n */\n\n/**\n * Whether the data point is selected initially.\n *\n * @type      {boolean}\n * @default   false\n * @product   highcharts highstock\n * @apioption series.line.data.selected\n */\n\n/**\n * The x value of the point. For datetime axes, the X value is the timestamp\n * in milliseconds since 1970.\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.line.data.x\n */\n\n/**\n * The y value of the point.\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.line.data.y\n */\n\n/**\n * Individual point events\n *\n * @extends   plotOptions.series.point.events\n * @product   highcharts highstock\n * @apioption series.line.data.events\n */\n\n/**\n * @extends   plotOptions.series.marker\n * @product   highcharts highstock\n * @apioption series.line.data.marker\n */"
    },
    {
     "id": 241,
     "name": "../node_modules/highcharts/js/es-modules/parts/Options.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 243,
     "name": "../node_modules/highcharts/js/es-modules/parts/Chart.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Callback for chart constructors.\n *\n * @callback Highcharts.ChartCallbackFunction\n *\n * @param {Highcharts.Chart} chart\n *        Created chart.\n */\n\n/**\n * The chart title. The title has an `update` method that allows modifying the\n * options directly or indirectly via `chart.update`.\n *\n * @interface Highcharts.TitleObject\n * @extends Highcharts.SVGElement\n */\n\n/**\n* Modify options for the title.\n*\n* @function Highcharts.TitleObject#update\n*\n* @param {Highcharts.TitleOptions} titleOptions\n*        Options to modify.\n*/\n\n/**\n * The chart subtitle. The subtitle has an `update` method that\n * allows modifying the options directly or indirectly via\n * `chart.update`.\n *\n * @interface Highcharts.SubtitleObject\n * @extends Highcharts.SVGElement\n */\n\n/**\n* Modify options for the subtitle.\n*\n* @function Highcharts.SubtitleObject#update\n*\n* @param {Highcharts.SubtitleOptions} subtitleOptions\n*        Options to modify.\n*/\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Axis.js';\nimport './Legend.js';\nimport './Options.js';\nimport './Pointer.js';\nvar addEvent = H.addEvent,\n    animate = H.animate,\n    animObject = H.animObject,\n    attr = H.attr,\n    doc = H.doc,\n    Axis = H.Axis,\n    // @todo add as requirement\ncreateElement = H.createElement,\n    defaultOptions = H.defaultOptions,\n    discardElement = H.discardElement,\n    charts = H.charts,\n    css = H.css,\n    defined = H.defined,\n    each = H.each,\n    extend = H.extend,\n    find = H.find,\n    fireEvent = H.fireEvent,\n    grep = H.grep,\n    isNumber = H.isNumber,\n    isObject = H.isObject,\n    isString = H.isString,\n    Legend = H.Legend,\n    // @todo add as requirement\nmarginNames = H.marginNames,\n    merge = H.merge,\n    objectEach = H.objectEach,\n    Pointer = H.Pointer,\n    // @todo add as requirement\npick = H.pick,\n    pInt = H.pInt,\n    removeEvent = H.removeEvent,\n    seriesTypes = H.seriesTypes,\n    splat = H.splat,\n    syncTimeout = H.syncTimeout,\n    win = H.win;\n/**\n * The Chart class. The recommended constructor is {@link Highcharts#chart}.\n *\n * @example\n * var chart = Highcharts.chart('container', {\n *        title: {\n *               text: 'My chart'\n *        },\n *        series: [{\n *            data: [1, 3, 2, 4]\n *        }]\n * })\n *\n * @class\n * @name Highcharts.Chart\n *\n * @param {Highcharts.Options} options\n *        The chart options structure.\n *\n * @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n *        Function to run when the chart has loaded and and all external images\n *        are loaded. Defining a\n *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n *        handler is equivalent.\n */\n\n/**\n* @class\n* @name Highcharts.Chart\n*\n* @param {string|Highcharts.HTMLDOMElement} renderTo\n*        The DOM element to render to, or its id.\n*\n* @param {Highcharts.Options} options\n*        The chart options structure.\n*\n* @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n*        Function to run when the chart has loaded and and all external images\n*        are loaded. Defining a\n*        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n*        handler is equivalent.\n*/\n\nvar Chart = H.Chart = function () {\n  this.getArgs.apply(this, arguments);\n};\n/**\n * Factory function for basic charts.\n *\n * @example\n * // Render a chart in to div#container\n * var chart = Highcharts.chart('container', {\n *     title: {\n *         text: 'My chart'\n *     },\n *     series: [{\n *         data: [1, 3, 2, 4]\n *     }]\n * });\n *\n * @function Highcharts.chart\n *\n * @param {Highcharts.Options} options\n *        The chart options structure.\n *\n * @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n *        Function to run when the chart has loaded and and all external images\n *        are loaded. Defining a\n *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n *        handler is equivalent.\n *\n * @return {Highcharts.Chart}\n *         Returns the Chart object.\n */\n\n/**\n* @function Highcharts.chart\n*\n* @param {string|Highcharts.HTMLDOMElement} renderTo\n*        The DOM element to render to, or its id.\n*\n* @param {Highcharts.Options} options\n*        The chart options structure.\n*\n* @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n*        Function to run when the chart has loaded and and all external images\n*        are loaded. Defining a\n*        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n*        handler is equivalent.\n*\n* @return {Highcharts.Chart}\n*         Returns the Chart object.\n*/\n\n\nH.chart = function (a, b, c) {\n  return new Chart(a, b, c);\n};\n\nextend(Chart.prototype,\n/** @lends Highcharts.Chart.prototype */\n{\n  // Hook for adding callbacks in modules\n  callbacks: [],\n\n  /**\n   * Handle the arguments passed to the constructor.\n   *\n   * @private\n   * @function Highcharts.Chart#getArgs\n   *\n   * @param {...Array<*>} arguments\n   *        All arguments for the constructor.\n   *\n   * @return {Array<*>}\n   *         Passed arguments without renderTo.\n   *\n   * @fires Highcharts.Chart#event:init\n   * @fires Highcharts.Chart#event:afterInit\n   */\n  getArgs: function getArgs() {\n    var args = [].slice.call(arguments); // Remove the optional first argument, renderTo, and\n    // set it on this.\n\n    if (isString(args[0]) || args[0].nodeName) {\n      this.renderTo = args.shift();\n    }\n\n    this.init(args[0], args[1]);\n  },\n\n  /**\n   * Overridable function that initializes the chart. The constructor's\n   * arguments are passed on directly.\n   *\n   * @function Highcharts.Chart#init\n   *\n   * @param {Highcharts.Options} userOptions\n   *        Custom options.\n   *\n   * @param {Function|undefined} [callback]\n   *        Function to run when the chart has loaded and and all external\n   *        images are loaded.\n   *\n   * @fires Highcharts.Chart#event:init\n   * @fires Highcharts.Chart#event:afterInit\n   */\n  init: function init(userOptions, callback) {\n    // Handle regular options\n    var options,\n        type,\n        // skip merging data points to increase performance\n    seriesOptions = userOptions.series,\n        userPlotOptions = userOptions.plotOptions || {}; // Fire the event with a default function\n\n    fireEvent(this, 'init', {\n      args: arguments\n    }, function () {\n      userOptions.series = null;\n      options = merge(defaultOptions, userOptions); // do the merge\n      // Override (by copy of user options) or clear tooltip options\n      // in chart.options.plotOptions (#6218)\n\n      for (type in options.plotOptions) {\n        options.plotOptions[type].tooltip = userPlotOptions[type] && merge(userPlotOptions[type].tooltip) // override by copy\n        || undefined; // or clear\n      } // User options have higher priority than default options\n      // (#6218). In case of exporting: path is changed\n\n\n      options.tooltip.userOptions = userOptions.chart && userOptions.chart.forExport && userOptions.tooltip.userOptions || userOptions.tooltip; // set back the series data\n\n      options.series = userOptions.series = seriesOptions;\n      this.userOptions = userOptions;\n      var optionsChart = options.chart;\n      var chartEvents = optionsChart.events;\n      this.margin = [];\n      this.spacing = []; // Pixel data bounds for touch zoom\n\n      this.bounds = {\n        h: {},\n        v: {}\n      }; // An array of functions that returns labels that should be\n      // considered for anti-collision\n\n      this.labelCollectors = [];\n      this.callback = callback;\n      this.isResizing = 0;\n      /**\n       * The options structure for the chart. It contains members for\n       * the sub elements like series, legend, tooltip etc.\n       *\n       * @name Highcharts.Chart#options\n       * @type {Highcharts.Options}\n       */\n\n      this.options = options;\n      /**\n       * All the axes in the chart.\n       *\n       * @see  Highcharts.Chart.xAxis\n       * @see  Highcharts.Chart.yAxis\n       *\n       * @name Highcharts.Chart#axes\n       * @type {Array<Highcharts.Axis>}\n       */\n\n      this.axes = [];\n      /**\n       * All the current series in the chart.\n       *\n       * @name Highcharts.Chart#series\n       * @type {Array<Highcharts.Series>}\n       */\n\n      this.series = [];\n      /**\n       * The `Time` object associated with the chart. Since v6.0.5,\n       * time settings can be applied individually for each chart. If\n       * no individual settings apply, the `Time` object is shared by\n       * all instances.\n       *\n       * @name Highcharts.Chart#time\n       * @type {Highcharts.Time}\n       */\n\n      this.time = userOptions.time && H.keys(userOptions.time).length ? new H.Time(userOptions.time) : H.time;\n      this.hasCartesianSeries = optionsChart.showAxes;\n      var chart = this; // Add the chart to the global lookup\n\n      chart.index = charts.length;\n      charts.push(chart);\n      H.chartCount++; // Chart event handlers\n\n      if (chartEvents) {\n        objectEach(chartEvents, function (event, eventType) {\n          addEvent(chart, eventType, event);\n        });\n      }\n      /**\n       * A collection of the X axes in the chart.\n       *\n       * @name Highcharts.Chart#xAxis\n       * @type {Array<Highcharts.Axis>}\n       */\n\n\n      chart.xAxis = [];\n      /**\n       * A collection of the Y axes in the chart.\n       *\n       * @name Highcharts.Chart#yAxis\n       * @type {Array<Highcharts.Axis>}\n       *\n       * @todo\n       * Make events official: Fire the event `afterInit`.\n       */\n\n      chart.yAxis = [];\n      chart.pointCount = chart.colorCounter = chart.symbolCounter = 0; // Fire after init but before first render, before axes and series\n      // have been initialized.\n\n      fireEvent(chart, 'afterInit');\n      chart.firstRender();\n    });\n  },\n\n  /**\n   * Internal function to unitialize an individual series.\n   *\n   * @private\n   * @function Highcharts.Chart#initSeries\n   *\n   * @param {Highcharts.ChartOptions} options\n   *\n   * @return {Highcharts.Series}\n   */\n  initSeries: function initSeries(options) {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n        series,\n        Constr = seriesTypes[type]; // No such series type\n\n    if (!Constr) {\n      H.error(17, true);\n    }\n\n    series = new Constr();\n    series.init(this, options);\n    return series;\n  },\n\n  /**\n   * Order all series above a given index. When series are added and ordered\n   * by configuration, only the last series is handled (#248, #1123, #2456,\n   * #6112). This function is called on series initialization and destroy.\n   *\n   * @private\n   * @function Highcharts.Series#orderSeries\n   *\n   * @param {number} fromIndex\n   *        If this is given, only the series above this index are handled.\n   */\n  orderSeries: function orderSeries(fromIndex) {\n    var series = this.series,\n        i = fromIndex || 0;\n\n    for (; i < series.length; i++) {\n      if (series[i]) {\n        series[i].index = i;\n        series[i].name = series[i].getName();\n      }\n    }\n  },\n\n  /**\n   * Check whether a given point is within the plot area.\n   *\n   * @function Highcharts.Chart#isInsidePlot\n   *\n   * @param {number} plotX\n   *        Pixel x relative to the plot area.\n   *\n   * @param {number} plotY\n   *        Pixel y relative to the plot area.\n   *\n   * @param {boolean} inverted\n   *        Whether the chart is inverted.\n   *\n   * @return {boolean}\n   *         Returns true if the given point is inside the plot area.\n   */\n  isInsidePlot: function isInsidePlot(plotX, plotY, inverted) {\n    var x = inverted ? plotY : plotX,\n        y = inverted ? plotX : plotY;\n    return x >= 0 && x <= this.plotWidth && y >= 0 && y <= this.plotHeight;\n  },\n\n  /**\n   * Redraw the chart after changes have been done to the data, axis extremes\n   * chart size or chart elements. All methods for updating axes, series or\n   * points have a parameter for redrawing the chart. This is `true` by\n   * default. But in many cases you want to do more than one operation on the\n   * chart before redrawing, for example add a number of points. In those\n   * cases it is a waste of resources to redraw the chart for each new point\n   * added. So you add the points and call `chart.redraw()` after.\n   *\n   * @function Highcharts.Chart#redraw\n   *\n   * @param {boolean|Highcharts.AnimationOptionsObject|undefined} [animation]\n   *        If or how to apply animation to the redraw.\n   *\n   * @fires Highcharts.Chart#event:afterSetExtremes\n   * @fires Highcharts.Chart#event:beforeRedraw\n   * @fires Highcharts.Chart#event:predraw\n   * @fires Highcharts.Chart#event:redraw\n   * @fires Highcharts.Chart#event:render\n   * @fires Highcharts.Chart#event:updatedData\n   */\n  redraw: function redraw(animation) {\n    fireEvent(this, 'beforeRedraw');\n    var chart = this,\n        axes = chart.axes,\n        series = chart.series,\n        pointer = chart.pointer,\n        legend = chart.legend,\n        legendUserOptions = chart.userOptions.legend,\n        redrawLegend = chart.isDirtyLegend,\n        hasStackedSeries,\n        hasDirtyStacks,\n        hasCartesianSeries = chart.hasCartesianSeries,\n        isDirtyBox = chart.isDirtyBox,\n        i,\n        serie,\n        renderer = chart.renderer,\n        isHiddenChart = renderer.isHidden(),\n        afterRedraw = []; // Handle responsive rules, not only on resize (#6130)\n\n    if (chart.setResponsive) {\n      chart.setResponsive(false);\n    }\n\n    H.setAnimation(animation, chart);\n\n    if (isHiddenChart) {\n      chart.temporaryDisplay();\n    } // Adjust title layout (reflow multiline text)\n\n\n    chart.layOutTitles(); // link stacked series\n\n    i = series.length;\n\n    while (i--) {\n      serie = series[i];\n\n      if (serie.options.stacking) {\n        hasStackedSeries = true;\n\n        if (serie.isDirty) {\n          hasDirtyStacks = true;\n          break;\n        }\n      }\n    }\n\n    if (hasDirtyStacks) {\n      // mark others as dirty\n      i = series.length;\n\n      while (i--) {\n        serie = series[i];\n\n        if (serie.options.stacking) {\n          serie.isDirty = true;\n        }\n      }\n    } // Handle updated data in the series\n\n\n    each(series, function (serie) {\n      if (serie.isDirty) {\n        if (serie.options.legendType === 'point') {\n          if (serie.updateTotals) {\n            serie.updateTotals();\n          }\n\n          redrawLegend = true;\n        } else if (legendUserOptions && (legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {\n          redrawLegend = true; // #2165\n        }\n      }\n\n      if (serie.isDirtyData) {\n        fireEvent(serie, 'updatedData');\n      }\n    }); // handle added or removed series\n\n    if (redrawLegend && legend && legend.options.enabled) {\n      // draw legend graphics\n      legend.render();\n      chart.isDirtyLegend = false;\n    } // reset stacks\n\n\n    if (hasStackedSeries) {\n      chart.getStacks();\n    }\n\n    if (hasCartesianSeries) {\n      // set axes scales\n      each(axes, function (axis) {\n        axis.updateNames();\n        axis.setScale();\n      });\n    }\n\n    chart.getMargins(); // #3098\n\n    if (hasCartesianSeries) {\n      // If one axis is dirty, all axes must be redrawn (#792, #2169)\n      each(axes, function (axis) {\n        if (axis.isDirty) {\n          isDirtyBox = true;\n        }\n      }); // redraw axes\n\n      each(axes, function (axis) {\n        // Fire 'afterSetExtremes' only if extremes are set\n        var key = axis.min + ',' + axis.max;\n\n        if (axis.extKey !== key) {\n          // #821, #4452\n          axis.extKey = key; // prevent a recursive call to chart.redraw() (#1119)\n\n          afterRedraw.push(function () {\n            fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n\n            delete axis.eventArgs;\n          });\n        }\n\n        if (isDirtyBox || hasStackedSeries) {\n          axis.redraw();\n        }\n      });\n    } // the plot areas size has changed\n\n\n    if (isDirtyBox) {\n      chart.drawChartBox();\n    } // Fire an event before redrawing series, used by the boost module to\n    // clear previous series renderings.\n\n\n    fireEvent(chart, 'predraw'); // redraw affected series\n\n    each(series, function (serie) {\n      if ((isDirtyBox || serie.isDirty) && serie.visible) {\n        serie.redraw();\n      } // Set it here, otherwise we will have unlimited 'updatedData' calls\n      // for a hidden series after setData(). Fixes #6012\n\n\n      serie.isDirtyData = false;\n    }); // move tooltip or reset\n\n    if (pointer) {\n      pointer.reset(true);\n    } // redraw if canvas\n\n\n    renderer.draw(); // Fire the events\n\n    fireEvent(chart, 'redraw');\n    fireEvent(chart, 'render');\n\n    if (isHiddenChart) {\n      chart.temporaryDisplay(true);\n    } // Fire callbacks that are put on hold until after the redraw\n\n\n    each(afterRedraw, function (callback) {\n      callback.call();\n    });\n  },\n\n  /**\n   * Get an axis, series or point object by `id` as given in the configuration\n   * options. Returns `undefined` if no item is found.\n   *\n   * @sample highcharts/plotoptions/series-id/\n   *         Get series by id\n   *\n   * @function Highcharts.Chart#get\n   *\n   * @param {string} id\n   *        The id as given in the configuration options.\n   *\n   * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}\n   *         The retrieved item.\n   */\n  get: function get(id) {\n    var ret,\n        series = this.series,\n        i;\n\n    function itemById(item) {\n      return item.id === id || item.options && item.options.id === id;\n    }\n\n    ret = // Search axes\n    find(this.axes, itemById) || // Search series\n    find(this.series, itemById); // Search points\n\n    for (i = 0; !ret && i < series.length; i++) {\n      ret = find(series[i].points || [], itemById);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Create the Axis instances based on the config options.\n   *\n   * @private\n   * @function Highcharts.Chart#getAxes\n   *\n   * @fires Highcharts.Chart#event:afterGetAxes\n   * @fires Highcharts.Chart#event:getAxes\n   */\n  getAxes: function getAxes() {\n    var chart = this,\n        options = this.options,\n        xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n        yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n        optionsArray;\n    fireEvent(this, 'getAxes'); // make sure the options are arrays and add some members\n\n    each(xAxisOptions, function (axis, i) {\n      axis.index = i;\n      axis.isX = true;\n    });\n    each(yAxisOptions, function (axis, i) {\n      axis.index = i;\n    }); // concatenate all axis options into one array\n\n    optionsArray = xAxisOptions.concat(yAxisOptions);\n    each(optionsArray, function (axisOptions) {\n      new Axis(chart, axisOptions); // eslint-disable-line no-new\n    });\n    fireEvent(this, 'afterGetAxes');\n  },\n\n  /**\n   * Returns an array of all currently selected points in the chart. Points\n   * can be selected by clicking or programmatically by the\n   * {@link Highcharts.Point#select}\n   * function.\n   *\n   * @sample highcharts/plotoptions/series-allowpointselect-line/\n   *         Get selected points\n   *\n   * @function Highcharts.Chart#getSelectedPoints\n   *\n   * @return {Array<Highcharts.Point>}\n   *         The currently selected points.\n   */\n  getSelectedPoints: function getSelectedPoints() {\n    var points = [];\n    each(this.series, function (serie) {\n      // series.data - for points outside of viewed range (#6445)\n      points = points.concat(grep(serie.data || [], function (point) {\n        return point.selected;\n      }));\n    });\n    return points;\n  },\n\n  /**\n   * Returns an array of all currently selected series in the chart. Series\n   * can be selected either programmatically by the\n   * {@link Highcharts.Series#select}\n   * function or by checking the checkbox next to the legend item if\n   * {@link https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox| series.showCheckBox}\n   * is true.\n   *\n   * @sample highcharts/members/chart-getselectedseries/\n   *         Get selected series\n   *\n   * @function Highcharts.Chart#getSelectedSeries\n   *\n   * @return {Array<Highcharts.Series>}\n   *         The currently selected series.\n   */\n  getSelectedSeries: function getSelectedSeries() {\n    return grep(this.series, function (serie) {\n      return serie.selected;\n    });\n  },\n\n  /**\n   * Set a new title or subtitle for the chart.\n   *\n   * @sample highcharts/members/chart-settitle/\n   *         Set title text and styles\n   *\n   * @function Highcharts.Chart#setTitle\n   *\n   * @param {Highcharts.TitleOptions} titleOptions\n   *        New title options. The title text itself is set by the\n   *        `titleOptions.text` property.\n   *\n   * @param {Highcharts.SubtitleOptions} subtitleOptions\n   *        New subtitle options. The subtitle text itself is set by the\n   *        `subtitleOptions.text` property.\n   *\n   * @param {boolean} redraw\n   *        Whether to redraw the chart or wait for a later call to\n   *        `chart.redraw()`.\n   */\n  setTitle: function setTitle(titleOptions, subtitleOptions, redraw) {\n    var chart = this,\n        options = chart.options,\n        chartTitleOptions,\n        chartSubtitleOptions;\n    chartTitleOptions = options.title = merge(options.title, titleOptions);\n    chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions); // add title and subtitle\n\n    /**\n     * The chart title. The title has an `update` method that allows\n     * modifying the options directly or indirectly via\n     * `chart.update`.\n     *\n     * @sample highcharts/members/title-update/\n     *         Updating titles\n     *\n     * @name Highcharts.Chart#title\n     * @type {Highcharts.TitleObject}\n     */\n\n    /**\n     * The chart subtitle. The subtitle has an `update` method that\n     * allows modifying the options directly or indirectly via\n     * `chart.update`.\n     *\n     * @name Highcharts.Chart#subtitle\n     * @type {Highcharts.SubtitleObject}\n     */\n\n    each([['title', titleOptions, chartTitleOptions], ['subtitle', subtitleOptions, chartSubtitleOptions]], function (arr, i) {\n      var name = arr[0],\n          title = chart[name],\n          titleOptions = arr[1],\n          chartTitleOptions = arr[2];\n\n      if (title && titleOptions) {\n        chart[name] = title = title.destroy(); // remove old\n      }\n\n      if (chartTitleOptions && !title) {\n        chart[name] = chart.renderer.text(chartTitleOptions.text, 0, 0, chartTitleOptions.useHTML).attr({\n          align: chartTitleOptions.align,\n          'class': 'highcharts-' + name,\n          zIndex: chartTitleOptions.zIndex || 4\n        }).add(); // Update methods, shortcut to Chart.setTitle\n\n        chart[name].update = function (o) {\n          chart.setTitle(!i && o, i && o);\n        };\n      }\n    });\n    chart.layOutTitles(redraw);\n  },\n\n  /**\n   * Internal function to lay out the chart titles and cache the full offset\n   * height for use in `getMargins`. The result is stored in\n   * `this.titleOffset`.\n   *\n   * @private\n   * @function Highcharts.Chart#layOutTitles\n   *\n   * @param {boolean|undefined} [redraw=true]\n   */\n  layOutTitles: function layOutTitles(redraw) {\n    var titleOffset = 0,\n        requiresDirtyBox,\n        renderer = this.renderer,\n        spacingBox = this.spacingBox; // Lay out the title and the subtitle respectively\n\n    each(['title', 'subtitle'], function (key) {\n      var title = this[key],\n          titleOptions = this.options[key],\n          offset = key === 'title' ? -3 : // Floating subtitle (#6574)\n      titleOptions.verticalAlign ? 0 : titleOffset + 2,\n          titleSize;\n\n      if (title) {\n        titleSize = renderer.fontMetrics(titleSize, title).b;\n        title.css({\n          width: (titleOptions.width || spacingBox.width + titleOptions.widthAdjust) + 'px'\n        }).align(extend({\n          y: offset + titleSize\n        }, titleOptions), false, 'spacingBox');\n\n        if (!titleOptions.floating && !titleOptions.verticalAlign) {\n          titleOffset = Math.ceil(titleOffset + // Skip the cache for HTML (#3481)\n          title.getBBox(titleOptions.useHTML).height);\n        }\n      }\n    }, this);\n    requiresDirtyBox = this.titleOffset !== titleOffset;\n    this.titleOffset = titleOffset; // used in getMargins\n\n    if (!this.isDirtyBox && requiresDirtyBox) {\n      this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox; // Redraw if necessary (#2719, #2744)\n\n      if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n        this.redraw();\n      }\n    }\n  },\n\n  /**\n   * Internal function to get the chart width and height according to options\n   * and container size. Sets\n   * {@link Chart.chartWidth} and\n   * {@link Chart.chartHeight}.\n   *\n   * @function Highcharts.Chart#getChartSize\n   *\n   * @return {void}\n   */\n  getChartSize: function getChartSize() {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        widthOption = optionsChart.width,\n        heightOption = optionsChart.height,\n        renderTo = chart.renderTo; // Get inner width and height\n\n    if (!defined(widthOption)) {\n      chart.containerWidth = H.getStyle(renderTo, 'width');\n    }\n\n    if (!defined(heightOption)) {\n      chart.containerHeight = H.getStyle(renderTo, 'height');\n    }\n    /**\n     * The current pixel width of the chart.\n     *\n     * @name Highcharts.Chart#chartWidth\n     * @type {number}\n     */\n\n\n    chart.chartWidth = Math.max( // #1393\n    0, widthOption || chart.containerWidth || 600 // #1460\n    );\n    /**\n     * The current pixel height of the chart.\n     *\n     * @name Highcharts.Chart#chartHeight\n     * @type {number}\n     */\n\n    chart.chartHeight = Math.max(0, H.relativeLength(heightOption, chart.chartWidth) || (chart.containerHeight > 1 ? chart.containerHeight : 400));\n  },\n\n  /**\n   * If the renderTo element has no offsetWidth, most likely one or more of\n   * its parents are hidden. Loop up the DOM tree to temporarily display the\n   * parents, then save the original display properties, and when the true\n   * size is retrieved, reset them. Used on first render and on redraws.\n   *\n   * @private\n   * @function Highcharts.Chart#temporaryDisplay\n   *\n   * @param {boolean} revert\n   *        Revert to the saved original styles.\n   */\n  temporaryDisplay: function temporaryDisplay(revert) {\n    var node = this.renderTo,\n        tempStyle;\n\n    if (!revert) {\n      while (node && node.style) {\n        // When rendering to a detached node, it needs to be temporarily\n        // attached in order to read styling and bounding boxes (#5783,\n        // #7024).\n        if (!doc.body.contains(node) && !node.parentNode) {\n          node.hcOrigDetached = true;\n          doc.body.appendChild(node);\n        }\n\n        if (H.getStyle(node, 'display', false) === 'none' || node.hcOricDetached) {\n          node.hcOrigStyle = {\n            display: node.style.display,\n            height: node.style.height,\n            overflow: node.style.overflow\n          };\n          tempStyle = {\n            display: 'block',\n            overflow: 'hidden'\n          };\n\n          if (node !== this.renderTo) {\n            tempStyle.height = 0;\n          }\n\n          H.css(node, tempStyle); // If it still doesn't have an offset width after setting\n          // display to block, it probably has an !important priority\n          // #2631, 6803\n\n          if (!node.offsetWidth) {\n            node.style.setProperty('display', 'block', 'important');\n          }\n        }\n\n        node = node.parentNode;\n\n        if (node === doc.body) {\n          break;\n        }\n      }\n    } else {\n      while (node && node.style) {\n        if (node.hcOrigStyle) {\n          H.css(node, node.hcOrigStyle);\n          delete node.hcOrigStyle;\n        }\n\n        if (node.hcOrigDetached) {\n          doc.body.removeChild(node);\n          node.hcOrigDetached = false;\n        }\n\n        node = node.parentNode;\n      }\n    }\n  },\n\n  /**\n   * Set the {@link Chart.container|chart container's} class name, in\n   * addition to `highcharts-container`.\n   *\n   * @function Highcharts.Chart#setClassName\n   *\n   * @param {string} className\n   */\n  setClassName: function setClassName(className) {\n    this.container.className = 'highcharts-container ' + (className || '');\n  },\n\n  /**\n   * Get the containing element, determine the size and create the inner\n   * container div to hold the chart.\n   *\n   * @private\n   * @function Highcharts.Chart#afterGetContainer\n   *\n   * @fires Highcharts.Chart#event:afterGetContainer\n   */\n  getContainer: function getContainer() {\n    var chart = this,\n        container,\n        options = chart.options,\n        optionsChart = options.chart,\n        chartWidth,\n        chartHeight,\n        renderTo = chart.renderTo,\n        indexAttrName = 'data-highcharts-chart',\n        oldChartIndex,\n        Ren,\n        containerId = H.uniqueKey(),\n        containerStyle,\n        key;\n\n    if (!renderTo) {\n      chart.renderTo = renderTo = optionsChart.renderTo;\n    }\n\n    if (isString(renderTo)) {\n      chart.renderTo = renderTo = doc.getElementById(renderTo);\n    } // Display an error if the renderTo is wrong\n\n\n    if (!renderTo) {\n      H.error(13, true);\n    } // If the container already holds a chart, destroy it. The check for\n    // hasRendered is there because web pages that are saved to disk from\n    // the browser, will preserve the data-highcharts-chart attribute and\n    // the SVG contents, but not an interactive chart. So in this case,\n    // charts[oldChartIndex] will point to the wrong chart if any (#2609).\n\n\n    oldChartIndex = pInt(attr(renderTo, indexAttrName));\n\n    if (isNumber(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {\n      charts[oldChartIndex].destroy();\n    } // Make a reference to the chart from the div\n\n\n    attr(renderTo, indexAttrName, chart.index); // remove previous chart\n\n    renderTo.innerHTML = ''; // If the container doesn't have an offsetWidth, it has or is a child of\n    // a node that has display:none. We need to temporarily move it out to a\n    // visible state to determine the size, else the legend and tooltips\n    // won't render properly. The skipClone option is used in sparklines as\n    // a micro optimization, saving about 1-2 ms each chart.\n\n    if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n      chart.temporaryDisplay();\n    } // get the width and height\n\n\n    chart.getChartSize();\n    chartWidth = chart.chartWidth;\n    chartHeight = chart.chartHeight; // Create the inner container\n\n    /**\n     * The containing HTML element of the chart. The container is\n     * dynamically inserted into the element given as the `renderTo`\n     * parameter in the {@link Highcharts#chart} constructor.\n     *\n     * @name Highcharts.Chart#container\n     * @type {Highcharts.HTMLDOMElement}\n     */\n\n    container = createElement('div', {\n      id: containerId\n    }, containerStyle, renderTo);\n    chart.container = container; // cache the cursor (#1650)\n\n    chart._cursor = container.style.cursor; // Initialize the renderer\n\n    Ren = H[optionsChart.renderer] || H.Renderer;\n    /**\n     * The renderer instance of the chart. Each chart instance has only one\n     * associated renderer.\n     *\n     * @name Highcharts.Chart#renderer\n     * @type {Highcharts.SVGRenderer}\n     */\n\n    chart.renderer = new Ren(container, chartWidth, chartHeight, null, optionsChart.forExport, options.exporting && options.exporting.allowHTML);\n    chart.setClassName(optionsChart.className); // Initialize definitions\n\n    for (key in options.defs) {\n      this.renderer.definition(options.defs[key]);\n    } // Add a reference to the charts index\n\n\n    chart.renderer.chartIndex = chart.index;\n    fireEvent(this, 'afterGetContainer');\n  },\n\n  /**\n   * Calculate margins by rendering axis labels in a preliminary position.\n   * Title, subtitle and legend have already been rendered at this stage, but\n   * will be moved into their final positions.\n   *\n   * @private\n   * @function Highcharts.Chart#getMargins\n   *\n   * @param  {boolean} skipAxes\n   *\n   * @fires Highcharts.Chart#event:getMargins\n   */\n  getMargins: function getMargins(skipAxes) {\n    var chart = this,\n        spacing = chart.spacing,\n        margin = chart.margin,\n        titleOffset = chart.titleOffset;\n    chart.resetMargins(); // Adjust for title and subtitle\n\n    if (titleOffset && !defined(margin[0])) {\n      chart.plotTop = Math.max(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);\n    } // Adjust for legend\n\n\n    if (chart.legend && chart.legend.display) {\n      chart.legend.adjustMargins(margin, spacing);\n    }\n\n    fireEvent(this, 'getMargins');\n\n    if (!skipAxes) {\n      this.getAxisMargins();\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Chart#getAxisMargins\n   */\n  getAxisMargins: function getAxisMargins() {\n    var chart = this,\n        // [top, right, bottom, left]\n    axisOffset = chart.axisOffset = [0, 0, 0, 0],\n        margin = chart.margin; // pre-render axes to get labels offset width\n\n    if (chart.hasCartesianSeries) {\n      each(chart.axes, function (axis) {\n        if (axis.visible) {\n          axis.getOffset();\n        }\n      });\n    } // Add the axis offsets\n\n\n    each(marginNames, function (m, side) {\n      if (!defined(margin[side])) {\n        chart[m] += axisOffset[side];\n      }\n    });\n    chart.setChartSize();\n  },\n\n  /**\n   * Reflows the chart to its container. By default, the chart reflows\n   * automatically to its container following a `window.resize` event, as per\n   * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}\n   * option. However, there are no reliable events for div resize, so if the\n   * container is resized without a window resize event, this must be called\n   * explicitly.\n   *\n   * @sample highcharts/members/chart-reflow/\n   *         Resize div and reflow\n   * @sample highcharts/chart/events-container/\n   *         Pop up and reflow\n   *\n   * @function Highcharts.Chart#reflow\n   *\n   * @param  {global.Event} e\n   *         Event arguments. Used primarily when the function is called\n   *         internally as a response to window resize.\n   */\n  reflow: function reflow(e) {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        renderTo = chart.renderTo,\n        hasUserSize = defined(optionsChart.width) && defined(optionsChart.height),\n        width = optionsChart.width || H.getStyle(renderTo, 'width'),\n        height = optionsChart.height || H.getStyle(renderTo, 'height'),\n        target = e ? e.target : win; // Width and height checks for display:none. Target is doc in IE8 and\n    // Opera, win in Firefox, Chrome and IE9.\n\n    if (!hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) {\n      if (width !== chart.containerWidth || height !== chart.containerHeight) {\n        H.clearTimeout(chart.reflowTimeout); // When called from window.resize, e is set, else it's called\n        // directly (#2224)\n\n        chart.reflowTimeout = syncTimeout(function () {\n          // Set size, it may have been destroyed in the meantime\n          // (#1257)\n          if (chart.container) {\n            chart.setSize(undefined, undefined, false);\n          }\n        }, e ? 100 : 0);\n      }\n\n      chart.containerWidth = width;\n      chart.containerHeight = height;\n    }\n  },\n\n  /**\n   * Toggle the event handlers necessary for auto resizing, depending on the\n   * `chart.reflow` option.\n   *\n   * @private\n   * @function Highcharts.Chart#setReflow\n   *\n   * @param  {boolean} reflow\n   */\n  setReflow: function setReflow(reflow) {\n    var chart = this;\n\n    if (reflow !== false && !this.unbindReflow) {\n      this.unbindReflow = addEvent(win, 'resize', function (e) {\n        chart.reflow(e);\n      });\n      addEvent(this, 'destroy', this.unbindReflow);\n    } else if (reflow === false && this.unbindReflow) {\n      // Unbind and unset\n      this.unbindReflow = this.unbindReflow();\n    } // The following will add listeners to re-fit the chart before and after\n    // printing (#2284). However it only works in WebKit. Should have worked\n    // in Firefox, but not supported in IE.\n\n    /*\n    if (win.matchMedia) {\n        win.matchMedia('print').addListener(function reflow() {\n            chart.reflow();\n        });\n    }\n    //*/\n\n  },\n\n  /**\n   * Resize the chart to a given width and height. In order to set the width\n   * only, the height argument may be skipped. To set the height only, pass\n   * `undefined` for the width.\n   *\n   * @sample highcharts/members/chart-setsize-button/\n   *         Test resizing from buttons\n   * @sample highcharts/members/chart-setsize-jquery-resizable/\n   *         Add a jQuery UI resizable\n   * @sample stock/members/chart-setsize/\n   *         Highstock with UI resizable\n   *\n   * @function Highcharts.Chart#setSize\n   *\n   * @param  {number|null|undefined} [width]\n   *         The new pixel width of the chart. Since v4.2.6, the argument can\n   *         be `undefined` in order to preserve the current value (when\n   *         setting height only), or `null` to adapt to the width of the\n   *         containing element.\n   *\n   * @param  {number|null|undefined} [height]\n   *         The new pixel height of the chart. Since v4.2.6, the argument can\n   *         be `undefined` in order to preserve the current value, or `null`\n   *         in order to adapt to the height of the containing element.\n   *\n   * @param  {Highcharts.AnimationOptionsObject|undefined} [animation=true]\n   *         Whether and how to apply animation.\n   *\n   * @fires Highcharts.Chart#event:endResize\n   * @fires Highcharts.Chart#event:resize\n   */\n  setSize: function setSize(width, height, animation) {\n    var chart = this,\n        renderer = chart.renderer,\n        globalAnimation; // Handle the isResizing counter\n\n    chart.isResizing += 1; // set the animation for the current process\n\n    H.setAnimation(animation, chart);\n    chart.oldChartHeight = chart.chartHeight;\n    chart.oldChartWidth = chart.chartWidth;\n\n    if (width !== undefined) {\n      chart.options.chart.width = width;\n    }\n\n    if (height !== undefined) {\n      chart.options.chart.height = height;\n    }\n\n    chart.getChartSize(); // Resize the container with the global animation applied if enabled\n    // (#2503)\n\n    chart.setChartSize(true);\n    renderer.setSize(chart.chartWidth, chart.chartHeight, animation); // handle axes\n\n    each(chart.axes, function (axis) {\n      axis.isDirty = true;\n      axis.setScale();\n    });\n    chart.isDirtyLegend = true; // force legend redraw\n\n    chart.isDirtyBox = true; // force redraw of plot and chart border\n\n    chart.layOutTitles(); // #2857\n\n    chart.getMargins();\n    chart.redraw(animation);\n    chart.oldChartHeight = null;\n    fireEvent(chart, 'resize'); // Fire endResize and set isResizing back. If animation is disabled,\n    // fire without delay\n\n    syncTimeout(function () {\n      if (chart) {\n        fireEvent(chart, 'endResize', null, function () {\n          chart.isResizing -= 1;\n        });\n      }\n    }, animObject(globalAnimation).duration);\n  },\n\n  /**\n   * Set the public chart properties. This is done before and after the\n   * pre-render to determine margin sizes.\n   *\n   * @private\n   * @function Highcharts.Chart#setChartSize\n   *\n   * @param  {boolean} skipAxes\n   *\n   * @fires Highcharts.Chart#event:afterSetChartSize\n   */\n  setChartSize: function setChartSize(skipAxes) {\n    var chart = this,\n        inverted = chart.inverted,\n        renderer = chart.renderer,\n        chartWidth = chart.chartWidth,\n        chartHeight = chart.chartHeight,\n        optionsChart = chart.options.chart,\n        spacing = chart.spacing,\n        clipOffset = chart.clipOffset,\n        clipX,\n        clipY,\n        plotLeft,\n        plotTop,\n        plotWidth,\n        plotHeight,\n        plotBorderWidth;\n    /**\n     * The current left position of the plot area in pixels.\n     *\n     * @name Highcharts.Chart#plotLeft\n     * @type {number}\n     */\n\n    chart.plotLeft = plotLeft = Math.round(chart.plotLeft);\n    /**\n     * The current top position of the plot area in pixels.\n     *\n     * @name Highcharts.Chart#plotTop\n     * @type {number}\n     */\n\n    chart.plotTop = plotTop = Math.round(chart.plotTop);\n    /**\n     * The current width of the plot area in pixels.\n     *\n     * @name Highcharts.Chart#plotWidth\n     * @type {number}\n     */\n\n    chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));\n    /**\n     * The current height of the plot area in pixels.\n     *\n     * @name Highcharts.Chart#plotHeight\n     * @type {number}\n     */\n\n    chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));\n    chart.plotSizeX = inverted ? plotHeight : plotWidth;\n    chart.plotSizeY = inverted ? plotWidth : plotHeight;\n    chart.plotBorderWidth = optionsChart.plotBorderWidth || 0; // Set boxes used for alignment\n\n    chart.spacingBox = renderer.spacingBox = {\n      x: spacing[3],\n      y: spacing[0],\n      width: chartWidth - spacing[3] - spacing[1],\n      height: chartHeight - spacing[0] - spacing[2]\n    };\n    chart.plotBox = renderer.plotBox = {\n      x: plotLeft,\n      y: plotTop,\n      width: plotWidth,\n      height: plotHeight\n    };\n    plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);\n    clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2);\n    clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);\n    chart.clipBox = {\n      x: clipX,\n      y: clipY,\n      width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX),\n      height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))\n    };\n\n    if (!skipAxes) {\n      each(chart.axes, function (axis) {\n        axis.setAxisSize();\n        axis.setAxisTranslation();\n      });\n    }\n\n    fireEvent(chart, 'afterSetChartSize', {\n      skipAxes: skipAxes\n    });\n  },\n\n  /**\n   * Initial margins before auto size margins are applied.\n   *\n   * @private\n   * @function Highcharts.Chart#resetMargins\n   */\n  resetMargins: function resetMargins() {\n    var chart = this,\n        chartOptions = chart.options.chart; // Create margin and spacing array\n\n    each(['margin', 'spacing'], function splashArrays(target) {\n      var value = chartOptions[target],\n          values = isObject(value) ? value : [value, value, value, value];\n      each(['Top', 'Right', 'Bottom', 'Left'], function (sideName, side) {\n        chart[target][side] = pick(chartOptions[target + sideName], values[side]);\n      });\n    }); // Set margin names like chart.plotTop, chart.plotLeft,\n    // chart.marginRight, chart.marginBottom.\n\n    each(marginNames, function (m, side) {\n      chart[m] = pick(chart.margin[side], chart.spacing[side]);\n    });\n    chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n\n    chart.clipOffset = [0, 0, 0, 0];\n  },\n\n  /**\n   * Internal function to draw or redraw the borders and backgrounds for chart\n   * and plot area.\n   *\n   * @private\n   * @function Highcharts.Chart#drawChartBox\n   *\n   * @fires Highcharts.Chart#event:afterDrawChartBox\n   */\n  drawChartBox: function drawChartBox() {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        renderer = chart.renderer,\n        chartWidth = chart.chartWidth,\n        chartHeight = chart.chartHeight,\n        chartBackground = chart.chartBackground,\n        plotBackground = chart.plotBackground,\n        plotBorder = chart.plotBorder,\n        chartBorderWidth,\n        mgn,\n        bgAttr,\n        plotLeft = chart.plotLeft,\n        plotTop = chart.plotTop,\n        plotWidth = chart.plotWidth,\n        plotHeight = chart.plotHeight,\n        plotBox = chart.plotBox,\n        clipRect = chart.clipRect,\n        clipBox = chart.clipBox,\n        verb = 'animate'; // Chart area\n\n    if (!chartBackground) {\n      chart.chartBackground = chartBackground = renderer.rect().addClass('highcharts-background').add();\n      verb = 'attr';\n    }\n\n    chartBorderWidth = mgn = chartBackground.strokeWidth();\n    chartBackground[verb]({\n      x: mgn / 2,\n      y: mgn / 2,\n      width: chartWidth - mgn - chartBorderWidth % 2,\n      height: chartHeight - mgn - chartBorderWidth % 2,\n      r: optionsChart.borderRadius\n    }); // Plot background\n\n    verb = 'animate';\n\n    if (!plotBackground) {\n      verb = 'attr';\n      chart.plotBackground = plotBackground = renderer.rect().addClass('highcharts-plot-background').add();\n    }\n\n    plotBackground[verb](plotBox); // Plot clip\n\n    if (!clipRect) {\n      chart.clipRect = renderer.clipRect(clipBox);\n    } else {\n      clipRect.animate({\n        width: clipBox.width,\n        height: clipBox.height\n      });\n    } // Plot area border\n\n\n    verb = 'animate';\n\n    if (!plotBorder) {\n      verb = 'attr';\n      chart.plotBorder = plotBorder = renderer.rect().addClass('highcharts-plot-border').attr({\n        zIndex: 1 // Above the grid\n\n      }).add();\n    }\n\n    plotBorder[verb](plotBorder.crisp({\n      x: plotLeft,\n      y: plotTop,\n      width: plotWidth,\n      height: plotHeight\n    }, -plotBorder.strokeWidth())); // #3282 plotBorder should be negative;\n    // reset\n\n    chart.isDirtyBox = false;\n    fireEvent(this, 'afterDrawChartBox');\n  },\n\n  /**\n   * Detect whether a certain chart property is needed based on inspecting its\n   * options and series. This mainly applies to the chart.inverted property,\n   * and in extensions to the chart.angular and chart.polar properties.\n   *\n   * @private\n   * @function Highcharts.Chart#propFromSeries\n   */\n  propFromSeries: function propFromSeries() {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        klass,\n        seriesOptions = chart.options.series,\n        i,\n        value;\n    each(['inverted', 'angular', 'polar'], function (key) {\n      // The default series type's class\n      klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType]; // Get the value from available chart-wide properties\n\n      value = optionsChart[key] || // It is set in the options\n      klass && klass.prototype[key]; // The default series class\n      // requires it\n      // 4. Check if any the chart's series require it\n\n      i = seriesOptions && seriesOptions.length;\n\n      while (!value && i--) {\n        klass = seriesTypes[seriesOptions[i].type];\n\n        if (klass && klass.prototype[key]) {\n          value = true;\n        }\n      } // Set the chart property\n\n\n      chart[key] = value;\n    });\n  },\n\n  /**\n   * Internal function to link two or more series together, based on the\n   * `linkedTo` option. This is done from `Chart.render`, and after\n   * `Chart.addSeries` and `Series.remove`.\n   *\n   * @private\n   * @function Highcharts.Chart#linkSeries\n   *\n   * @fires Highcharts.Chart#event:afterLinkSeries\n   */\n  linkSeries: function linkSeries() {\n    var chart = this,\n        chartSeries = chart.series; // Reset links\n\n    each(chartSeries, function (series) {\n      series.linkedSeries.length = 0;\n    }); // Apply new links\n\n    each(chartSeries, function (series) {\n      var linkedTo = series.options.linkedTo;\n\n      if (isString(linkedTo)) {\n        if (linkedTo === ':previous') {\n          linkedTo = chart.series[series.index - 1];\n        } else {\n          linkedTo = chart.get(linkedTo);\n        } // #3341 avoid mutual linking\n\n\n        if (linkedTo && linkedTo.linkedParent !== series) {\n          linkedTo.linkedSeries.push(series);\n          series.linkedParent = linkedTo;\n          series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible); // #3879\n        }\n      }\n    });\n    fireEvent(this, 'afterLinkSeries');\n  },\n\n  /**\n   * Render series for the chart.\n   *\n   * @private\n   * @function Highcharts.Chart#renderSeries\n   */\n  renderSeries: function renderSeries() {\n    each(this.series, function (serie) {\n      serie.translate();\n      serie.render();\n    });\n  },\n\n  /**\n   * Render labels for the chart.\n   *\n   * @private\n   * @function Highcharts.Chart#renderLabels\n   */\n  renderLabels: function renderLabels() {\n    var chart = this,\n        labels = chart.options.labels;\n\n    if (labels.items) {\n      each(labels.items, function (label) {\n        var style = extend(labels.style, label.style),\n            x = pInt(style.left) + chart.plotLeft,\n            y = pInt(style.top) + chart.plotTop + 12; // delete to prevent rewriting in IE\n\n        delete style.left;\n        delete style.top;\n        chart.renderer.text(label.html, x, y).attr({\n          zIndex: 2\n        }).css(style).add();\n      });\n    }\n  },\n\n  /**\n   * Render all graphics for the chart. Runs internally on initialization.\n   *\n   * @private\n   * @function Highcharts.Chart#render\n   */\n  render: function render() {\n    var chart = this,\n        axes = chart.axes,\n        renderer = chart.renderer,\n        options = chart.options,\n        tempWidth,\n        tempHeight,\n        redoHorizontal,\n        redoVertical; // Title\n\n    chart.setTitle();\n    /**\n     * The overview of the chart's series.\n     *\n     * @name Highcharts.Chart#legend\n     * @type {Highcharts.Legend}\n     */\n\n    chart.legend = new Legend(chart, options.legend); // Get stacks\n\n    if (chart.getStacks) {\n      chart.getStacks();\n    } // Get chart margins\n\n\n    chart.getMargins(true);\n    chart.setChartSize(); // Record preliminary dimensions for later comparison\n\n    tempWidth = chart.plotWidth; // 21 is the most common correction for X axis labels\n    // use Math.max to prevent negative plotHeight\n\n    tempHeight = chart.plotHeight = Math.max(chart.plotHeight - 21, 0); // Get margins by pre-rendering axes\n\n    each(axes, function (axis) {\n      axis.setScale();\n    });\n    chart.getAxisMargins(); // If the plot area size has changed significantly, calculate tick\n    // positions again\n\n    redoHorizontal = tempWidth / chart.plotWidth > 1.1; // Height is more sensitive, use lower threshold\n\n    redoVertical = tempHeight / chart.plotHeight > 1.05;\n\n    if (redoHorizontal || redoVertical) {\n      each(axes, function (axis) {\n        if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {\n          // update to reflect the new margins\n          axis.setTickInterval(true);\n        }\n      });\n      chart.getMargins(); // second pass to check for new labels\n    } // Draw the borders and backgrounds\n\n\n    chart.drawChartBox(); // Axes\n\n    if (chart.hasCartesianSeries) {\n      each(axes, function (axis) {\n        if (axis.visible) {\n          axis.render();\n        }\n      });\n    } // The series\n\n\n    if (!chart.seriesGroup) {\n      chart.seriesGroup = renderer.g('series-group').attr({\n        zIndex: 3\n      }).add();\n    }\n\n    chart.renderSeries(); // Labels\n\n    chart.renderLabels(); // Credits\n\n    chart.addCredits(); // Handle responsiveness\n\n    if (chart.setResponsive) {\n      chart.setResponsive();\n    } // Set flag\n\n\n    chart.hasRendered = true;\n  },\n\n  /**\n   * Set a new credits label for the chart.\n   *\n   * @sample highcharts/credits/credits-update/\n   *         Add and update credits\n   *\n   * @function Highcharts.Chart#addCredits\n   *\n   * @param  {Highcharts.CreditsOptions} options\n   *         A configuration object for the new credits.\n   */\n  addCredits: function addCredits(credits) {\n    var chart = this;\n    credits = merge(true, this.options.credits, credits);\n\n    if (credits.enabled && !this.credits) {\n      /**\n       * The chart's credits label. The label has an `update` method that\n       * allows setting new options as per the\n       * {@link https://api.highcharts.com/highcharts/credits|credits options set}.\n       *\n       * @name Highcharts.Chart#credits\n       * @type {Highcharts.SVGElement}\n       */\n      this.credits = this.renderer.text(credits.text + (this.mapCredits || ''), 0, 0).addClass('highcharts-credits').on('click', function () {\n        if (credits.href) {\n          win.location.href = credits.href;\n        }\n      }).attr({\n        align: credits.position.align,\n        zIndex: 8\n      }).add().align(credits.position); // Dynamically update\n\n      this.credits.update = function (options) {\n        chart.credits = chart.credits.destroy();\n        chart.addCredits(options);\n      };\n    }\n  },\n\n  /**\n   * Remove the chart and purge memory. This method is called internally\n   * before adding a second chart into the same container, as well as on\n   * window unload to prevent leaks.\n   *\n   * @sample highcharts/members/chart-destroy/\n   *         Destroy the chart from a button\n   * @sample stock/members/chart-destroy/\n   *         Destroy with Highstock\n   *\n   * @function Highcharts.Chart#destroy\n   *\n   * @fires Highcharts.Chart#event:destroy\n   */\n  destroy: function destroy() {\n    var chart = this,\n        axes = chart.axes,\n        series = chart.series,\n        container = chart.container,\n        i,\n        parentNode = container && container.parentNode; // fire the chart.destoy event\n\n    fireEvent(chart, 'destroy'); // Delete the chart from charts lookup array\n\n    if (chart.renderer.forExport) {\n      H.erase(charts, chart); // #6569\n    } else {\n      charts[chart.index] = undefined;\n    }\n\n    H.chartCount--;\n    chart.renderTo.removeAttribute('data-highcharts-chart'); // remove events\n\n    removeEvent(chart); // ==== Destroy collections:\n    // Destroy axes\n\n    i = axes.length;\n\n    while (i--) {\n      axes[i] = axes[i].destroy();\n    } // Destroy scroller & scroller series before destroying base series\n\n\n    if (this.scroller && this.scroller.destroy) {\n      this.scroller.destroy();\n    } // Destroy each series\n\n\n    i = series.length;\n\n    while (i--) {\n      series[i] = series[i].destroy();\n    } // ==== Destroy chart properties:\n\n\n    each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n      var prop = chart[name];\n\n      if (prop && prop.destroy) {\n        chart[name] = prop.destroy();\n      }\n    }); // Remove container and all SVG, check container as it can break in IE\n    // when destroyed before finished loading\n\n    if (container) {\n      container.innerHTML = '';\n      removeEvent(container);\n\n      if (parentNode) {\n        discardElement(container);\n      }\n    } // clean it all up\n\n\n    objectEach(chart, function (val, key) {\n      delete chart[key];\n    });\n  },\n\n  /**\n   * Prepare for first rendering after all data are loaded.\n   *\n   * @private\n   * @function Highcharts.Chart#firstRender\n   *\n   * @fires Highcharts.Chart#event:beforeRender\n   */\n  firstRender: function firstRender() {\n    var chart = this,\n        options = chart.options; // Hook for oldIE to check whether the chart is ready to render\n\n    if (chart.isReadyToRender && !chart.isReadyToRender()) {\n      return;\n    } // Create the container\n\n\n    chart.getContainer();\n    chart.resetMargins();\n    chart.setChartSize(); // Set the common chart properties (mainly invert) from the given series\n\n    chart.propFromSeries(); // get axes\n\n    chart.getAxes(); // Initialize the series\n\n    each(options.series || [], function (serieOptions) {\n      chart.initSeries(serieOptions);\n    });\n    chart.linkSeries(); // Run an event after axes and series are initialized, but before\n    // render. At this stage, the series data is indexed and cached in the\n    // xData and yData arrays, so we can access those before rendering. Used\n    // in Highstock.\n\n    fireEvent(chart, 'beforeRender'); // depends on inverted and on margins being set\n\n    if (Pointer) {\n      /**\n       * The Pointer that keeps track of mouse and touch interaction.\n       *\n       * @memberof Highcharts.Chart\n       * @name pointer\n       * @type {Highcharts.Pointer}\n       * @instance\n       */\n      chart.pointer = new Pointer(chart, options);\n    }\n\n    chart.render(); // Fire the load event if there are no external images\n\n    if (!chart.renderer.imgCount && chart.onload) {\n      chart.onload();\n    } // If the chart was rendered outside the top container, put it back in\n    // (#3679)\n\n\n    chart.temporaryDisplay(true);\n  },\n\n  /**\n   * Internal function that runs on chart load, async if any images are loaded\n   * in the chart. Runs the callbacks and triggers the `load` and `render`\n   * events.\n   *\n   * @private\n   * @function Highcharts.Chart#onload\n   *\n   * @fires Highcharts.Chart#event:load\n   * @fires Highcharts.Chart#event:render\n   */\n  onload: function onload() {\n    // Run callbacks\n    each([this.callback].concat(this.callbacks), function (fn) {\n      // Chart destroyed in its own callback (#3600)\n      if (fn && this.index !== undefined) {\n        fn.apply(this, [this]);\n      }\n    }, this);\n    fireEvent(this, 'load');\n    fireEvent(this, 'render'); // Set up auto resize, check for not destroyed (#6068)\n\n    if (defined(this.index)) {\n      this.setReflow(this.options.chart.reflow);\n    } // Don't run again\n\n\n    this.onload = null;\n  }\n}); // end Chart"
    },
    {
     "id": 245,
     "name": "../node_modules/highcharts/js/es-modules/parts/Axis.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Options for crosshairs on axes.\n *\n * @typedef {Highcharts.XAxisCrosshairOptions|Highcharts.YAxisCrosshairOptions} Highcharts.AxisCrosshairOptions\n */\n\n/**\n * Options for axes.\n *\n * @typedef {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} Highcharts.AxisOptions\n */\n\n/**\n * Position of the axis title.\n *\n * @typedef Highcharts.AxisTitlePositionObject\n *\n * @property {number} x\n *           X position.\n *\n * @property {number} y\n *           Y position.\n */\n\n/**\n * The returned object literal from the {@link Highcharts.Axis#getExtremes}\n * function.\n *\n * @typedef Highcharts.ExtremesObject\n *\n * @property {number} dataMax\n *           The maximum value of the axis' associated series.\n *\n * @property {number} dataMin\n *           The minimum value of the axis' associated series.\n *\n * @property {number} max\n *           The maximum axis value, either automatic or set manually. If\n *           the `max` option is not set, `maxPadding` is 0 and `endOnTick`\n *           is false, this value will be the same as `dataMax`.\n *\n * @property {number} min\n *           The minimum axis value, either automatic or set manually. If\n *           the `min` option is not set, `minPadding` is 0 and\n *           `startOnTick` is false, this value will be the same\n *           as `dataMin`.\n *\n * @property {number} userMax\n *           The user defined maximum, either from the `max` option or from\n *           a zoom or `setExtremes` action.\n *\n * @property {number} userMin\n *           The user defined minimum, either from the `min` option or from\n *           a zoom or `setExtremes` action.\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Color.js';\nimport './Options.js';\nimport './Tick.js';\nvar addEvent = H.addEvent,\n    animObject = H.animObject,\n    arrayMax = H.arrayMax,\n    arrayMin = H.arrayMin,\n    color = H.color,\n    correctFloat = H.correctFloat,\n    defaultOptions = H.defaultOptions,\n    defined = H.defined,\n    deg2rad = H.deg2rad,\n    destroyObjectProperties = H.destroyObjectProperties,\n    each = H.each,\n    extend = H.extend,\n    fireEvent = H.fireEvent,\n    format = H.format,\n    getMagnitude = H.getMagnitude,\n    grep = H.grep,\n    inArray = H.inArray,\n    isArray = H.isArray,\n    isNumber = H.isNumber,\n    isString = H.isString,\n    merge = H.merge,\n    normalizeTickInterval = H.normalizeTickInterval,\n    objectEach = H.objectEach,\n    pick = H.pick,\n    removeEvent = H.removeEvent,\n    splat = H.splat,\n    syncTimeout = H.syncTimeout,\n    Tick = H.Tick;\n/**\n * Create a new axis object. Called internally when instanciating a new chart or\n * adding axes by {@link Highcharts.Chart#addAxis}.\n *\n * A chart can have from 0 axes (pie chart) to multiples. In a normal, single\n * series cartesian chart, there is one X axis and one Y axis.\n *\n * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is\n * an array of Axis objects. If there is only one axis, it can be referenced\n * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same\n * pattern goes for Y axes.\n *\n * If you need to get the axes from a series object, use the `series.xAxis` and\n * `series.yAxis` properties. These are not arrays, as one series can only be\n * associated to one X and one Y axis.\n *\n * A third way to reference the axis programmatically is by `id`. Add an `id` in\n * the axis configuration options, and get the axis by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the axes are given in options.xAxis and\n * options.yAxis.\n *\n * @class\n * @name Highcharts.Axis\n *\n * @param {Highcharts.Chart} chart\n *        The Chart instance to apply the axis on.\n *\n * @param {Highcharts.AxisOptions} options\n *        Axis options.\n */\n\nvar Axis = function Axis() {\n  this.init.apply(this, arguments);\n};\n\nH.extend(Axis.prototype,\n/** @lends Highcharts.Axis.prototype */\n{\n  /**\n   * The X axis or category axis. Normally this is the horizontal axis,\n   * though if the chart is inverted this is the vertical axis. In case of\n   * multiple axes, the xAxis node is an array of configuration objects.\n   *\n   * See [the Axis object](/class-reference/Highcharts.Axis) for\n   * programmatic access to the axis.\n   *\n   * @productdesc {highmaps}\n   * In Highmaps, the axis is hidden, but it is used behind the scenes to\n   * control features like zooming and panning. Zooming is in effect the same\n   * as setting the extremes of one of the exes.\n   *\n   * @optionparent xAxis\n   */\n  defaultOptions: {\n    /**\n     * When using multiple axis, the ticks of two or more opposite axes\n     * will automatically be aligned by adding ticks to the axis or axes\n     * with the least ticks, as if `tickAmount` were specified.\n     *\n     * This can be prevented by setting `alignTicks` to false. If the grid\n     * lines look messy, it's a good idea to hide them for the secondary\n     * axis by setting `gridLineWidth` to 0.\n     *\n     * If `startOnTick` or `endOnTick` in an Axis options are set to false,\n     * then the `alignTicks ` will be disabled for the Axis.\n     *\n     * Disabled for logarithmic axes.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @product   highcharts highstock\n     * @apioption xAxis.alignTicks\n     */\n\n    /**\n     * Whether to allow decimals in this axis' ticks. When counting\n     * integers, like persons or hits on a web page, decimals should\n     * be avoided in the labels.\n     *\n     * @see [minTickInterval](#xAxis.minTickInterval)\n     *\n     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/\n     *         True by default\n     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/\n     *         False\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     2.0\n     * @apioption xAxis.allowDecimals\n     */\n\n    /**\n     * When using an alternate grid color, a band is painted across the\n     * plot area between every other grid line.\n     *\n     * @sample {highcharts} highcharts/yaxis/alternategridcolor/\n     *         Alternate grid color on the Y axis\n     * @sample {highstock} stock/xaxis/alternategridcolor/\n     *         Alternate grid color on the Y axis\n     *\n     * @type      {Highcharts.ColorString}\n     * @apioption xAxis.alternateGridColor\n     */\n\n    /**\n     * An array defining breaks in the axis, the sections defined will be\n     * left out and all the points shifted closer to each other.\n     *\n     * @productdesc {highcharts}\n     * Requires that the broken-axis.js module is loaded.\n     *\n     * @sample {highcharts} highcharts/axisbreak/break-simple/\n     *         Simple break\n     * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/\n     *         Advanced with callback\n     * @sample {highstock} stock/demo/intraday-breaks/\n     *         Break on nights and weekends\n     *\n     * @type      {Array<*>}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks\n     */\n\n    /**\n     * A number indicating how much space should be left between the start\n     * and the end of the break. The break size is given in axis units,\n     * so for instance on a `datetime` axis, a break size of 3600000 would\n     * indicate the equivalent of an hour.\n     *\n     * @type      {number}\n     * @default   0\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks.breakSize\n     */\n\n    /**\n     * The point where the break starts.\n     *\n     * @type      {number}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks.from\n     */\n\n    /**\n     * Defines an interval after which the break appears again. By default\n     * the breaks do not repeat.\n     *\n     * @type      {number}\n     * @default   0\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks.repeat\n     */\n\n    /**\n     * The point where the break ends.\n     *\n     * @type      {number}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks.to\n     */\n\n    /**\n     * If categories are present for the xAxis, names are used instead of\n     * numbers for that axis. Since Highcharts 3.0, categories can also\n     * be extracted by giving each point a [name](#series.data) and setting\n     * axis [type](#xAxis.type) to `category`. However, if you have multiple\n     * series, best practice remains defining the `categories` array.\n     *\n     * Example:\n     *\n     * <pre>categories: ['Apples', 'Bananas', 'Oranges']</pre>\n     *\n     * @sample {highcharts} highcharts/demo/line-labels/\n     *         With\n     * @sample {highcharts} highcharts/xaxis/categories/\n     *         Without\n     *\n     * @type      {Array<string>}\n     * @product   highcharts\n     * @apioption xAxis.categories\n     */\n\n    /**\n     * The highest allowed value for automatically computed axis extremes.\n     *\n     * @see [floor](#xAxis.floor)\n     *\n     * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/\n     *         Floor and ceiling\n     *\n     * @type       {number}\n     * @since      4.0\n     * @product    highcharts highstock\n     * @apioption  xAxis.ceiling\n     */\n\n    /**\n     * A class name that opens for styling the axis by CSS, especially in\n     * Highcharts styled mode. The class name is applied to group elements\n     * for the grid, axis elements and labels.\n     *\n     * @sample {highcharts|highstock|highmaps} highcharts/css/axis/\n     *         Multiple axes with separate styling\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption xAxis.className\n     */\n\n    /**\n     * Configure a crosshair that follows either the mouse pointer or the\n     * hovered point.\n     *\n     * In styled mode, the crosshairs are styled in the\n     * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or\n     * `.highcharts-xaxis-category` classes.\n     *\n     * @productdesc {highstock}\n     * In Highstock, by default, the crosshair is enabled on the X axis and\n     * disabled on the Y axis.\n     *\n     * @sample {highcharts} highcharts/xaxis/crosshair-both/\n     *         Crosshair on both axes\n     * @sample {highstock} stock/xaxis/crosshairs-xy/\n     *         Crosshair on both axes\n     * @sample {highmaps} highcharts/xaxis/crosshair-both/\n     *         Crosshair on both axes\n     *\n     * @type      {boolean|*}\n     * @default   false\n     * @since     4.1\n     * @apioption xAxis.crosshair\n     */\n\n    /**\n     * A class name for the crosshair, especially as a hook for styling.\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption xAxis.crosshair.className\n     */\n\n    /**\n     * The color of the crosshair. Defaults to `#cccccc` for numeric and\n     * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where\n     * the crosshair by default highlights the whole category.\n     *\n     * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/\n     *         Customized crosshairs\n     *\n     * @type      {Highcharts.ColorString}\n     * @default   #cccccc\n     * @since     4.1\n     * @apioption xAxis.crosshair.color\n     */\n\n    /**\n     * The dash style for the crosshair. See\n     * [series.dashStyle](#plotOptions.series.dashStyle)\n     * for possible values.\n     *\n     * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/\n     *         Dotted crosshair\n     * @sample {highstock} stock/xaxis/crosshair-dashed/\n     *         Dashed X axis crosshair\n     *\n     * @type       {string}\n     * @default    Solid\n     * @since      4.1\n     * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n     *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\", \"DashDot\",\n     *             \"LongDashDot\", \"LongDashDotDot\"]\n     * @apioption  xAxis.crosshair.dashStyle\n     */\n\n    /**\n     * A label on the axis next to the crosshair.\n     *\n     * In styled mode, the label is styled with the\n     * `.highcharts-crosshair-label` class.\n     *\n     * @sample {highstock} stock/xaxis/crosshair-label/\n     *         Crosshair labels\n     * @sample {highstock} highcharts/css/crosshair-label/\n     *         Style mode\n     *\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label\n     */\n\n    /**\n     * Alignment of the label compared to the axis. Defaults to `left` for\n     * right-side axes, `right` for left-side axes and `center` for\n     * horizontal axes.\n     *\n     * @type      {string}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.align\n     */\n\n    /**\n     * The background color for the label. Defaults to the related series\n     * color, or `#666666` if that is not available.\n     *\n     * @type      {Highcharts.ColorString}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.backgroundColor\n     */\n\n    /**\n     * The border color for the crosshair label\n     *\n     * @type      {Highcharts.ColorString}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.borderColor\n     */\n\n    /**\n     * The border corner radius of the crosshair label.\n     *\n     * @type      {number}\n     * @default   3\n     * @since     2.1.10\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.borderRadius\n     */\n\n    /**\n     * The border width for the crosshair label.\n     *\n     * @type      {number}\n     * @default   0\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.borderWidth\n     */\n\n    /**\n     * A format string for the crosshair label. Defaults to `{value}` for\n     * numeric axes and `{value:%b %d, %Y}` for datetime axes.\n     *\n     * @type      {string}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.format\n     */\n\n    /**\n     * Formatter function for the label text.\n     *\n     * @type      {Highcharts.FormatterCallbackFunction}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.formatter\n     */\n\n    /**\n     * Padding inside the crosshair label.\n     *\n     * @type      {number}\n     * @default   8\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.padding\n     */\n\n    /**\n     * The shape to use for the label box.\n     *\n     * @type      {string}\n     * @default   callout\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.shape\n     */\n\n    /**\n     * Text styles for the crosshair label.\n     *\n     * @type      {Highcharts.CSSObject}\n     * @default   {\"color\": \"white\", \"fontWeight\": \"normal\", \"fontSize\": \"11px\", \"textAlign\": \"center\"}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.style\n     */\n\n    /**\n     * Whether the crosshair should snap to the point or follow the pointer\n     * independent of points.\n     *\n     * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/\n     *         True by default\n     * @sample {highmaps} maps/demo/latlon-advanced/\n     *         Snap is false\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.1\n     * @apioption xAxis.crosshair.snap\n     */\n\n    /**\n     * The pixel width of the crosshair. Defaults to 1 for numeric or\n     * datetime axes, and for one category width for category axes.\n     *\n     * @sample {highcharts} highcharts/xaxis/crosshair-customized/\n     *         Customized crosshairs\n     * @sample {highstock} highcharts/xaxis/crosshair-customized/\n     *         Customized crosshairs\n     * @sample {highmaps} highcharts/xaxis/crosshair-customized/\n     *         Customized crosshairs\n     *\n     * @type      {number}\n     * @default   1\n     * @since     4.1\n     * @apioption xAxis.crosshair.width\n     */\n\n    /**\n     * The Z index of the crosshair. Higher Z indices allow drawing the\n     * crosshair on top of the series or behind the grid lines.\n     *\n     * @type      {number}\n     * @default   2\n     * @since     4.1\n     * @apioption xAxis.crosshair.zIndex\n     */\n\n    /**\n     * For a datetime axis, the scale will automatically adjust to the\n     * appropriate unit. This member gives the default string\n     * representations used for each unit. For intermediate values,\n     * different units may be used, for example the `day` unit can be used\n     * on midnight and `hour` unit be used for intermediate values on the\n     * same axis. For an overview of the replacement codes, see\n     * [dateFormat](/class-reference/Highcharts#dateFormat). Defaults to:\n     *\n     * <pre>{\n     *     millisecond: '%H:%M:%S.%L',\n     *     second: '%H:%M:%S',\n     *     minute: '%H:%M',\n     *     hour: '%H:%M',\n     *     day: '%e. %b',\n     *     week: '%e. %b',\n     *     month: '%b \\'%y',\n     *     year: '%Y'\n     * }</pre>\n     *\n     * @sample {highcharts} highcharts/xaxis/datetimelabelformats/\n     *         Different day format on X axis\n     * @sample {highstock} stock/xaxis/datetimelabelformats/\n     *         More information in x axis labels\n     *\n     * @product highcharts highstock\n     */\n    dateTimeLabelFormats: {\n      millisecond: '%H:%M:%S.%L',\n      second: '%H:%M:%S',\n      minute: '%H:%M',\n      hour: '%H:%M',\n      day: '%e. %b',\n      week: '%e. %b',\n      month: '%b \\'%y',\n      year: '%Y'\n    },\n\n    /**\n     * _Requires Accessibility module_\n     *\n     * Description of the axis to screen reader users.\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption xAxis.description\n     */\n\n    /**\n     * Whether to force the axis to end on a tick. Use this option with\n     * the `maxPadding` option to control the axis end.\n     *\n     * @productdesc {highstock}\n     * In Highstock, `endOnTick` is always false when the navigator is\n     * enabled, to prevent jumpy scrolling.\n     *\n     * @sample {highcharts} highcharts/chart/reflow-true/\n     *         True by default\n     * @sample {highcharts} highcharts/yaxis/endontick/\n     *         False\n     * @sample {highstock} stock/demo/basic-line/\n     *         True by default\n     * @sample {highstock} stock/xaxis/endontick/\n     *         False\n     *\n     * @since 1.2.0\n     */\n    endOnTick: false,\n\n    /**\n     * Event handlers for the axis.\n     *\n     * @type      {*}\n     * @apioption xAxis.events\n     */\n\n    /**\n     * An event fired after the breaks have rendered.\n     *\n     * @see [breaks](#xAxis.breaks)\n     *\n     * @sample {highcharts} highcharts/axisbreak/break-event/\n     *         AfterBreak Event\n     *\n     * @type      {Function}\n     * @since     4.1.0\n     * @product   highcharts\n     * @apioption xAxis.events.afterBreaks\n     */\n\n    /**\n     * As opposed to the `setExtremes` event, this event fires after the\n     * final min and max values are computed and corrected for `minRange`.\n     *\n     *\n     * Fires when the minimum and maximum is set for the axis, either by\n     * calling the `.setExtremes()` method or by selecting an area in the\n     * chart. One parameter, `event`, is passed to the function, containing\n     * common event information.\n     *\n     * The new user set minimum and maximum values can be found by\n     * `event.min` and `event.max`. These reflect the axis minimum and\n     * maximum in axis values. The actual data extremes are found in\n     * `event.dataMin` and `event.dataMax`.\n     *\n     * @type      {Function}\n     * @since     2.3\n     * @context   Axis\n     * @apioption xAxis.events.afterSetExtremes\n     */\n\n    /**\n     * An event fired when a break from this axis occurs on a point.\n     *\n     * @see [breaks](#xAxis.breaks)\n     *\n     * @sample {highcharts} highcharts/axisbreak/break-visualized/\n     *         Visualization of a Break\n     *\n     * @type      {Function}\n     * @since     4.1.0\n     * @product   highcharts\n     * @context   Axis\n     * @apioption xAxis.events.pointBreak\n     */\n\n    /**\n     * An event fired when a point falls inside a break from this axis.\n     *\n     * @type      {Function}\n     * @product   highcharts highstock\n     * @context   Axis\n     * @apioption xAxis.events.pointInBreak\n     */\n\n    /**\n     * Fires when the minimum and maximum is set for the axis, either by\n     * calling the `.setExtremes()` method or by selecting an area in the\n     * chart. One parameter, `event`, is passed to the function,\n     * containing common event information.\n     *\n     * The new user set minimum and maximum values can be found by\n     * `event.min` and `event.max`. These reflect the axis minimum and\n     * maximum in data values. When an axis is zoomed all the way out from\n     * the \"Reset zoom\" button, `event.min` and `event.max` are null, and\n     * the new extremes are set based on `this.dataMin` and `this.dataMax`.\n     *\n     * @sample {highstock} stock/xaxis/events-setextremes/\n     *         Log new extremes on x axis\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Axis\n     * @apioption xAxis.events.setExtremes\n     */\n\n    /**\n     * The lowest allowed value for automatically computed axis extremes.\n     *\n     * @see [ceiling](#yAxis.ceiling)\n     *\n     * @sample {highcharts} highcharts/yaxis/floor-ceiling/\n     *         Floor and ceiling\n     * @sample {highstock} stock/demo/lazy-loading/\n     *         Prevent negative stock price on Y axis\n     *\n     * @type      {number}\n     * @since     4.0\n     * @product   highcharts highstock\n     * @apioption xAxis.floor\n     */\n\n    /**\n     * The dash or dot style of the grid lines. For possible values, see\n     * [this demonstration](https://jsfiddle.net/gh/get/library/pure/\n     * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/\n     * series-dashstyle-all/).\n     *\n     * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/\n     *         Long dashes\n     * @sample {highstock} stock/xaxis/gridlinedashstyle/\n     *         Long dashes\n     *\n     * @type       {string}\n     * @default    Solid\n     * @since      1.2\n     * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n     *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\", \"DashDot\",\n     *             \"LongDashDot\", \"LongDashDotDot\"]\n     * @apioption  xAxis.gridLineDashStyle\n     */\n\n    /**\n     * The Z index of the grid lines.\n     *\n     * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/\n     *         A Z index of 4 renders the grid above the graph\n     *\n     * @type      {number}\n     * @default   1\n     * @product   highcharts highstock\n     * @apioption xAxis.gridZIndex\n     */\n\n    /**\n     * An id for the axis. This can be used after render time to get\n     * a pointer to the axis object through `chart.get()`.\n     *\n     * @sample {highcharts} highcharts/xaxis/id/\n     *         Get the object\n     * @sample {highstock} stock/xaxis/id/\n     *         Get the object\n     *\n     * @type      {string}\n     * @since     1.2.0\n     * @apioption xAxis.id\n     */\n\n    /**\n     * The axis labels show the number or category for each tick.\n     *\n     * @productdesc {highmaps}\n     * X and Y axis labels are by default disabled in Highmaps, but the\n     * functionality is inherited from Highcharts and used on `colorAxis`,\n     * and can be enabled on X and Y axes too.\n     */\n    labels: {\n      /**\n       * What part of the string the given position is anchored to.\n       * If `left`, the left side of the string is at the axis position.\n       * Can be one of `\"left\"`, `\"center\"` or `\"right\"`. Defaults to\n       * an intelligent guess based on which side of the chart the axis\n       * is on and the rotation of the label.\n       *\n       * @see [reserveSpace](#xAxis.labels.reserveSpace)\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-align-left/\n       *         Left\n       * @sample {highcharts} highcharts/xaxis/labels-align-right/\n       *         Right\n       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/\n       *         Left-aligned labels on a vertical category axis\n       *\n       * @type       {string}\n       * @validvalue [\"left\", \"center\", \"right\"]\n       * @apioption  xAxis.labels.align\n       */\n\n      /**\n       * For horizontal axes, the allowed degrees of label rotation\n       * to prevent overlapping labels. If there is enough space,\n       * labels are not rotated. As the chart gets narrower, it\n       * will start rotating the labels -45 degrees, then remove\n       * every second label and try again with rotations 0 and -45 etc.\n       * Set it to `false` to disable rotation, which will\n       * cause the labels to word-wrap if possible.\n       *\n       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/\n       *         Default auto rotation of 0 or -45\n       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/\n       *         Custom graded auto rotation\n       *\n       * @type      {Array<number>}\n       * @default   [-45]\n       * @since     4.1.0\n       * @product   highcharts highstock\n       * @apioption xAxis.labels.autoRotation\n       */\n\n      /**\n       * When each category width is more than this many pixels, we don't\n       * apply auto rotation. Instead, we lay out the axis label with word\n       * wrap. A lower limit makes sense when the label contains multiple\n       * short words that don't extend the available horizontal space for\n       * each label.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/\n       *         Lower limit\n       *\n       * @type      {number}\n       * @default   80\n       * @since     4.1.5\n       * @product   highcharts\n       * @apioption xAxis.labels.autoRotationLimit\n       */\n\n      /**\n       * Polar charts only. The label's pixel distance from the perimeter\n       * of the plot area.\n       *\n       * @type      {number}\n       * @default   15\n       * @product   highcharts\n       * @apioption xAxis.labels.distance\n       */\n\n      /**\n       * Enable or disable the axis labels.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-enabled/\n       *         X axis labels disabled\n       * @sample {highstock} stock/xaxis/labels-enabled/\n       *         X axis labels disabled\n       *\n       * @default {highcharts|highstock} true\n       * @default {highmaps} false\n       */\n      enabled: true,\n\n      /**\n       * A [format string](https://www.highcharts.com/docs/chart-\n       * concepts/labels-and-string-formatting) for the axis label.\n       *\n       * @sample {highcharts|highstock} highcharts/yaxis/labels-format/\n       *         Add units to Y axis label\n       *\n       * @type      {string}\n       * @default   {value}\n       * @since     3.0\n       * @apioption xAxis.labels.format\n       */\n\n      /**\n       * Callback JavaScript function to format the label. The value\n       * is given by `this.value`. Additional properties for `this` are\n       * `axis`, `chart`, `isFirst` and `isLast`. The value of the default\n       * label formatter can be retrieved by calling\n       * `this.axis.defaultLabelFormatter.call(this)` within the function.\n       *\n       * Defaults to:\n       *\n       * <pre>function() {\n       *     return this.value;\n       * }</pre>\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/\n       *         Linked category names\n       * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/\n       *         Modified numeric labels\n       * @sample {highstock} stock/xaxis/labels-formatter/\n       *         Added units on Y axis\n       *\n       * @type      {Function}\n       * @apioption xAxis.labels.formatter\n       */\n\n      /**\n       * Horizontal axis only. When `staggerLines` is not set,\n       * `maxStaggerLines` defines how many lines the axis is allowed to\n       * add to automatically avoid overlapping X labels. Set to `1` to\n       * disable overlap detection.\n       *\n       * @deprecated\n       * @type      {number}\n       * @default   5\n       * @since     1.3.3\n       * @product   highstock highmaps\n       * @apioption xAxis.labels.maxStaggerLines\n       */\n\n      /**\n       * How to handle overflowing labels on horizontal axis. If set to\n       * `\"allow\"`, it will not be aligned at all. By default it\n       * `\"justify\"` labels inside the chart area. If there is room to\n       * move it, it will be aligned to the edge, else it will be removed.\n       *\n       * @type       {boolean|string}\n       * @default    justify\n       * @since      2.2.5\n       * @validvalue [\"allow\", \"justify\"]\n       * @apioption  xAxis.labels.overflow\n       */\n\n      /**\n       * The pixel padding for axis labels, to ensure white space between\n       * them.\n       *\n       * @type      {number}\n       * @default   5\n       * @product   highcharts\n       * @apioption xAxis.labels.padding\n       */\n\n      /**\n       * Whether to reserve space for the labels. By default, space is\n       * reserved for the labels in these cases:\n       *\n       * * On all horizontal axes.\n       * * On vertical axes if `label.align` is `right` on a left-side\n       * axis or `left` on a right-side axis.\n       * * On vertical axes if `label.align` is `center`.\n       *\n       * This can be turned off when for example the labels are rendered\n       * inside the plot area instead of outside.\n       *\n       * @see [labels.align](#xAxis.labels.align)\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-reservespace/\n       *         No reserved space, labels inside plot\n       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/\n       *         Left-aligned labels on a vertical category axis\n       *\n       * @type      {boolean}\n       * @since     4.1.10\n       * @product   highcharts\n       * @apioption xAxis.labels.reserveSpace\n       */\n\n      /**\n       * Rotation of the labels in degrees.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-rotation/\n       *         X axis labels rotated 90\n       *\n       * @type      {number}\n       * @default   0\n       * @apioption xAxis.labels.rotation\n       */\n\n      /**\n       * Horizontal axes only. The number of lines to spread the labels\n       * over to make room or tighter labels.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-staggerlines/\n       *         Show labels over two lines\n       * @sample {highstock} stock/xaxis/labels-staggerlines/\n       *         Show labels over two lines\n       *\n       * @type      {number}\n       * @since     2.1\n       * @apioption xAxis.labels.staggerLines\n       */\n\n      /**\n       * To show only every _n_'th label on the axis, set the step to _n_.\n       * Setting the step to 2 shows every other label.\n       *\n       * By default, the step is calculated automatically to avoid\n       * overlap. To prevent this, set it to 1\\. This usually only\n       * happens on a category axis, and is often a sign that you have\n       * chosen the wrong axis type.\n       *\n       * Read more at\n       * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)\n       * => What axis should I use?\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-step/\n       *         Showing only every other axis label on a categorized\n       *         x-axis\n       * @sample {highcharts} highcharts/xaxis/labels-step-auto/\n       *         Auto steps on a category axis\n       *\n       * @type      {number}\n       * @since     2.1\n       * @apioption xAxis.labels.step\n       */\n\n      /**\n       * Whether to [use HTML](https://www.highcharts.com/docs/chart-\n       * concepts/labels-and-string-formatting#html) to render the labels.\n       *\n       * @type      {boolean}\n       * @default   false\n       * @apioption xAxis.labels.useHTML\n       */\n\n      /**\n       * The x position offset of the label relative to the tick position\n       * on the axis.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-x/\n       *         Y axis labels placed on grid lines\n       */\n      x: 0\n      /**\n       * The y position offset of the label relative to the tick position\n       * on the axis. The default makes it adapt to the font size on\n       * bottom axis.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-x/\n       *         Y axis labels placed on grid lines\n       *\n       * @type      {number}\n       * @apioption xAxis.labels.y\n       */\n\n      /**\n       * The Z index for the axis labels.\n       *\n       * @type      {number}\n       * @default   7\n       * @apioption xAxis.labels.zIndex\n       */\n\n    },\n\n    /**\n     * Index of another axis that this axis is linked to. When an axis is\n     * linked to a master axis, it will take the same extremes as\n     * the master, but as assigned by min or max or by setExtremes.\n     * It can be used to show additional info, or to ease reading the\n     * chart by duplicating the scales.\n     *\n     * @sample {highcharts} highcharts/xaxis/linkedto/\n     *         Different string formats of the same date\n     * @sample {highcharts} highcharts/yaxis/linkedto/\n     *         Y values on both sides\n     *\n     * @type      {number}\n     * @since     2.0.2\n     * @product   highcharts highstock\n     * @apioption xAxis.linkedTo\n     */\n\n    /**\n     * The maximum value of the axis. If `null`, the max value is\n     * automatically calculated.\n     *\n     * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value\n     * might be rounded up.\n     *\n     * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended\n     * beyond the set max in order to reach the given number of ticks. The\n     * same may happen in a chart with multiple axes, determined by [chart.\n     * alignTicks](#chart), where a `tickAmount` is applied internally.\n     *\n     * @sample {highcharts} highcharts/yaxis/max-200/\n     *         Y axis max of 200\n     * @sample {highcharts} highcharts/yaxis/max-logarithmic/\n     *         Y axis max on logarithmic axis\n     * @sample {highstock} stock/xaxis/min-max/\n     *         Fixed min and max on X axis\n     * @sample {highmaps} maps/axis/min-max/\n     *         Pre-zoomed to a specific area\n     *\n     * @type      {number}\n     * @apioption xAxis.max\n     */\n\n    /**\n     * Padding of the max value relative to the length of the axis. A\n     * padding of 0.05 will make a 100px axis 5px longer. This is useful\n     * when you don't want the highest data value to appear on the edge\n     * of the plot area. When the axis' `max` option is set or a max extreme\n     * is set using `axis.setExtremes()`, the maxPadding will be ignored.\n     *\n     * @sample {highcharts} highcharts/yaxis/maxpadding/\n     *         Max padding of 0.25 on y axis\n     * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n     *         Greater min- and maxPadding\n     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/\n     *         Add some padding\n     *\n     * @default   {highcharts} 0.01\n     * @default   {highstock|highmaps} 0\n     * @since     1.2.0\n     */\n    maxPadding: 0.01,\n\n    /**\n     * Deprecated. Use `minRange` instead.\n     *\n     * @deprecated\n     * @type      {number}\n     * @product   highcharts highstock\n     * @apioption xAxis.maxZoom\n     */\n\n    /**\n     * The minimum value of the axis. If `null` the min value is\n     * automatically calculated.\n     *\n     * If the [startOnTick](#yAxis.startOnTick) option is true (default),\n     * the `min` value might be rounded down.\n     *\n     * The automatically calculated minimum value is also affected by\n     * [floor](#yAxis.floor), [softMin](#yAxis.softMin),\n     * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)\n     * as well as [series.threshold](#plotOptions.series.threshold)\n     * and [series.softThreshold](#plotOptions.series.softThreshold).\n     *\n     * @sample {highcharts} highcharts/yaxis/min-startontick-false/\n     *         -50 with startOnTick to false\n     * @sample {highcharts} highcharts/yaxis/min-startontick-true/\n     *         -50 with startOnTick true by default\n     * @sample {highstock} stock/xaxis/min-max/\n     *         Set min and max on X axis\n     * @sample {highmaps} maps/axis/min-max/\n     *         Pre-zoomed to a specific area\n     *\n     * @type      {number}\n     * @apioption xAxis.min\n     */\n\n    /**\n     * The dash or dot style of the minor grid lines. For possible values,\n     * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/\n     * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/\n     * series-dashstyle-all/).\n     *\n     * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/\n     *         Long dashes on minor grid lines\n     * @sample {highstock} stock/xaxis/minorgridlinedashstyle/\n     *         Long dashes on minor grid lines\n     *\n     * @type       {string}\n     * @default    Solid\n     * @since      1.2\n     * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n     *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\",\n     *             \"DashDot\", \"LongDashDot\", \"LongDashDotDot\"]\n     * @apioption  xAxis.minorGridLineDashStyle\n     */\n\n    /**\n     * Specific tick interval in axis units for the minor ticks. On a linear\n     * axis, if `\"auto\"`, the minor tick interval is calculated as a fifth\n     * of the tickInterval. If `null` or `undefined`, minor ticks are not\n     * shown.\n     *\n     * On logarithmic axes, the unit is the power of the value. For example,\n     * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,\n     * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks\n     * between 1 and 10, 10 and 100 etc.\n     *\n     * If user settings dictate minor ticks to become too dense, they don't\n     * make sense, and will be ignored to prevent performance problems.\n     *\n     * @sample {highcharts} highcharts/yaxis/minortickinterval-null/\n     *         Null by default\n     * @sample {highcharts} highcharts/yaxis/minortickinterval-5/\n     *         5 units\n     * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/\n     *         \"auto\"\n     * @sample {highcharts} highcharts/yaxis/minortickinterval-log/\n     *         0.1\n     * @sample {highstock} stock/demo/basic-line/\n     *         Null by default\n     * @sample {highstock} stock/xaxis/minortickinterval-auto/\n     *         \"auto\"\n     *\n     * @type      {number|string|null}\n     * @apioption xAxis.minorTickInterval\n     */\n\n    /**\n     * The pixel length of the minor tick marks.\n     *\n     * @sample {highcharts} highcharts/yaxis/minorticklength/\n     *         10px on Y axis\n     * @sample {highstock} stock/xaxis/minorticks/\n     *         10px on Y axis\n     */\n    minorTickLength: 2,\n\n    /**\n     * The position of the minor tick marks relative to the axis line.\n     *  Can be one of `inside` and `outside`.\n     *\n     * @sample {highcharts} highcharts/yaxis/minortickposition-outside/\n     *         Outside by default\n     * @sample {highcharts} highcharts/yaxis/minortickposition-inside/\n     *         Inside\n     * @sample {highstock} stock/xaxis/minorticks/\n     *         Inside\n     *\n     * @validvalue [\"inside\", \"outside\"]\n     */\n    minorTickPosition: 'outside',\n\n    /**\n     * Enable or disable minor ticks. Unless\n     * [minorTickInterval](#xAxis.minorTickInterval) is set, the tick\n     * interval is calculated as a fifth of the `tickInterval`.\n     *\n     * On a logarithmic axis, minor ticks are laid out based on a best\n     * guess, attempting to enter approximately 5 minor ticks between\n     * each major tick.\n     *\n     * Prior to v6.0.0, ticks were unabled in auto layout by setting\n     * `minorTickInterval` to `\"auto\"`.\n     *\n     * @productdesc {highcharts}\n     * On axes using [categories](#xAxis.categories), minor ticks are not\n     * supported.\n     *\n     * @sample {highcharts} highcharts/yaxis/minorticks-true/\n     *         Enabled on linear Y axis\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     6.0.0\n     * @apioption xAxis.minorTicks\n     */\n\n    /**\n     * The pixel width of the minor tick mark.\n     *\n     * @sample {highcharts} highcharts/yaxis/minortickwidth/\n     *         3px width\n     * @sample {highstock} stock/xaxis/minorticks/\n     *         1px width\n     *\n     * @type      {number}\n     * @default   0\n     * @apioption xAxis.minorTickWidth\n     */\n\n    /**\n     * Padding of the min value relative to the length of the axis. A\n     * padding of 0.05 will make a 100px axis 5px longer. This is useful\n     * when you don't want the lowest data value to appear on the edge\n     * of the plot area. When the axis' `min` option is set or a min extreme\n     * is set using `axis.setExtremes()`, the minPadding will be ignored.\n     *\n     * @sample {highcharts} highcharts/yaxis/minpadding/\n     *         Min padding of 0.2\n     * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n     *         Greater min- and maxPadding\n     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/\n     *         Add some padding\n     *\n     * @default    {highcharts} 0.01\n     * @default    {highstock|highmaps} 0\n     * @since      1.2.0\n     * @product    highcharts highstock\n     */\n    minPadding: 0.01,\n\n    /**\n     * The minimum range to display on this axis. The entire axis will not\n     * be allowed to span over a smaller interval than this. For example,\n     * for a datetime axis the main unit is milliseconds. If minRange is\n     * set to 3600000, you can't zoom in more than to one hour.\n     *\n     * The default minRange for the x axis is five times the smallest\n     * interval between any of the data points.\n     *\n     * On a logarithmic axis, the unit for the minimum range is the power.\n     * So a minRange of 1 means that the axis can be zoomed to 10-100,\n     * 100-1000, 1000-10000 etc.\n     *\n     * Note that the `minPadding`, `maxPadding`, `startOnTick` and\n     * `endOnTick` settings also affect how the extremes of the axis\n     * are computed.\n     *\n     * @sample {highcharts} highcharts/xaxis/minrange/\n     *         Minimum range of 5\n     * @sample {highstock} stock/xaxis/minrange/\n     *         Max zoom of 6 months overrides user selections\n     * @sample {highmaps} maps/axis/minrange/\n     *         Minimum range of 1000\n     *\n     * @type      {number}\n     * @apioption xAxis.minRange\n     */\n\n    /**\n     * The minimum tick interval allowed in axis values. For example on\n     * zooming in on an axis with daily data, this can be used to prevent\n     * the axis from showing hours. Defaults to the closest distance between\n     * two points on the axis.\n     *\n     * @type      {number}\n     * @since     2.3.0\n     * @apioption xAxis.minTickInterval\n     */\n\n    /**\n     * The distance in pixels from the plot area to the axis line.\n     * A positive offset moves the axis with it's line, labels and ticks\n     * away from the plot area. This is typically used when two or more\n     * axes are displayed on the same side of the plot. With multiple\n     * axes the offset is dynamically adjusted to avoid collision, this\n     * can be overridden by setting offset explicitly.\n     *\n     * @sample    {highcharts} highcharts/yaxis/offset/\n     *            Y axis offset of 70\n     * @sample    {highcharts} highcharts/yaxis/offset-centered/\n     *            Axes positioned in the center of the plot\n     * @sample    {highstock} stock/xaxis/offset/\n     *            Y axis offset by 70 px\n     *\n     * @type      {number}\n     * @default   0\n     * @apioption xAxis.offset\n     */\n\n    /**\n     * Whether to display the axis on the opposite side of the normal. The\n     * normal is on the left side for vertical axes and bottom for\n     * horizontal, so the opposite sides will be right and top respectively.\n     * This is typically used with dual or multiple axes.\n     *\n     * @sample {highcharts} highcharts/yaxis/opposite/\n     *         Secondary Y axis opposite\n     * @sample {highstock} stock/xaxis/opposite/\n     *         Y axis on left side\n     *\n     * @type      {boolean}\n     * @default   false\n     * @apioption xAxis.opposite\n     */\n\n    /**\n     * In an ordinal axis, the points are equally spaced in the chart\n     * regardless of the actual time or x distance between them. This means\n     * that missing data periods (e.g. nights or weekends for a stock chart)\n     * will not take up space in the chart.\n     * Having `ordinal: false` will show any gaps created by the `gapSize`\n     * setting proportionate to their duration.\n     *\n     * In stock charts the X axis is ordinal by default, unless\n     * the boost module is used and at least one of the series' data length\n     * exceeds the [boostThreshold](#series.line.boostThreshold).\n     *\n     * @sample {highstock} stock/xaxis/ordinal-true/\n     *         True by default\n     * @sample {highstock} stock/xaxis/ordinal-false/\n     *         False\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     1.1\n     * @product   highstock\n     * @apioption xAxis.ordinal\n     */\n\n    /**\n     * Additional range on the right side of the xAxis. Works similar to\n     * `xAxis.maxPadding`, but value is set in milliseconds. Can be set for\n     * both main `xAxis` and the navigator's `xAxis`.\n     *\n     * @sample {highstock} stock/xaxis/overscroll/\n     *         One minute overscroll with live data\n     *\n     * @type      {number}\n     * @default   0\n     * @since     6.0.0\n     * @product   highstock\n     * @apioption xAxis.overscroll\n     */\n\n    /**\n     * Refers to the index in the [panes](#panes) array. Used for circular\n     * gauges and polar charts. When the option is not set then first pane\n     * will be used.\n     *\n     * @sample highcharts/demo/gauge-vu-meter\n     *         Two gauges with different center\n     *\n     * @type      {number}\n     * @product   highcharts\n     * @apioption xAxis.pane\n     */\n\n    /**\n     * The zoomed range to display when only defining one or none of `min`\n     * or `max`. For example, to show the latest month, a range of one month\n     * can be set.\n     *\n     * @sample {highstock} stock/xaxis/range/\n     *         Setting a zoomed range when the rangeSelector is disabled\n     *\n     * @type      {number}\n     * @product   highstock\n     * @apioption xAxis.range\n     */\n\n    /**\n     * Whether to reverse the axis so that the highest number is closest\n     * to the origin. If the chart is inverted, the x axis is reversed by\n     * default.\n     *\n     * @sample {highcharts} highcharts/yaxis/reversed/\n     *         Reversed Y axis\n     * @sample {highstock} stock/xaxis/reversed/\n     *         Reversed Y axis\n     *\n     * @type      {boolean}\n     * @default   false\n     * @apioption xAxis.reversed\n     */\n    // reversed: false,\n\n    /**\n     * This option determines how stacks should be ordered within a group.\n     * For example reversed xAxis also reverses stacks, so first series\n     * comes last in a group. To keep order like for non-reversed xAxis\n     * enable this option.\n     *\n     * @sample {highcharts} highcharts/xaxis/reversedstacks/\n     *         Reversed stacks comparison\n     * @sample {highstock} highcharts/xaxis/reversedstacks/\n     *         Reversed stacks comparison\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     6.1.1\n     * @product   highcharts highstock\n     * @apioption xAxis.reversedStacks\n     */\n\n    /**\n     * An optional scrollbar to display on the X axis in response to\n     * limiting the minimum and maximum of the axis values.\n     *\n     * In styled mode, all the presentational options for the scrollbar\n     * are replaced by the classes `.highcharts-scrollbar-thumb`,\n     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,\n     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.\n     *\n     * @sample {highstock} stock/yaxis/heatmap-scrollbars/\n     *         Heatmap with both scrollbars\n     *\n     * @type      {*}\n     * @extends   scrollbar\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption xAxis.scrollbar\n     */\n\n    /**\n     * Whether to show the axis line and title when the axis has no data.\n     *\n     * @sample {highcharts} highcharts/yaxis/showempty/\n     *         When clicking the legend to hide series, one axis preserves\n     *         line and title, the other doesn't\n     * @sample {highstock} highcharts/yaxis/showempty/\n     *         When clicking the legend to hide series, one axis preserves\n     *         line and title, the other doesn't\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     1.1\n     * @apioption xAxis.showEmpty\n     */\n\n    /**\n     * Whether to show the first tick label.\n     *\n     * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/\n     *         Set to false on X axis\n     * @sample {highstock} stock/xaxis/showfirstlabel/\n     *         Labels below plot lines on Y axis\n     *\n     * @type      {boolean}\n     * @default   true\n     * @apioption xAxis.showFirstLabel\n     */\n\n    /**\n     * Whether to show the last tick label. Defaults to `true` on cartesian\n     * charts, and `false` on polar charts.\n     *\n     * @sample {highcharts} highcharts/xaxis/showlastlabel-true/\n     *         Set to true on X axis\n     * @sample {highstock} stock/xaxis/showfirstlabel/\n     *         Labels below plot lines on Y axis\n     *\n     * @type      {boolean}\n     * @default   true\n     * @product   highcharts highstock\n     * @apioption xAxis.showLastLabel\n     */\n\n    /**\n     * A soft maximum for the axis. If the series data maximum is less than\n     * this, the axis will stay at this maximum, but if the series data\n     * maximum is higher, the axis will flex to show all data.\n     *\n     * @sample highcharts/yaxis/softmin-softmax/\n     *         Soft min and max\n     *\n     * @type      {number}\n     * @since     5.0.1\n     * @product   highcharts highstock\n     * @apioption xAxis.softMax\n     */\n\n    /**\n     * A soft minimum for the axis. If the series data minimum is greater\n     * than this, the axis will stay at this minimum, but if the series\n     * data minimum is lower, the axis will flex to show all data.\n     *\n     * @sample highcharts/yaxis/softmin-softmax/\n     *         Soft min and max\n     *\n     * @type      {number}\n     * @since     5.0.1\n     * @product   highcharts highstock\n     * @apioption xAxis.softMin\n     */\n\n    /**\n     * For datetime axes, this decides where to put the tick between weeks.\n     *  0 = Sunday, 1 = Monday.\n     *\n     * @sample {highcharts} highcharts/xaxis/startofweek-monday/\n     *         Monday by default\n     * @sample {highcharts} highcharts/xaxis/startofweek-sunday/\n     *         Sunday\n     * @sample {highstock} stock/xaxis/startofweek-1\n     *         Monday by default\n     * @sample {highstock} stock/xaxis/startofweek-0\n     *         Sunday\n     *\n     * @product highcharts highstock\n     */\n    startOfWeek: 1,\n\n    /**\n     * Whether to force the axis to start on a tick. Use this option with\n     * the `minPadding` option to control the axis start.\n     *\n     * @productdesc {highstock}\n     * In Highstock, `startOnTick` is always false when the navigator is\n     * enabled, to prevent jumpy scrolling.\n     *\n     * @sample {highcharts} highcharts/xaxis/startontick-false/\n     *         False by default\n     * @sample {highcharts} highcharts/xaxis/startontick-true/\n     *         True\n     * @sample {highstock} stock/xaxis/endontick/\n     *         False for Y axis\n     *\n     * @since 1.2.0\n     */\n    startOnTick: false,\n\n    /**\n     * The amount of ticks to draw on the axis. This opens up for aligning\n     * the ticks of multiple charts or panes within a chart. This option\n     * overrides the `tickPixelInterval` option.\n     *\n     * This option only has an effect on linear axes. Datetime, logarithmic\n     * or category axes are not affected.\n     *\n     * @sample {highcharts} highcharts/yaxis/tickamount/\n     *         8 ticks on Y axis\n     * @sample {highstock} highcharts/yaxis/tickamount/\n     *         8 ticks on Y axis\n     *\n     * @type      {number}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.tickAmount\n     */\n\n    /**\n     * The interval of the tick marks in axis units. When `undefined`, the\n     * tick interval is computed to approximately follow the\n     * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime\n     * axes. On categorized axes, a `undefined` tickInterval will default to\n     * 1, one category. Note that datetime axes are based on milliseconds,\n     * so for example an interval of one day is expressed as\n     * `24 * 3600 * 1000`.\n     *\n     * On logarithmic axes, the tickInterval is based on powers, so a\n     * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A\n     * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval\n     * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,\n     * 40 etc.\n     *\n     *\n     * If the tickInterval is too dense for labels to be drawn, Highcharts\n     * may remove ticks.\n     *\n     * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)\n     * option may interfere with the `tickInterval` setting.\n     *\n     * @see [tickPixelInterval](#xAxis.tickPixelInterval)\n     * @see [tickPositions](#xAxis.tickPositions)\n     * @see [tickPositioner](#xAxis.tickPositioner)\n     *\n     * @sample {highcharts} highcharts/xaxis/tickinterval-5/\n     *         Tick interval of 5 on a linear axis\n     * @sample {highstock} stock/xaxis/tickinterval/\n     *         Tick interval of 0.01 on Y axis\n     *\n     * @type      {number}\n     * @apioption xAxis.tickInterval\n     */\n\n    /**\n     * The pixel length of the main tick marks.\n     *\n     * @sample {highcharts} highcharts/xaxis/ticklength/\n     *         20 px tick length on the X axis\n     * @sample {highstock} stock/xaxis/ticks/\n     *         Formatted ticks on X axis\n     */\n    tickLength: 10,\n\n    /**\n     * If tickInterval is `null` this option sets the approximate pixel\n     * interval of the tick marks. Not applicable to categorized axis.\n     *\n     * The tick interval is also influenced by the [minTickInterval](\n     * #xAxis.minTickInterval) option, that, by default prevents ticks from\n     * being denser than the data points.\n     *\n     * @see [tickInterval](#xAxis.tickInterval)\n     * @see [tickPositioner](#xAxis.tickPositioner)\n     * @see [tickPositions](#xAxis.tickPositions)\n     *\n     * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/\n     *         50 px on X axis\n     * @sample {highstock} stock/xaxis/tickpixelinterval/\n     *         200 px on X axis\n     */\n    tickPixelInterval: 100,\n\n    /**\n     * For categorized axes only. If `on` the tick mark is placed in the\n     * center of the category, if `between` the tick mark is placed between\n     * categories. The default is `between` if the `tickInterval` is 1,\n     *  else `on`.\n     *\n     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/\n     *         \"between\" by default\n     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/\n     *         \"on\"\n     *\n     * @product    highcharts\n     * @validvalue [null, \"on\", \"between\"]\n     */\n    tickmarkPlacement: 'between',\n\n    /**\n     * The position of the major tick marks relative to the axis line.\n     * Can be one of `inside` and `outside`.\n     *\n     * @sample {highcharts} highcharts/xaxis/tickposition-outside/\n     *         \"outside\" by default\n     * @sample {highcharts} highcharts/xaxis/tickposition-inside/\n     *         \"inside\"\n     * @sample {highstock} stock/xaxis/ticks/\n     *         Formatted ticks on X axis\n     *\n     * @validvalue [\"inside\", \"outside\"]\n     */\n    tickPosition: 'outside',\n\n    /**\n     * A callback function returning array defining where the ticks are\n     * laid out on the axis. This overrides the default behaviour of\n     * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](\n     * #xAxis.tickInterval). The automatic tick positions are accessible\n     * through `this.tickPositions` and can be modified by the callback.\n     *\n     * @see [tickPositions](#xAxis.tickPositions)\n     *\n     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/\n     *         Demo of tickPositions and tickPositioner\n     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/\n     *         Demo of tickPositions and tickPositioner\n     *\n     * @type      {Function}\n     * @apioption xAxis.tickPositioner\n     */\n\n    /**\n     * An array defining where the ticks are laid out on the axis. This\n     * overrides the default behaviour of [tickPixelInterval](\n     * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).\n     *\n     * @see [tickPositioner](#xAxis.tickPositioner)\n     *\n     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/\n     *         Demo of tickPositions and tickPositioner\n     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/\n     *         Demo of tickPositions and tickPositioner\n     *\n     * @type      {Array<number>}\n     * @apioption xAxis.tickPositions\n     */\n\n    /**\n     * The pixel width of the major tick marks.\n     *\n     * In styled mode, the stroke width is given in the `.highcharts-tick`\n     * class.\n     *\n     * @sample {highcharts} highcharts/xaxis/tickwidth/\n     *         10 px width\n     * @sample {highcharts} highcharts/css/axis-grid/\n     *         Styled mode\n     * @sample {highstock} stock/xaxis/ticks/\n     *         Formatted ticks on X axis\n     * @sample {highstock} highcharts/css/axis-grid/\n     *         Styled mode\n     *\n     * @type      {number}\n     * @default   {highcharts} 1\n     * @default   {highstock} 1\n     * @default   {highmaps} 0\n     * @apioption xAxis.tickWidth\n     */\n\n    /**\n     * The axis title, showing next to the axis line.\n     *\n     * @productdesc {highmaps}\n     * In Highmaps, the axis is hidden by default, but adding an axis title\n     * is still possible. X axis and Y axis titles will appear at the bottom\n     * and left by default.\n     */\n    title: {\n      /**\n       * Deprecated. Set the `text` to `null` to disable the title.\n       *\n       * @deprecated\n       * @type      {string}\n       * @default   middle\n       * @product   highcharts\n       * @apioption xAxis.title.enabled\n       */\n\n      /**\n       * The pixel distance between the axis labels or line and the title.\n       * Defaults to 0 for horizontal axes, 10 for vertical\n       *\n       * @sample {highcharts} highcharts/xaxis/title-margin/\n       *         Y axis title margin of 60\n       *\n       * @type      {number}\n       * @apioption xAxis.title.margin\n       */\n\n      /**\n       * The distance of the axis title from the axis line. By default,\n       * this distance is computed from the offset width of the labels,\n       * the labels' distance from the axis and the title's margin.\n       * However when the offset option is set, it overrides all this.\n       *\n       * @sample {highcharts} highcharts/yaxis/title-offset/\n       *         Place the axis title on top of the axis\n       * @sample {highstock} highcharts/yaxis/title-offset/\n       *         Place the axis title on top of the Y axis\n       *\n       * @type      {number}\n       * @since     2.2.0\n       * @apioption xAxis.title.offset\n       */\n\n      /**\n       * Whether to reserve space for the title when laying out the axis.\n       *\n       * @type      {boolean}\n       * @default   true\n       * @since     5.0.11\n       * @product   highcharts highstock\n       * @apioption xAxis.title.reserveSpace\n       */\n\n      /**\n       * The rotation of the text in degrees. 0 is horizontal, 270 is\n       * vertical reading from bottom to top.\n       *\n       * @sample {highcharts} highcharts/yaxis/title-offset/\n       *         Horizontal\n       *\n       * @type      {number}\n       * @default   0\n       * @apioption xAxis.title.rotation\n       */\n\n      /**\n       * The actual text of the axis title. It can contain basic HTML text\n       * markup like <b>, <i> and spans with style.\n       *\n       * @sample {highcharts} highcharts/xaxis/title-text/\n       *         Custom HTML\n       * @sample {highstock} stock/xaxis/title-text/\n       *         Titles for both axes\n       *\n       * @type      {string}\n       * @apioption xAxis.title.text\n       */\n\n      /**\n       * Alignment of the text, can be `\"left\"`, `\"right\"` or `\"center\"`.\n       * Default alignment depends on the\n       * [title.align](xAxis.title.align):\n       *\n       * Horizontal axes:\n       * - for `align` = `\"low\"`, `textAlign` is set to `left`\n       * - for `align` = `\"middle\"`, `textAlign` is set to `center`\n       * - for `align` = `\"high\"`, `textAlign` is set to `right`\n       *\n       * Vertical axes:\n       * - for `align` = `\"low\"` and `opposite` = `true`, `textAlign` is\n       *   set to `right`\n       * - for `align` = `\"low\"` and `opposite` = `false`, `textAlign` is\n       *   set to `left`\n       * - for `align` = `\"middle\"`, `textAlign` is set to `center`\n       * - for `align` = `\"high\"` and `opposite` = `true` `textAlign` is\n       *   set to `left`\n       * - for `align` = `\"high\"` and `opposite` = `false` `textAlign` is\n       *   set to `right`\n       *\n       * @type      {string}\n       * @apioption xAxis.title.textAlign\n       */\n\n      /**\n       * Whether to [use HTML](https://www.highcharts.com/docs/\n       * chart-concepts/labels-and-string-formatting#html) to render the\n       * axis title.\n       *\n       * @type      {boolean}\n       * @default   false\n       * @product   highcharts highstock\n       * @apioption xAxis.title.useHTML\n       */\n\n      /**\n       * Horizontal pixel offset of the title position.\n       *\n       * @type      {number}\n       * @default   0\n       * @since     4.1.6\n       * @product   highcharts highstock\n       * @apioption xAxis.title.x\n       */\n\n      /**\n       * Vertical pixel offset of the title position.\n       *\n       * @type      {number}\n       * @product   highcharts highstock\n       * @apioption xAxis.title.y\n       */\n\n      /**\n       * Alignment of the title relative to the axis values. Possible\n       * values are \"low\", \"middle\" or \"high\".\n       *\n       * @sample {highcharts} highcharts/xaxis/title-align-low/\n       *         \"low\"\n       * @sample {highcharts} highcharts/xaxis/title-align-center/\n       *         \"middle\" by default\n       * @sample {highcharts} highcharts/xaxis/title-align-high/\n       *         \"high\"\n       * @sample {highcharts} highcharts/yaxis/title-offset/\n       *         Place the Y axis title on top of the axis\n       * @sample {highstock} stock/xaxis/title-align/\n       *         Aligned to \"high\" value\n       *\n       * @validvalue [\"low\", \"middle\", \"high\"]\n       */\n      align: 'middle'\n    },\n\n    /**\n     * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`\n     * or `category`. In a datetime axis, the numbers are given in\n     * milliseconds, and tick marks are placed on appropriate values like\n     * full hours or days. In a category axis, the\n     * [point names](#series.line.data.name) of the chart's series are used\n     * for categories, if not a [categories](#xAxis.categories) array is\n     * defined.\n     *\n     * @sample {highcharts} highcharts/xaxis/type-linear/\n     *         Linear\n     * @sample {highcharts} highcharts/yaxis/type-log/\n     *         Logarithmic\n     * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/\n     *         Logarithmic with minor grid lines\n     * @sample {highcharts} highcharts/xaxis/type-log-both/\n     *         Logarithmic on two axes\n     * @sample {highcharts} highcharts/yaxis/type-log-negative/\n     *         Logarithmic with extension to emulate negative values\n     *\n     * @product    highcharts\n     * @validvalue [\"linear\", \"logarithmic\", \"datetime\", \"category\"]\n     */\n    type: 'linear'\n    /**\n     * Applies only when the axis `type` is `category`. When `uniqueNames`\n     * is true, points are placed on the X axis according to their names.\n     * If the same point name is repeated in the same or another series,\n     * the point is placed on the same X position as other points of the\n     * same name. When `uniqueNames` is false, the points are laid out in\n     * increasing X positions regardless of their names, and the X axis\n     * category will take the name of the last point in each position.\n     *\n     * @sample {highcharts} highcharts/xaxis/uniquenames-true/\n     *         True by default\n     * @sample {highcharts} highcharts/xaxis/uniquenames-false/\n     *         False\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.2.7\n     * @product   highcharts\n     * @apioption xAxis.uniqueNames\n     */\n\n    /**\n     * Datetime axis only. An array determining what time intervals the\n     * ticks are allowed to fall on. Each array item is an array where the\n     * first value is the time unit and the second value another array of\n     * allowed multiples. Defaults to:\n     *\n     * <pre>units: [[\n     *     'millisecond', // unit name\n     *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n     * ], [\n     *     'second',\n     *     [1, 2, 5, 10, 15, 30]\n     * ], [\n     *     'minute',\n     *     [1, 2, 5, 10, 15, 30]\n     * ], [\n     *     'hour',\n     *     [1, 2, 3, 4, 6, 8, 12]\n     * ], [\n     *     'day',\n     *     [1]\n     * ], [\n     *     'week',\n     *     [1]\n     * ], [\n     *     'month',\n     *     [1, 3, 6]\n     * ], [\n     *     'year',\n     *     null\n     * ]]</pre>\n     *\n     * @type      {Array<Array<string|Array<number>>>}\n     * @product   highcharts highstock\n     * @apioption xAxis.units\n     */\n\n    /**\n     * Whether axis, including axis title, line, ticks and labels, should\n     * be visible.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.1.9\n     * @product   highcharts highstock\n     * @apioption xAxis.visible\n     */\n\n  },\n\n  /**\n   * The Y axis or value axis. Normally this is the vertical axis,\n   * though if the chart is inverted this is the horizontal axis.\n   * In case of multiple axes, the yAxis node is an array of\n   * configuration objects.\n   *\n   * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic\n   * access to the axis.\n   *\n   * @extends      xAxis\n   * @excluding    ordinal, overscroll\n   * @optionparent yAxis\n   */\n  defaultYAxisOptions: {\n    /**\n     * In a polar chart, this is the angle of the Y axis in degrees, where\n     * 0 is up and 90 is right. The angle determines the position of the\n     * axis line and the labels, though the coordinate system is unaffected.\n     *\n     * @sample {highcharts} highcharts/yaxis/angle/\n     *         Dual axis polar chart\n     *\n     * @type      {number}\n     * @default   0\n     * @since     4.2.7\n     * @product   highcharts\n     * @apioption yAxis.angle\n     */\n\n    /**\n     * Polar charts only. Whether the grid lines should draw as a polygon\n     * with straight lines between categories, or as circles. Can be either\n     * `circle` or `polygon`.\n     *\n     * @sample {highcharts} highcharts/demo/polar-spider/\n     *         Polygon grid lines\n     * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/\n     *         Circle and polygon\n     *\n     * @type       {string}\n     * @product    highcharts\n     * @validvalue [\"circle\", \"polygon\"]\n     * @apioption  yAxis.gridLineInterpolation\n     */\n\n    /**\n     * The height of the Y axis. If it's a number, it is interpreted as\n     * pixels.\n     *\n     * Since Highstock 2: If it's a percentage string, it is interpreted\n     * as percentages of the total plot height.\n     *\n     * @see [yAxis.top](#yAxis.top)\n     *\n     * @sample {highstock} stock/demo/candlestick-and-volume/\n     *         Percentage height panes\n     *\n     * @type      {number|string}\n     * @product   highstock\n     * @apioption yAxis.height\n     */\n\n    /**\n     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color\n     * to represent the maximum value of the Y axis.\n     *\n     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/\n     *         Min and max colors\n     *\n     * @type      {Highcharts.ColorString}\n     * @default   #003399\n     * @since     4.0\n     * @product   highcharts\n     * @apioption yAxis.maxColor\n     */\n\n    /**\n     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color\n     * to represent the minimum value of the Y axis.\n     *\n     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/\n     *         Min and max color\n     *\n     * @type      {Highcharts.ColorString}\n     * @default   #e6ebf5\n     * @since     4.0\n     * @product   highcharts\n     * @apioption yAxis.minColor\n     */\n\n    /**\n     * Whether to reverse the axis so that the highest number is closest\n     * to the origin.\n     *\n     * @sample {highcharts} highcharts/yaxis/reversed/\n     *         Reversed Y axis\n     * @sample {highstock} stock/xaxis/reversed/\n     *         Reversed Y axis\n     *\n     * @type      {boolean}\n     * @default   {highcharts} false\n     * @default   {highstock} false\n     * @default   {highmaps} true\n     * @apioption yAxis.reversed\n     */\n\n    /**\n     * If `true`, the first series in a stack will be drawn on top in a\n     * positive, non-reversed Y axis. If `false`, the first series is in\n     * the base of the stack.\n     *\n     * @sample {highcharts} highcharts/yaxis/reversedstacks-false/\n     *         Non-reversed stacks\n     * @sample {highstock} highcharts/yaxis/reversedstacks-false/\n     *         Non-reversed stacks\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     3.0.10\n     * @product   highcharts highstock\n     * @apioption yAxis.reversedStacks\n     */\n\n    /**\n     * Solid gauge series only. Color stops for the solid gauge. Use this\n     * in cases where a linear gradient between a `minColor` and `maxColor`\n     * is not sufficient. The stops is an array of tuples, where the first\n     * item is a float between 0 and 1 assigning the relative position in\n     * the gradient, and the second item is the color.\n     *\n     * For solid gauges, the Y axis also inherits the concept of [data classes](http://api.\n     * highcharts.com/highmaps#colorAxis.dataClasses) from the Highmaps\n     * color axis.\n     *\n     * @see [minColor](#yAxis.minColor)\n     * @see [maxColor](#yAxis.maxColor)\n     *\n     * @sample {highcharts} highcharts/demo/gauge-solid/\n     *         True by default\n     *\n     * @type      {Array<Array<number, Highcharts.ColorString>>}\n     * @since     4.0\n     * @product   highcharts\n     * @apioption yAxis.stops\n     */\n\n    /**\n     * The pixel width of the major tick marks.\n     *\n     * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width\n     * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis\n     *\n     * @type      {number}\n     * @default   0\n     * @product   highcharts highstock\n     * @apioption yAxis.tickWidth\n     */\n\n    /**\n     * Angular gauges and solid gauges only. The label's pixel distance\n     * from the perimeter of the plot area.\n     *\n     * @type      {number}\n     * @default   -25\n     * @product   highcharts\n     * @apioption yAxis.labels.distance\n     */\n\n    /**\n     * The y position offset of the label relative to the tick position\n     * on the axis.\n     *\n     * @sample {highcharts} highcharts/xaxis/labels-x/\n     *         Y axis labels placed on grid lines\n     *\n     * @type      {number}\n     * @default   {highcharts} 3\n     * @default   {highstock} -2\n     * @default   {highmaps} 3\n     * @apioption yAxis.labels.y\n     */\n\n    /**\n     * @productdesc {highstock}\n     * In Highstock, `endOnTick` is always false when the navigator is\n     * enabled, to prevent jumpy scrolling.\n     */\n    endOnTick: true,\n\n    /**\n     * Padding of the max value relative to the length of the axis. A\n     * padding of 0.05 will make a 100px axis 5px longer. This is useful\n     * when you don't want the highest data value to appear on the edge\n     * of the plot area. When the axis' `max` option is set or a max extreme\n     * is set using `axis.setExtremes()`, the maxPadding will be ignored.\n     *\n     * @sample {highcharts} highcharts/yaxis/maxpadding-02/\n     *         Max padding of 0.2\n     * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n     *         Greater min- and maxPadding\n     *\n     * @since   1.2.0\n     * @product highcharts highstock\n     */\n    maxPadding: 0.05,\n\n    /**\n     * Padding of the min value relative to the length of the axis. A\n     * padding of 0.05 will make a 100px axis 5px longer. This is useful\n     * when you don't want the lowest data value to appear on the edge\n     * of the plot area. When the axis' `min` option is set or a max extreme\n     * is set using `axis.setExtremes()`, the maxPadding will be ignored.\n     *\n     * @sample {highcharts} highcharts/yaxis/minpadding/\n     *         Min padding of 0.2\n     * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n     *         Greater min- and maxPadding\n     *\n     * @since   1.2.0\n     * @product highcharts highstock\n     */\n    minPadding: 0.05,\n\n    /**\n     * @productdesc {highstock}\n     * In Highstock 1.x, the Y axis was placed on the left side by default.\n     *\n     * @sample {highcharts} highcharts/yaxis/opposite/\n     *         Secondary Y axis opposite\n     * @sample {highstock} stock/xaxis/opposite/\n     *         Y axis on left side\n     *\n     * @type      {boolean}\n     * @default   {highstock} true\n     * @default   {highcharts} false\n     * @product   highstock highcharts\n     * @apioption yAxis.opposite\n     */\n\n    /**\n     * @see [tickInterval](#xAxis.tickInterval)\n     * @see [tickPositioner](#xAxis.tickPositioner)\n     * @see [tickPositions](#xAxis.tickPositions)\n     */\n    tickPixelInterval: 72,\n    showLastLabel: true,\n\n    /**\n     * @extends    xAxis.labels\n     */\n    labels: {\n      /**\n       * What part of the string the given position is anchored to. Can\n       * be one of `\"left\"`, `\"center\"` or `\"right\"`. The exact position\n       * also depends on the `labels.x` setting.\n       *\n       * Angular gauges and solid gauges defaults to `center`.\n       *\n       * @sample {highcharts} highcharts/yaxis/labels-align-left/\n       *         Left\n       *\n       * @type       {string}\n       * @default    {highcharts|highmaps} right\n       * @default    {highstock} left\n       * @validvalue [\"left\", \"center\", \"right\"]\n       * @apioption  yAxis.labels.align\n       */\n\n      /**\n       * The x position offset of the label relative to the tick position\n       * on the axis. Defaults to -15 for left axis, 15 for right axis.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-x/\n       *         Y axis labels placed on grid lines\n       */\n      x: -8\n    },\n\n    /**\n     * @productdesc {highmaps}\n     * In Highmaps, the axis line is hidden by default, because the axis is\n     * not visible by default.\n     *\n     * @type      {Highcharts.ColorString}\n     * @apioption yAxis.lineColor\n     */\n\n    /**\n     * @sample {highcharts} highcharts/yaxis/max-200/\n     *         Y axis max of 200\n     * @sample {highcharts} highcharts/yaxis/max-logarithmic/\n     *         Y axis max on logarithmic axis\n     * @sample {highstock} stock/yaxis/min-max/\n     *         Fixed min and max on Y axis\n     * @sample {highmaps} maps/axis/min-max/\n     *         Pre-zoomed to a specific area\n     *\n     * @type      {number}\n     * @apioption yAxis.max\n     */\n\n    /**\n     * @sample {highcharts} highcharts/yaxis/min-startontick-false/\n     *         -50 with startOnTick to false\n     * @sample {highcharts} highcharts/yaxis/min-startontick-true/\n     *         -50 with startOnTick true by default\n     * @sample {highstock} stock/yaxis/min-max/\n     *         Fixed min and max on Y axis\n     * @sample {highmaps} maps/axis/min-max/\n     *         Pre-zoomed to a specific area\n     *\n     * @type      {number}\n     * @apioption yAxis.min\n     */\n\n    /**\n     * An optional scrollbar to display on the Y axis in response to\n     * limiting the minimum an maximum of the axis values.\n     *\n     * In styled mode, all the presentational options for the scrollbar\n     * are replaced by the classes `.highcharts-scrollbar-thumb`,\n     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,\n     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.\n     *\n     * @sample {highstock} stock/yaxis/scrollbar/\n     *         Scrollbar on the Y axis\n     *\n     * @extends   scrollbar\n     * @excluding height\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar\n     */\n\n    /**\n     * Enable the scrollbar on the Y axis.\n     *\n     * @sample {highstock} stock/yaxis/scrollbar/\n     *         Enabled on Y axis\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.enabled\n     */\n\n    /**\n     * Pixel margin between the scrollbar and the axis elements.\n     *\n     * @type      {number}\n     * @default   10\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.margin\n     */\n\n    /**\n     * Whether to show the scrollbar when it is fully zoomed out at max\n     * range. Setting it to `false` on the Y axis makes the scrollbar stay\n     * hidden until the user zooms in, like common in browsers.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.showFull\n     */\n\n    /**\n     * The width of a vertical scrollbar or height of a horizontal\n     * scrollbar. Defaults to 20 on touch devices.\n     *\n     * @type      {number}\n     * @default   14\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.size\n     */\n\n    /**\n     * Z index of the scrollbar elements.\n     *\n     * @type      {number}\n     * @default   3\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.zIndex\n     */\n\n    /**\n     * A soft maximum for the axis. If the series data maximum is less\n     * than this, the axis will stay at this maximum, but if the series\n     * data maximum is higher, the axis will flex to show all data.\n     *\n     * **Note**: The [series.softThreshold](\n     * #plotOptions.series.softThreshold) option takes precedence over this\n     * option.\n     *\n     * @sample highcharts/yaxis/softmin-softmax/\n     *         Soft min and max\n     *\n     * @type      {number}\n     * @since     5.0.1\n     * @product   highcharts highstock\n     * @apioption yAxis.softMax\n     */\n\n    /**\n     * A soft minimum for the axis. If the series data minimum is greater\n     * than this, the axis will stay at this minimum, but if the series\n     * data minimum is lower, the axis will flex to show all data.\n     *\n     * **Note**: The [series.softThreshold](\n     * #plotOptions.series.softThreshold) option takes precedence over this\n     * option.\n     *\n     * @sample highcharts/yaxis/softmin-softmax/\n     *         Soft min and max\n     *\n     * @type      {number}\n     * @since     5.0.1\n     * @product   highcharts highstock\n     * @apioption yAxis.softMin\n     */\n\n    /**\n     * Defines the horizontal alignment of the stack total label. Can be one\n     * of `\"left\"`, `\"center\"` or `\"right\"`. The default value is calculated\n     * at runtime and depends on orientation and whether the stack is\n     * positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/\n     *         Aligned to the left\n     * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/\n     *         Aligned in center\n     * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/\n     *         Aligned to the right\n     *\n     * @type       {string}\n     * @since      2.1.5\n     * @product    highcharts\n     * @validvalue [\"left\", \"center\", \"right\"]\n     * @apioption  yAxis.stackLabels.align\n     */\n\n    /**\n     * A [format string](http://docs.highcharts.com/#formatting) for the\n     * data label. Available variables are the same as for `formatter`.\n     *\n     * @type      {string}\n     * @default   {total}\n     * @since     3.0.2\n     * @product   highcharts highstock\n     * @apioption yAxis.stackLabels.format\n     */\n\n    /**\n     * Rotation of the labels in degrees.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/\n     *         Labels rotated 45\n     *\n     * @type      {number}\n     * @default   0\n     * @since     2.1.5\n     * @product   highcharts\n     * @apioption yAxis.stackLabels.rotation\n     */\n\n    /**\n     * The text alignment for the label. While `align` determines where the\n     * texts anchor point is placed with regards to the stack, `textAlign`\n     * determines how the text is aligned against its anchor point. Possible\n     * values are `\"left\"`, `\"center\"` and `\"right\"`. The default value is\n     * calculated at runtime and depends on orientation and whether the\n     * stack is positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/\n     *         Label in center position but text-aligned left\n     *\n     * @type       {string}\n     * @since      2.1.5\n     * @product    highcharts\n     * @validvalue [\"left\", \"center\", \"right\"]\n     * @apioption  yAxis.stackLabels.textAlign\n     */\n\n    /**\n     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/\n     * labels-and-string-formatting#html) to render the labels.\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     3.0\n     * @product   highcharts highstock\n     * @apioption yAxis.stackLabels.useHTML\n     */\n\n    /**\n     * Defines the vertical alignment of the stack total label. Can be one\n     * of `\"top\"`, `\"middle\"` or `\"bottom\"`. The default value is calculated\n     * at runtime and depends on orientation and whether the stack is\n     * positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/\n     *         Vertically aligned top\n     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/\n     *         Vertically aligned middle\n     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/\n     *         Vertically aligned bottom\n     *\n     * @type       {string}\n     * @since      2.1.5\n     * @product    highcharts\n     * @validvalue [\"top\", \"middle\", \"bottom\"]\n     * @apioption  yAxis.stackLabels.verticalAlign\n     */\n\n    /**\n     * The x position offset of the label relative to the left of the\n     * stacked bar. The default value is calculated at runtime and depends\n     * on orientation and whether the stack is positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-x/\n     *         Stack total labels with x offset\n     *\n     * @type      {number}\n     * @since     2.1.5\n     * @product   highcharts\n     * @apioption yAxis.stackLabels.x\n     */\n\n    /**\n     * The y position offset of the label relative to the tick position\n     * on the axis. The default value is calculated at runtime and depends\n     * on orientation and whether the stack is positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-y/\n     *         Stack total labels with y offset\n     *\n     * @type      {number}\n     * @since     2.1.5\n     * @product   highcharts\n     * @apioption yAxis.stackLabels.y\n     */\n\n    /**\n     * Whether to force the axis to start on a tick. Use this option with\n     * the `maxPadding` option to control the axis start.\n     *\n     * @sample  {highcharts} highcharts/xaxis/startontick-false/\n     *          False by default\n     * @sample  {highcharts} highcharts/xaxis/startontick-true/\n     *          True\n     * @sample  {highstock} stock/xaxis/endontick/\n     *          False for Y axis\n     *\n     * @since   1.2.0\n     * @product highcharts highstock\n     */\n    startOnTick: true,\n    title: {\n      /**\n       * The pixel distance between the axis labels and the title.\n       * Positive values are outside the axis line, negative are inside.\n       *\n       * @sample {highcharts} highcharts/xaxis/title-margin/\n       *         Y axis title margin of 60\n       *\n       * @type      {number}\n       * @default   40\n       * @apioption yAxis.title.margin\n       */\n\n      /**\n       * The rotation of the text in degrees. 0 is horizontal, 270 is\n       * vertical reading from bottom to top.\n       *\n       * @sample {highcharts} highcharts/yaxis/title-offset/\n       *         Horizontal\n       */\n      rotation: 270,\n\n      /**\n       * The actual text of the axis title. Horizontal texts can contain\n       * HTML, but rotated texts are painted using vector techniques and\n       * must be clean text. The Y axis title is disabled by setting the\n       * `text` option to `undefined`.\n       *\n       * @sample  {highcharts} highcharts/xaxis/title-text/\n       *          Custom HTML\n       *\n       * @default {highcharts} Values\n       * @default {highstock} undefined\n       * @product highcharts highstock\n       */\n      text: 'Values'\n    },\n\n    /**\n     * The top position of the Y axis. If it's a number, it is interpreted\n     * as pixel position relative to the chart.\n     *\n     * Since Highstock 2: If it's a percentage string, it is interpreted\n     * as percentages of the plot height, offset from plot area top.\n     *\n     * @see [yAxis.height](#yAxis.height)\n     *\n     * @sample {highstock} stock/demo/candlestick-and-volume/\n     *         Percentage height panes\n     *\n     * @type      {number|string}\n     * @product   highstock\n     * @apioption yAxis.top\n     */\n\n    /**\n     * The stack labels show the total value for each bar in a stacked\n     * column or bar chart. The label will be placed on top of positive\n     * columns and below negative columns. In case of an inverted column\n     * chart or a bar chart the label is placed to the right of positive\n     * bars and to the left of negative bars.\n     *\n     * @product highcharts\n     */\n    stackLabels: {\n      /**\n       * Allow the stack labels to overlap.\n       *\n       * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/\n       *         Default false\n       *\n       * @since   5.0.13\n       * @product highcharts\n       */\n      allowOverlap: false,\n\n      /**\n       * Enable or disable the stack total labels.\n       *\n       * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/\n       *         Enabled stack total labels\n       *\n       * @since   2.1.5\n       * @product highcharts\n       */\n      enabled: false,\n\n      /**\n       * Callback JavaScript function to format the label. The value is\n       * given by `this.total`.\n       *\n       * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/\n       *         Added units to stack total value\n       *\n       * @type    {Highcharts.FormatterCallbackFunction}\n       * @since   2.1.5\n       * @product highcharts\n       */\n      formatter: function formatter() {\n        return H.numberFormat(this.total, -1);\n      }\n    }\n  },\n\n  /**\n   * The Z axis or depth axis for 3D plots.\n   *\n   * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic\n   * access to the axis.\n   *\n   * @sample {highcharts} highcharts/3d/scatter-zaxis-categories/\n   *         Z-Axis with Categories\n   * @sample {highcharts} highcharts/3d/scatter-zaxis-grid/\n   *         Z-Axis with styling\n   *\n   * @extends   xAxis\n   * @since     5.0.0\n   * @product   highcharts\n   * @excluding breaks, crosshair, lineColor, lineWidth, nameToX, showEmpty\n   * @apioption zAxis\n   */\n\n  /**\n   * These options extend the defaultOptions for left axes.\n   *\n   * @private\n   * @name Highcharts.Axis#defaultLeftAxisOptions\n   * @type {*}\n   */\n  defaultLeftAxisOptions: {\n    labels: {\n      x: -15\n    },\n    title: {\n      rotation: 270\n    }\n  },\n\n  /**\n   * These options extend the defaultOptions for right axes.\n   *\n   * @private\n   * @name Highcharts.Axis#defaultRightAxisOptions\n   * @type {*}\n   */\n  defaultRightAxisOptions: {\n    labels: {\n      x: 15\n    },\n    title: {\n      rotation: 90\n    }\n  },\n\n  /**\n   * These options extend the defaultOptions for bottom axes.\n   *\n   * @private\n   * @name Highcharts.Axis#defaultBottomAxisOptions\n   * @type {*}\n   */\n  defaultBottomAxisOptions: {\n    labels: {\n      autoRotation: [-45],\n      x: 0 // overflow: undefined,\n      // staggerLines: null\n\n    },\n    title: {\n      rotation: 0\n    }\n  },\n\n  /**\n   * These options extend the defaultOptions for top axes.\n   *\n   * @private\n   * @name Highcharts.Axis#defaultTopAxisOptions\n   * @type {*}\n   */\n  defaultTopAxisOptions: {\n    labels: {\n      autoRotation: [-45],\n      x: 0 // overflow: undefined\n      // staggerLines: null\n\n    },\n    title: {\n      rotation: 0\n    }\n  },\n\n  /**\n   * Overrideable function to initialize the axis.\n   *\n   * @see {@link Axis}\n   *\n   * @function Highcharts.Axis#init\n   *\n   * @param {Highcharts.Chart} chart\n   *\n   * @param {Highcharts.Options} userOptions\n   *\n   * @fires Highcharts.Axis#event:afterInit\n   * @fires Highcharts.Axis#event:init\n   */\n  init: function init(chart, userOptions) {\n    var isXAxis = userOptions.isX,\n        axis = this;\n    /**\n     * The Chart that the axis belongs to.\n     *\n     * @name Highcharts.Axis#chart\n     * @type {Highcharts.Chart}\n     */\n\n    axis.chart = chart;\n    /**\n     * Whether the axis is horizontal.\n     *\n     * @name Highcharts.Axis#horiz\n     * @type {boolean}\n     */\n\n    axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis; // Flag, isXAxis\n\n    axis.isXAxis = isXAxis;\n    /**\n     * The collection where the axis belongs, for example `xAxis`, `yAxis`\n     * or `colorAxis`. Corresponds to properties on Chart, for example\n     * {@link Chart.xAxis}.\n     *\n     * @name Highcharts.Axis#coll\n     * @type {string}\n     */\n\n    axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');\n    fireEvent(this, 'init', {\n      userOptions: userOptions\n    });\n    axis.opposite = userOptions.opposite; // needed in setOptions\n\n    /**\n     * The side on which the axis is rendered. 0 is top, 1 is right, 2 is\n     * bottom and 3 is left.\n     *\n     * @name Highcharts.Axis#side\n     * @type {number}\n     */\n\n    axis.side = userOptions.side || (axis.horiz ? axis.opposite ? 0 : 2 : // top : bottom\n    axis.opposite ? 1 : 3); // right : left\n\n    axis.setOptions(userOptions);\n    var options = this.options,\n        type = options.type,\n        isDatetimeAxis = type === 'datetime';\n    axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n    // Flag, stagger lines or not\n\n    axis.userOptions = userOptions;\n    axis.minPixelPadding = 0;\n    /**\n     * Whether the axis is reversed. Based on the `axis.reversed`,\n     * option, but inverted charts have reversed xAxis by default.\n     *\n     * @name Highcharts.Axis#reversed\n     * @type {boolean}\n     */\n\n    axis.reversed = options.reversed;\n    axis.visible = options.visible !== false;\n    axis.zoomEnabled = options.zoomEnabled !== false; // Initial categories\n\n    axis.hasNames = type === 'category' || options.categories === true;\n    axis.categories = options.categories || axis.hasNames;\n\n    if (!axis.names) {\n      // Preserve on update (#3830)\n      axis.names = [];\n      axis.names.keys = {};\n    } // Placeholder for plotlines and plotbands groups\n\n\n    axis.plotLinesAndBandsGroups = {}; // Shorthand types\n\n    axis.isLog = type === 'logarithmic';\n    axis.isDatetimeAxis = isDatetimeAxis;\n    axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog; // Flag, if axis is linked to another axis\n\n    axis.isLinked = defined(options.linkedTo); // Major ticks\n\n    axis.ticks = {};\n    axis.labelEdge = []; // Minor ticks\n\n    axis.minorTicks = {}; // List of plotLines/Bands\n\n    axis.plotLinesAndBands = []; // Alternate bands\n\n    axis.alternateBands = {}; // Axis metrics\n\n    axis.len = 0;\n    axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n    axis.range = options.range;\n    axis.offset = options.offset || 0; // Dictionary for stacks\n\n    axis.stacks = {};\n    axis.oldStacks = {};\n    axis.stacksTouched = 0;\n    /**\n     * The maximum value of the axis. In a logarithmic axis, this is the\n     * logarithm of the real value, and the real value can be obtained from\n     * {@link Axis#getExtremes}.\n     *\n     * @name Highcharts.Axis#max\n     * @type {number}\n     */\n\n    axis.max = null;\n    /**\n     * The minimum value of the axis. In a logarithmic axis, this is the\n     * logarithm of the real value, and the real value can be obtained from\n     * {@link Axis#getExtremes}.\n     *\n     * @name Highcharts.Axis#min\n     * @type {number}\n     */\n\n    axis.min = null;\n    /**\n     * The processed crosshair options.\n     *\n     * @name Highcharts.Axis#crosshair\n     * @type {false|Highcharts.AxisCrosshairOptions}\n     */\n\n    axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n    var events = axis.options.events; // Register. Don't add it again on Axis.update().\n\n    if (inArray(axis, chart.axes) === -1) {\n      //\n      if (isXAxis) {\n        // #2713\n        chart.axes.splice(chart.xAxis.length, 0, axis);\n      } else {\n        chart.axes.push(axis);\n      }\n\n      chart[axis.coll].push(axis);\n    }\n    /**\n     * All series associated to the axis.\n     *\n     * @name Highcharts.Axis#series\n     * @type {Array<Highcharts.Series>}\n     */\n\n\n    axis.series = axis.series || []; // populated by Series\n    // Reversed axis\n\n    if (chart.inverted && !axis.isZAxis && isXAxis && axis.reversed === undefined) {\n      axis.reversed = true;\n    } // register event listeners\n\n\n    objectEach(events, function (event, eventType) {\n      addEvent(axis, eventType, event);\n    }); // extend logarithmic axis\n\n    axis.lin2log = options.linearToLogConverter || axis.lin2log;\n\n    if (axis.isLog) {\n      axis.val2lin = axis.log2lin;\n      axis.lin2val = axis.lin2log;\n    }\n\n    fireEvent(this, 'afterInit');\n  },\n\n  /**\n   * Merge and set options.\n   *\n   * @private\n   * @function Highcharts.Axis#setOptions\n   *\n   * @param {Highcharts.AxisOptions} userOptions\n   *\n   * @fires Highcharts.Axis#event:afterSetOptions\n   */\n  setOptions: function setOptions(userOptions) {\n    this.options = merge(this.defaultOptions, this.coll === 'yAxis' && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], merge(defaultOptions[this.coll], // if set in setOptions (#1053)\n    userOptions));\n    fireEvent(this, 'afterSetOptions', {\n      userOptions: userOptions\n    });\n  },\n\n  /**\n   * The default label formatter. The context is a special config object for\n   * the label. In apps, use the {@link\n   * https://api.highcharts.com/highcharts/xAxis.labels.formatter|\n   * labels.formatter} instead except when a modification is needed.\n   *\n   * @private\n   * @function Highcharts.Axis#defaultLabelFormatter\n   *\n   * @return {string}\n   */\n  defaultLabelFormatter: function defaultLabelFormatter() {\n    var axis = this.axis,\n        value = this.value,\n        time = axis.chart.time,\n        categories = axis.categories,\n        dateTimeLabelFormat = this.dateTimeLabelFormat,\n        lang = defaultOptions.lang,\n        numericSymbols = lang.numericSymbols,\n        numSymMagnitude = lang.numericSymbolMagnitude || 1000,\n        i = numericSymbols && numericSymbols.length,\n        multi,\n        ret,\n        formatOption = axis.options.labels.format,\n        // make sure the same symbol is added for all labels on a linear\n    // axis\n    numericSymbolDetector = axis.isLog ? Math.abs(value) : axis.tickInterval;\n\n    if (formatOption) {\n      ret = format(formatOption, this, time);\n    } else if (categories) {\n      ret = value;\n    } else if (dateTimeLabelFormat) {\n      // datetime axis\n      ret = time.dateFormat(dateTimeLabelFormat, value);\n    } else if (i && numericSymbolDetector >= 1000) {\n      // Decide whether we should add a numeric symbol like k (thousands)\n      // or M (millions). If we are to enable this in tooltip or other\n      // places as well, we can move this logic to the numberFormatter and\n      // enable it by a parameter.\n      while (i-- && ret === undefined) {\n        multi = Math.pow(numSymMagnitude, i + 1);\n\n        if ( // Only accept a numeric symbol when the distance is more\n        // than a full unit. So for example if the symbol is k, we\n        // don't accept numbers like 0.5k.\n        numericSymbolDetector >= multi && // Accept one decimal before the symbol. Accepts 0.5k but\n        // not 0.25k. How does this work with the previous?\n        value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0) {\n          // #5480\n          ret = H.numberFormat(value / multi, -1) + numericSymbols[i];\n        }\n      }\n    }\n\n    if (ret === undefined) {\n      if (Math.abs(value) >= 10000) {\n        // add thousands separators\n        ret = H.numberFormat(value, -1);\n      } else {\n        // small numbers\n        ret = H.numberFormat(value, -1, undefined, ''); // #2466\n      }\n    }\n\n    return ret;\n  },\n\n  /**\n   * Get the minimum and maximum for the series of each axis. The function\n   * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.\n   *\n   * @private\n   * @function Highcharts.Axis#getSeriesExtremes\n   *\n   * @fires Highcharts.Axis#event:afterGetSeriesExtremes\n   * @fires Highcharts.Axis#event:getSeriesExtremes\n   */\n  getSeriesExtremes: function getSeriesExtremes() {\n    var axis = this,\n        chart = axis.chart;\n    fireEvent(this, 'getSeriesExtremes', null, function () {\n      axis.hasVisibleSeries = false; // Reset properties in case we're redrawing (#3353)\n\n      axis.dataMin = axis.dataMax = axis.threshold = null;\n      axis.softThreshold = !axis.isXAxis;\n\n      if (axis.buildStacks) {\n        axis.buildStacks();\n      } // loop through this axis' series\n\n\n      each(axis.series, function (series) {\n        if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n          var seriesOptions = series.options,\n              xData,\n              threshold = seriesOptions.threshold,\n              seriesDataMin,\n              seriesDataMax;\n          axis.hasVisibleSeries = true; // Validate threshold in logarithmic axes\n\n          if (axis.positiveValuesOnly && threshold <= 0) {\n            threshold = null;\n          } // Get dataMin and dataMax for X axes\n\n\n          if (axis.isXAxis) {\n            xData = series.xData;\n\n            if (xData.length) {\n              // If xData contains values which is not numbers,\n              // then filter them out. To prevent performance hit,\n              // we only do this after we have already found\n              // seriesDataMin because in most cases all data is\n              // valid. #5234.\n              seriesDataMin = arrayMin(xData);\n              seriesDataMax = arrayMax(xData);\n\n              if (!isNumber(seriesDataMin) && !(seriesDataMin instanceof Date) // #5010\n              ) {\n                  xData = grep(xData, isNumber); // Do it again with valid data\n\n                  seriesDataMin = arrayMin(xData);\n                  seriesDataMax = arrayMax(xData);\n                }\n\n              if (xData.length) {\n                axis.dataMin = Math.min(pick(axis.dataMin, xData[0], seriesDataMin), seriesDataMin);\n                axis.dataMax = Math.max(pick(axis.dataMax, xData[0], seriesDataMax), seriesDataMax);\n              }\n            } // Get dataMin and dataMax for Y axes, as well as handle\n            // stacking and processed data\n\n          } else {\n            // Get this particular series extremes\n            series.getExtremes();\n            seriesDataMax = series.dataMax;\n            seriesDataMin = series.dataMin; // Get the dataMin and dataMax so far. If percentage is\n            // used, the min and max are always 0 and 100. If\n            // seriesDataMin and seriesDataMax is null, then series\n            // doesn't have active y data, we continue with nulls\n\n            if (defined(seriesDataMin) && defined(seriesDataMax)) {\n              axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n              axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n            } // Adjust to threshold\n\n\n            if (defined(threshold)) {\n              axis.threshold = threshold;\n            } // If any series has a hard threshold, it takes\n            // precedence\n\n\n            if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {\n              axis.softThreshold = false;\n            }\n          }\n        }\n      });\n    });\n    fireEvent(this, 'afterGetSeriesExtremes');\n  },\n\n  /**\n   * Translate from axis value to pixel position on the chart, or back. Use\n   * the `toPixels` and `toValue` functions in applications.\n   *\n   * @private\n   * @function Highcharts.Axis#translate\n   *\n   * @param {number} val\n   *\n   * @param {boolean} [backwards]\n   *\n   * @param {boolean} [cvsCoord]\n   *\n   * @param {boolean} [old]\n   *\n   * @param {boolean} [handleLog]\n   *\n   * @param {number} [pointPlacement=0]\n   *\n   * @return {number|undefined}\n   */\n  translate: function translate(val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n    var axis = this.linkedParent || this,\n        // #1417\n    sign = 1,\n        cvsOffset = 0,\n        localA = old ? axis.oldTransA : axis.transA,\n        localMin = old ? axis.oldMin : axis.min,\n        returnValue,\n        minPixelPadding = axis.minPixelPadding,\n        doPostTranslate = (axis.isOrdinal || axis.isBroken || axis.isLog && handleLog) && axis.lin2val;\n\n    if (!localA) {\n      localA = axis.transA;\n    } // In vertical axes, the canvas coordinates start from 0 at the top like\n    // in SVG.\n\n\n    if (cvsCoord) {\n      sign *= -1; // canvas coordinates inverts the value\n\n      cvsOffset = axis.len;\n    } // Handle reversed axis\n\n\n    if (axis.reversed) {\n      sign *= -1;\n      cvsOffset -= sign * (axis.sector || axis.len);\n    } // From pixels to value\n\n\n    if (backwards) {\n      // reverse translation\n      val = val * sign + cvsOffset;\n      val -= minPixelPadding;\n      returnValue = val / localA + localMin; // from chart pixel to value\n\n      if (doPostTranslate) {\n        // log and ordinal axes\n        returnValue = axis.lin2val(returnValue);\n      } // From value to pixels\n\n    } else {\n      if (doPostTranslate) {\n        // log and ordinal axes\n        val = axis.val2lin(val);\n      }\n\n      returnValue = isNumber(localMin) ? sign * (val - localMin) * localA + cvsOffset + sign * minPixelPadding + (isNumber(pointPlacement) ? localA * pointPlacement : 0) : undefined;\n    }\n\n    return returnValue;\n  },\n\n  /**\n   * Translate a value in terms of axis units into pixels within the chart.\n   *\n   * @function Highcharts.Axis#toPixels\n   *\n   * @param {number} value\n   *        A value in terms of axis units.\n   *\n   * @param {boolean} paneCoordinates\n   *        Whether to return the pixel coordinate relative to the chart or\n   *        just the axis/pane itself.\n   *\n   * @return {number}\n   *         Pixel position of the value on the chart or axis.\n   */\n  toPixels: function toPixels(value, paneCoordinates) {\n    return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);\n  },\n\n  /**\n   * Translate a pixel position along the axis to a value in terms of axis\n   * units.\n   *\n   * @function Highcharts.Axis#toValue\n   *\n   * @param {number} pixel\n   *        The pixel value coordinate.\n   *\n   * @param {boolean} paneCoordiantes\n   *        Whether the input pixel is relative to the chart or just the\n   *        axis/pane itself.\n   *\n   * @return {number}\n   *         The axis value.\n   */\n  toValue: function toValue(pixel, paneCoordinates) {\n    return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);\n  },\n\n  /**\n   * Create the path for a plot line that goes from the given value on\n   * this axis, across the plot to the opposite side. Also used internally for\n   * grid lines and crosshairs.\n   *\n   * @function Highcharts.Axis#getPlotLinePath\n   *\n   * @param {number} value\n   *        Axis value.\n   *\n   * @param {number} [lineWidth=1]\n   *        Used for calculation crisp line coordinates.\n   *\n   * @param {boolean} [old=false]\n   *        Use old coordinates (for resizing and rescaling).\n   *\n   * @param {boolean} [force=false]\n   *        If `false`, the function will return null when it falls outside\n   *        the axis bounds.\n   *\n   * @param {number} [translatedValue]\n   *        If given, return the plot line path of a pixel position on the\n   *        axis.\n   *\n   * @return {Array<string|number>}\n   *         The SVG path definition for the plot line.\n   */\n  getPlotLinePath: function getPlotLinePath(value, lineWidth, old, force, translatedValue) {\n    var axis = this,\n        chart = axis.chart,\n        axisLeft = axis.left,\n        axisTop = axis.top,\n        x1,\n        y1,\n        x2,\n        y2,\n        cHeight = old && chart.oldChartHeight || chart.chartHeight,\n        cWidth = old && chart.oldChartWidth || chart.chartWidth,\n        skip,\n        transB = axis.transB,\n\n    /**\n     * Check if x is between a and b. If not, either move to a/b\n     * or skip, depending on the force parameter.\n     */\n    between = function between(x, a, b) {\n      if (x < a || x > b) {\n        if (force) {\n          x = Math.min(Math.max(a, x), b);\n        } else {\n          skip = true;\n        }\n      }\n\n      return x;\n    };\n\n    translatedValue = pick(translatedValue, axis.translate(value, null, null, old)); // Keep the translated value within sane bounds, and avoid Infinity to\n    // fail the isNumber test (#7709).\n\n    translatedValue = Math.min(Math.max(-1e5, translatedValue), 1e5);\n    x1 = x2 = Math.round(translatedValue + transB);\n    y1 = y2 = Math.round(cHeight - translatedValue - transB);\n\n    if (!isNumber(translatedValue)) {\n      // no min or max\n      skip = true;\n      force = false; // #7175, don't force it when path is invalid\n    } else if (axis.horiz) {\n      y1 = axisTop;\n      y2 = cHeight - axis.bottom;\n      x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n    } else {\n      x1 = axisLeft;\n      x2 = cWidth - axis.right;\n      y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n    }\n\n    return skip && !force ? null : chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);\n  },\n\n  /**\n   * Internal function to et the tick positions of a linear axis to round\n   * values like whole tens or every five.\n   *\n   * @function Highcharts.Axis#getLinearTickPositions\n   *\n   * @param {number} tickInterval\n   *        The normalized tick interval.\n   *\n   * @param {number} min\n   *        Axis minimum.\n   *\n   * @param {number} max\n   *        Axis maximum.\n   *\n   * @return {Array<number>}\n   *         An array of axis values where ticks should be placed.\n   */\n  getLinearTickPositions: function getLinearTickPositions(tickInterval, min, max) {\n    var pos,\n        lastPos,\n        roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),\n        roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),\n        tickPositions = [],\n        precision; // When the precision is higher than what we filter out in\n    // correctFloat, skip it (#6183).\n\n    if (correctFloat(roundedMin + tickInterval) === roundedMin) {\n      precision = 20;\n    } // For single points, add a tick regardless of the relative position\n    // (#2662, #6274)\n\n\n    if (this.single) {\n      return [min];\n    } // Populate the intermediate values\n\n\n    pos = roundedMin;\n\n    while (pos <= roundedMax) {\n      // Place the tick on the rounded value\n      tickPositions.push(pos); // Always add the raw tickInterval, not the corrected one.\n\n      pos = correctFloat(pos + tickInterval, precision); // If the interval is not big enough in the current min - max range\n      // to actually increase the loop variable, we need to break out to\n      // prevent endless loop. Issue #619\n\n      if (pos === lastPos) {\n        break;\n      } // Record the last value\n\n\n      lastPos = pos;\n    }\n\n    return tickPositions;\n  },\n\n  /**\n   * Resolve the new minorTicks/minorTickInterval options into the legacy\n   * loosely typed minorTickInterval option.\n   *\n   * @function Highcharts.Axis#getMinorTickInterval\n   *\n   * @return {number|'auto'|null}\n   */\n  getMinorTickInterval: function getMinorTickInterval() {\n    var options = this.options;\n\n    if (options.minorTicks === true) {\n      return pick(options.minorTickInterval, 'auto');\n    }\n\n    if (options.minorTicks === false) {\n      return null;\n    }\n\n    return options.minorTickInterval;\n  },\n\n  /**\n   * Internal function to return the minor tick positions. For logarithmic\n   * axes, the same logic as for major ticks is reused.\n   *\n   * @function Highcharts.Axis#getMinorTickPositions\n   *\n   * @return {Array<number>}\n   *         An array of axis values where ticks should be placed.\n   */\n  getMinorTickPositions: function getMinorTickPositions() {\n    var axis = this,\n        options = axis.options,\n        tickPositions = axis.tickPositions,\n        minorTickInterval = axis.minorTickInterval,\n        minorTickPositions = [],\n        pos,\n        pointRangePadding = axis.pointRangePadding || 0,\n        min = axis.min - pointRangePadding,\n        // #1498\n    max = axis.max + pointRangePadding,\n        // #1498\n    range = max - min; // If minor ticks get too dense, they are hard to read, and may cause\n    // long running script. So we don't draw them.\n\n    if (range && range / minorTickInterval < axis.len / 3) {\n      // #3875\n      if (axis.isLog) {\n        // For each interval in the major ticks, compute the minor ticks\n        // separately.\n        each(this.paddedTicks, function (pos, i, paddedTicks) {\n          if (i) {\n            minorTickPositions.push.apply(minorTickPositions, axis.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));\n          }\n        });\n      } else if (axis.isDatetimeAxis && this.getMinorTickInterval() === 'auto') {\n        // #1314\n        minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));\n      } else {\n        for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n          // Very, very, tight grid lines (#5771)\n          if (pos === minorTickPositions[0]) {\n            break;\n          }\n\n          minorTickPositions.push(pos);\n        }\n      }\n    }\n\n    if (minorTickPositions.length !== 0) {\n      axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330\n    }\n\n    return minorTickPositions;\n  },\n\n  /**\n   * Adjust the min and max for the minimum range. Keep in mind that the\n   * series data is not yet processed, so we don't have information on data\n   * cropping and grouping, or updated axis.pointRange or series.pointRange.\n   * The data can't be processed until we have finally established min and\n   * max.\n   *\n   * @private\n   * @function Highcharts.Axis#adjustForMinRange\n   */\n  adjustForMinRange: function adjustForMinRange() {\n    var axis = this,\n        options = axis.options,\n        min = axis.min,\n        max = axis.max,\n        zoomOffset,\n        spaceAvailable,\n        closestDataRange,\n        i,\n        distance,\n        xData,\n        loopLength,\n        minArgs,\n        maxArgs,\n        minRange; // Set the automatic minimum range based on the closest point distance\n\n    if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {\n      if (defined(options.min) || defined(options.max)) {\n        axis.minRange = null; // don't do this again\n      } else {\n        // Find the closest distance between raw data points, as opposed\n        // to closestPointRange that applies to processed points\n        // (cropped and grouped)\n        each(axis.series, function (series) {\n          xData = series.xData;\n          loopLength = series.xIncrement ? 1 : xData.length - 1;\n\n          for (i = loopLength; i > 0; i--) {\n            distance = xData[i] - xData[i - 1];\n\n            if (closestDataRange === undefined || distance < closestDataRange) {\n              closestDataRange = distance;\n            }\n          }\n        });\n        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);\n      }\n    } // if minRange is exceeded, adjust\n\n\n    if (max - min < axis.minRange) {\n      spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;\n      minRange = axis.minRange;\n      zoomOffset = (minRange - max + min) / 2; // if min and max options have been set, don't go beyond it\n\n      minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)]; // If space is available, stay within the data range\n\n      if (spaceAvailable) {\n        minArgs[2] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;\n      }\n\n      min = arrayMax(minArgs);\n      maxArgs = [min + minRange, pick(options.max, min + minRange)]; // If space is availabe, stay within the data range\n\n      if (spaceAvailable) {\n        maxArgs[2] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;\n      }\n\n      max = arrayMin(maxArgs); // now if the max is adjusted, adjust the min back\n\n      if (max - min < minRange) {\n        minArgs[0] = max - minRange;\n        minArgs[1] = pick(options.min, max - minRange);\n        min = arrayMax(minArgs);\n      }\n    } // Record modified extremes\n\n\n    axis.min = min;\n    axis.max = max;\n  },\n\n  /**\n   * Find the closestPointRange across all series.\n   *\n   * @private\n   * @function Highcharts.Axis#getClosest\n   *\n   * @return {number}\n   */\n  getClosest: function getClosest() {\n    var ret;\n\n    if (this.categories) {\n      ret = 1;\n    } else {\n      each(this.series, function (series) {\n        var seriesClosest = series.closestPointRange,\n            visible = series.visible || !series.chart.options.chart.ignoreHiddenSeries;\n\n        if (!series.noSharedTooltip && defined(seriesClosest) && visible) {\n          ret = defined(ret) ? Math.min(ret, seriesClosest) : seriesClosest;\n        }\n      });\n    }\n\n    return ret;\n  },\n\n  /**\n   * When a point name is given and no x, search for the name in the existing\n   * categories, or if categories aren't provided, search names or create a\n   * new category (#2522).\n   *\n   * @private\n   * @function Highcharts.Axis#nameToX\n   *\n   * @param {Highcharts.Point} point\n   *        The point to inspect.\n   *\n   * @return {number}\n   *         The X value that the point is given.\n   */\n  nameToX: function nameToX(point) {\n    var explicitCategories = isArray(this.categories),\n        names = explicitCategories ? this.categories : this.names,\n        nameX = point.options.x,\n        x;\n    point.series.requireSorting = false;\n\n    if (!defined(nameX)) {\n      nameX = this.options.uniqueNames === false ? point.series.autoIncrement() : explicitCategories ? inArray(point.name, names) : pick(names.keys[point.name], -1);\n    }\n\n    if (nameX === -1) {\n      // Not found in currenct categories\n      if (!explicitCategories) {\n        x = names.length;\n      }\n    } else {\n      x = nameX;\n    } // Write the last point's name to the names array\n\n\n    if (x !== undefined) {\n      this.names[x] = point.name; // Backwards mapping is much faster than array searching (#7725)\n\n      this.names.keys[point.name] = x;\n    }\n\n    return x;\n  },\n\n  /**\n   * When changes have been done to series data, update the axis.names.\n   *\n   * @private\n   * @function Highcharts.Axis#updateNames\n   */\n  updateNames: function updateNames() {\n    var axis = this,\n        names = this.names,\n        i = names.length;\n\n    if (i > 0) {\n      each(H.keys(names.keys), function (key) {\n        delete names.keys[key];\n      });\n      names.length = 0;\n      this.minRange = this.userMinRange; // Reset\n\n      each(this.series || [], function (series) {\n        // Reset incrementer (#5928)\n        series.xIncrement = null; // When adding a series, points are not yet generated\n\n        if (!series.points || series.isDirtyData) {\n          series.processData();\n          series.generatePoints();\n        }\n\n        each(series.points, function (point, i) {\n          var x;\n\n          if (point.options) {\n            x = axis.nameToX(point);\n\n            if (x !== undefined && x !== point.x) {\n              point.x = x;\n              series.xData[i] = x;\n            }\n          }\n        });\n      });\n    }\n  },\n\n  /**\n   * Update translation information.\n   *\n   * @private\n   * @function Highcharts.Axis#setAxisTranslation\n   *\n   * @param {boolean} saveOld\n   *\n   * @fires Highcharts.Axis#event:afterSetAxisTranslation\n   */\n  setAxisTranslation: function setAxisTranslation(saveOld) {\n    var axis = this,\n        range = axis.max - axis.min,\n        pointRange = axis.axisPointRange || 0,\n        closestPointRange,\n        minPointOffset = 0,\n        pointRangePadding = 0,\n        linkedParent = axis.linkedParent,\n        ordinalCorrection,\n        hasCategories = !!axis.categories,\n        transA = axis.transA,\n        isXAxis = axis.isXAxis; // Adjust translation for padding. Y axis with categories need to go\n    // through the same (#1784).\n\n    if (isXAxis || hasCategories || pointRange) {\n      // Get the closest points\n      closestPointRange = axis.getClosest();\n\n      if (linkedParent) {\n        minPointOffset = linkedParent.minPointOffset;\n        pointRangePadding = linkedParent.pointRangePadding;\n      } else {\n        each(axis.series, function (series) {\n          var seriesPointRange = hasCategories ? 1 : isXAxis ? pick(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0,\n              // #2806\n          pointPlacement = series.options.pointPlacement;\n          pointRange = Math.max(pointRange, seriesPointRange);\n\n          if (!axis.single) {\n            // minPointOffset is the value padding to the left of\n            // the axis in order to make room for points with a\n            // pointRange, typically columns. When the\n            // pointPlacement option is 'between' or 'on', this\n            // padding does not apply.\n            minPointOffset = Math.max(minPointOffset, isString(pointPlacement) ? 0 : seriesPointRange / 2); // Determine the total padding needed to the length of\n            // the axis to make room for the pointRange. If the\n            // series' pointPlacement is 'on', no padding is added.\n\n            pointRangePadding = Math.max(pointRangePadding, pointPlacement === 'on' ? 0 : seriesPointRange);\n          }\n        });\n      } // Record minPointOffset and pointRangePadding\n\n\n      ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n\n      axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n      axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection; // pointRange means the width reserved for each point, like in a\n      // column chart\n\n      axis.pointRange = Math.min(pointRange, range); // closestPointRange means the closest distance between points. In\n      // columns it is mostly equal to pointRange, but in lines pointRange\n      // is 0 while closestPointRange is some other value\n\n      if (isXAxis) {\n        axis.closestPointRange = closestPointRange;\n      }\n    } // Secondary values\n\n\n    if (saveOld) {\n      axis.oldTransA = transA;\n    }\n\n    axis.translationSlope = axis.transA = transA = axis.options.staticScale || axis.len / (range + pointRangePadding || 1); // Translation addend\n\n    axis.transB = axis.horiz ? axis.left : axis.bottom;\n    axis.minPixelPadding = transA * minPointOffset;\n    fireEvent(this, 'afterSetAxisTranslation');\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Axis#minFromRange\n   *\n   * @return {number}\n   */\n  minFromRange: function minFromRange() {\n    return this.max - this.range;\n  },\n\n  /**\n   * Set the tick positions to round values and optionally extend the extremes\n   * to the nearest tick.\n   *\n   * @private\n   * @function Highcharts.Axis#setTickInterval\n   *\n   * @param {boolean} secondPass\n   *\n   * @fires Highcharts.Axis#event:foundExtremes\n   */\n  setTickInterval: function setTickInterval(secondPass) {\n    var axis = this,\n        chart = axis.chart,\n        options = axis.options,\n        isLog = axis.isLog,\n        isDatetimeAxis = axis.isDatetimeAxis,\n        isXAxis = axis.isXAxis,\n        isLinked = axis.isLinked,\n        maxPadding = options.maxPadding,\n        minPadding = options.minPadding,\n        length,\n        linkedParentExtremes,\n        tickIntervalOption = options.tickInterval,\n        minTickInterval,\n        tickPixelIntervalOption = options.tickPixelInterval,\n        categories = axis.categories,\n        threshold = isNumber(axis.threshold) ? axis.threshold : null,\n        softThreshold = axis.softThreshold,\n        thresholdMin,\n        thresholdMax,\n        hardMin,\n        hardMax;\n\n    if (!isDatetimeAxis && !categories && !isLinked) {\n      this.getTickAmount();\n    } // Min or max set either by zooming/setExtremes or initial options\n\n\n    hardMin = pick(axis.userMin, options.min);\n    hardMax = pick(axis.userMax, options.max); // Linked axis gets the extremes from the parent axis\n\n    if (isLinked) {\n      axis.linkedParent = chart[axis.coll][options.linkedTo];\n      linkedParentExtremes = axis.linkedParent.getExtremes();\n      axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n      axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n\n      if (options.type !== axis.linkedParent.options.type) {\n        H.error(11, 1); // Can't link axes of different type\n      } // Initial min and max from the extreme data values\n\n    } else {\n      // Adjust to hard threshold\n      if (!softThreshold && defined(threshold)) {\n        if (axis.dataMin >= threshold) {\n          thresholdMin = threshold;\n          minPadding = 0;\n        } else if (axis.dataMax <= threshold) {\n          thresholdMax = threshold;\n          maxPadding = 0;\n        }\n      }\n\n      axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n      axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n    }\n\n    if (isLog) {\n      if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0) {\n        // #978\n        H.error(10, 1); // Can't plot negative values on log axis\n      } // The correctFloat cures #934, float errors on full tens. But it\n      // was too aggressive for #4360 because of conversion back to lin,\n      // therefore use precision 15.\n\n\n      axis.min = correctFloat(axis.log2lin(axis.min), 15);\n      axis.max = correctFloat(axis.log2lin(axis.max), 15);\n    } // handle zoomed range\n\n\n    if (axis.range && defined(axis.max)) {\n      axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange()); // #618, #6773\n\n      axis.userMax = hardMax = axis.max;\n      axis.range = null; // don't use it when running setExtremes\n    } // Hook for Highstock Scroller. Consider combining with beforePadding.\n\n\n    fireEvent(axis, 'foundExtremes'); // Hook for adjusting this.min and this.max. Used by bubble series.\n\n    if (axis.beforePadding) {\n      axis.beforePadding();\n    } // adjust min and max for the minimum range\n\n\n    axis.adjustForMinRange(); // Pad the values to get clear of the chart's edges. To avoid\n    // tickInterval taking the padding into account, we do this after\n    // computing tick interval (#1337).\n\n    if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n      length = axis.max - axis.min;\n\n      if (length) {\n        if (!defined(hardMin) && minPadding) {\n          axis.min -= length * minPadding;\n        }\n\n        if (!defined(hardMax) && maxPadding) {\n          axis.max += length * maxPadding;\n        }\n      }\n    } // Handle options for floor, ceiling, softMin and softMax (#6359)\n\n\n    if (isNumber(options.softMin) && !isNumber(axis.userMin)) {\n      axis.min = Math.min(axis.min, options.softMin);\n    }\n\n    if (isNumber(options.softMax) && !isNumber(axis.userMax)) {\n      axis.max = Math.max(axis.max, options.softMax);\n    }\n\n    if (isNumber(options.floor)) {\n      axis.min = Math.max(axis.min, options.floor);\n    }\n\n    if (isNumber(options.ceiling)) {\n      axis.max = Math.min(axis.max, options.ceiling);\n    } // When the threshold is soft, adjust the extreme value only if the data\n    // extreme and the padded extreme land on either side of the threshold.\n    // For example, a series of [0, 1, 2, 3] would make the yAxis add a tick\n    // for -1 because of the default minPadding and startOnTick options.\n    // This is prevented by the softThreshold option.\n\n\n    if (softThreshold && defined(axis.dataMin)) {\n      threshold = threshold || 0;\n\n      if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {\n        axis.min = threshold;\n      } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {\n        axis.max = threshold;\n      }\n    } // get tickInterval\n\n\n    if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n      axis.tickInterval = 1;\n    } else if (isLinked && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n      axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;\n    } else {\n      axis.tickInterval = pick(tickIntervalOption, this.tickAmount ? (axis.max - axis.min) / Math.max(this.tickAmount - 1, 1) : undefined, // For categoried axis, 1 is default, for linear axis use\n      // tickPix\n      categories ? 1 : // don't let it be more than the data range\n      (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption));\n    }\n    /**\n     * Now we're finished detecting min and max, crop and group series data.\n     * This is in turn needed in order to find tick positions in\n     * ordinal axes.\n     */\n\n\n    if (isXAxis && !secondPass) {\n      each(axis.series, function (series) {\n        series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n      });\n    } // set the translation factor used in translate function\n\n\n    axis.setAxisTranslation(true); // hook for ordinal axes and radial axes\n\n    if (axis.beforeSetTickPositions) {\n      axis.beforeSetTickPositions();\n    } // hook for extensions, used in Highstock ordinal axes\n\n\n    if (axis.postProcessTickInterval) {\n      axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n    } // In column-like charts, don't cramp in more ticks than there are\n    // points (#1943, #4184)\n\n\n    if (axis.pointRange && !tickIntervalOption) {\n      axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);\n    } // Before normalizing the tick interval, handle minimum tick interval.\n    // This applies only if tickInterval is not defined.\n\n\n    minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n\n    if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n      axis.tickInterval = minTickInterval;\n    } // for linear axes, get magnitude and normalize the interval\n\n\n    if (!isDatetimeAxis && !isLog && !tickIntervalOption) {\n      axis.tickInterval = normalizeTickInterval(axis.tickInterval, null, getMagnitude(axis.tickInterval), // If the tick interval is between 0.5 and 5 and the axis max is\n      // in the order of thousands, chances are we are dealing with\n      // years. Don't allow decimals. #3363.\n      pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)), !!this.tickAmount);\n    } // Prevent ticks from getting so close that we can't draw the labels\n\n\n    if (!this.tickAmount) {\n      axis.tickInterval = axis.unsquish();\n    }\n\n    this.setTickPositions();\n  },\n\n  /**\n   * Now we have computed the normalized tickInterval, get the tick positions\n   *\n   * @function Highcharts.Axis#setTickPositions\n   *\n   * @fires Highcharts.Axis#event:afterSetTickPositions\n   */\n  setTickPositions: function setTickPositions() {\n    var options = this.options,\n        tickPositions,\n        tickPositionsOption = options.tickPositions,\n        minorTickIntervalOption = this.getMinorTickInterval(),\n        tickPositioner = options.tickPositioner,\n        startOnTick = options.startOnTick,\n        endOnTick = options.endOnTick; // Set the tickmarkOffset\n\n    this.tickmarkOffset = this.categories && options.tickmarkPlacement === 'between' && this.tickInterval === 1 ? 0.5 : 0; // #3202\n    // get minorTickInterval\n\n    this.minorTickInterval = minorTickIntervalOption === 'auto' && this.tickInterval ? this.tickInterval / 5 : minorTickIntervalOption; // When there is only one point, or all points have the same value on\n    // this axis, then min and max are equal and tickPositions.length is 0\n    // or 1. In this case, add some padding in order to center the point,\n    // but leave it with one tick. #1337.\n\n    this.single = this.min === this.max && defined(this.min) && !this.tickAmount && ( // Data is on integer (#6563)\n    parseInt(this.min, 10) === this.min || // Between integers and decimals are not allowed (#6274)\n    options.allowDecimals !== false); // Find the tick positions. Work on a copy (#1565)\n\n    this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice();\n\n    if (!tickPositions) {\n      // Too many ticks (#6405). Create a friendly warning and provide two\n      // ticks so at least we can show the data series.\n      if (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {\n        tickPositions = [this.min, this.max];\n        H.error(19);\n      } else if (this.isDatetimeAxis) {\n        tickPositions = this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, this.ordinalPositions, this.closestPointRange, true);\n      } else if (this.isLog) {\n        tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);\n      } else {\n        tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n      } // Too dense ticks, keep only the first and last (#4477)\n\n\n      if (tickPositions.length > this.len) {\n        tickPositions = [tickPositions[0], tickPositions.pop()]; // Reduce doubled value (#7339)\n\n        if (tickPositions[0] === tickPositions[1]) {\n          tickPositions.length = 1;\n        }\n      }\n\n      this.tickPositions = tickPositions; // Run the tick positioner callback, that allows modifying auto tick\n      // positions.\n\n      if (tickPositioner) {\n        tickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n\n        if (tickPositioner) {\n          this.tickPositions = tickPositions = tickPositioner;\n        }\n      }\n    } // Reset min/max or remove extremes based on start/end on tick\n\n\n    this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor\n\n    this.trimTicks(tickPositions, startOnTick, endOnTick);\n\n    if (!this.isLinked) {\n      // Substract half a unit (#2619, #2846, #2515, #3390),\n      // but not in case of multiple ticks (#6897)\n      if (this.single && tickPositions.length < 2) {\n        this.min -= 0.5;\n        this.max += 0.5;\n      }\n\n      if (!tickPositionsOption && !tickPositioner) {\n        this.adjustTickAmount();\n      }\n    }\n\n    fireEvent(this, 'afterSetTickPositions');\n  },\n\n  /**\n   * Handle startOnTick and endOnTick by either adapting to padding min/max or\n   * rounded min/max. Also handle single data points.\n   *\n   * @private\n   * @function Highcharts.Axis#trimTicks\n   *\n   * @param {Array<number>} tickPositions\n   *\n   * @param {boolean} startOnTicl\n   *\n   * @param {boolean} endOnTick\n   */\n  trimTicks: function trimTicks(tickPositions, startOnTick, endOnTick) {\n    var roundedMin = tickPositions[0],\n        roundedMax = tickPositions[tickPositions.length - 1],\n        minPointOffset = this.minPointOffset || 0;\n\n    if (!this.isLinked) {\n      if (startOnTick && roundedMin !== -Infinity) {\n        // #6502\n        this.min = roundedMin;\n      } else {\n        while (this.min - minPointOffset > tickPositions[0]) {\n          tickPositions.shift();\n        }\n      }\n\n      if (endOnTick) {\n        this.max = roundedMax;\n      } else {\n        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {\n          tickPositions.pop();\n        }\n      } // If no tick are left, set one tick in the middle (#3195)\n\n\n      if (tickPositions.length === 0 && defined(roundedMin) && !this.options.tickPositions) {\n        tickPositions.push((roundedMax + roundedMin) / 2);\n      }\n    }\n  },\n\n  /**\n   * Check if there are multiple axes in the same pane.\n   *\n   * @private\n   * @function Highcharts.Axis#alignToOthers\n   *\n   * @return {boolean}\n   *         True if there are other axes.\n   */\n  alignToOthers: function alignToOthers() {\n    var others = {},\n        // Whether there is another axis to pair with this one\n    hasOther,\n        options = this.options;\n\n    if ( // Only if alignTicks is true\n    this.chart.options.chart.alignTicks !== false && options.alignTicks !== false && // Disabled when startOnTick or endOnTick are false (#7604)\n    options.startOnTick !== false && options.endOnTick !== false && // Don't try to align ticks on a log axis, they are not evenly\n    // spaced (#6021)\n    !this.isLog) {\n      each(this.chart[this.coll], function (axis) {\n        var otherOptions = axis.options,\n            horiz = axis.horiz,\n            key = [horiz ? otherOptions.left : otherOptions.top, otherOptions.width, otherOptions.height, otherOptions.pane].join(',');\n\n        if (axis.series.length) {\n          // #4442\n          if (others[key]) {\n            hasOther = true; // #4201\n          } else {\n            others[key] = 1;\n          }\n        }\n      });\n    }\n\n    return hasOther;\n  },\n\n  /**\n   * Find the max ticks of either the x and y axis collection, and record it\n   * in `this.tickAmount`.\n   *\n   * @private\n   * @function Highcharts.Axis#getTickAmount\n   */\n  getTickAmount: function getTickAmount() {\n    var options = this.options,\n        tickAmount = options.tickAmount,\n        tickPixelInterval = options.tickPixelInterval;\n\n    if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial && !this.isLog && options.startOnTick && options.endOnTick) {\n      tickAmount = 2;\n    }\n\n    if (!tickAmount && this.alignToOthers()) {\n      // Add 1 because 4 tick intervals require 5 ticks (including first\n      // and last)\n      tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;\n    } // For tick amounts of 2 and 3, compute five ticks and remove the\n    // intermediate ones. This prevents the axis from adding ticks that are\n    // too far away from the data extremes.\n\n\n    if (tickAmount < 4) {\n      this.finalTickAmt = tickAmount;\n      tickAmount = 5;\n    }\n\n    this.tickAmount = tickAmount;\n  },\n\n  /**\n   * When using multiple axes, adjust the number of ticks to match the highest\n   * number of ticks in that group.\n   *\n   * @private\n   * @function Highcharts.Axis#adjustTickAmount\n   */\n  adjustTickAmount: function adjustTickAmount() {\n    var tickInterval = this.tickInterval,\n        tickPositions = this.tickPositions,\n        tickAmount = this.tickAmount,\n        finalTickAmt = this.finalTickAmt,\n        currentTickAmount = tickPositions && tickPositions.length,\n        threshold = pick(this.threshold, this.softThreshold ? 0 : null),\n        i,\n        len;\n\n    if (this.hasData()) {\n      if (currentTickAmount < tickAmount) {\n        while (tickPositions.length < tickAmount) {\n          // Extend evenly for both sides unless we're on the\n          // threshold (#3965)\n          if (tickPositions.length % 2 || this.min === threshold) {\n            // to the end\n            tickPositions.push(correctFloat(tickPositions[tickPositions.length - 1] + tickInterval));\n          } else {\n            // to the start\n            tickPositions.unshift(correctFloat(tickPositions[0] - tickInterval));\n          }\n        }\n\n        this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n        this.min = tickPositions[0];\n        this.max = tickPositions[tickPositions.length - 1]; // We have too many ticks, run second pass to try to reduce ticks\n      } else if (currentTickAmount > tickAmount) {\n        this.tickInterval *= 2;\n        this.setTickPositions();\n      } // The finalTickAmt property is set in getTickAmount\n\n\n      if (defined(finalTickAmt)) {\n        i = len = tickPositions.length;\n\n        while (i--) {\n          if ( // Remove every other tick\n          finalTickAmt === 3 && i % 2 === 1 || // Remove all but first and last\n          finalTickAmt <= 2 && i > 0 && i < len - 1) {\n            tickPositions.splice(i, 1);\n          }\n        }\n\n        this.finalTickAmt = undefined;\n      }\n    }\n  },\n\n  /**\n   * Set the scale based on data min and max, user set min and max or options.\n   *\n   * @private\n   * @function Highcharts.Axis#setScale\n   *\n   * @fires Highcharts.Axis#event:afterSetScale\n   */\n  setScale: function setScale() {\n    var axis = this,\n        isDirtyData,\n        isDirtyAxisLength;\n    axis.oldMin = axis.min;\n    axis.oldMax = axis.max;\n    axis.oldAxisLength = axis.len; // set the new axisLength\n\n    axis.setAxisSize();\n    isDirtyAxisLength = axis.len !== axis.oldAxisLength; // is there new data?\n\n    each(axis.series, function (series) {\n      if (series.isDirtyData || series.isDirty || // When x axis is dirty, we need new data extremes for y as well\n      series.xAxis.isDirty) {\n        isDirtyData = true;\n      }\n    }); // do we really need to go through all this?\n\n    if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw || axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {\n      if (axis.resetStacks) {\n        axis.resetStacks();\n      }\n\n      axis.forceRedraw = false; // get data extremes if needed\n\n      axis.getSeriesExtremes(); // get fixed positions based on tickInterval\n\n      axis.setTickInterval(); // record old values to decide whether a rescale is necessary later\n      // on (#540)\n\n      axis.oldUserMin = axis.userMin;\n      axis.oldUserMax = axis.userMax; // Mark as dirty if it is not already set to dirty and extremes have\n      // changed. #595.\n\n      if (!axis.isDirty) {\n        axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n      }\n    } else if (axis.cleanStacks) {\n      axis.cleanStacks();\n    }\n\n    fireEvent(this, 'afterSetScale');\n  },\n\n  /**\n   * Set the minimum and maximum of the axes after render time. If the\n   * `startOnTick` and `endOnTick` options are true, the minimum and maximum\n   * values are rounded off to the nearest tick. To prevent this, these\n   * options can be set to false before calling setExtremes. Also, setExtremes\n   * will not allow a range lower than the `minRange` option, which by default\n   * is the range of five points.\n   *\n   * @sample highcharts/members/axis-setextremes/\n   *         Set extremes from a button\n   * @sample highcharts/members/axis-setextremes-datetime/\n   *         Set extremes on a datetime axis\n   * @sample highcharts/members/axis-setextremes-off-ticks/\n   *         Set extremes off ticks\n   * @sample stock/members/axis-setextremes/\n   *         Set extremes in Highstock\n   * @sample maps/members/axis-setextremes/\n   *         Set extremes in Highmaps\n   *\n   * @function Highcharts.Axis#setExtremes\n   *\n   * @param {number} [newMin]\n   *        The new minimum value.\n   *\n   * @param {number} [newMax]\n   *        The new maximum value.\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart or wait for an explicit call to\n   *        {@link Highcharts.Chart#redraw}\n   *\n   * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]\n   *        Enable or modify animations.\n   *\n   * @param {*} [eventArguments]\n   *        Arguments to be accessed in event handler.\n   *\n   * @fires Highcharts.Axis#event:setExtremes\n   */\n  setExtremes: function setExtremes(newMin, newMax, redraw, animation, eventArguments) {\n    var axis = this,\n        chart = axis.chart;\n    redraw = pick(redraw, true); // defaults to true\n\n    each(axis.series, function (serie) {\n      delete serie.kdTree;\n    }); // Extend the arguments with min and max\n\n    eventArguments = extend(eventArguments, {\n      min: newMin,\n      max: newMax\n    }); // Fire the event\n\n    fireEvent(axis, 'setExtremes', eventArguments, function () {\n      axis.userMin = newMin;\n      axis.userMax = newMax;\n      axis.eventArgs = eventArguments;\n\n      if (redraw) {\n        chart.redraw(animation);\n      }\n    });\n  },\n\n  /**\n   * Overridable method for zooming chart. Pulled out in a separate method to\n   * allow overriding in stock charts.\n   *\n   * @private\n   * @function Highcharts.Axis#zoom\n   *\n   * @param {number} newMin\n   *\n   * @param {number} newMax\n   *\n   * @return {boolean}\n   */\n  zoom: function zoom(newMin, newMax) {\n    var dataMin = this.dataMin,\n        dataMax = this.dataMax,\n        options = this.options,\n        min = Math.min(dataMin, pick(options.min, dataMin)),\n        max = Math.max(dataMax, pick(options.max, dataMax));\n\n    if (newMin !== this.min || newMax !== this.max) {\n      // #5790\n      // Prevent pinch zooming out of range. Check for defined is for\n      // #1946. #1734.\n      if (!this.allowZoomOutside) {\n        // #6014, sometimes newMax will be smaller than min (or newMin\n        // will be larger than max).\n        if (defined(dataMin)) {\n          if (newMin < min) {\n            newMin = min;\n          }\n\n          if (newMin > max) {\n            newMin = max;\n          }\n        }\n\n        if (defined(dataMax)) {\n          if (newMax < min) {\n            newMax = min;\n          }\n\n          if (newMax > max) {\n            newMax = max;\n          }\n        }\n      } // In full view, displaying the reset zoom button is not required\n\n\n      this.displayBtn = newMin !== undefined || newMax !== undefined; // Do it\n\n      this.setExtremes(newMin, newMax, false, undefined, {\n        trigger: 'zoom'\n      });\n    }\n\n    return true;\n  },\n\n  /**\n   * Update the axis metrics.\n   *\n   * @private\n   * @function Highcharts.Axis#setAxisSize\n   */\n  setAxisSize: function setAxisSize() {\n    var chart = this.chart,\n        options = this.options,\n        // [top, right, bottom, left]\n    offsets = options.offsets || [0, 0, 0, 0],\n        horiz = this.horiz,\n        // Check for percentage based input values. Rounding fixes problems\n    // with column overflow and plot line filtering (#4898, #4899)\n    width = this.width = Math.round(H.relativeLength(pick(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)),\n        height = this.height = Math.round(H.relativeLength(pick(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)),\n        top = this.top = Math.round(H.relativeLength(pick(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)),\n        left = this.left = Math.round(H.relativeLength(pick(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft)); // Expose basic values to use in Series object and navigator\n\n    this.bottom = chart.chartHeight - height - top;\n    this.right = chart.chartWidth - width - left; // Direction agnostic properties\n\n    this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905\n\n    this.pos = horiz ? left : top; // distance from SVG origin\n  },\n\n  /**\n   * Get the current extremes for the axis.\n   *\n   * @sample highcharts/members/axis-getextremes/\n   *         Report extremes by click on a button\n   * @sample maps/members/axis-getextremes/\n   *         Get extremes in Highmaps\n   *\n   * @function Highcharts.Axis#getExtremes\n   *\n   * @returns {Highcharts.ExtremesObject}\n   *          An object containing extremes information.\n   */\n  getExtremes: function getExtremes() {\n    var axis = this,\n        isLog = axis.isLog;\n    return {\n      min: isLog ? correctFloat(axis.lin2log(axis.min)) : axis.min,\n      max: isLog ? correctFloat(axis.lin2log(axis.max)) : axis.max,\n      dataMin: axis.dataMin,\n      dataMax: axis.dataMax,\n      userMin: axis.userMin,\n      userMax: axis.userMax\n    };\n  },\n\n  /**\n   * Get the zero plane either based on zero or on the min or max value.\n   * Used in bar and area plots.\n   *\n   * @function Highcharts.Axis#getThreshold\n   *\n   * @param {number} threshold\n   *        The threshold in axis values.\n   *\n   * @return {number}\n   *         The translated threshold position in terms of pixels, and\n   *         corrected to stay within the axis bounds.\n   */\n  getThreshold: function getThreshold(threshold) {\n    var axis = this,\n        isLog = axis.isLog,\n        realMin = isLog ? axis.lin2log(axis.min) : axis.min,\n        realMax = isLog ? axis.lin2log(axis.max) : axis.max;\n\n    if (threshold === null || threshold === -Infinity) {\n      threshold = realMin;\n    } else if (threshold === Infinity) {\n      threshold = realMax;\n    } else if (realMin > threshold) {\n      threshold = realMin;\n    } else if (realMax < threshold) {\n      threshold = realMax;\n    }\n\n    return axis.translate(threshold, 0, 1, 0, 1);\n  },\n\n  /**\n   * Compute auto alignment for the axis label based on which side the axis is\n   * on and the given rotation for the label.\n   *\n   * @private\n   * @function Highcharts.Axis#autoLabelAlign\n   *\n   * @param {number} rotation\n   *        The rotation in degrees as set by either the `rotation` or\n   *        `autoRotation` options.\n   *\n   * @return {string}\n   *         Can be `center`, `left` or `right`.\n   */\n  autoLabelAlign: function autoLabelAlign(rotation) {\n    var ret,\n        angle = (pick(rotation, 0) - this.side * 90 + 720) % 360;\n\n    if (angle > 15 && angle < 165) {\n      ret = 'right';\n    } else if (angle > 195 && angle < 345) {\n      ret = 'left';\n    } else {\n      ret = 'center';\n    }\n\n    return ret;\n  },\n\n  /**\n   * Get the tick length and width for the axis based on axis options.\n   *\n   * @private\n   * @function Highcharts.Axis#tickSize\n   *\n   * @param {string} prefix\n   *        'tick' or 'minorTick'\n   *\n   * @return {Array<number>}\n   *         An array of tickLength and tickWidth\n   */\n  tickSize: function tickSize(prefix) {\n    var options = this.options,\n        tickLength = options[prefix + 'Length'],\n        tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0 // X axis default 1\n    );\n\n    if (tickWidth && tickLength) {\n      // Negate the length\n      if (options[prefix + 'Position'] === 'inside') {\n        tickLength = -tickLength;\n      }\n\n      return [tickLength, tickWidth];\n    }\n  },\n\n  /**\n   * Return the size of the labels.\n   *\n   * @private\n   * @function Highcharts.Axis#labelMetrics\n   *\n   * @return {Highcharts.FontMetricsObject}\n   */\n  labelMetrics: function labelMetrics() {\n    var index = this.tickPositions && this.tickPositions[0] || 0;\n    return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[index] && this.ticks[index].label);\n  },\n\n  /**\n   * Prevent the ticks from getting so close we can't draw the labels. On a\n   * horizontal axis, this is handled by rotating the labels, removing ticks\n   * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.\n   *\n   * @private\n   * @function Highcharts.Axis#unsquish\n   *\n   * @return {number}\n   */\n  unsquish: function unsquish() {\n    var labelOptions = this.options.labels,\n        horiz = this.horiz,\n        tickInterval = this.tickInterval,\n        newTickInterval = tickInterval,\n        slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n        rotation,\n        rotationOption = labelOptions.rotation,\n        labelMetrics = this.labelMetrics(),\n        step,\n        bestScore = Number.MAX_VALUE,\n        autoRotation,\n        // Return the multiple of tickInterval that is needed to avoid\n    // collision\n    getStep = function getStep(spaceNeeded) {\n      var step = spaceNeeded / (slotSize || 1);\n      step = step > 1 ? Math.ceil(step) : 1;\n      return correctFloat(step * tickInterval);\n    };\n\n    if (horiz) {\n      autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971\n      defined(rotationOption) ? [rotationOption] : slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation);\n\n      if (autoRotation) {\n        // Loop over the given autoRotation options, and determine\n        // which gives the best score. The best score is that with\n        // the lowest number of steps and a rotation closest\n        // to horizontal.\n        each(autoRotation, function (rot) {\n          var score;\n\n          if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {\n            // #3891\n            step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));\n            score = step + Math.abs(rot / 360);\n\n            if (score < bestScore) {\n              bestScore = score;\n              rotation = rot;\n              newTickInterval = step;\n            }\n          }\n        });\n      }\n    } else if (!labelOptions.step) {\n      // #4411\n      newTickInterval = getStep(labelMetrics.h);\n    }\n\n    this.autoRotation = autoRotation;\n    this.labelRotation = pick(rotation, rotationOption);\n    return newTickInterval;\n  },\n\n  /**\n   * Get the general slot width for labels/categories on this axis. This may\n   * change between the pre-render (from Axis.getOffset) and the final tick\n   * rendering and placement.\n   *\n   * @private\n   * @function Highcharts.Axis#getSlotWidth\n   *\n   * @param {*} [tick]\n   *        Optionally, calculate the slot width basing on tick label. It is\n   *        used in highcharts-3d module, where the slots has different widths\n   *        depending on perspective angles.\n   *\n   * @return {number}\n   *         The pixel width allocated to each axis label.\n   */\n  getSlotWidth: function getSlotWidth() {\n    // #5086, #1580, #1931\n    var chart = this.chart,\n        horiz = this.horiz,\n        labelOptions = this.options.labels,\n        slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n        marginLeft = chart.margin[3];\n    return horiz && (labelOptions.step || 0) < 2 && !labelOptions.rotation && // #4415\n    (this.staggerLines || 1) * this.len / slotCount || !horiz && ( // #7028\n    labelOptions.style && parseInt(labelOptions.style.width, 10) || marginLeft && marginLeft - chart.spacing[3] || chart.chartWidth * 0.33);\n  },\n\n  /**\n   * Render the axis labels and determine whether ellipsis or rotation need\n   * to be applied.\n   *\n   * @private\n   * @function Highcharts.Axis#renderUnsquish\n   */\n  renderUnsquish: function renderUnsquish() {\n    var chart = this.chart,\n        renderer = chart.renderer,\n        tickPositions = this.tickPositions,\n        ticks = this.ticks,\n        labelOptions = this.options.labels,\n        labelStyleOptions = labelOptions && labelOptions.style || {},\n        horiz = this.horiz,\n        slotWidth = this.getSlotWidth(),\n        innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),\n        attr = {},\n        labelMetrics = this.labelMetrics(),\n        textOverflowOption = labelOptions.style && labelOptions.style.textOverflow,\n        commonWidth,\n        commonTextOverflow,\n        maxLabelLength = 0,\n        label,\n        i,\n        pos; // Set rotation option unless it is \"auto\", like in gauges\n\n    if (!isString(labelOptions.rotation)) {\n      attr.rotation = labelOptions.rotation || 0; // #4443\n    } // Get the longest label length\n\n\n    each(tickPositions, function (tick) {\n      tick = ticks[tick];\n\n      if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {\n        maxLabelLength = tick.label.textPxLength;\n      }\n    });\n    this.maxLabelLength = maxLabelLength; // Handle auto rotation on horizontal axis\n\n    if (this.autoRotation) {\n      // Apply rotation only if the label is too wide for the slot, and\n      // the label is wider than its height.\n      if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {\n        attr.rotation = this.labelRotation;\n      } else {\n        this.labelRotation = 0;\n      } // Handle word-wrap or ellipsis on vertical axis\n\n    } else if (slotWidth) {\n      // For word-wrap or ellipsis\n      commonWidth = innerWidth;\n\n      if (!textOverflowOption) {\n        commonTextOverflow = 'clip'; // On vertical axis, only allow word wrap if there is room\n        // for more lines.\n\n        i = tickPositions.length;\n\n        while (!horiz && i--) {\n          pos = tickPositions[i];\n          label = ticks[pos].label;\n\n          if (label) {\n            // Reset ellipsis in order to get the correct\n            // bounding box (#4070)\n            if (label.styles && label.styles.textOverflow === 'ellipsis') {\n              label.css({\n                textOverflow: 'clip'\n              }); // Set the correct width in order to read\n              // the bounding box height (#4678, #5034)\n            } else if (label.textPxLength > slotWidth) {\n              label.css({\n                width: slotWidth + 'px'\n              });\n            }\n\n            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {\n              label.specificTextOverflow = 'ellipsis';\n            }\n          }\n        }\n      }\n    } // Add ellipsis if the label length is significantly longer than ideal\n\n\n    if (attr.rotation) {\n      commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;\n\n      if (!textOverflowOption) {\n        commonTextOverflow = 'ellipsis';\n      }\n    } // Set the explicit or automatic label alignment\n\n\n    this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n\n    if (this.labelAlign) {\n      attr.align = this.labelAlign;\n    } // Apply general and specific CSS\n\n\n    each(tickPositions, function (pos) {\n      var tick = ticks[pos],\n          label = tick && tick.label,\n          widthOption = labelStyleOptions.width,\n          css = {};\n\n      if (label) {\n        // This needs to go before the CSS in old IE (#4502)\n        label.attr(attr);\n\n        if (commonWidth && !widthOption && // Setting width in this case messes with the bounding box\n        // (#7975)\n        labelStyleOptions.whiteSpace !== 'nowrap' && ( // Speed optimizing, #7656\n        commonWidth < label.textPxLength || // Resetting CSS, #4928\n        label.element.tagName === 'SPAN')) {\n          css.width = commonWidth;\n\n          if (!textOverflowOption) {\n            css.textOverflow = label.specificTextOverflow || commonTextOverflow;\n          }\n\n          label.css(css); // Reset previously shortened label (#8210)\n        } else if (label.styles && label.styles.width && !css.width && !widthOption) {\n          label.css({\n            width: null\n          });\n        }\n\n        delete label.specificTextOverflow;\n        tick.rotation = attr.rotation;\n      }\n    }); // Note: Why is this not part of getLabelPosition?\n\n    this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n  },\n\n  /**\n   * Return true if the axis has associated data.\n   *\n   * @function Highcharts.Axis#hasData\n   *\n   * @return {boolean}\n   *         True if the axis has associated visible series and those series\n   *         have either valid data points or explicit `min` and `max`\n   *         settings.\n   */\n  hasData: function hasData() {\n    return this.hasVisibleSeries || defined(this.min) && defined(this.max) && this.tickPositions && this.tickPositions.length > 0;\n  },\n\n  /**\n   * Adds the title defined in axis.options.title.\n   *\n   * @function Highcharts.Axis#addTitle\n   *\n   * @param {boolean} display\n   *        Whether or not to display the title.\n   */\n  addTitle: function addTitle(display) {\n    var axis = this,\n        renderer = axis.chart.renderer,\n        horiz = axis.horiz,\n        opposite = axis.opposite,\n        options = axis.options,\n        axisTitleOptions = options.title,\n        textAlign;\n\n    if (!axis.axisTitle) {\n      textAlign = axisTitleOptions.textAlign;\n\n      if (!textAlign) {\n        textAlign = (horiz ? {\n          low: 'left',\n          middle: 'center',\n          high: 'right'\n        } : {\n          low: opposite ? 'right' : 'left',\n          middle: 'center',\n          high: opposite ? 'left' : 'right'\n        })[axisTitleOptions.align];\n      }\n\n      axis.axisTitle = renderer.text(axisTitleOptions.text, 0, 0, axisTitleOptions.useHTML).attr({\n        zIndex: 7,\n        rotation: axisTitleOptions.rotation || 0,\n        align: textAlign\n      }).addClass('highcharts-axis-title').add(axis.axisGroup);\n      axis.axisTitle.isNew = true;\n    } // Max width defaults to the length of the axis\n\n\n    axis.axisTitle.css({\n      width: axis.len\n    }); // hide or show the title depending on whether showEmpty is set\n\n    axis.axisTitle[display ? 'show' : 'hide'](true);\n  },\n\n  /**\n   * Generates a tick for initial positioning.\n   *\n   * @private\n   * @function Highcharts.Axis#generateTick\n   *\n   * @param {number} pos\n   *        The tick position in axis values.\n   *\n   * @param {number} i\n   *        The index of the tick in {@link Axis.tickPositions}.\n   */\n  generateTick: function generateTick(pos) {\n    var ticks = this.ticks;\n\n    if (!ticks[pos]) {\n      ticks[pos] = new Tick(this, pos);\n    } else {\n      ticks[pos].addLabel(); // update labels depending on tick interval\n    }\n  },\n\n  /**\n   * Render the tick labels to a preliminary position to get their sizes.\n   *\n   * @private\n   * @function Highcharts.Axis#getOffset\n   *\n   * @fires Highcharts.Axis#event:afterGetOffset\n   */\n  getOffset: function getOffset() {\n    var axis = this,\n        chart = axis.chart,\n        renderer = chart.renderer,\n        options = axis.options,\n        tickPositions = axis.tickPositions,\n        ticks = axis.ticks,\n        horiz = axis.horiz,\n        side = axis.side,\n        invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side,\n        hasData,\n        showAxis,\n        titleOffset = 0,\n        titleOffsetOption,\n        titleMargin = 0,\n        axisTitleOptions = options.title,\n        labelOptions = options.labels,\n        labelOffset = 0,\n        // reset\n    labelOffsetPadded,\n        axisOffset = chart.axisOffset,\n        clipOffset = chart.clipOffset,\n        clip,\n        directionFactor = [-1, 1, 1, -1][side],\n        className = options.className,\n        axisParent = axis.axisParent,\n        // Used in color axis\n    lineHeightCorrection,\n        tickSize = this.tickSize('tick'); // For reuse in Axis.render\n\n    hasData = axis.hasData();\n    axis.showAxis = showAxis = hasData || pick(options.showEmpty, true); // Set/reset staggerLines\n\n    axis.staggerLines = axis.horiz && labelOptions.staggerLines; // Create the axisGroup and gridGroup elements on first iteration\n\n    if (!axis.axisGroup) {\n      axis.gridGroup = renderer.g('grid').attr({\n        zIndex: options.gridZIndex || 1\n      }).addClass('highcharts-' + this.coll.toLowerCase() + '-grid ' + (className || '')).add(axisParent);\n      axis.axisGroup = renderer.g('axis').attr({\n        zIndex: options.zIndex || 2\n      }).addClass('highcharts-' + this.coll.toLowerCase() + ' ' + (className || '')).add(axisParent);\n      axis.labelGroup = renderer.g('axis-labels').attr({\n        zIndex: labelOptions.zIndex || 7\n      }).addClass('highcharts-' + axis.coll.toLowerCase() + '-labels ' + (className || '')).add(axisParent);\n    }\n\n    if (hasData || axis.isLinked) {\n      // Generate ticks\n      each(tickPositions, function (pos, i) {\n        // i is not used here, but may be used in overrides\n        axis.generateTick(pos, i);\n      });\n      axis.renderUnsquish(); // Left side must be align: right and right side must\n      // have align: left for labels\n\n      axis.reserveSpaceDefault = side === 0 || side === 2 || {\n        1: 'left',\n        3: 'right'\n      }[side] === axis.labelAlign;\n\n      if (pick(labelOptions.reserveSpace, axis.labelAlign === 'center' ? true : null, axis.reserveSpaceDefault)) {\n        each(tickPositions, function (pos) {\n          // get the highest offset\n          labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);\n        });\n      }\n\n      if (axis.staggerLines) {\n        labelOffset *= axis.staggerLines;\n      }\n\n      axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n    } else {\n      // doesn't have data\n      objectEach(ticks, function (tick, n) {\n        tick.destroy();\n        delete ticks[n];\n      });\n    }\n\n    if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n      axis.addTitle(showAxis);\n\n      if (showAxis && axisTitleOptions.reserveSpace !== false) {\n        axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n        titleOffsetOption = axisTitleOptions.offset;\n        titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n      }\n    } // Render the axis line\n\n\n    axis.renderLine(); // handle automatic or user set offset\n\n    axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n    axis.tickRotCorr = axis.tickRotCorr || {\n      x: 0,\n      y: 0\n    }; // polar\n\n    if (side === 0) {\n      lineHeightCorrection = -axis.labelMetrics().h;\n    } else if (side === 2) {\n      lineHeightCorrection = axis.tickRotCorr.y;\n    } else {\n      lineHeightCorrection = 0;\n    } // Find the padded label offset\n\n\n    labelOffsetPadded = Math.abs(labelOffset) + titleMargin;\n\n    if (labelOffset) {\n      labelOffsetPadded -= lineHeightCorrection;\n      labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);\n    }\n\n    axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n    axisOffset[side] = Math.max(axisOffset[side], axis.axisTitleMargin + titleOffset + directionFactor * axis.offset, labelOffsetPadded, // #3027\n    hasData && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0 // #4866\n    ); // Decide the clipping needed to keep the graph inside\n    // the plot area and axis lines\n\n    clip = options.offset ? 0 : Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371\n\n    clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);\n    fireEvent(this, 'afterGetOffset');\n  },\n\n  /**\n   * Internal function to get the path for the axis line. Extended for polar\n   * charts.\n   *\n   * @function Highcharts.Axis#getLinePath\n   *\n   * @param {number} lineWidth\n   *        The line width in pixels.\n   *\n   * @return {Highcharts.SVGPathArray}\n   *         The SVG path definition in array form.\n   */\n  getLinePath: function getLinePath(lineWidth) {\n    var chart = this.chart,\n        opposite = this.opposite,\n        offset = this.offset,\n        horiz = this.horiz,\n        lineLeft = this.left + (opposite ? this.width : 0) + offset,\n        lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n\n    if (opposite) {\n      lineWidth *= -1; // crispify the other way - #1480, #1687\n    }\n\n    return chart.renderer.crispLine(['M', horiz ? this.left : lineLeft, horiz ? lineTop : this.top, 'L', horiz ? chart.chartWidth - this.right : lineLeft, horiz ? lineTop : chart.chartHeight - this.bottom], lineWidth);\n  },\n\n  /**\n   * Render the axis line. Called internally when rendering and redrawing the\n   * axis.\n   *\n   * @function Highcharts.Axis#renderLine\n   */\n  renderLine: function renderLine() {\n    if (!this.axisLine) {\n      this.axisLine = this.chart.renderer.path().addClass('highcharts-axis-line').add(this.axisGroup);\n    }\n  },\n\n  /**\n   * Position the axis title.\n   *\n   * @private\n   * @function Highcharts.Axis#getTitlePosition\n   *\n   * @return {Highcharts.AxisTitlePositionObject}\n   *         X and Y positions for the title.\n   */\n  getTitlePosition: function getTitlePosition() {\n    // compute anchor points for each of the title align options\n    var horiz = this.horiz,\n        axisLeft = this.left,\n        axisTop = this.top,\n        axisLength = this.len,\n        axisTitleOptions = this.options.title,\n        margin = horiz ? axisLeft : axisTop,\n        opposite = this.opposite,\n        offset = this.offset,\n        xOption = axisTitleOptions.x || 0,\n        yOption = axisTitleOptions.y || 0,\n        axisTitle = this.axisTitle,\n        fontMetrics = this.chart.renderer.fontMetrics(axisTitleOptions.style && axisTitleOptions.style.fontSize, axisTitle),\n        // The part of a multiline text that is below the baseline of the\n    // first line. Subtract 1 to preserve pixel-perfectness from the\n    // old behaviour (v5.0.12), where only one line was allowed.\n    textHeightOvershoot = Math.max(axisTitle.getBBox(null, 0).height - fontMetrics.h - 1, 0),\n        // the position in the length direction of the axis\n    alongAxis = {\n      low: margin + (horiz ? 0 : axisLength),\n      middle: margin + axisLength / 2,\n      high: margin + (horiz ? axisLength : 0)\n    }[axisTitleOptions.align],\n        // the position in the perpendicular direction of the axis\n    offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * ( // horizontal axis reverses the margin\n    opposite ? -1 : 1) * // so does opposite axes\n    this.axisTitleMargin + [-textHeightOvershoot, // top\n    textHeightOvershoot, // right\n    fontMetrics.f, // bottom\n    -textHeightOvershoot // left\n    ][this.side];\n    return {\n      x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,\n      y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption\n    };\n  },\n\n  /**\n   * Render a minor tick into the given position. If a minor tick already\n   * exists in this position, move it.\n   *\n   * @function Highcharts.Axis#renderMinorTick\n   *\n   * @param {number} pos\n   *        The position in axis values.\n   */\n  renderMinorTick: function renderMinorTick(pos) {\n    var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),\n        minorTicks = this.minorTicks;\n\n    if (!minorTicks[pos]) {\n      minorTicks[pos] = new Tick(this, pos, 'minor');\n    } // Render new ticks in old position\n\n\n    if (slideInTicks && minorTicks[pos].isNew) {\n      minorTicks[pos].render(null, true);\n    }\n\n    minorTicks[pos].render(null, false, 1);\n  },\n\n  /**\n   * Render a major tick into the given position. If a tick already exists\n   * in this position, move it.\n   *\n   * @function Highcharts.Axis#renderTick\n   *\n   * @param {number} pos\n   *        The position in axis values.\n   *\n   * @param {number} i\n   *        The tick index.\n   */\n  renderTick: function renderTick(pos, i) {\n    var isLinked = this.isLinked,\n        ticks = this.ticks,\n        slideInTicks = this.chart.hasRendered && isNumber(this.oldMin); // Linked axes need an extra check to find out if\n\n    if (!isLinked || pos >= this.min && pos <= this.max) {\n      if (!ticks[pos]) {\n        ticks[pos] = new Tick(this, pos);\n      } // render new ticks in old position\n\n\n      if (slideInTicks && ticks[pos].isNew) {\n        ticks[pos].render(i, true, 0.1);\n      }\n\n      ticks[pos].render(i);\n    }\n  },\n\n  /**\n   * Render the axis.\n   *\n   * @private\n   * @function Highcharts.Axis#render\n   *\n   * @fires Highcharts.Axis#event:afterRender\n   */\n  render: function render() {\n    var axis = this,\n        chart = axis.chart,\n        renderer = chart.renderer,\n        options = axis.options,\n        isLog = axis.isLog,\n        isLinked = axis.isLinked,\n        tickPositions = axis.tickPositions,\n        axisTitle = axis.axisTitle,\n        ticks = axis.ticks,\n        minorTicks = axis.minorTicks,\n        alternateBands = axis.alternateBands,\n        stackLabelOptions = options.stackLabels,\n        alternateGridColor = options.alternateGridColor,\n        tickmarkOffset = axis.tickmarkOffset,\n        axisLine = axis.axisLine,\n        showAxis = axis.showAxis,\n        animation = animObject(renderer.globalAnimation),\n        from,\n        to; // Reset\n\n    axis.labelEdge.length = 0;\n    axis.overlap = false; // Mark all elements inActive before we go over and mark the active ones\n\n    each([ticks, minorTicks, alternateBands], function (coll) {\n      objectEach(coll, function (tick) {\n        tick.isActive = false;\n      });\n    }); // If the series has data draw the ticks. Else only the line and title\n\n    if (axis.hasData() || isLinked) {\n      // minor ticks\n      if (axis.minorTickInterval && !axis.categories) {\n        each(axis.getMinorTickPositions(), function (pos) {\n          axis.renderMinorTick(pos);\n        });\n      } // Major ticks. Pull out the first item and render it last so that\n      // we can get the position of the neighbour label. #808.\n\n\n      if (tickPositions.length) {\n        // #1300\n        each(tickPositions, function (pos, i) {\n          axis.renderTick(pos, i);\n        }); // In a categorized axis, the tick marks are displayed\n        // between labels. So we need to add a tick mark and\n        // grid line at the left edge of the X axis.\n\n        if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n          if (!ticks[-1]) {\n            ticks[-1] = new Tick(axis, -1, null, true);\n          }\n\n          ticks[-1].render(-1);\n        }\n      } // alternate grid color\n\n\n      if (alternateGridColor) {\n        each(tickPositions, function (pos, i) {\n          to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;\n\n          if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {\n            // #2248, #4660\n            if (!alternateBands[pos]) {\n              alternateBands[pos] = new H.PlotLineOrBand(axis);\n            }\n\n            from = pos + tickmarkOffset; // #949\n\n            alternateBands[pos].options = {\n              from: isLog ? axis.lin2log(from) : from,\n              to: isLog ? axis.lin2log(to) : to,\n              color: alternateGridColor\n            };\n            alternateBands[pos].render();\n            alternateBands[pos].isActive = true;\n          }\n        });\n      } // custom plot lines and bands\n\n\n      if (!axis._addedPlotLB) {\n        // only first time\n        each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n          axis.addPlotBandOrLine(plotLineOptions);\n        });\n        axis._addedPlotLB = true;\n      }\n    } // end if hasData\n    // Remove inactive ticks\n\n\n    each([ticks, minorTicks, alternateBands], function (coll) {\n      var i,\n          forDestruction = [],\n          delay = animation.duration,\n          destroyInactiveItems = function destroyInactiveItems() {\n        i = forDestruction.length;\n\n        while (i--) {\n          // When resizing rapidly, the same items\n          // may be destroyed in different timeouts,\n          // or the may be reactivated\n          if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n            coll[forDestruction[i]].destroy();\n            delete coll[forDestruction[i]];\n          }\n        }\n      };\n\n      objectEach(coll, function (tick, pos) {\n        if (!tick.isActive) {\n          // Render to zero opacity\n          tick.render(pos, false, 0);\n          tick.isActive = false;\n          forDestruction.push(pos);\n        }\n      }); // When the objects are finished fading out, destroy them\n\n      syncTimeout(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);\n    }); // Set the axis line path\n\n    if (axisLine) {\n      axisLine[axisLine.isPlaced ? 'animate' : 'attr']({\n        d: this.getLinePath(axisLine.strokeWidth())\n      });\n      axisLine.isPlaced = true; // Show or hide the line depending on options.showEmpty\n\n      axisLine[showAxis ? 'show' : 'hide'](true);\n    }\n\n    if (axisTitle && showAxis) {\n      var titleXy = axis.getTitlePosition();\n\n      if (isNumber(titleXy.y)) {\n        axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);\n        axisTitle.isNew = false;\n      } else {\n        axisTitle.attr('y', -9999);\n        axisTitle.isNew = true;\n      }\n    } // Stacked totals:\n\n\n    if (stackLabelOptions && stackLabelOptions.enabled) {\n      axis.renderStackTotals();\n    } // End stacked totals\n\n\n    axis.isDirty = false;\n    fireEvent(this, 'afterRender');\n  },\n\n  /**\n   * Redraw the axis to reflect changes in the data or axis extremes. Called\n   * internally from {@link Chart#redraw}.\n   *\n   * @private\n   * @function Highcharts.Axis#redraw\n   */\n  redraw: function redraw() {\n    if (this.visible) {\n      // render the axis\n      this.render(); // move plot lines and bands\n\n      each(this.plotLinesAndBands, function (plotLine) {\n        plotLine.render();\n      });\n    } // mark associated series as dirty and ready for redraw\n\n\n    each(this.series, function (series) {\n      series.isDirty = true;\n    });\n  },\n  // Properties to survive after destroy, needed for Axis.update (#4317,\n  // #5773, #5881).\n  keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],\n\n  /**\n   * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint\n   * to fully remove the axis.\n   *\n   * @private\n   * @function Highcharts.Axis#destroy\n   *\n   * @param {boolean} keepEvents\n   *        Whether to preserve events, used internally in Axis.update.\n   */\n  destroy: function destroy(keepEvents) {\n    var axis = this,\n        stacks = axis.stacks,\n        plotLinesAndBands = axis.plotLinesAndBands,\n        plotGroup,\n        i;\n    fireEvent(this, 'destroy', {\n      keepEvents: keepEvents\n    }); // Remove the events\n\n    if (!keepEvents) {\n      removeEvent(axis);\n    } // Destroy each stack total\n\n\n    objectEach(stacks, function (stack, stackKey) {\n      destroyObjectProperties(stack);\n      stacks[stackKey] = null;\n    }); // Destroy collections\n\n    each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {\n      destroyObjectProperties(coll);\n    });\n\n    if (plotLinesAndBands) {\n      i = plotLinesAndBands.length;\n\n      while (i--) {\n        // #1975\n        plotLinesAndBands[i].destroy();\n      }\n    } // Destroy elements\n\n\n    each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross', 'scrollbar'], function (prop) {\n      if (axis[prop]) {\n        axis[prop] = axis[prop].destroy();\n      }\n    }); // Destroy each generated group for plotlines and plotbands\n\n    for (plotGroup in axis.plotLinesAndBandsGroups) {\n      axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();\n    } // Delete all properties and fall back to the prototype.\n\n\n    objectEach(axis, function (val, key) {\n      if (inArray(key, axis.keepProps) === -1) {\n        delete axis[key];\n      }\n    });\n  },\n\n  /**\n   * Internal function to draw a crosshair.\n   *\n   * @function Highcharts.Axis#drawCrosshair\n   *\n   * @param {Highcharts.PointerEventObject} [e]\n   *        The event arguments from the modified pointer event, extended with\n   *        `chartX` and `chartY`\n   *\n   * @param {Highcharts.Point} [point]\n   *        The Point object if the crosshair snaps to points.\n   *\n   * @fires Highcharts.Axis#event:afterDrawCrosshair\n   * @fires Highcharts.Axis#event:drawCrosshair\n   */\n  drawCrosshair: function drawCrosshair(e, point) {\n    var path,\n        options = this.crosshair,\n        snap = pick(options.snap, true),\n        pos,\n        categorized,\n        graphic = this.cross;\n    fireEvent(this, 'drawCrosshair', {\n      e: e,\n      point: point\n    }); // Use last available event when updating non-snapped crosshairs without\n    // mouse interaction (#5287)\n\n    if (!e) {\n      e = this.cross && this.cross.e;\n    }\n\n    if ( // Disabled in options\n    !this.crosshair || // Snap\n    (defined(point) || !snap) === false) {\n      this.hideCrosshair();\n    } else {\n      // Get the path\n      if (!snap) {\n        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n      } else if (defined(point)) {\n        // #3834\n        pos = pick(point.crosshairPos, // 3D axis extension\n        this.isXAxis ? point.plotX : this.len - point.plotY);\n      }\n\n      if (defined(pos)) {\n        path = this.getPlotLinePath( // First argument, value, only used on radial\n        point && (this.isXAxis ? point.x : pick(point.stackY, point.y)), null, null, null, pos // Translated position\n        ) || null; // #3189\n      }\n\n      if (!defined(path)) {\n        this.hideCrosshair();\n        return;\n      }\n\n      categorized = this.categories && !this.isRadial; // Draw the cross\n\n      if (!graphic) {\n        this.cross = graphic = this.chart.renderer.path().addClass('highcharts-crosshair highcharts-crosshair-' + (categorized ? 'category ' : 'thin ') + options.className).attr({\n          zIndex: pick(options.zIndex, 2)\n        }).add();\n      }\n\n      graphic.show().attr({\n        d: path\n      });\n\n      if (categorized && !options.width) {\n        graphic.attr({\n          'stroke-width': this.transA\n        });\n      }\n\n      this.cross.e = e;\n    }\n\n    fireEvent(this, 'afterDrawCrosshair', {\n      e: e,\n      point: point\n    });\n  },\n\n  /**\n   * Hide the crosshair if visible.\n   *\n   * @function Highcharts.Axis#hideCrosshair\n   */\n  hideCrosshair: function hideCrosshair() {\n    if (this.cross) {\n      this.cross.hide();\n    }\n  }\n}); // end Axis\n\nH.Axis = Axis;\nexport default Axis;"
    },
    {
     "id": 247,
     "name": "../node_modules/highcharts/js/es-modules/parts/Point.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Configuration hash for the data label and tooltip formatters.\n *\n * @typedef Highcharts.PointLabelObject\n *\n * @property {number|string} x\n *           For categorized axes this property holds the category name for the\n *           point. For other axes it holds the X value.\n *\n * @property {number} [y]\n *           The y value of the point.\n *\n * @property {Highcharts.ColorString} color\n *           The point's current color.\n *\n * @property {number} colorIndex\n *           The point's current color index, used in styled mode instead of\n *           `color`. The color index is inserted in class names used for\n *           styling.\n *\n * @property {number|string} key\n *           The name of the related point.\n *\n * @property {Highcharts.Series} series\n *           The related series.\n *\n * @property {Highcharts.Point} point\n *           The related point.\n *\n * @property {number} percentage\n *           The percentage for related points in a stacked series or pies.\n *\n * @property {number} total\n *           The total of values in either a stack for stacked series, or a pie\n *           in a pie series.\n */\n'use strict';\n\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport Highcharts from './Globals.js';\nimport './Utilities.js';\nvar Point,\n    H = Highcharts,\n    each = H.each,\n    extend = H.extend,\n    erase = H.erase,\n    fireEvent = H.fireEvent,\n    format = H.format,\n    isArray = H.isArray,\n    isNumber = H.isNumber,\n    pick = H.pick,\n    removeEvent = H.removeEvent;\n/**\n * The Point object. The point objects are generated from the `series.data`\n * configuration objects or raw numbers. They can be accessed from the\n * `Series.points` array. Other ways to instantiate points are through {@link\n * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.\n *\n * @class\n * @name Highcharts.Point\n */\n\nHighcharts.Point = Point = function Point() {};\n\nHighcharts.Point.prototype = {\n  /**\n   * Initialize the point. Called internally based on the `series.data`\n   * option.\n   *\n   * @function Highcharts.Point#init\n   *\n   * @param {Highcharts.Series} series\n   *        The series object containing this point.\n   *\n   * @param {number|Array<number>|*} options\n   *        The data in either number, array or object format.\n   *\n   * @param {number} x\n   *        Optionally, the X value of the point.\n   *\n   * @return {Highcharts.Point}\n   *         The Point instance.\n   *\n   * @fires Highcharts.Point#event:afterInit\n   */\n  init: function init(series, options, x) {\n    var point = this,\n        colors,\n        colorCount = series.chart.options.chart.colorCount,\n        colorIndex;\n    /**\n     * The series object associated with the point.\n     *\n     * @name Highcharts.Point#series\n     * @type {Highcharts.Series}\n     */\n\n    point.series = series;\n    point.applyOptions(options, x);\n\n    if (series.options.colorByPoint) {\n      colorIndex = series.colorCounter;\n      series.colorCounter++; // loop back to zero\n\n      if (series.colorCounter === colorCount) {\n        series.colorCounter = 0;\n      }\n    } else {\n      colorIndex = series.colorIndex;\n    }\n    /**\n     * The point's current color index, used in styled mode instead of\n     * `color`. The color index is inserted in class names used for styling.\n     *\n     * @name Highcharts.Point#colorIndex\n     * @type {number}\n     */\n\n\n    point.colorIndex = pick(point.colorIndex, colorIndex);\n    series.chart.pointCount++;\n    fireEvent(point, 'afterInit');\n    return point;\n  },\n\n  /**\n   * Apply the options containing the x and y data and possible some extra\n   * properties. Called on point init or from point.update.\n   *\n   * @private\n   * @function Highcharts.Point#applyOptions\n   *\n   * @param {*} options\n   *        The point options as defined in series.data.\n   *\n   * @param {number} x\n   *        Optionally, the x value.\n   *\n   * @return {Highcharts.Point}\n   *         The Point instance.\n   */\n  applyOptions: function applyOptions(options, x) {\n    var point = this,\n        series = point.series,\n        pointValKey = series.options.pointValKey || series.pointValKey;\n    options = Point.prototype.optionsToObject.call(this, options); // copy options directly to point\n\n    extend(point, options);\n    /**\n     * The point's options as applied in the initial configuration, or\n     * extended through `Point.update`.\n     *\n     * @name Highcharts.Point#options\n     * @type {*}\n     */\n\n    point.options = point.options ? extend(point.options, options) : options; // Since options are copied into the Point instance, some accidental\n    // options must be shielded (#5681)\n\n    if (options.group) {\n      delete point.group;\n    }\n    /**\n     * The y value of the point.\n     *\n     * @name Highcharts.Point#y\n     * @type {number|undefined}\n     */\n    // For higher dimension series types. For instance, for ranges, point.y\n    // is mapped to point.low.\n\n\n    if (pointValKey) {\n      point.y = point[pointValKey];\n    }\n\n    point.isNull = pick(point.isValid && !point.isValid(), point.x === null || !isNumber(point.y, true)); // #3571, check for NaN\n    // The point is initially selected by options (#5777)\n\n    if (point.selected) {\n      point.state = 'select';\n    }\n    /**\n     * The x value of the point.\n     *\n     * @name Highcharts.Point#x\n     * @type {number}\n     */\n    // If no x is set by now, get auto incremented value. All points must\n    // have an x value, however the y value can be null to create a gap in\n    // the series\n\n\n    if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {\n      point.x = series.xAxis.nameToX(point);\n    }\n\n    if (point.x === undefined && series) {\n      if (x === undefined) {\n        point.x = series.autoIncrement(point);\n      } else {\n        point.x = x;\n      }\n    }\n\n    return point;\n  },\n\n  /**\n   * Set a value in an object, on the property defined by key. The key\n   * supports nested properties using dot notation. The function modifies the\n   * input object and does not make a copy.\n   *\n   * @function Highcharts.Point#setNestedProperty\n   *\n   * @param {*} object\n   *        The object to set the value on.\n   *\n   * @param {*} value\n   *        The value to set.\n   *\n   * @param {string} key\n   *        Key to the property to set.\n   *\n   * @return {*}\n   *         The modified object.\n   */\n  setNestedProperty: function setNestedProperty(object, value, key) {\n    var nestedKeys = key.split('.');\n    H.reduce(nestedKeys, function (result, key, i, arr) {\n      var isLastKey = arr.length - 1 === i;\n      result[key] = isLastKey ? value : H.isObject(result[key], true) ? result[key] : {};\n      return result[key];\n    }, object);\n    return object;\n  },\n\n  /**\n   * Transform number or array configs into objects. Used internally to unify\n   * the different configuration formats for points. For example, a simple\n   * number `10` in a line series will be transformed to `{ y: 10 }`, and an\n   * array config like `[1, 10]` in a scatter series will be transformed to\n   * `{ x: 1, y: 10 }`.\n   *\n   * @function Highcharts.Point#optionsToObject\n   *\n   * @param {number|Array<number>|*} options\n   *        The input option.\n   *\n   * @return {*}\n   *         Transformed options.\n   */\n  optionsToObject: function optionsToObject(options) {\n    var ret = {},\n        series = this.series,\n        keys = series.options.keys,\n        pointArrayMap = keys || series.pointArrayMap || ['y'],\n        valueCount = pointArrayMap.length,\n        firstItemType,\n        i = 0,\n        j = 0;\n\n    if (isNumber(options) || options === null) {\n      ret[pointArrayMap[0]] = options;\n    } else if (isArray(options)) {\n      // with leading x value\n      if (!keys && options.length > valueCount) {\n        firstItemType = _typeof(options[0]);\n\n        if (firstItemType === 'string') {\n          ret.name = options[0];\n        } else if (firstItemType === 'number') {\n          ret.x = options[0];\n        }\n\n        i++;\n      }\n\n      while (j < valueCount) {\n        // Skip undefined positions for keys\n        if (!keys || options[i] !== undefined) {\n          if (pointArrayMap[j].indexOf('.') > 0) {\n            // Handle nested keys, e.g. ['color.pattern.image']\n            // Avoid function call unless necessary.\n            H.Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);\n          } else {\n            ret[pointArrayMap[j]] = options[i];\n          }\n        }\n\n        i++;\n        j++;\n      }\n    } else if (_typeof(options) === 'object') {\n      ret = options; // This is the fastest way to detect if there are individual point\n      // dataLabels that need to be considered in drawDataLabels. These\n      // can only occur in object configs.\n\n      if (options.dataLabels) {\n        series._hasPointLabels = true;\n      } // Same approach as above for markers\n\n\n      if (options.marker) {\n        series._hasPointMarkers = true;\n      }\n    }\n\n    return ret;\n  },\n\n  /**\n   * Get the CSS class names for individual points. Used internally where the\n   * returned value is set on every point.\n   *\n   * @function Highcharts.Point#getClassName\n   *\n   * @return {string}\n   *         The class names.\n   */\n  getClassName: function getClassName() {\n    return 'highcharts-point' + (this.selected ? ' highcharts-point-select' : '') + (this.negative ? ' highcharts-negative' : '') + (this.isNull ? ' highcharts-null-point' : '') + (this.colorIndex !== undefined ? ' highcharts-color-' + this.colorIndex : '') + (this.options.className ? ' ' + this.options.className : '') + (this.zone && this.zone.className ? ' ' + this.zone.className.replace('highcharts-negative', '') : '');\n  },\n\n  /**\n   * In a series with `zones`, return the zone that the point belongs to.\n   *\n   * @function Highcharts.Point#getZone\n   *\n   * @return {Highcharts.PlotSeriesZonesOptions}\n   *         The zone item.\n   */\n  getZone: function getZone() {\n    var series = this.series,\n        zones = series.zones,\n        zoneAxis = series.zoneAxis || 'y',\n        i = 0,\n        zone;\n    zone = zones[i];\n\n    while (this[zoneAxis] >= zone.value) {\n      zone = zones[++i];\n    } // For resetting or reusing the point (#8100)\n\n\n    if (!this.nonZonedColor) {\n      this.nonZonedColor = this.color;\n    }\n\n    if (zone && zone.color && !this.options.color) {\n      this.color = zone.color;\n    } else {\n      this.color = this.nonZonedColor;\n    }\n\n    return zone;\n  },\n\n  /**\n   * Destroy a point to clear memory. Its reference still stays in\n   * `series.data`.\n   *\n   * @private\n   * @function Highcharts.Point#destroy\n   */\n  destroy: function destroy() {\n    var point = this,\n        series = point.series,\n        chart = series.chart,\n        hoverPoints = chart.hoverPoints,\n        prop;\n    chart.pointCount--;\n\n    if (hoverPoints) {\n      point.setState();\n      erase(hoverPoints, point);\n\n      if (!hoverPoints.length) {\n        chart.hoverPoints = null;\n      }\n    }\n\n    if (point === chart.hoverPoint) {\n      point.onMouseOut();\n    } // Remove all events\n\n\n    if (point.graphic || point.dataLabel) {\n      removeEvent(point);\n      point.destroyElements();\n    }\n\n    if (point.legendItem) {\n      // pies have legend items\n      chart.legend.destroyItem(point);\n    }\n\n    for (prop in point) {\n      point[prop] = null;\n    }\n  },\n\n  /**\n   * Destroy SVG elements associated with the point.\n   *\n   * @private\n   * @function Highcharts.Point#destroyElements\n   */\n  destroyElements: function destroyElements() {\n    var point = this,\n        props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],\n        prop,\n        i = 6;\n\n    while (i--) {\n      prop = props[i];\n\n      if (point[prop]) {\n        point[prop] = point[prop].destroy();\n      }\n    }\n  },\n\n  /**\n   * Return the configuration hash needed for the data label and tooltip\n   * formatters.\n   *\n   * @function Highcharts.Point#getLabelConfig\n   *\n   * @return {Highcharts.PointLabelObject}\n   *         Abstract object used in formatters and formats.\n   */\n  getLabelConfig: function getLabelConfig() {\n    return {\n      x: this.category,\n      y: this.y,\n      color: this.color,\n      colorIndex: this.colorIndex,\n      key: this.name || this.category,\n      series: this.series,\n      point: this,\n      percentage: this.percentage,\n      total: this.total || this.stackTotal\n    };\n  },\n\n  /**\n   * Extendable method for formatting each point's tooltip line.\n   *\n   * @function Highcharts.Point#tooltipFormatter\n   *\n   * @param {string} pointFormat\n   *        The point format.\n   *\n   * @return {string}\n   *         A string to be concatenated in to the common tooltip text.\n   */\n  tooltipFormatter: function tooltipFormatter(pointFormat) {\n    // Insert options for valueDecimals, valuePrefix, and valueSuffix\n    var series = this.series,\n        seriesTooltipOptions = series.tooltipOptions,\n        valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n        valuePrefix = seriesTooltipOptions.valuePrefix || '',\n        valueSuffix = seriesTooltipOptions.valueSuffix || ''; // Loop over the point array map and replace unformatted values with\n    // sprintf formatting markup\n\n    each(series.pointArrayMap || ['y'], function (key) {\n      key = '{point.' + key; // without the closing bracket\n\n      if (valuePrefix || valueSuffix) {\n        pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), valuePrefix + key + '}' + valueSuffix);\n      }\n\n      pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), key + ':,.' + valueDecimals + 'f}');\n    });\n    return format(pointFormat, {\n      point: this,\n      series: this.series\n    }, series.chart.time);\n  },\n\n  /**\n   * Fire an event on the Point object.\n   *\n   * @private\n   * @function Highcharts.Point#firePointEvent\n   *\n   * @param {string} eventType\n   *        Type of the event.\n   *\n   * @param {*} eventArgs\n   *        Additional event arguments.\n   *\n   * @param {Function} defaultFunction\n   *        Default event handler.\n   *\n   * @fires Highcharts.Point#event:*\n   */\n  firePointEvent: function firePointEvent(eventType, eventArgs, defaultFunction) {\n    var point = this,\n        series = this.series,\n        seriesOptions = series.options; // load event handlers on demand to save time on mouseover/out\n\n    if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {\n      this.importEvents();\n    } // add default handler if in selection mode\n\n\n    if (eventType === 'click' && seriesOptions.allowPointSelect) {\n      defaultFunction = function defaultFunction(event) {\n        // Control key is for Windows, meta (= Cmd key) for Mac, Shift\n        // for Opera.\n        if (point.select) {\n          // #2911\n          point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n        }\n      };\n    }\n\n    fireEvent(this, eventType, eventArgs, defaultFunction);\n  },\n\n  /**\n   * For certain series types, like pie charts, where individual points can\n   * be shown or hidden.\n   *\n   * @name Highcharts.Point#visible\n   * @type {boolean}\n   */\n  visible: true\n};\n/**\n * For categorized axes this property holds the category name for the\n * point. For other axes it holds the X value.\n *\n * @name Highcharts.Point#category\n * @type {number|string}\n */\n\n/**\n * The name of the point. The name can be given as the first position of the\n * point configuration array, or as a `name` property in the configuration:\n *\n * @example\n * // Array config\n * data: [\n *     ['John', 1],\n *     ['Jane', 2]\n * ]\n *\n * // Object config\n * data: [{\n *        name: 'John',\n *        y: 1\n * }, {\n *     name: 'Jane',\n *     y: 2\n * }]\n *\n * @name Highcharts.Point#name\n * @type {string}\n */\n\n/**\n * The percentage for points in a stacked series or pies.\n *\n * @name Highcharts.Point#percentage\n * @type {number}\n */\n\n/**\n * The total of values in either a stack for stacked series, or a pie in a pie\n * series.\n *\n * @name Highcharts.Point#total\n * @type {number}\n */"
    },
    {
     "id": 250,
     "name": "../node_modules/highcharts/js/es-modules/parts/Color.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * A valid color to be parsed and handled by Highcharts. Highcharts internally\n * supports hex colors like `#ffffff`, rgb colors like `rgb(255,255,255)` and\n * rgba colors like `rgba(255,255,255,1)`. Other colors may be supported by the\n * browsers and displayed correctly, but Highcharts is not able to process them\n * and apply concepts like opacity and brightening.\n *\n * @typedef {string} Highcharts.ColorString\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nvar each = H.each,\n    isNumber = H.isNumber,\n    map = H.map,\n    merge = H.merge,\n    pInt = H.pInt;\n/**\n * Handle color operations. The object methods are chainable.\n *\n * @ignore\n * @class Highcharts.Color\n *\n * @param {Highcharts.ColorString} input\n *        The input color in either rbga or hex format\n */\n\nH.Color = function (input) {\n  // Backwards compatibility, allow instanciation without new\n  if (!(this instanceof H.Color)) {\n    return new H.Color(input);\n  } // Initialize\n\n\n  this.init(input);\n};\n\nH.Color.prototype = {\n  // Collection of parsers. This can be extended from the outside by pushing\n  // parsers to Highcharts.Color.prototype.parsers.\n  parsers: [{\n    // RGBA color\n    regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n    // eslint-disable-line security/detect-unsafe-regex\n    parse: function parse(result) {\n      return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n    }\n  }, {\n    // RGB color\n    regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n    parse: function parse(result) {\n      return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n    }\n  }],\n  // Collection of named colors. Can be extended from the outside by adding\n  // colors to Highcharts.Color.prototype.names.\n  names: {\n    white: '#ffffff',\n    black: '#000000'\n  },\n\n  /**\n   * Parse the input color to rgba array\n   *\n   * @private\n   * @function Highcharts.Color#init\n   *\n   * @param  {Highcharts.ColorString} input\n   *         The input color in either rbga or hex format\n   *\n   * @return {void}\n   */\n  init: function init(input) {\n    var result, rgba, i, parser, len;\n    this.input = input = this.names[input && input.toLowerCase ? input.toLowerCase() : ''] || input; // Gradients\n\n    if (input && input.stops) {\n      this.stops = map(input.stops, function (stop) {\n        return new H.Color(stop[1]);\n      }); // Solid colors\n    } else {\n      // Bitmasking as input[0] is not working for legacy IE.\n      if (input && input.charAt && input.charAt() === '#') {\n        len = input.length;\n        input = parseInt(input.substr(1), 16); // Handle long-form, e.g. #AABBCC\n\n        if (len === 7) {\n          rgba = [(input & 0xFF0000) >> 16, (input & 0xFF00) >> 8, input & 0xFF, 1]; // Handle short-form, e.g. #ABC\n          // In short form, the value is assumed to be the same\n          // for both nibbles for each component. e.g. #ABC = #AABBCC\n        } else if (len === 4) {\n          rgba = [(input & 0xF00) >> 4 | (input & 0xF00) >> 8, (input & 0xF0) >> 4 | input & 0xF0, (input & 0xF) << 4 | input & 0xF, 1];\n        }\n      } // Otherwise, check regex parsers\n\n\n      if (!rgba) {\n        i = this.parsers.length;\n\n        while (i-- && !rgba) {\n          parser = this.parsers[i];\n          result = parser.regex.exec(input);\n\n          if (result) {\n            rgba = parser.parse(result);\n          }\n        }\n      }\n    }\n\n    this.rgba = rgba || [];\n  },\n\n  /**\n   * Return the color in the specified format\n   *\n   * @function Highcharts.Color#get\n   *\n   * @param  {string} format\n   *         Possible values are 'a', 'rgb', undefined\n   *\n   * @return {Highcharts.ColorString}\n   *         This color as a string.\n   */\n  get: function get(format) {\n    var input = this.input,\n        rgba = this.rgba,\n        ret;\n\n    if (this.stops) {\n      ret = merge(input);\n      ret.stops = [].concat(ret.stops);\n      each(this.stops, function (stop, i) {\n        ret.stops[i] = [ret.stops[i][0], stop.get(format)];\n      }); // it's NaN if gradient colors on a column chart\n    } else if (rgba && isNumber(rgba[0])) {\n      if (format === 'rgb' || !format && rgba[3] === 1) {\n        ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n      } else if (format === 'a') {\n        ret = rgba[3];\n      } else {\n        ret = 'rgba(' + rgba.join(',') + ')';\n      }\n    } else {\n      ret = input;\n    }\n\n    return ret;\n  },\n\n  /**\n   * Brighten the color instance.\n   *\n   * @function Highcharts.Color#brighten\n   *\n   * @param  {number} alpha\n   *         The alpha value.\n   *\n   * @return {Highcharts.ColorString}\n   *         This color with modifications.\n   */\n  brighten: function brighten(alpha) {\n    var i,\n        rgba = this.rgba;\n\n    if (this.stops) {\n      each(this.stops, function (stop) {\n        stop.brighten(alpha);\n      });\n    } else if (isNumber(alpha) && alpha !== 0) {\n      for (i = 0; i < 3; i++) {\n        rgba[i] += pInt(alpha * 255);\n\n        if (rgba[i] < 0) {\n          rgba[i] = 0;\n        }\n\n        if (rgba[i] > 255) {\n          rgba[i] = 255;\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Set the color's opacity to a given alpha value.\n   *\n   * @function Highcharts.Color#setOpacity\n   *\n   * @param  {number} alpha\n   *         Opacity between 0 and 1.\n   *\n   * @return {Highcharts.ColorString}\n   *         Color with modifications.\n   */\n  setOpacity: function setOpacity(alpha) {\n    this.rgba[3] = alpha;\n    return this;\n  },\n\n  /**\n   * Return an intermediate color between two colors.\n   *\n   * @function Highcharts.Color#tweenTo\n   *\n   * @param  {Highcharts.Color} to\n   *         The color object to tween to.\n   *\n   * @param  {number} pos\n   *         The intermediate position, where 0 is the from color (current\n   *         color item), and 1 is the `to` color.\n   *\n   * @return {Highcharts.ColorString}\n   *         The intermediate color in rgba notation.\n   */\n  tweenTo: function tweenTo(to, pos) {\n    // Check for has alpha, because rgba colors perform worse due to lack of\n    // support in WebKit.\n    var fromRgba = this.rgba,\n        toRgba = to.rgba,\n        hasAlpha,\n        ret; // Unsupported color, return to-color (#3920, #7034)\n\n    if (!toRgba.length || !fromRgba || !fromRgba.length) {\n      ret = to.input || 'none'; // Interpolate\n    } else {\n      hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1;\n      ret = (hasAlpha ? 'rgba(' : 'rgb(') + Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) + ',' + Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) + ',' + Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) + (hasAlpha ? ',' + (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos)) : '') + ')';\n    }\n\n    return ret;\n  }\n};\n\nH.color = function (input) {\n  return new H.Color(input);\n};"
    },
    {
     "id": 251,
     "name": "../node_modules/highcharts/js/es-modules/parts/Legend.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport Highcharts from './Globals.js';\nimport './Utilities.js';\nvar H = Highcharts,\n    addEvent = H.addEvent,\n    css = H.css,\n    discardElement = H.discardElement,\n    defined = H.defined,\n    each = H.each,\n    fireEvent = H.fireEvent,\n    isFirefox = H.isFirefox,\n    marginNames = H.marginNames,\n    merge = H.merge,\n    pick = H.pick,\n    setAnimation = H.setAnimation,\n    stableSort = H.stableSort,\n    win = H.win,\n    wrap = H.wrap;\n/**\n * The overview of the chart's series. The legend object is instanciated\n * internally in the chart constructor, and is available from the `chart.legend`\n * property. Each chart has only one legend.\n *\n * @class\n * @name Highcharts.Legend\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @param {Highcharts.LegendOptions} options\n *        Legend options.\n */\n\nHighcharts.Legend = function (chart, options) {\n  this.init(chart, options);\n};\n\nHighcharts.Legend.prototype = {\n  /**\n   * Initialize the legend.\n   *\n   * @private\n   * @function Highcharts.Legend#init\n   *\n   * @param {Highcharts.Chart} chart\n   *        The chart instance.\n   *\n   * @param {Highcharts.LegendOptions} options\n   *        Legend options.\n   */\n  init: function init(chart, options) {\n    /**\n     * Chart of this legend.\n     *\n     * @readonly\n     * @name Highcharts.Legend#chart\n     * @type {Highcharts.Chart}\n     */\n    this.chart = chart;\n    this.setOptions(options);\n\n    if (options.enabled) {\n      // Render it\n      this.render(); // move checkboxes\n\n      addEvent(this.chart, 'endResize', function () {\n        this.legend.positionCheckboxes();\n      });\n\n      if (this.proximate) {\n        this.unchartrender = addEvent(this.chart, 'render', function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        });\n      } else if (this.unchartrender) {\n        this.unchartrender();\n      }\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Legend#setOptions\n   *\n   * @param {Highcharts.LegendOptions} options\n   */\n  setOptions: function setOptions(options) {\n    var padding = pick(options.padding, 8);\n    /**\n     * Legend options.\n     *\n     * @readonly\n     * @name Highcharts.Legend#options\n     * @type {Highcharts.LegendOptions}\n     */\n\n    this.options = options;\n    this.itemMarginTop = options.itemMarginTop || 0;\n    this.padding = padding;\n    this.initialItemY = padding - 5; // 5 is pixels above the text\n\n    this.symbolWidth = pick(options.symbolWidth, 16);\n    this.pages = [];\n    this.proximate = options.layout === 'proximate' && !this.chart.inverted;\n  },\n\n  /**\n   * Update the legend with new options. Equivalent to running `chart.update`\n   * with a legend configuration option.\n   *\n   * @sample highcharts/legend/legend-update/\n   *         Legend update\n   *\n   * @function Highcharts.Legend#update\n   *\n   * @param {Highcharts.LegendOptions} options\n   *        Legend options.\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart.\n   *\n   * @todo\n   * Make events official: Fires the event `afterUpdate`.\n   */\n  update: function update(options, redraw) {\n    var chart = this.chart;\n    this.setOptions(merge(true, this.options, options));\n    this.destroy();\n    chart.isDirtyLegend = chart.isDirtyBox = true;\n\n    if (pick(redraw, true)) {\n      chart.redraw();\n    }\n\n    fireEvent(this, 'afterUpdate');\n  },\n\n  /**\n   * Set the colors for the legend item.\n   *\n   * @private\n   * @function Highcharts.Legend#colorizeItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        A Series or Point instance\n   *\n   * @param {boolean} [visible=false]\n   *        Dimmed or colored\n   *\n   * @todo\n   * Make events official: Fires the event `afterColorizeItem`.\n   */\n  colorizeItem: function colorizeItem(item, visible) {\n    item.legendGroup[visible ? 'removeClass' : 'addClass']('highcharts-legend-item-hidden');\n    fireEvent(this, 'afterColorizeItem', {\n      item: item,\n      visible: visible\n    });\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Legend#positionItems\n   */\n  positionItems: function positionItems() {\n    // Now that the legend width and height are established, put the items\n    // in the final position\n    each(this.allItems, this.positionItem, this);\n\n    if (!this.chart.isResizing) {\n      this.positionCheckboxes();\n    }\n  },\n\n  /**\n   * Position the legend item.\n   *\n   * @private\n   * @function Highcharts.Legend#positionItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The item to position\n   */\n  positionItem: function positionItem(item) {\n    var legend = this,\n        options = legend.options,\n        symbolPadding = options.symbolPadding,\n        ltr = !options.rtl,\n        legendItemPos = item._legendItemPos,\n        itemX = legendItemPos[0],\n        itemY = legendItemPos[1],\n        checkbox = item.checkbox,\n        legendGroup = item.legendGroup;\n\n    if (legendGroup && legendGroup.element) {\n      legendGroup[defined(legendGroup.translateY) ? 'animate' : 'attr']({\n        translateX: ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n        translateY: itemY\n      });\n    }\n\n    if (checkbox) {\n      checkbox.x = itemX;\n      checkbox.y = itemY;\n    }\n  },\n\n  /**\n   * Destroy a single legend item, used internally on removing series items.\n   *\n   * @private\n   * @function Highcharts.Legend#destroyItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The item to remove\n   */\n  destroyItem: function destroyItem(item) {\n    var checkbox = item.checkbox; // destroy SVG elements\n\n    each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n      if (item[key]) {\n        item[key] = item[key].destroy();\n      }\n    });\n\n    if (checkbox) {\n      discardElement(item.checkbox);\n    }\n  },\n\n  /**\n   * Destroy the legend. Used internally. To reflow objects, `chart.redraw`\n   * must be called after destruction.\n   *\n   * @private\n   * @function Highcharts.Legend#destroy\n   */\n  destroy: function destroy() {\n    function destroyItems(key) {\n      if (this[key]) {\n        this[key] = this[key].destroy();\n      }\n    } // Destroy items\n\n\n    each(this.getAllItems(), function (item) {\n      each(['legendItem', 'legendGroup'], destroyItems, item);\n    }); // Destroy legend elements\n\n    each(['clipRect', 'up', 'down', 'pager', 'nav', 'box', 'title', 'group'], destroyItems, this);\n    this.display = null; // Reset in .render on update.\n  },\n\n  /**\n   * Position the checkboxes after the width is determined.\n   *\n   * @private\n   * @function Highcharts.Legend#positionCheckboxes\n   */\n  positionCheckboxes: function positionCheckboxes() {\n    var alignAttr = this.group && this.group.alignAttr,\n        translateY,\n        clipHeight = this.clipHeight || this.legendHeight,\n        titleHeight = this.titleHeight;\n\n    if (alignAttr) {\n      translateY = alignAttr.translateY;\n      each(this.allItems, function (item) {\n        var checkbox = item.checkbox,\n            top;\n\n        if (checkbox) {\n          top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;\n          css(checkbox, {\n            left: alignAttr.translateX + item.checkboxOffset + checkbox.x - 20 + 'px',\n            top: top + 'px',\n            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : 'none'\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * Render the legend title on top of the legend.\n   *\n   * @private\n   * @function Highcharts.Legend#renderTitle\n   */\n  renderTitle: function renderTitle() {\n    var options = this.options,\n        padding = this.padding,\n        titleOptions = options.title,\n        titleHeight = 0,\n        bBox;\n\n    if (titleOptions.text) {\n      if (!this.title) {\n        /**\n         * SVG element of the legend title.\n         *\n         * @readonly\n         * @name Highcharts.Legend#title\n         * @type {Highcharts.SVGElement}\n         */\n        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, options.useHTML, null, 'legend-title').attr({\n          zIndex: 1\n        }).add(this.group);\n      }\n\n      bBox = this.title.getBBox();\n      titleHeight = bBox.height;\n      this.offsetWidth = bBox.width; // #1717\n\n      this.contentGroup.attr({\n        translateY: titleHeight\n      });\n    }\n\n    this.titleHeight = titleHeight;\n  },\n\n  /**\n   * Set the legend item text.\n   *\n   * @function Highcharts.Legend#setText\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The item for which to update the text in the legend.\n   */\n  setText: function setText(item) {\n    var options = this.options;\n    item.legendItem.attr({\n      text: options.labelFormat ? H.format(options.labelFormat, item, this.chart.time) : options.labelFormatter.call(item)\n    });\n  },\n\n  /**\n   * Render a single specific legend item. Called internally from the `render`\n   * function.\n   *\n   * @private\n   * @function Highcharts.Legend#renderItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The item to render.\n   */\n  renderItem: function renderItem(item) {\n    var legend = this,\n        chart = legend.chart,\n        renderer = chart.renderer,\n        options = legend.options,\n        horizontal = options.layout === 'horizontal',\n        symbolWidth = legend.symbolWidth,\n        symbolPadding = options.symbolPadding,\n        itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n        ltr = !options.rtl,\n        bBox,\n        li = item.legendItem,\n        isSeries = !item.series,\n        series = !isSeries && item.series.drawLegendSymbol ? item.series : item,\n        seriesOptions = series.options,\n        showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n        // full width minus text width\n    itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0),\n        useHTML = options.useHTML,\n        fontSize = 12,\n        itemClassName = item.options.className;\n\n    if (!li) {\n      // generate it once, later move it\n      // Generate the group box, a group to hold the symbol and text. Text\n      // is to be appended in Legend class.\n      item.legendGroup = renderer.g('legend-item').addClass('highcharts-' + series.type + '-series ' + 'highcharts-color-' + item.colorIndex + (itemClassName ? ' ' + itemClassName : '') + (isSeries ? ' highcharts-series-' + item.index : '')).attr({\n        zIndex: 1\n      }).add(legend.scrollGroup); // Generate the list item text and add it to the group\n\n      item.legendItem = li = renderer.text('', ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML).attr({\n        align: ltr ? 'left' : 'right',\n        zIndex: 2\n      }).add(item.legendGroup); // Get the baseline for the first item - the font size is equal for\n      // all\n\n      if (!legend.baseline) {\n        legend.fontMetrics = renderer.fontMetrics(fontSize, li);\n        legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;\n        li.attr('y', legend.baseline);\n      } // Draw the legend symbol inside the group box\n\n\n      legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;\n      series.drawLegendSymbol(legend, item);\n\n      if (legend.setItemEvents) {\n        legend.setItemEvents(item, li, useHTML);\n      } // add the HTML checkbox on top\n\n\n      if (showCheckbox) {\n        legend.createCheckboxForItem(item);\n      }\n    } // Colorize the items\n\n\n    legend.colorizeItem(item, item.visible); // Take care of max width and text overflow (#6659)\n\n    li.css({\n      width: (options.itemWidth || options.width || chart.spacingBox.width) - itemExtraWidth\n    }); // Always update the text\n\n    legend.setText(item); // calculate the positions for the next line\n\n    bBox = li.getBBox();\n    item.itemWidth = item.checkboxOffset = options.itemWidth || item.legendItemWidth || bBox.width + itemExtraWidth;\n    legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);\n    legend.totalItemWidth += item.itemWidth;\n    legend.itemHeight = item.itemHeight = Math.round(item.legendItemHeight || bBox.height || legend.symbolHeight);\n  },\n\n  /**\n   * Get the position of the item in the layout. We now know the\n   * maxItemWidth from the previous loop.\n   *\n   * @private\n   * @function Highcharts.Legend#layoutItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   */\n  layoutItem: function layoutItem(item) {\n    var options = this.options,\n        padding = this.padding,\n        horizontal = options.layout === 'horizontal',\n        itemHeight = item.itemHeight,\n        itemMarginBottom = options.itemMarginBottom || 0,\n        itemMarginTop = this.itemMarginTop,\n        itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n        widthOption = options.width,\n        maxLegendWidth = widthOption || this.chart.spacingBox.width - 2 * padding - options.x,\n        itemWidth = options.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item.itemWidth; // If the item exceeds the width, start a new line\n\n    if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {\n      this.itemX = padding;\n      this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;\n      this.lastLineHeight = 0; // reset for next line (#915, #3976)\n    } // Set the edge positions\n\n\n    this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;\n    this.lastLineHeight = Math.max( // #915\n    itemHeight, this.lastLineHeight); // cache the position of the newly generated or reordered items\n\n    item._legendItemPos = [this.itemX, this.itemY]; // advance\n\n    if (horizontal) {\n      this.itemX += itemWidth;\n    } else {\n      this.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n      this.lastLineHeight = itemHeight;\n    } // the width of the widest item\n\n\n    this.offsetWidth = widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ? // decrease by itemDistance only when no checkbox #4853\n    0 : itemDistance) : itemWidth) + padding, this.offsetWidth);\n  },\n\n  /**\n   * Get all items, which is one item per series for most series and one\n   * item per point for pie series and its derivatives.\n   *\n   * @private\n   * @function Highcharts.Legend#getAllItems\n   *\n   * @return {Array<Highcharts.Point|Highcharts.Series>}\n   *         The current items in the legend.\n   *\n   * @fires Highcharts.Legend#event:afterGetAllItems\n   *\n   * @todo\n   * Make events official: Fires the event `afterGetAllItems`.\n   */\n  getAllItems: function getAllItems() {\n    var allItems = [];\n    each(this.chart.series, function (series) {\n      var seriesOptions = series && series.options; // Handle showInLegend. If the series is linked to another series,\n      // defaults to false.\n\n      if (series && pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? undefined : false, true)) {\n        // Use points or series for the legend item depending on\n        // legendType\n        allItems = allItems.concat(series.legendItems || (seriesOptions.legendType === 'point' ? series.data : series));\n      }\n    });\n    fireEvent(this, 'afterGetAllItems', {\n      allItems: allItems\n    });\n    return allItems;\n  },\n\n  /**\n   * Get a short, three letter string reflecting the alignment and layout.\n   *\n   * @private\n   * @function Highcharts.Legend#getAlignment\n   *\n   * @return {string}\n   *         The alignment, empty string if floating\n   */\n  getAlignment: function getAlignment() {\n    var options = this.options; // Use the first letter of each alignment option in order to detect\n    // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)\n\n    if (this.proximate) {\n      return options.align.charAt(0) + 'tv';\n    }\n\n    return options.floating ? '' : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);\n  },\n\n  /**\n   * Adjust the chart margins by reserving space for the legend on only one\n   * side of the chart. If the position is set to a corner, top or bottom is\n   * reserved for horizontal legends and left or right for vertical ones.\n   *\n   * @private\n   * @function Highcharts.Legend#adjustMargins\n   *\n   * @param {Array<number>} margin\n   *\n   * @param {number} spacing\n   */\n  adjustMargins: function adjustMargins(margin, spacing) {\n    var chart = this.chart,\n        options = this.options,\n        alignment = this.getAlignment();\n\n    if (alignment) {\n      each([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (alignments, side) {\n        if (alignments.test(alignment) && !defined(margin[side])) {\n          // Now we have detected on which side of the chart we should\n          // reserve space for the legend\n          chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + [1, -1, -1, 1][side] * options[side % 2 ? 'x' : 'y'] + pick(options.margin, 12) + spacing[side] + (side === 0 && chart.options.title.margin !== undefined ? chart.titleOffset + chart.options.title.margin : 0) // #7428, #7894\n          );\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Legend#proximatePositions\n   */\n  proximatePositions: function proximatePositions() {\n    var chart = this.chart,\n        boxes = [],\n        alignLeft = this.options.align === 'left';\n    each(this.allItems, function (item) {\n      var lastPoint,\n          height,\n          useFirstPoint = alignLeft;\n\n      if (item.xAxis && item.points) {\n        if (item.xAxis.options.reversed) {\n          useFirstPoint = !useFirstPoint;\n        }\n\n        lastPoint = H.find(useFirstPoint ? item.points : item.points.slice(0).reverse(), function (item) {\n          return H.isNumber(item.plotY);\n        });\n        height = item.legendGroup.getBBox().height;\n        boxes.push({\n          target: item.visible ? (lastPoint ? lastPoint.plotY : item.xAxis.height) - 0.3 * height : chart.plotHeight,\n          size: height,\n          item: item\n        });\n      }\n    }, this);\n    H.distribute(boxes, chart.plotHeight);\n    each(boxes, function (box) {\n      box.item._legendItemPos[1] = chart.plotTop - chart.spacing[0] + box.pos;\n    });\n  },\n\n  /**\n   * Render the legend. This method can be called both before and after\n   * `chart.render`. If called after, it will only rearrange items instead\n   * of creating new ones. Called internally on initial render and after\n   * redraws.\n   *\n   * @private\n   * @function Highcharts.Legend#render\n   */\n  render: function render() {\n    var legend = this,\n        chart = legend.chart,\n        renderer = chart.renderer,\n        legendGroup = legend.group,\n        allItems,\n        display,\n        legendWidth,\n        legendHeight,\n        box = legend.box,\n        options = legend.options,\n        padding = legend.padding,\n        alignTo;\n    legend.itemX = padding;\n    legend.itemY = legend.initialItemY;\n    legend.offsetWidth = 0;\n    legend.lastItemY = 0;\n\n    if (!legendGroup) {\n      /**\n       * SVG group of the legend.\n       *\n       * @readonly\n       * @name Highcharts.Legend#group\n       * @type {Highcharts.SVGElement}\n       */\n      legend.group = legendGroup = renderer.g('legend').attr({\n        zIndex: 7\n      }).add();\n      legend.contentGroup = renderer.g().attr({\n        zIndex: 1\n      }) // above background\n      .add(legendGroup);\n      legend.scrollGroup = renderer.g().add(legend.contentGroup);\n    }\n\n    legend.renderTitle(); // add each series or point\n\n    allItems = legend.getAllItems(); // sort by legendIndex\n\n    stableSort(allItems, function (a, b) {\n      return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n    }); // reversed legend\n\n    if (options.reversed) {\n      allItems.reverse();\n    }\n    /**\n     * All items for the legend, which is an array of series for most series\n     * and an array of points for pie series and its derivatives.\n     *\n     * @readonly\n     * @name Highcharts.Legend#allItems\n     * @type {Array<Highcharts.Point|Highcharts.Series>}\n     */\n\n\n    legend.allItems = allItems;\n    legend.display = display = !!allItems.length; // Render the items. First we run a loop to set the text and properties\n    // and read all the bounding boxes. The next loop computes the item\n    // positions based on the bounding boxes.\n\n    legend.lastLineHeight = 0;\n    legend.maxItemWidth = 0;\n    legend.totalItemWidth = 0;\n    legend.itemHeight = 0;\n    each(allItems, legend.renderItem, legend);\n    each(allItems, legend.layoutItem, legend); // Get the box\n\n    legendWidth = (options.width || legend.offsetWidth) + padding;\n    legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n    legendHeight = legend.handleOverflow(legendHeight);\n    legendHeight += padding; // Draw the border and/or background\n\n    if (!box) {\n      /**\n       * SVG element of the legend box.\n       *\n       * @readonly\n       * @name Highcharts.Legend#box\n       * @type {Highcharts.SVGElement}\n       */\n      legend.box = box = renderer.rect().addClass('highcharts-legend-box').attr({\n        r: options.borderRadius\n      }).add(legendGroup);\n      box.isNew = true;\n    }\n\n    if (legendWidth > 0 && legendHeight > 0) {\n      box[box.isNew ? 'attr' : 'animate'](box.crisp.call({}, {\n        // #7260\n        x: 0,\n        y: 0,\n        width: legendWidth,\n        height: legendHeight\n      }, box.strokeWidth()));\n      box.isNew = false;\n    } // hide the border if no items\n\n\n    box[display ? 'show' : 'hide'](); // Open for responsiveness\n\n    if (legendGroup.getStyle('display') === 'none') {\n      legendWidth = legendHeight = 0;\n    }\n\n    legend.legendWidth = legendWidth;\n    legend.legendHeight = legendHeight;\n\n    if (display) {\n      // If aligning to the top and the layout is horizontal, adjust for\n      // the title (#7428)\n      alignTo = chart.spacingBox;\n\n      if (/(lth|ct|rth)/.test(legend.getAlignment())) {\n        alignTo = merge(alignTo, {\n          y: alignTo.y + chart.titleOffset + chart.options.title.margin\n        });\n      }\n\n      legendGroup.align(merge(options, {\n        width: legendWidth,\n        height: legendHeight,\n        verticalAlign: this.proximate ? 'top' : options.verticalAlign\n      }), true, alignTo);\n    }\n\n    if (!this.proximate) {\n      this.positionItems();\n    }\n  },\n\n  /**\n   * Set up the overflow handling by adding navigation with up and down arrows\n   * below the legend.\n   *\n   * @private\n   * @function Highcharts.Legend#handleOverflow\n   *\n   * @param {number} legendHeight\n   *\n   * @return {number}\n   */\n  handleOverflow: function handleOverflow(legendHeight) {\n    var legend = this,\n        chart = this.chart,\n        renderer = chart.renderer,\n        options = this.options,\n        optionsY = options.y,\n        alignTop = options.verticalAlign === 'top',\n        padding = this.padding,\n        spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding,\n        maxHeight = options.maxHeight,\n        clipHeight,\n        clipRect = this.clipRect,\n        navOptions = options.navigation,\n        animation = pick(navOptions.animation, true),\n        arrowSize = navOptions.arrowSize || 12,\n        nav = this.nav,\n        pages = this.pages,\n        lastY,\n        allItems = this.allItems,\n        clipToHeight = function clipToHeight(height) {\n      if (typeof height === 'number') {\n        clipRect.attr({\n          height: height\n        });\n      } else if (clipRect) {\n        // Reset (#5912)\n        legend.clipRect = clipRect.destroy();\n        legend.contentGroup.clip();\n      } // useHTML\n\n\n      if (legend.contentGroup.div) {\n        legend.contentGroup.div.style.clip = height ? 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)' : 'auto';\n      }\n    }; // Adjust the height\n\n\n    if (options.layout === 'horizontal' && options.verticalAlign !== 'middle' && !options.floating) {\n      spaceHeight /= 2;\n    }\n\n    if (maxHeight) {\n      spaceHeight = Math.min(spaceHeight, maxHeight);\n    } // Reset the legend height and adjust the clipping rectangle\n\n\n    pages.length = 0;\n\n    if (legendHeight > spaceHeight && navOptions.enabled !== false) {\n      this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);\n      this.currentPage = pick(this.currentPage, 1);\n      this.fullHeight = legendHeight; // Fill pages with Y positions so that the top of each a legend item\n      // defines the scroll top for each page (#2098)\n\n      each(allItems, function (item, i) {\n        var y = item._legendItemPos[1],\n            h = Math.round(item.legendItem.getBBox().height),\n            len = pages.length;\n\n        if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {\n          pages.push(lastY || y);\n          len++;\n        } // Keep track of which page each item is on\n\n\n        item.pageIx = len - 1;\n\n        if (lastY) {\n          allItems[i - 1].pageIx = len - 1;\n        }\n\n        if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {\n          pages.push(y);\n          item.pageIx = len;\n        }\n\n        if (y !== lastY) {\n          lastY = y;\n        }\n      }); // Only apply clipping if needed. Clipping causes blurred legend in\n      // PDF export (#1787)\n\n      if (!clipRect) {\n        clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);\n        legend.contentGroup.clip(clipRect);\n      }\n\n      clipToHeight(clipHeight); // Add navigation elements\n\n      if (!nav) {\n        this.nav = nav = renderer.g().attr({\n          zIndex: 1\n        }).add(this.group);\n        this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize).on('click', function () {\n          legend.scroll(-1, animation);\n        }).add(nav);\n        this.pager = renderer.text('', 15, 10).addClass('highcharts-legend-navigation').add(nav);\n        this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize).on('click', function () {\n          legend.scroll(1, animation);\n        }).add(nav);\n      } // Set initial position\n\n\n      legend.scroll(0);\n      legendHeight = spaceHeight; // Reset\n    } else if (nav) {\n      clipToHeight();\n      this.nav = nav.destroy(); // #6322\n\n      this.scrollGroup.attr({\n        translateY: 1\n      });\n      this.clipHeight = 0; // #1379\n    }\n\n    return legendHeight;\n  },\n\n  /**\n   * Scroll the legend by a number of pages.\n   *\n   * @private\n   * @function Highcharts.Legend#scroll\n   *\n   * @param {number} scrollBy\n   *        The number of pages to scroll.\n   *\n   * @param {Highcharts.AnimationOptionsObject} animation\n   *        Whether and how to apply animation.\n   */\n  scroll: function scroll(scrollBy, animation) {\n    var pages = this.pages,\n        pageCount = pages.length,\n        currentPage = this.currentPage + scrollBy,\n        clipHeight = this.clipHeight,\n        navOptions = this.options.navigation,\n        pager = this.pager,\n        padding = this.padding; // When resizing while looking at the last page\n\n    if (currentPage > pageCount) {\n      currentPage = pageCount;\n    }\n\n    if (currentPage > 0) {\n      if (animation !== undefined) {\n        setAnimation(animation, this.chart);\n      }\n\n      this.nav.attr({\n        translateX: padding,\n        translateY: clipHeight + this.padding + 7 + this.titleHeight,\n        visibility: 'visible'\n      });\n      this.up.attr({\n        'class': currentPage === 1 ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n      });\n      pager.attr({\n        text: currentPage + '/' + pageCount\n      });\n      this.down.attr({\n        'x': 18 + this.pager.getBBox().width,\n        // adjust to text width\n        'class': currentPage === pageCount ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n      });\n      this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n      this.scrollGroup.animate({\n        translateY: this.scrollOffset\n      });\n      this.currentPage = currentPage;\n      this.positionCheckboxes();\n    }\n  }\n};\n/**\n * Legend symbol mixin.\n *\n * @private\n * @mixin Highcharts.LegendSymbolMixin\n */\n\nH.LegendSymbolMixin = {\n  /**\n   * Get the series' symbol in the legend\n   *\n   * @private\n   * @function Highcharts.LegendSymbolMixin.drawRectangle\n   *\n   * @param {Highcharts.Legend} legend\n   *        The legend object\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The series (this) or point\n   */\n  drawRectangle: function drawRectangle(legend, item) {\n    var options = legend.options,\n        symbolHeight = legend.symbolHeight,\n        square = options.squareSymbol,\n        symbolWidth = square ? symbolHeight : legend.symbolWidth;\n    item.legendSymbol = this.chart.renderer.rect(square ? (legend.symbolWidth - symbolHeight) / 2 : 0, legend.baseline - symbolHeight + 1, // #3988\n    symbolWidth, symbolHeight, pick(legend.options.symbolRadius, symbolHeight / 2)).addClass('highcharts-point').attr({\n      zIndex: 3\n    }).add(item.legendGroup);\n  },\n\n  /**\n   * Get the series' symbol in the legend. This method should be overridable\n   * to create custom symbols through\n   * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n   *\n   * @private\n   * @function Highcharts.LegendSymbolMixin.drawLineMarker\n   *\n   * @param {Highcharts.Legend} legend\n   *        The legend object.\n   */\n  drawLineMarker: function drawLineMarker(legend) {\n    var options = this.options,\n        markerOptions = options.marker,\n        radius,\n        legendSymbol,\n        symbolWidth = legend.symbolWidth,\n        symbolHeight = legend.symbolHeight,\n        generalRadius = symbolHeight / 2,\n        renderer = this.chart.renderer,\n        legendItemGroup = this.legendGroup,\n        verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3),\n        attr = {}; // Draw the line\n\n    this.legendLine = renderer.path(['M', 0, verticalCenter, 'L', symbolWidth, verticalCenter]).addClass('highcharts-graph').attr(attr).add(legendItemGroup); // Draw the marker\n\n    if (markerOptions && markerOptions.enabled !== false && symbolWidth) {\n      // Do not allow the marker to be larger than the symbolHeight\n      radius = Math.min(pick(markerOptions.radius, generalRadius), generalRadius); // Restrict symbol markers size\n\n      if (this.symbol.indexOf('url') === 0) {\n        markerOptions = merge(markerOptions, {\n          width: symbolHeight,\n          height: symbolHeight\n        });\n        radius = 0;\n      }\n\n      this.legendSymbol = legendSymbol = renderer.symbol(this.symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius, markerOptions).addClass('highcharts-point').add(legendItemGroup);\n      legendSymbol.isMarker = true;\n    }\n  }\n}; // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n// and for #2580, a similar drawing flaw in Firefox 26.\n// Explore if there's a general cause for this. The problem may be related\n// to nested group elements, as the legend item texts are within 4 group\n// elements.\n\nif (/Trident\\/7\\.0/.test(win.navigator.userAgent) || isFirefox) {\n  wrap(Highcharts.Legend.prototype, 'positionItem', function (proceed, item) {\n    var legend = this,\n        // If chart destroyed in sync, this is undefined (#2030)\n    runPositionItem = function runPositionItem() {\n      if (item._legendItemPos) {\n        proceed.call(legend, item);\n      }\n    }; // Do it now, for export and to get checkbox placement\n\n\n    runPositionItem(); // Do it after to work around the core issue\n\n    setTimeout(runPositionItem);\n  });\n}"
    },
    {
     "id": 253,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-column.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2018 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { DirMixin } from '@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js';\nimport { Templatizer } from './vaadin-grid-templatizer.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { animationFrame } from '@polymer/polymer/lib/utils/async.js';\n/**\n * @polymerMixin\n */\n\nexport var ColumnBaseMixin = function ColumnBaseMixin(superClass) {\n  return /*#__PURE__*/function (_superClass) {\n    _inherits(ColumnBaseMixin, _superClass);\n\n    var _super = _createSuper(ColumnBaseMixin);\n\n    _createClass(ColumnBaseMixin, [{\n      key: \"connectedCallback\",\n\n      /** @protected */\n      value: function connectedCallback() {\n        var _this2 = this;\n\n        _get(_getPrototypeOf(ColumnBaseMixin.prototype), \"connectedCallback\", this).call(this);\n\n        this._bodyTemplate && (this._bodyTemplate.templatizer._grid = this._grid);\n        this._headerTemplate && (this._headerTemplate.templatizer._grid = this._grid);\n        this._footerTemplate && (this._footerTemplate.templatizer._grid = this._grid);\n\n        this._templateObserver.flush();\n\n        if (!this._bodyTemplate) {\n          // The observer might not have triggered if the tag is empty. Run manually.\n          this._templateObserver.callback();\n        }\n\n        requestAnimationFrame(function () {\n          _this2._allCells.forEach(function (cell) {\n            if (!cell._content.parentNode) {\n              _this2._grid && _this2._grid.appendChild(cell._content);\n            }\n          });\n        });\n      }\n      /** @protected */\n\n    }, {\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        var _this3 = this;\n\n        _get(_getPrototypeOf(ColumnBaseMixin.prototype), \"disconnectedCallback\", this).call(this);\n\n        requestAnimationFrame(function () {\n          if (!_this3._findHostGrid()) {\n            _this3._allCells.forEach(function (cell) {\n              if (cell._content.parentNode) {\n                cell._content.parentNode.removeChild(cell._content);\n              }\n            });\n          }\n        });\n        this._gridValue = undefined;\n      }\n      /**\n       * @return {!GridElement | undefined}\n       * @protected\n       */\n\n    }, {\n      key: \"_findHostGrid\",\n      value: function _findHostGrid() {\n        var el = this; // Custom elements extending grid must have a specific localName\n\n        while (el && !/^vaadin.*grid(-pro)?$/.test(el.localName)) {\n          el = el.assignedSlot ? el.assignedSlot.parentNode : el.parentNode;\n        }\n\n        return el || undefined;\n      }\n      /**\n       * @return {!GridElement | undefined}\n       * @protected\n       */\n\n    }, {\n      key: \"_grid\",\n      get: function get() {\n        if (!this._gridValue) {\n          this._gridValue = this._findHostGrid();\n        }\n\n        return this._gridValue;\n      }\n      /**\n       * @return {!Array<!HTMLElement>}\n       * @protected\n       */\n\n    }, {\n      key: \"_allCells\",\n      get: function get() {\n        return [].concat(this._cells || []).concat(this._emptyCells || []).concat(this._headerCell).concat(this._footerCell).filter(function (cell) {\n          return cell;\n        });\n      }\n    }], [{\n      key: \"properties\",\n      get: function get() {\n        return {\n          /**\n           * When set to true, the column is user-resizable.\n           * @default false\n           */\n          resizable: {\n            type: Boolean,\n            value: function value() {\n              if (this.localName === 'vaadin-grid-column-group') {\n                return;\n              }\n\n              var parent = this.parentNode;\n\n              if (parent && parent.localName === 'vaadin-grid-column-group') {\n                return parent.resizable || false;\n              } else {\n                return false;\n              }\n            }\n          },\n\n          /**\n           * @type {HTMLTemplateElement}\n           * @protected\n           */\n          _headerTemplate: {\n            type: Object\n          },\n\n          /**\n           * @type {HTMLTemplateElement}\n           * @protected\n           */\n          _footerTemplate: {\n            type: Object\n          },\n\n          /**\n           * When true, the column is frozen. When a column inside of a column group is frozen,\n           * all of the sibling columns inside the group will get frozen also.\n           * @type {boolean}\n           */\n          frozen: {\n            type: Boolean,\n            value: false\n          },\n\n          /**\n           * When set to true, the cells for this column are hidden.\n           */\n          hidden: {\n            type: Boolean\n          },\n\n          /**\n           * Text content to display in the header cell of the column.\n           */\n          header: {\n            type: String\n          },\n\n          /**\n           * Aligns the columns cell content horizontally.\n           * Supported values: \"start\", \"center\" and \"end\".\n           * @attr {start|center|end} text-align\n           * @type {GridColumnTextAlign | null | undefined}\n           */\n          textAlign: {\n            type: String\n          },\n\n          /**\n           * @type {boolean}\n           * @protected\n           */\n          _lastFrozen: {\n            type: Boolean,\n            value: false\n          },\n\n          /** @protected */\n          _order: Number,\n\n          /** @private */\n          _reorderStatus: Boolean,\n\n          /**\n           * @type {Array<!HTMLElement>}\n           * @protected\n           */\n          _emptyCells: Array,\n\n          /** @private */\n          _headerCell: Object,\n\n          /** @private */\n          _footerCell: Object,\n\n          /** @protected */\n          _grid: Object,\n\n          /**\n           * Custom function for rendering the header content.\n           * Receives two arguments:\n           *\n           * - `root` The header cell content DOM element. Append your content to it.\n           * - `column` The `<vaadin-grid-column>` element.\n           *\n           * @type {GridHeaderFooterRenderer | null | undefined}\n           */\n          headerRenderer: Function,\n\n          /**\n           * Custom function for rendering the footer content.\n           * Receives two arguments:\n           *\n           * - `root` The footer cell content DOM element. Append your content to it.\n           * - `column` The `<vaadin-grid-column>` element.\n           *\n           * @type {GridHeaderFooterRenderer | null | undefined}\n           */\n          footerRenderer: Function\n        };\n      }\n    }, {\n      key: \"observers\",\n      get: function get() {\n        return ['_widthChanged(width, _headerCell, _footerCell, _cells.*)', '_frozenChanged(frozen, _headerCell, _footerCell, _cells.*)', '_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells.*)', '_pathOrHeaderChanged(path, header, _headerCell, _footerCell, _cells.*, renderer, headerRenderer, _bodyTemplate, _headerTemplate)', '_textAlignChanged(textAlign, _cells.*, _headerCell, _footerCell)', '_orderChanged(_order, _headerCell, _footerCell, _cells.*)', '_lastFrozenChanged(_lastFrozen)', '_setBodyTemplateOrRenderer(_bodyTemplate, renderer, _cells, _cells.*)', '_setHeaderTemplateOrRenderer(_headerTemplate, headerRenderer, _headerCell)', '_setFooterTemplateOrRenderer(_footerTemplate, footerRenderer, _footerCell)', '_resizableChanged(resizable, _headerCell)', '_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells.*)', '_hiddenChanged(hidden, _headerCell, _footerCell, _cells.*)'];\n      }\n    }]);\n\n    function ColumnBaseMixin() {\n      var _this;\n\n      _classCallCheck(this, ColumnBaseMixin);\n\n      _this = _super.call(this);\n      _this._templateObserver = new FlattenedNodesObserver(_assertThisInitialized(_this), function (info) {\n        _this._headerTemplate = _this._prepareHeaderTemplate();\n        _this._footerTemplate = _this._prepareFooterTemplate();\n        _this._bodyTemplate = _this._prepareBodyTemplate();\n      });\n      return _this;\n    }\n    /**\n     * @return {HTMLTemplateElement}\n     * @protected\n     */\n\n\n    _createClass(ColumnBaseMixin, [{\n      key: \"_prepareHeaderTemplate\",\n      value: function _prepareHeaderTemplate() {\n        return this._prepareTemplatizer(this._findTemplate(true) || null, {});\n      }\n      /**\n       * @return {HTMLTemplateElement}\n       * @protected\n       */\n\n    }, {\n      key: \"_prepareFooterTemplate\",\n      value: function _prepareFooterTemplate() {\n        return this._prepareTemplatizer(this._findTemplate(false, true) || null, {});\n      }\n      /**\n       * @return {HTMLTemplateElement}\n       * @protected\n       */\n\n    }, {\n      key: \"_prepareBodyTemplate\",\n      value: function _prepareBodyTemplate() {\n        return this._prepareTemplatizer(this._findTemplate() || null);\n      }\n      /**\n       * @param {HTMLTemplateElement} template\n       * @param {object} instanceProps\n       * @return {HTMLTemplateElement}\n       * @protected\n       */\n\n    }, {\n      key: \"_prepareTemplatizer\",\n      value: function _prepareTemplatizer(template, instanceProps) {\n        if (template && !template.templatizer) {\n          var templatizer = new Templatizer();\n          templatizer._grid = this._grid;\n          templatizer.dataHost = this.dataHost;\n          templatizer._instanceProps = instanceProps || templatizer._instanceProps;\n          templatizer.template = template;\n          template.templatizer = templatizer;\n        }\n\n        return template;\n      }\n      /** @protected */\n\n    }, {\n      key: \"_renderHeaderAndFooter\",\n      value: function _renderHeaderAndFooter() {\n        if (this.headerRenderer && this._headerCell) {\n          this.__runRenderer(this.headerRenderer, this._headerCell);\n        }\n\n        if (this.footerRenderer && this._footerCell) {\n          this.__runRenderer(this.footerRenderer, this._footerCell);\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"__runRenderer\",\n      value: function __runRenderer(renderer, cell, model) {\n        var args = [cell._content, this];\n\n        if (model && model.item) {\n          args.push(model);\n        }\n\n        renderer.apply(this, args);\n      }\n      /** @private */\n\n    }, {\n      key: \"__setColumnTemplateOrRenderer\",\n      value: function __setColumnTemplateOrRenderer(template, renderer, cells) {\n        var _this4 = this;\n\n        if (template && renderer) {\n          throw new Error('You should only use either a renderer or a template');\n        }\n\n        cells.forEach(function (cell) {\n          var model = _this4._grid.__getRowModel(cell.parentElement);\n\n          if (renderer) {\n            cell._renderer = renderer;\n\n            if (model.item || renderer === _this4.headerRenderer || renderer === _this4.footerRenderer) {\n              _this4.__runRenderer(renderer, cell, model);\n            }\n          } else if (cell._template !== template) {\n            cell._template = template;\n            cell._content.innerHTML = '';\n            template.templatizer._grid = template.templatizer._grid || _this4._grid;\n            var inst = template.templatizer.createInstance();\n\n            cell._content.appendChild(inst.root);\n\n            cell._instance = inst;\n\n            if (model.item) {\n              cell._instance.setProperties(model);\n            }\n          }\n        });\n      }\n      /** @private */\n\n    }, {\n      key: \"_setBodyTemplateOrRenderer\",\n      value: function _setBodyTemplateOrRenderer(template, renderer, cells, splices) {\n        if ((template || renderer) && cells) {\n          this.__setColumnTemplateOrRenderer(template, renderer, cells);\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"_setHeaderTemplateOrRenderer\",\n      value: function _setHeaderTemplateOrRenderer(headerTemplate, headerRenderer, headerCell) {\n        if ((headerTemplate || headerRenderer) && headerCell) {\n          this.__setColumnTemplateOrRenderer(headerTemplate, headerRenderer, [headerCell]);\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"_setFooterTemplateOrRenderer\",\n      value: function _setFooterTemplateOrRenderer(footerTemplate, footerRenderer, footerCell) {\n        if ((footerTemplate || footerRenderer) && footerCell) {\n          this.__setColumnTemplateOrRenderer(footerTemplate, footerRenderer, [footerCell]);\n\n          this._grid.__updateHeaderFooterRowVisibility(footerCell.parentElement);\n        }\n      }\n      /**\n       * @param {boolean} header\n       * @param {boolean} footer\n       * @return {HTMLTemplateElement}\n       * @protected\n       */\n\n    }, {\n      key: \"_selectFirstTemplate\",\n      value: function _selectFirstTemplate() {\n        var header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var footer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        return FlattenedNodesObserver.getFlattenedNodes(this).filter(function (node) {\n          return node.localName === 'template' && node.classList.contains('header') === header && node.classList.contains('footer') === footer;\n        })[0];\n      }\n      /**\n       * @param {boolean} header\n       * @param {boolean} footer\n       * @return {HTMLTemplateElement}\n       * @protected\n       */\n\n    }, {\n      key: \"_findTemplate\",\n      value: function _findTemplate(header, footer) {\n        var template = this._selectFirstTemplate(header, footer);\n\n        if (template) {\n          if (this.dataHost) {\n            // set dataHost to the context where template has been defined\n            template._rootDataHost = this.dataHost._rootDataHost || this.dataHost;\n          }\n        }\n\n        return template;\n      }\n      /** @private */\n\n    }, {\n      key: \"_flexGrowChanged\",\n      value: function _flexGrowChanged(flexGrow, headerCell, footerCell, cells) {\n        if (this.parentElement && this.parentElement._columnPropChanged) {\n          this.parentElement._columnPropChanged('flexGrow');\n        }\n\n        this._allCells.forEach(function (cell) {\n          return cell.style.flexGrow = flexGrow;\n        });\n      }\n      /** @private */\n\n    }, {\n      key: \"_orderChanged\",\n      value: function _orderChanged(order, headerCell, footerCell, cells) {\n        this._allCells.forEach(function (cell) {\n          return cell.style.order = order;\n        });\n      }\n      /** @private */\n\n    }, {\n      key: \"_widthChanged\",\n      value: function _widthChanged(width, headerCell, footerCell, cells) {\n        if (this.parentElement && this.parentElement._columnPropChanged) {\n          this.parentElement._columnPropChanged('width');\n        }\n\n        this._allCells.forEach(function (cell) {\n          return cell.style.width = width;\n        }); // Force a reflow to workaround browser issues causing double scrollbars to grid\n        // https://github.com/vaadin/vaadin-grid/issues/1586\n\n\n        if (this._grid && this._grid.__forceReflow) {\n          this._grid.__forceReflow();\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"_frozenChanged\",\n      value: function _frozenChanged(frozen, headerCell, footerCell, cells) {\n        var _this5 = this;\n\n        if (this.parentElement && this.parentElement._columnPropChanged) {\n          this.parentElement._columnPropChanged('frozen', frozen);\n        }\n\n        this._allCells.forEach(function (cell) {\n          return _this5._toggleAttribute('frozen', frozen, cell);\n        });\n\n        this._grid && this._grid._frozenCellsChanged && this._grid._frozenCellsChanged();\n      }\n      /** @private */\n\n    }, {\n      key: \"_lastFrozenChanged\",\n      value: function _lastFrozenChanged(lastFrozen) {\n        var _this6 = this;\n\n        this._allCells.forEach(function (cell) {\n          return _this6._toggleAttribute('last-frozen', lastFrozen, cell);\n        });\n\n        if (this.parentElement && this.parentElement._columnPropChanged) {\n          this.parentElement._lastFrozen = lastFrozen;\n        }\n      }\n      /**\n       * @param {string | undefined} path\n       * @param {string | undefined} header\n       * @param {!HTMLTableCellElement | undefined} headerCell\n       * @param {!HTMLTableCellElement | undefined} footerCell\n       * @param {!object | undefined} cells\n       * @param {GridBodyRenderer | undefined} renderer\n       * @param {GridHeaderFooterRenderer | undefined} headerRenderer\n       * @param {HTMLTemplateElement | undefined} bodyTemplate\n       * @param {HTMLTemplateElement | undefined} headerTemplate\n       * @protected\n       */\n\n    }, {\n      key: \"_pathOrHeaderChanged\",\n      value: function _pathOrHeaderChanged(path, header, headerCell, footerCell, cells, renderer, headerRenderer, bodyTemplate, headerTemplate) {\n        var _this7 = this;\n\n        var hasHeaderText = header !== undefined;\n\n        if (!headerRenderer && !headerTemplate && hasHeaderText && headerCell) {\n          this.__setTextContent(headerCell._content, header);\n        }\n\n        if (path && cells.value) {\n          if (!renderer && !bodyTemplate) {\n            var pathRenderer = function pathRenderer(root, owner, _ref) {\n              var item = _ref.item;\n              return _this7.__setTextContent(root, _this7.get(path, item));\n            };\n\n            this.__setColumnTemplateOrRenderer(undefined, pathRenderer, cells.value);\n          }\n\n          if (!headerRenderer && !headerTemplate && !hasHeaderText && headerCell && header !== null) {\n            this.__setTextContent(headerCell._content, this._generateHeader(path));\n          }\n        }\n\n        if (headerCell) {\n          this._grid.__updateHeaderFooterRowVisibility(headerCell.parentElement);\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"__setTextContent\",\n      value: function __setTextContent(node, textContent) {\n        node.textContent !== textContent && (node.textContent = textContent);\n      }\n      /**\n       * @param {string} path\n       * @return {string}\n       * @protected\n       */\n\n    }, {\n      key: \"_generateHeader\",\n      value: function _generateHeader(path) {\n        return path.substr(path.lastIndexOf('.') + 1).replace(/([A-Z])/g, '-$1').toLowerCase().replace(/-/g, ' ').replace(/^./, function (match) {\n          return match.toUpperCase();\n        });\n      }\n      /**\n       * @param {string} name\n       * @param {boolean} bool\n       * @param {!Element} node\n       * @protected\n       */\n\n    }, {\n      key: \"_toggleAttribute\",\n      value: function _toggleAttribute(name, bool, node) {\n        if (node.hasAttribute(name) === !bool) {\n          if (bool) {\n            node.setAttribute(name, '');\n          } else {\n            node.removeAttribute(name);\n          }\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"_reorderStatusChanged\",\n      value: function _reorderStatusChanged(reorderStatus, headerCell, footerCell, cells) {\n        this._allCells.forEach(function (cell) {\n          return cell.setAttribute('reorder-status', reorderStatus);\n        });\n      }\n      /** @private */\n\n    }, {\n      key: \"_resizableChanged\",\n      value: function _resizableChanged(resizable, headerCell) {\n        if (resizable === undefined || headerCell === undefined) {\n          return;\n        }\n\n        if (headerCell) {\n          [headerCell].concat(this._emptyCells).forEach(function (cell) {\n            if (cell) {\n              var existingHandle = cell.querySelector('[part~=\"resize-handle\"]');\n\n              if (existingHandle) {\n                cell.removeChild(existingHandle);\n              }\n\n              if (resizable) {\n                var handle = document.createElement('div');\n                handle.setAttribute('part', 'resize-handle');\n                cell.appendChild(handle);\n              }\n            }\n          });\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"_textAlignChanged\",\n      value: function _textAlignChanged(textAlign, _cells, _headerCell, _footerCell) {\n        if (textAlign === undefined) {\n          return;\n        }\n\n        if (['start', 'end', 'center'].indexOf(textAlign) === -1) {\n          console.warn('textAlign can only be set as \"start\", \"end\" or \"center\"');\n          return;\n        }\n\n        var textAlignFallback;\n\n        if (getComputedStyle(this._grid).direction === 'ltr') {\n          if (textAlign === 'start') {\n            textAlignFallback = 'left';\n          } else if (textAlign === 'end') {\n            textAlignFallback = 'right';\n          }\n        } else {\n          if (textAlign === 'start') {\n            textAlignFallback = 'right';\n          } else if (textAlign === 'end') {\n            textAlignFallback = 'left';\n          }\n        }\n\n        this._allCells.forEach(function (cell) {\n          cell._content.style.textAlign = textAlign;\n\n          if (getComputedStyle(cell._content).textAlign !== textAlign) {\n            cell._content.style.textAlign = textAlignFallback;\n          }\n        });\n      }\n      /** @private */\n\n    }, {\n      key: \"_hiddenChanged\",\n      value: function _hiddenChanged(hidden, headerCell, footerCell, cells) {\n        var _this8 = this;\n\n        if (this.parentElement && this.parentElement._columnPropChanged) {\n          this.parentElement._columnPropChanged('hidden', hidden);\n        }\n\n        if (!!hidden !== !!this._previousHidden && this._grid) {\n          if (hidden === true) {\n            this._allCells.forEach(function (cell) {\n              if (cell._content.parentNode) {\n                cell._content.parentNode.removeChild(cell._content);\n              }\n            });\n          }\n\n          this._grid._debouncerHiddenChanged = Debouncer.debounce(this._grid._debouncerHiddenChanged, animationFrame, function () {\n            if (_this8._grid && _this8._grid._renderColumnTree) {\n              _this8._grid._renderColumnTree(_this8._grid._columnTree);\n            }\n          });\n          this._grid._updateLastFrozen && this._grid._updateLastFrozen();\n          this._grid.notifyResize && this._grid.notifyResize();\n          this._grid._resetKeyboardNavigation && this._grid._resetKeyboardNavigation();\n        }\n\n        this._previousHidden = hidden;\n      }\n    }]);\n\n    return ColumnBaseMixin;\n  }(superClass);\n};\n/**\n * A `<vaadin-grid-column>` is used to configure how a column in `<vaadin-grid>`\n * should look like.\n *\n * See `<vaadin-grid>` documentation and demos for instructions and examples on how\n * to configure the `<vaadin-grid-column>`.\n * ```\n *\n * @extends PolymerElement\n * @mixes ColumnBaseMixin\n */\n\nvar GridColumnElement = /*#__PURE__*/function (_ColumnBaseMixin) {\n  _inherits(GridColumnElement, _ColumnBaseMixin);\n\n  var _super2 = _createSuper(GridColumnElement);\n\n  function GridColumnElement() {\n    _classCallCheck(this, GridColumnElement);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(GridColumnElement, null, [{\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-grid-column';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * Width of the cells for this column.\n         */\n        width: {\n          type: String,\n          value: '100px'\n        },\n\n        /**\n         * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.\n         * @attr {number} flex-grow\n         * @type {number}\n         */\n        flexGrow: {\n          type: Number,\n          value: 1\n        },\n\n        /**\n         * Custom function for rendering the cell content.\n         * Receives three arguments:\n         *\n         * - `root` The cell content DOM element. Append your content to it.\n         * - `column` The `<vaadin-grid-column>` element.\n         * - `model` The object with the properties related with\n         *   the rendered item, contains:\n         *   - `model.index` The index of the item.\n         *   - `model.item` The item.\n         *   - `model.expanded` Sublevel toggle state.\n         *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.\n         *   - `model.selected` Selected state.\n         *\n         * @type {GridBodyRenderer | null | undefined}\n         */\n        renderer: Function,\n\n        /**\n         * Path to an item sub-property whose value gets displayed in the column body cells.\n         * The property name is also shown in the column header if an explicit header or renderer isn't defined.\n         */\n        path: {\n          type: String\n        },\n\n        /**\n         * Automatically sets the width of the column based on the column contents when this is set to `true`.\n         *\n         * For performance reasons the column width is calculated automatically only once when the grid items\n         * are rendered for the first time and the calculation only considers the rows which are currently\n         * rendered in DOM (a bit more than what is currently visible). If the grid is scrolled, or the cell\n         * content changes, the column width might not match the contents anymore.\n         *\n         * Hidden columns are ignored in the calculation and their widths are not automatically updated when\n         * you show a column that was initially hidden.\n         *\n         * You can manually trigger the auto sizing behavior again by calling `grid.recalculateColumnWidths()`.\n         *\n         * The column width may still grow larger when `flexGrow` is not 0.\n         * @attr {boolean} auto-width\n         * @type {boolean}\n         */\n        autoWidth: {\n          type: Boolean,\n          value: false\n        },\n\n        /**\n         * @type {HTMLTemplateElement}\n         * @protected\n         */\n        _bodyTemplate: {\n          type: Object\n        },\n\n        /**\n         * @type {Array<!HTMLElement>}\n         * @protected\n         */\n        _cells: Array\n      };\n    }\n  }]);\n\n  return GridColumnElement;\n}(ColumnBaseMixin(DirMixin(PolymerElement)));\n\ncustomElements.define(GridColumnElement.is, GridColumnElement);\nexport { GridColumnElement };"
    },
    {
     "id": 255,
     "name": "../node_modules/highcharts/js/es-modules/parts/SvgRenderer.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Options to align the element relative to the chart or another box.\n *\n * @typedef Highcharts.AlignObject\n *\n * @property {string} [align='left']\n *           Horizontal alignment. Can be one of `left`, `center` and\n *           `right`.\n *\n * @property {string} [verticalAlign='top']\n *           Vertical alignment. Can be one of `top`, `middle` and `bottom`.\n *\n * @property {number} [x=0]\n *           Horizontal pixel offset from alignment.\n *\n * @property {number} [y=0]\n *           Vertical pixel offset from alignment.\n *\n * @property {boolean} [alignByTranslate=false]\n *           Use the `transform` attribute with translateX and translateY\n *           custom attributes to align this elements rather than `x` and\n *           `y` attributes.\n */\n\n/**\n * Bounding box of an element.\n *\n * @typedef Highcharts.BBoxObject\n *\n * @property {number} height\n *           Height of the bounding box.\n *\n * @property {number} width\n *           Width of the bounding box.\n *\n * @property {number} x\n *           Horizontal position of the bounding box.\n *\n * @property {number} y\n *           Vertical position of the bounding box.\n */\n\n/**\n * A clipping rectangle that can be applied to one or more\n * {@link SVGElement} instances. It is instanciated with the\n * {@link SVGRenderer#clipRect} function and applied with the\n * {@link SVGElement#clip} function.\n *\n * @example\n * var circle = renderer.circle(100, 100, 100)\n *     .attr({ fill: 'red' })\n *     .add();\n * var clipRect = renderer.clipRect(100, 100, 100, 100);\n *\n * // Leave only the lower right quarter visible\n * circle.clip(clipRect);\n *\n * @typedef {Highcharts.SVGElement} Highcharts.ClipRectElement\n */\n\n/**\n * The font metrics.\n *\n * @typedef Highcharts.FontMetricsObject\n *\n * @property {number} b\n *           The baseline relative to the top of the box.\n *\n * @property {number} h\n *           The line height.\n *\n * @property {number} f\n *           The font size.\n */\n\n/**\n * Gradient options instead of a solid color.\n *\n * @example\n * // Linear gradient used as a color option\n * color: {\n *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },\n *         stops: [\n *             [0, '#003399'], // start\n *             [0.5, '#ffffff'], // middle\n *             [1, '#3366AA'] // end\n *         ]\n *     }\n * }\n *\n * @private\n * @typedef Highcharts.GradientColorObject\n *\n * @property {Highcharts.LinearGradientColorObject} linearGradient\n *           Holds an object that defines the start position and the end\n *           position relative to the shape.\n *\n * @property {Highcharts.RadialGradientColorObject} radialGradient\n *           Holds an object that defines the center position and the\n *           radius.\n *\n * @property {Array<Array<number|string>>} stops\n *           The first item in each tuple is the position in the gradient,\n *           where 0 is the start of the gradient and 1 is the end of the\n *           gradient. Multiple stops can be applied. The second item is the\n *           color for each stop. This color can also be given in the rgba\n *           format.\n */\n\n/**\n * Defines the start position and the end position for a gradient relative\n * to the shape.\n *\n * @private\n * @typedef Highcharts.LinearGradientColorObject\n *\n * @property {number} x1\n *           Start horizontal position of the gradient. Ranges 0-1.\n *\n * @property {number} x2\n *           End horizontal position of the gradient. Ranges 0-1.\n *\n * @property {number} y1\n *           Start vertical position of the gradient. Ranges 0-1.\n *\n * @property {number} y2\n *           End vertical position of the gradient. Ranges 0-1.\n */\n\n/**\n * Defines the center position and the radius for a gradient.\n *\n * @private\n * @typedef Highcharts.RadialGradientColorObject\n *\n * @property {number} cx\n *           Center horizontal position relative to the shape. Ranges 0-1.\n *\n * @property {number} cy\n *           Center vertical position relative to the shape. Ranges 0-1.\n *\n * @property {number} r\n *           Radius relative to the shape. Ranges 0-1.\n */\n\n/**\n * A rectangle.\n *\n * @typedef Highcharts.RectangleObject\n *\n * @property {number} height\n *           Height of the rectangle.\n *\n * @property {number} width\n *           Width of the rectangle.\n *\n * @property {number} x\n *           Horizontal position of the rectangle.\n *\n * @property {number} y\n *           Vertical position of the rectangle.\n */\n\n/**\n * The shadow options.\n *\n * @typedef Highcharts.ShadowOptionsObject\n *\n * @property {string} [color=#000000]\n *           The shadow color.\n *\n * @property {number} [offsetX=1]\n *           The horizontal offset from the element.\n *\n * @property {number} [offsetY=1]\n *           The vertical offset from the element.\n *\n * @property {number} [opacity=0.15]\n *           The shadow opacity.\n *\n * @property {number} [width=3]\n *           The shadow width or distance from the element.\n */\n\n/**\n * Serialized form of an SVG definition, including children. Some key\n * property names are reserved: tagName, textContent, and children.\n *\n * @typedef Highcharts.SVGDefinitionObject\n *\n * @property {number|string|Array<Highcharts.SVGDefinitionObject>|undefined} [key:string]\n *\n * @property {Array<Highcharts.SVGDefinitionObject>} [children]\n *\n * @property {string} [tagName]\n *\n * @property {string} [textContent]\n */\n\n/**\n * An extendable collection of functions for defining symbol paths.\n *\n * @typedef Highcharts.SymbolDictionary\n *\n * @property {Function} [key:Highcharts.SymbolKey]\n */\n\n/**\n * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,\n * `triangle`, `triangle-down`. Symbols are used internally for point\n * markers, button and label borders and backgrounds, or custom shapes.\n * Extendable by adding to {@link SVGRenderer#symbols}.\n *\n * @typedef {string} Highcharts.SymbolKey\n *\n * @validvalue [\"arc\", \"callout\", \"circle\", \"diamond\", \"square\", \"triangle\",\n *             \"triangle-down\"]\n */\n\n/**\n * Additional options, depending on the actual symbol drawn.\n *\n * @typedef Highcharts.SymbolOptionsObject\n *\n * @property {number} anchorX\n *           The anchor X position for the `callout` symbol. This is where\n *           the chevron points to.\n *\n * @property {number} anchorY\n *           The anchor Y position for the `callout` symbol. This is where\n *           the chevron points to.\n *\n * @property {number} end\n *           The end angle of an `arc` symbol.\n *\n * @property {boolean} open\n *           Whether to draw `arc` symbol open or closed.\n *\n * @property {number} r\n *           The radius of an `arc` symbol, or the border radius for the\n *           `callout` symbol.\n *\n * @property {number} start\n *           The start angle of an `arc` symbol.\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Color.js';\nvar SVGElement,\n    SVGRenderer,\n    addEvent = H.addEvent,\n    _animate = H.animate,\n    attr = H.attr,\n    charts = H.charts,\n    color = H.color,\n    _css = H.css,\n    createElement = H.createElement,\n    defined = H.defined,\n    deg2rad = H.deg2rad,\n    destroyObjectProperties = H.destroyObjectProperties,\n    doc = H.doc,\n    each = H.each,\n    extend = H.extend,\n    erase = H.erase,\n    grep = H.grep,\n    hasTouch = H.hasTouch,\n    inArray = H.inArray,\n    isArray = H.isArray,\n    isFirefox = H.isFirefox,\n    isMS = H.isMS,\n    isObject = H.isObject,\n    isString = H.isString,\n    isWebKit = H.isWebKit,\n    merge = H.merge,\n    noop = H.noop,\n    objectEach = H.objectEach,\n    pick = H.pick,\n    pInt = H.pInt,\n    removeEvent = H.removeEvent,\n    splat = H.splat,\n    stop = H.stop,\n    svg = H.svg,\n    SVG_NS = H.SVG_NS,\n    symbolSizes = H.symbolSizes,\n    win = H.win;\n/**\n * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the\n * rendering layer of Highcharts. Combined with the {@link\n * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation\n * in the charts or even in HTML pages without instanciating a chart. The\n * SVGElement can also wrap HTML labels, when `text` or `label` elements are\n * created with the `useHTML` parameter.\n *\n * The SVGElement instances are created through factory functions on the\n * {@link Highcharts.SVGRenderer} object, like\n * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link\n * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},\n * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link\n * Highcharts.SVGRenderer#g} and more.\n *\n * @class\n * @name Highcharts.SVGElement\n */\n\nSVGElement = H.SVGElement = function () {\n  return this;\n};\n\nextend(SVGElement.prototype,\n/** @lends Highcharts.SVGElement.prototype */\n{\n  // Default base for animation\n  opacity: 1,\n  SVG_NS: SVG_NS,\n\n  /**\n   * For labels, these CSS properties are applied to the `text` node directly.\n   *\n   * @private\n   * @name Highcharts.SVGElement#textProps\n   * @type {Array<string>}\n   */\n  textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color', 'lineHeight', 'width', 'textAlign', 'textDecoration', 'textOverflow', 'textOutline', 'cursor'],\n\n  /**\n   * Initialize the SVG element. This function only exists to make the\n   * initiation process overridable. It should not be called directly.\n   *\n   * @function Highcharts.SVGElement#init\n   *\n   * @param {Highcharts.SVGRenderer} renderer\n   *        The SVGRenderer instance to initialize to.\n   *\n   * @param {string} nodeName\n   *        The SVG node name.\n   */\n  init: function init(renderer, nodeName) {\n    /**\n     * The primary DOM node. Each `SVGElement` instance wraps a main DOM\n     * node, but may also represent more nodes.\n     *\n     * @name Highcharts.SVGElement#element\n     * @type {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}\n     */\n    this.element = nodeName === 'span' ? createElement(nodeName) : doc.createElementNS(this.SVG_NS, nodeName);\n    /**\n     * The renderer that the SVGElement belongs to.\n     *\n     * @name Highcharts.SVGElement#renderer\n     * @type {Highcharts.SVGRenderer}\n     */\n\n    this.renderer = renderer;\n  },\n\n  /**\n   * Animate to given attributes or CSS properties.\n   *\n   * @sample highcharts/members/element-on/\n   *         Setting some attributes by animation\n   *\n   * @function Highcharts.SVGElement#animate\n   *\n   * @param {Highcharts.SVGAttributes} params\n   *        SVG attributes or CSS to animate.\n   *\n   * @param {Highcharts.AnimationOptionsObject} [options]\n   *        Animation options.\n   *\n   * @param {Function} [complete]\n   *        Function to perform at the end of animation.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  animate: function animate(params, options, complete) {\n    var animOptions = H.animObject(pick(options, this.renderer.globalAnimation, true));\n\n    if (animOptions.duration !== 0) {\n      // allows using a callback with the global animation without\n      // overwriting it\n      if (complete) {\n        animOptions.complete = complete;\n      }\n\n      _animate(this, params, animOptions);\n    } else {\n      this.attr(params, null, complete);\n\n      if (animOptions.step) {\n        animOptions.step.call(this);\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Build and apply an SVG gradient out of a common JavaScript configuration\n   * object. This function is called from the attribute setters. An event\n   * hook is added for supporting other complex color types.\n   *\n   * @private\n   * @function Highcharts.SVGElement#complexColor\n   *\n   * @param {Highcharts.GradientColorObject} color\n   *        The gradient options structure.\n   *\n   * @param {string} prop\n   *        The property to apply, can either be `fill` or `stroke`.\n   *\n   * @param {Highcharts.SVGDOMElement} elem\n   *        SVG DOM element to apply the gradient on.\n   */\n  complexColor: function complexColor(color, prop, elem) {\n    var renderer = this.renderer,\n        colorObject,\n        gradName,\n        gradAttr,\n        radAttr,\n        gradients,\n        gradientObject,\n        stops,\n        stopColor,\n        stopOpacity,\n        radialReference,\n        id,\n        key = [],\n        value;\n    H.fireEvent(this.renderer, 'complexColor', {\n      args: arguments\n    }, function () {\n      // Apply linear or radial gradients\n      if (color.radialGradient) {\n        gradName = 'radialGradient';\n      } else if (color.linearGradient) {\n        gradName = 'linearGradient';\n      }\n\n      if (gradName) {\n        gradAttr = color[gradName];\n        gradients = renderer.gradients;\n        stops = color.stops;\n        radialReference = elem.radialReference; // Keep < 2.2 kompatibility\n\n        if (isArray(gradAttr)) {\n          color[gradName] = gradAttr = {\n            x1: gradAttr[0],\n            y1: gradAttr[1],\n            x2: gradAttr[2],\n            y2: gradAttr[3],\n            gradientUnits: 'userSpaceOnUse'\n          };\n        } // Correct the radial gradient for the radial reference system\n\n\n        if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n          // Save the radial attributes for updating\n          radAttr = gradAttr;\n          gradAttr = merge(gradAttr, renderer.getRadialAttr(radialReference, radAttr), {\n            gradientUnits: 'userSpaceOnUse'\n          });\n        } // Build the unique key to detect whether we need to create a\n        // new element (#1282)\n\n\n        objectEach(gradAttr, function (val, n) {\n          if (n !== 'id') {\n            key.push(n, val);\n          }\n        });\n        objectEach(stops, function (val) {\n          key.push(val);\n        });\n        key = key.join(','); // Check if a gradient object with the same config object is\n        // created within this renderer\n\n        if (gradients[key]) {\n          id = gradients[key].attr('id');\n        } else {\n          // Set the id and create the element\n          gradAttr.id = id = H.uniqueKey();\n          gradients[key] = gradientObject = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);\n          gradientObject.radAttr = radAttr; // The gradient needs to keep a list of stops to be able to\n          // destroy them\n\n          gradientObject.stops = [];\n          each(stops, function (stop) {\n            var stopObject;\n\n            if (stop[1].indexOf('rgba') === 0) {\n              colorObject = H.color(stop[1]);\n              stopColor = colorObject.get('rgb');\n              stopOpacity = colorObject.get('a');\n            } else {\n              stopColor = stop[1];\n              stopOpacity = 1;\n            }\n\n            stopObject = renderer.createElement('stop').attr({\n              offset: stop[0],\n              'stop-color': stopColor,\n              'stop-opacity': stopOpacity\n            }).add(gradientObject); // Add the stop element to the gradient\n\n            gradientObject.stops.push(stopObject);\n          });\n        } // Set the reference to the gradient object\n\n\n        value = 'url(' + renderer.url + '#' + id + ')';\n        elem.setAttribute(prop, value);\n        elem.gradient = key; // Allow the color to be concatenated into tooltips formatters\n        // etc. (#2995)\n\n        color.toString = function () {\n          return value;\n        };\n      }\n    });\n  },\n\n  /**\n   * Apply a text outline through a custom CSS property, by copying the text\n   * element and apply stroke to the copy. Used internally. Contrast checks at\n   * {@link https://jsfiddle.net/highcharts/43soe9m1/2/}.\n   *\n   * @example\n   * // Specific color\n   * text.css({\n   *    textOutline: '1px black'\n   * });\n   * // Automatic contrast\n   * text.css({\n   *    color: '#000000', // black text\n   *    textOutline: '1px contrast' // => white outline\n   * });\n   *\n   * @private\n   * @function Highcharts.SVGElement#applyTextOutline\n   *\n   * @param {string} textOutline\n   *        A custom CSS `text-outline` setting, defined by `width color`.\n   */\n  applyTextOutline: function applyTextOutline(textOutline) {\n    var elem = this.element,\n        tspans,\n        tspan,\n        hasContrast = textOutline.indexOf('contrast') !== -1,\n        styles = {},\n        color,\n        strokeWidth,\n        firstRealChild,\n        i; // When the text shadow is set to contrast, use dark stroke for light\n    // text and vice versa.\n\n    if (hasContrast) {\n      styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n    } // Extract the stroke width and color\n\n\n    textOutline = textOutline.split(' ');\n    color = textOutline[textOutline.length - 1];\n    strokeWidth = textOutline[0];\n\n    if (strokeWidth && strokeWidth !== 'none' && H.svg) {\n      this.fakeTS = true; // Fake text shadow\n\n      tspans = [].slice.call(elem.getElementsByTagName('tspan')); // In order to get the right y position of the clone,\n      // copy over the y setter\n\n      this.ySetter = this.xSetter; // Since the stroke is applied on center of the actual outline, we\n      // need to double it to get the correct stroke-width outside the\n      // glyphs.\n\n      strokeWidth = strokeWidth.replace(/(^[\\d\\.]+)(.*?)$/g, function (match, digit, unit) {\n        return 2 * digit + unit;\n      }); // Remove shadows from previous runs. Iterate from the end to\n      // support removing items inside the cycle (#6472).\n\n      i = tspans.length;\n\n      while (i--) {\n        tspan = tspans[i];\n\n        if (tspan.getAttribute('class') === 'highcharts-text-outline') {\n          // Remove then erase\n          erase(tspans, elem.removeChild(tspan));\n        }\n      } // For each of the tspans, create a stroked copy behind it.\n\n\n      firstRealChild = elem.firstChild;\n      each(tspans, function (tspan, y) {\n        var clone; // Let the first line start at the correct X position\n\n        if (y === 0) {\n          tspan.setAttribute('x', elem.getAttribute('x'));\n          y = elem.getAttribute('y');\n          tspan.setAttribute('y', y || 0);\n\n          if (y === null) {\n            elem.setAttribute('y', 0);\n          }\n        } // Create the clone and apply outline properties\n\n\n        clone = tspan.cloneNode(1);\n        attr(clone, {\n          'class': 'highcharts-text-outline',\n          'fill': color,\n          'stroke': color,\n          'stroke-width': strokeWidth,\n          'stroke-linejoin': 'round'\n        });\n        elem.insertBefore(clone, firstRealChild);\n      });\n    }\n  },\n\n  /**\n   * Apply native and custom attributes to the SVG elements.\n   *\n   * In order to set the rotation center for rotation, set x and y to 0 and\n   * use `translateX` and `translateY` attributes to position the element\n   * instead.\n   *\n   * Attributes frequently used in Highcharts are `fill`, `stroke`,\n   * `stroke-width`.\n   *\n   * @sample highcharts/members/renderer-rect/\n   *         Setting some attributes\n   *\n   * @example\n   * // Set multiple attributes\n   * element.attr({\n   *     stroke: 'red',\n   *     fill: 'blue',\n   *     x: 10,\n   *     y: 10\n   * });\n   *\n   * // Set a single attribute\n   * element.attr('stroke', 'red');\n   *\n   * // Get an attribute\n   * element.attr('stroke'); // => 'red'\n   *\n   * @function Highcharts.SVGElement#attr\n   *\n   * @param {string|Highcharts.SVGAttributes} [hash]\n   *        The native and custom SVG attributes.\n   *\n   * @param {string} [val]\n   *        If the type of the first argument is `string`, the second can be a\n   *        value, which will serve as a single attribute setter. If the first\n   *        argument is a string and the second is undefined, the function\n   *        serves as a getter and the current value of the property is\n   *        returned.\n   *\n   * @param {Function} [complete]\n   *        A callback function to execute after setting the attributes. This\n   *        makes the function compliant and interchangeable with the\n   *        {@link SVGElement#animate} function.\n   *\n   * @param {boolean} [continueAnimation=true]\n   *        Used internally when `.attr` is called as part of an animation\n   *        step. Otherwise, calling `.attr` for an attribute will stop\n   *        animation for that attribute.\n   *\n   * @return {number|string|Highcharts.SVGElement}\n   *         If used as a setter, it returns the current\n   *         {@link Highcharts.SVGElement} so the calls can be chained. If\n   *         used as a getter, the current value of the attribute is returned.\n   */\n  attr: function attr(hash, val, complete, continueAnimation) {\n    var key,\n        element = this.element,\n        hasSetSymbolSize,\n        ret = this,\n        skipAttr,\n        setter; // single key-value pair\n\n    if (typeof hash === 'string' && val !== undefined) {\n      key = hash;\n      hash = {};\n      hash[key] = val;\n    } // used as a getter: first argument is a string, second is undefined\n\n\n    if (typeof hash === 'string') {\n      ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element); // setter\n    } else {\n      objectEach(hash, function eachAttribute(val, key) {\n        skipAttr = false; // Unless .attr is from the animator update, stop current\n        // running animation of this property\n\n        if (!continueAnimation) {\n          stop(this, key);\n        } // Special handling of symbol attributes\n\n\n        if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(key)) {\n          if (!hasSetSymbolSize) {\n            this.symbolAttr(hash);\n            hasSetSymbolSize = true;\n          }\n\n          skipAttr = true;\n        }\n\n        if (this.rotation && (key === 'x' || key === 'y')) {\n          this.doTransform = true;\n        }\n\n        if (!skipAttr) {\n          setter = this[key + 'Setter'] || this._defaultSetter;\n          setter.call(this, val, key, element);\n        }\n      }, this);\n      this.afterSetters();\n    } // In accordance with animate, run a complete callback\n\n\n    if (complete) {\n      complete.call(this);\n    }\n\n    return ret;\n  },\n\n  /**\n   * This method is executed in the end of `attr()`, after setting all\n   * attributes in the hash. In can be used to efficiently consolidate\n   * multiple attributes in one SVG property -- e.g., translate, rotate and\n   * scale are merged in one \"transform\" attribute in the SVG node.\n   *\n   * @private\n   * @function Highcharts.SVGElement#afterSetters\n   */\n  afterSetters: function afterSetters() {\n    // Update transform. Do this outside the loop to prevent redundant\n    // updating for batch setting of attributes.\n    if (this.doTransform) {\n      this.updateTransform();\n      this.doTransform = false;\n    }\n  },\n\n  /**\n   * Add a class name to an element.\n   *\n   * @function Highcharts.SVGElement#addClass\n   *\n   * @param {string} className\n   *        The new class name to add.\n   *\n   * @param {boolean} [replace=false]\n   *        When true, the existing class name(s) will be overwritten with\n   *        the new one. When false, the new one is added.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Return the SVG element for chainability.\n   */\n  addClass: function addClass(className, replace) {\n    var currentClassName = this.attr('class') || '';\n\n    if (currentClassName.indexOf(className) === -1) {\n      if (!replace) {\n        className = (currentClassName + (currentClassName ? ' ' : '') + className).replace('  ', ' ');\n      }\n\n      this.attr('class', className);\n    }\n\n    return this;\n  },\n\n  /**\n   * Check if an element has the given class name.\n   *\n   * @function Highcharts.SVGElement#hasClass\n   *\n   * @param {string} className\n   *        The class name to check for.\n   *\n   * @return {boolean}\n   *         Whether the class name is found.\n   */\n  hasClass: function hasClass(className) {\n    return inArray(className, (this.attr('class') || '').split(' ')) !== -1;\n  },\n\n  /**\n   * Remove a class name from the element.\n   *\n   * @function Highcharts.SVGElement#removeClass\n   *\n   * @param {string|RegExp} className\n   *        The class name to remove.\n   *\n   * @return {Highcharts.SVGElement} Returns the SVG element for chainability.\n   */\n  removeClass: function removeClass(className) {\n    return this.attr('class', (this.attr('class') || '').replace(className, ''));\n  },\n\n  /**\n   * If one of the symbol size affecting parameters are changed,\n   * check all the others only once for each call to an element's\n   * .attr() method\n   *\n   * @private\n   * @function Highcharts.SVGElement#symbolAttr\n   *\n   * @param {Highcharts.Dictionary<number|string>} hash\n   *        The attributes to set.\n   */\n  symbolAttr: function symbolAttr(hash) {\n    var wrapper = this;\n    each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {\n      wrapper[key] = pick(hash[key], wrapper[key]);\n    });\n    wrapper.attr({\n      d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)\n    });\n  },\n\n  /**\n   * Apply a clipping rectangle to this element.\n   *\n   * @function Highcharts.SVGElement#clip\n   *\n   * @param {Highcharts.ClipRectElement} [clipRect]\n   *        The clipping rectangle. If skipped, the current clip is removed.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVG element to allow chaining.\n   */\n  clip: function clip(clipRect) {\n    return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : 'none');\n  },\n\n  /**\n   * Calculate the coordinates needed for drawing a rectangle crisply and\n   * return the calculated attributes.\n   *\n   * @function Highcharts.SVGElement#crisp\n   *\n   * @param {Highcharts.RectangleObject} rect\n   *        Rectangle to crisp.\n   *\n   * @param {number} [strokeWidth]\n   *        The stroke width to consider when computing crisp positioning. It\n   *        can also be set directly on the rect parameter.\n   *\n   * @return {Highcharts.RectangleObject}\n   *         The modified rectangle arguments.\n   */\n  crisp: function crisp(rect, strokeWidth) {\n    var wrapper = this,\n        normalizer;\n    strokeWidth = strokeWidth || rect.strokeWidth || 0; // Math.round because strokeWidth can sometimes have roundoff errors\n\n    normalizer = Math.round(strokeWidth) % 2 / 2; // normalize for crisp edges\n\n    rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n    rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n    rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);\n    rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);\n\n    if (defined(rect.strokeWidth)) {\n      rect.strokeWidth = strokeWidth;\n    }\n\n    return rect;\n  },\n\n  /**\n   * Set styles for the element. In addition to CSS styles supported by\n   * native SVG and HTML elements, there are also some custom made for\n   * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text\n   * elements.\n   *\n   * @sample highcharts/members/renderer-text-on-chart/\n   *         Styled text\n   *\n   * @function Highcharts.SVGElement#css\n   *\n   * @param {Highcharts.CSSObject} styles\n   *        The new CSS styles.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Return the SVG element for chaining.\n   */\n  css: function css(styles) {\n    var oldStyles = this.styles,\n        newStyles = {},\n        elem = this.element,\n        textWidth,\n        serializedCss = '',\n        hyphenate,\n        hasNew = !oldStyles,\n        // These CSS properties are interpreted internally by the SVG\n    // renderer, but are not supported by SVG and should not be added to\n    // the DOM. In styled mode, no CSS should find its way to the DOM\n    // whatsoever (#6173, #6474).\n    svgPseudoProps = ['textOutline', 'textOverflow', 'width']; // convert legacy\n\n    if (styles && styles.color) {\n      styles.fill = styles.color;\n    } // Filter out existing styles to increase performance (#2640)\n\n\n    if (oldStyles) {\n      objectEach(styles, function (style, n) {\n        if (style !== oldStyles[n]) {\n          newStyles[n] = style;\n          hasNew = true;\n        }\n      });\n    }\n\n    if (hasNew) {\n      // Merge the new styles with the old ones\n      if (oldStyles) {\n        styles = extend(oldStyles, newStyles);\n      } // Get the text width from style\n\n\n      if (styles) {\n        // Previously set, unset it (#8234)\n        if (styles.width === null || styles.width === 'auto') {\n          delete this.textWidth; // Apply new\n        } else if (elem.nodeName.toLowerCase() === 'text' && styles.width) {\n          textWidth = this.textWidth = pInt(styles.width);\n        }\n      } // store object\n\n\n      this.styles = styles;\n\n      if (textWidth && !svg && this.renderer.forExport) {\n        delete styles.width;\n      } // Serialize and set style attribute\n\n\n      if (elem.namespaceURI === this.SVG_NS) {\n        // #7633\n        hyphenate = function hyphenate(a, b) {\n          return '-' + b.toLowerCase();\n        };\n\n        objectEach(styles, function (style, n) {\n          if (inArray(n, svgPseudoProps) === -1) {\n            serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + style + ';';\n          }\n        });\n\n        if (serializedCss) {\n          attr(elem, 'style', serializedCss); // #1881\n        }\n      } else {\n        _css(elem, styles);\n      }\n\n      if (this.added) {\n        // Rebuild text after added. Cache mechanisms in the buildText\n        // will prevent building if there are no significant changes.\n        if (this.element.nodeName === 'text') {\n          this.renderer.buildText(this);\n        } // Apply text outline after added\n\n\n        if (styles && styles.textOutline) {\n          this.applyTextOutline(styles.textOutline);\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Get the computed style. Only in styled mode.\n   *\n   * @example\n   * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'\n   *\n   * @function Highcharts.SVGElement#getStyle\n   *\n   * @param {string} prop\n   *        The property name to check for.\n   *\n   * @return {string}\n   *         The current computed value.\n   */\n  getStyle: function getStyle(prop) {\n    return win.getComputedStyle(this.element || this, '').getPropertyValue(prop);\n  },\n\n  /**\n   * Get the computed stroke width in pixel values. This is used extensively\n   * when drawing shapes to ensure the shapes are rendered crisp and\n   * positioned correctly relative to each other. Using\n   * `shape-rendering: crispEdges` leaves us less control over positioning,\n   * for example when we want to stack columns next to each other, or position\n   * things pixel-perfectly within the plot box.\n   *\n   * The common pattern when placing a shape is:\n   * - Create the SVGElement and add it to the DOM. In styled mode, it will\n   *   now receive a stroke width from the style sheet. In classic mode we\n   *   will add the `stroke-width` attribute.\n   * - Read the computed `elem.strokeWidth()`.\n   * - Place it based on the stroke width.\n   *\n   * @function Highcharts.SVGElement#strokeWidth\n   *\n   * @return {number}\n   *         The stroke width in pixels. Even if the given stroke widtch (in\n   *         CSS or by attributes) is based on `em` or other units, the pixel\n   *         size is returned.\n   */\n  strokeWidth: function strokeWidth() {\n    var val = this.getStyle('stroke-width'),\n        ret,\n        dummy; // Read pixel values directly\n\n    if (val.indexOf('px') === val.length - 2) {\n      ret = pInt(val); // Other values like em, pt etc need to be measured\n    } else {\n      dummy = doc.createElementNS(SVG_NS, 'rect');\n      attr(dummy, {\n        'width': val,\n        'stroke-width': 0\n      });\n      this.element.parentNode.appendChild(dummy);\n      ret = dummy.getBBox().width;\n      dummy.parentNode.removeChild(dummy);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Add an event listener. This is a simple setter that replaces all other\n   * events of the same type, opposed to the {@link Highcharts#addEvent}\n   * function.\n   *\n   * @sample highcharts/members/element-on/\n   *         A clickable rectangle\n   *\n   * @function Highcharts.SVGElement#on\n   *\n   * @param {string} eventType\n   *        The event type. If the type is `click`, Highcharts will internally\n   *        translate it to a `touchstart` event on touch devices, to prevent\n   *        the browser from waiting for a click event from firing.\n   *\n   * @param {Function} handler\n   *        The handler callback.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The SVGElement for chaining.\n   */\n  on: function on(eventType, handler) {\n    var svgElement = this,\n        element = svgElement.element; // touch\n\n    if (hasTouch && eventType === 'click') {\n      element.ontouchstart = function (e) {\n        svgElement.touchEventFired = Date.now(); // #2269\n\n        e.preventDefault();\n        handler.call(element, e);\n      };\n\n      element.onclick = function (e) {\n        if (win.navigator.userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) {\n          handler.call(element, e);\n        }\n      };\n    } else {\n      // simplest possible event model for internal use\n      element['on' + eventType] = handler;\n    }\n\n    return this;\n  },\n\n  /**\n   * Set the coordinates needed to draw a consistent radial gradient across\n   * a shape regardless of positioning inside the chart. Used on pie slices\n   * to make all the slices have the same radial reference point.\n   *\n   * @function Highcharts.SVGElement#setRadialReference\n   *\n   * @param {Array<number>} coordinates\n   *        The center reference. The format is `[centerX, centerY, diameter]`\n   *        in pixels.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  setRadialReference: function setRadialReference(coordinates) {\n    var existingGradient = this.renderer.gradients[this.element.gradient];\n    this.element.radialReference = coordinates; // On redrawing objects with an existing gradient, the gradient needs\n    // to be repositioned (#3801)\n\n    if (existingGradient && existingGradient.radAttr) {\n      existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));\n    }\n\n    return this;\n  },\n\n  /**\n   * Move an object and its children by x and y values.\n   *\n   * @function Highcharts.SVGElement#translate\n   *\n   * @param {number} x\n   *        The x value.\n   *\n   * @param {number} y\n   *        The y value.\n   */\n  translate: function translate(x, y) {\n    return this.attr({\n      translateX: x,\n      translateY: y\n    });\n  },\n\n  /**\n   * Invert a group, rotate and flip. This is used internally on inverted\n   * charts, where the points and graphs are drawn as if not inverted, then\n   * the series group elements are inverted.\n   *\n   * @function Highcharts.SVGElement#invert\n   *\n   * @param {boolean} inverted\n   *        Whether to invert or not. An inverted shape can be un-inverted by\n   *        setting it to false.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Return the SVGElement for chaining.\n   */\n  invert: function invert(inverted) {\n    var wrapper = this;\n    wrapper.inverted = inverted;\n    wrapper.updateTransform();\n    return wrapper;\n  },\n\n  /**\n   * Update the transform attribute based on internal properties. Deals with\n   * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`\n   * attributes and updates the SVG `transform` attribute.\n   *\n   * @private\n   * @function Highcharts.SVGElement#updateTransform\n   */\n  updateTransform: function updateTransform() {\n    var wrapper = this,\n        translateX = wrapper.translateX || 0,\n        translateY = wrapper.translateY || 0,\n        scaleX = wrapper.scaleX,\n        scaleY = wrapper.scaleY,\n        inverted = wrapper.inverted,\n        rotation = wrapper.rotation,\n        matrix = wrapper.matrix,\n        element = wrapper.element,\n        transform; // Flipping affects translate as adjustment for flipping around the\n    // group's axis\n\n    if (inverted) {\n      translateX += wrapper.width;\n      translateY += wrapper.height;\n    } // Apply translate. Nearly all transformed elements have translation,\n    // so instead of checking for translate = 0, do it always (#1767,\n    // #1846).\n\n\n    transform = ['translate(' + translateX + ',' + translateY + ')']; // apply matrix\n\n    if (defined(matrix)) {\n      transform.push('matrix(' + matrix.join(',') + ')');\n    } // apply rotation\n\n\n    if (inverted) {\n      transform.push('rotate(90) scale(-1,1)');\n    } else if (rotation) {\n      // text rotation\n      transform.push('rotate(' + rotation + ' ' + pick(this.rotationOriginX, element.getAttribute('x'), 0) + ' ' + pick(this.rotationOriginY, element.getAttribute('y') || 0) + ')');\n    } // apply scale\n\n\n    if (defined(scaleX) || defined(scaleY)) {\n      transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n    }\n\n    if (transform.length) {\n      element.setAttribute('transform', transform.join(' '));\n    }\n  },\n\n  /**\n   * Bring the element to the front. Alternatively, a new zIndex can be set.\n   *\n   * @sample highcharts/members/element-tofront/\n   *         Click an element to bring it to front\n   *\n   * @function Highcharts.SVGElement#toFront\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  toFront: function toFront() {\n    var element = this.element;\n    element.parentNode.appendChild(element);\n    return this;\n  },\n\n  /**\n   * Align the element relative to the chart or another box.\n   *\n   * @function Highcharts.SVGElement#align\n   *\n   * @param {Highcharts.AlignObject} [alignOptions]\n   *        The alignment options. The function can be called without this\n   *        parameter in order to re-align an element after the box has been\n   *        updated.\n   *\n   * @param {boolean} [alignByTranslate]\n   *        Align element by translation.\n   *\n   * @param {string|Highcharts.BBoxObject} [box]\n   *        The box to align to, needs a width and height. When the box is a\n   *        string, it refers to an object in the Renderer. For example, when\n   *        box is `spacingBox`, it refers to `Renderer.spacingBox` which\n   *        holds `width`, `height`, `x` and `y` properties.\n   *\n   * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n   */\n  align: function align(alignOptions, alignByTranslate, box) {\n    var align,\n        vAlign,\n        x,\n        y,\n        attribs = {},\n        alignTo,\n        renderer = this.renderer,\n        alignedObjects = renderer.alignedObjects,\n        alignFactor,\n        vAlignFactor; // First call on instanciate\n\n    if (alignOptions) {\n      this.alignOptions = alignOptions;\n      this.alignByTranslate = alignByTranslate;\n\n      if (!box || isString(box)) {\n        this.alignTo = alignTo = box || 'renderer'; // prevent duplicates, like legendGroup after resize\n\n        erase(alignedObjects, this);\n        alignedObjects.push(this);\n        box = null; // reassign it below\n      } // When called on resize, no arguments are supplied\n\n    } else {\n      alignOptions = this.alignOptions;\n      alignByTranslate = this.alignByTranslate;\n      alignTo = this.alignTo;\n    }\n\n    box = pick(box, renderer[alignTo], renderer); // Assign variables\n\n    align = alignOptions.align;\n    vAlign = alignOptions.verticalAlign;\n    x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n\n    y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n    // Align\n\n    if (align === 'right') {\n      alignFactor = 1;\n    } else if (align === 'center') {\n      alignFactor = 2;\n    }\n\n    if (alignFactor) {\n      x += (box.width - (alignOptions.width || 0)) / alignFactor;\n    }\n\n    attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x); // Vertical align\n\n    if (vAlign === 'bottom') {\n      vAlignFactor = 1;\n    } else if (vAlign === 'middle') {\n      vAlignFactor = 2;\n    }\n\n    if (vAlignFactor) {\n      y += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n    }\n\n    attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y); // Animate only if already placed\n\n    this[this.placed ? 'animate' : 'attr'](attribs);\n    this.placed = true;\n    this.alignAttr = attribs;\n    return this;\n  },\n\n  /**\n   * Get the bounding box (width, height, x and y) for the element. Generally\n   * used to get rendered text size. Since this is called a lot in charts,\n   * the results are cached based on text properties, in order to save DOM\n   * traffic. The returned bounding box includes the rotation, so for example\n   * a single text line of rotation 90 will report a greater height, and a\n   * width corresponding to the line-height.\n   *\n   * @sample highcharts/members/renderer-on-chart/\n   *         Draw a rectangle based on a text's bounding box\n   *\n   * @function Highcharts.SVGElement#getBBox\n   *\n   * @param {boolean} [reload]\n   *        Skip the cache and get the updated DOM bouding box.\n   *\n   * @param {number} [rot]\n   *        Override the element's rotation. This is internally used on axis\n   *        labels with a value of 0 to find out what the bounding box would\n   *        be have been if it were not rotated.\n   *\n   * @return {Highcharts.BBoxObject}\n   *         The bounding box with `x`, `y`, `width` and `height` properties.\n   */\n  getBBox: function getBBox(reload, rot) {\n    var wrapper = this,\n        bBox,\n        // = wrapper.bBox,\n    renderer = wrapper.renderer,\n        width,\n        height,\n        rotation,\n        rad,\n        element = wrapper.element,\n        styles = wrapper.styles,\n        fontSize,\n        textStr = wrapper.textStr,\n        toggleTextShadowShim,\n        cache = renderer.cache,\n        cacheKeys = renderer.cacheKeys,\n        cacheKey;\n    rotation = pick(rot, wrapper.rotation);\n    rad = rotation * deg2rad;\n    fontSize = element && SVGElement.prototype.getStyle.call(element, 'font-size'); // Avoid undefined and null (#7316)\n\n    if (defined(textStr)) {\n      cacheKey = textStr.toString(); // Since numbers are monospaced, and numerical labels appear a lot\n      // in a chart, we assume that a label of n characters has the same\n      // bounding box as others of the same length. Unless there is inner\n      // HTML in the label. In that case, leave the numbers as is (#5899).\n\n      if (cacheKey.indexOf('<') === -1) {\n        cacheKey = cacheKey.replace(/[0-9]/g, '0');\n      } // Properties that affect bounding box\n\n\n      cacheKey += ['', rotation || 0, fontSize, wrapper.textWidth, // #7874, also useHTML\n      styles && styles.textOverflow // #5968\n      ].join(',');\n    }\n\n    if (cacheKey && !reload) {\n      bBox = cache[cacheKey];\n    } // No cache found\n\n\n    if (!bBox) {\n      // SVG elements\n      if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {\n        try {\n          // Fails in Firefox if the container has display: none.\n          // When the text shadow shim is used, we need to hide the\n          // fake shadows to get the correct bounding box (#3872)\n          toggleTextShadowShim = this.fakeTS && function (display) {\n            each(element.querySelectorAll('.highcharts-text-outline'), function (tspan) {\n              tspan.style.display = display;\n            });\n          }; // Workaround for #3842, Firefox reporting wrong bounding\n          // box for shadows\n\n\n          if (toggleTextShadowShim) {\n            toggleTextShadowShim('none');\n          }\n\n          bBox = element.getBBox ? // SVG: use extend because IE9 is not allowed to change\n          // width and height in case of rotation (below)\n          extend({}, element.getBBox()) : {\n            // Legacy IE in export mode\n            width: element.offsetWidth,\n            height: element.offsetHeight\n          }; // #3842\n\n          if (toggleTextShadowShim) {\n            toggleTextShadowShim('');\n          }\n        } catch (e) {} // If the bBox is not set, the try-catch block above failed. The\n        // other condition is for Opera that returns a width of\n        // -Infinity on hidden elements.\n\n\n        if (!bBox || bBox.width < 0) {\n          bBox = {\n            width: 0,\n            height: 0\n          };\n        } // VML Renderer or useHTML within SVG\n\n      } else {\n        bBox = wrapper.htmlGetBBox();\n      } // True SVG elements as well as HTML elements in modern browsers\n      // using the .useHTML option need to compensated for rotation\n\n\n      if (renderer.isSVG) {\n        width = bBox.width;\n        height = bBox.height; // Workaround for wrong bounding box in IE, Edge and Chrome on\n        // Windows. With Highcharts' default font, IE and Edge report\n        // a box height of 16.899 and Chrome rounds it to 17. If this\n        // stands uncorrected, it results in more padding added below\n        // the text than above when adding a label border or background.\n        // Also vertical positioning is affected.\n        // https://jsfiddle.net/highcharts/em37nvuj/\n        // (#1101, #1505, #1669, #2568, #6213).\n\n        if (styles && styles.fontSize === '11px' && Math.round(height) === 17) {\n          bBox.height = height = 14;\n        } // Adjust for rotated text\n\n\n        if (rotation) {\n          bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));\n          bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));\n        }\n      } // Cache it. When loading a chart in a hidden iframe in Firefox and\n      // IE/Edge, the bounding box height is 0, so don't cache it (#5620).\n\n\n      if (cacheKey && bBox.height > 0) {\n        // Rotate (#4681)\n        while (cacheKeys.length > 250) {\n          delete cache[cacheKeys.shift()];\n        }\n\n        if (!cache[cacheKey]) {\n          cacheKeys.push(cacheKey);\n        }\n\n        cache[cacheKey] = bBox;\n      }\n    }\n\n    return bBox;\n  },\n\n  /**\n   * Show the element after it has been hidden.\n   *\n   * @function Highcharts.SVGElement#show\n   *\n   * @param {boolean} [inherit=false]\n   *        Set the visibility attribute to `inherit` rather than `visible`.\n   *        The difference is that an element with `visibility=\"visible\"`\n   *        will be visible even if the parent is hidden.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  show: function show(inherit) {\n    return this.attr({\n      visibility: inherit ? 'inherit' : 'visible'\n    });\n  },\n\n  /**\n   * Hide the element, equivalent to setting the `visibility` attribute to\n   * `hidden`.\n   *\n   * @function Highcharts.SVGElement#hide\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  hide: function hide() {\n    return this.attr({\n      visibility: 'hidden'\n    });\n  },\n\n  /**\n   * Fade out an element by animating its opacity down to 0, and hide it on\n   * complete. Used internally for the tooltip.\n   *\n   * @function Highcharts.SVGElement#fadeOut\n   *\n   * @param {number} [duration=150]\n   *        The fade duration in milliseconds.\n   */\n  fadeOut: function fadeOut(duration) {\n    var elemWrapper = this;\n    elemWrapper.animate({\n      opacity: 0\n    }, {\n      duration: duration || 150,\n      complete: function complete() {\n        // #3088, assuming we're only using this for tooltips\n        elemWrapper.attr({\n          y: -9999\n        });\n      }\n    });\n  },\n\n  /**\n   * Add the element to the DOM. All elements must be added this way.\n   *\n   * @sample highcharts/members/renderer-g\n   *         Elements added to a group\n   *\n   * @function Highcharts.SVGElement#add\n   *\n   * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [parent]\n   *        The parent item to add it to. If undefined, the element is added\n   *        to the {@link Highcharts.SVGRenderer.box}.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  add: function add(parent) {\n    var renderer = this.renderer,\n        element = this.element,\n        inserted;\n\n    if (parent) {\n      this.parentGroup = parent;\n    } // mark as inverted\n\n\n    this.parentInverted = parent && parent.inverted; // build formatted text\n\n    if (this.textStr !== undefined) {\n      renderer.buildText(this);\n    } // Mark as added\n\n\n    this.added = true; // If we're adding to renderer root, or other elements in the group\n    // have a z index, we need to handle it\n\n    if (!parent || parent.handleZ || this.zIndex) {\n      inserted = this.zIndexSetter();\n    } // If zIndex is not handled, append at the end\n\n\n    if (!inserted) {\n      (parent ? parent.element : renderer.box).appendChild(element);\n    } // fire an event for internal hooks\n\n\n    if (this.onAdd) {\n      this.onAdd();\n    }\n\n    return this;\n  },\n\n  /**\n   * Removes an element from the DOM.\n   *\n   * @private\n   * @function Highcharts.SVGElement#safeRemoveChild\n   *\n   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n   *        The DOM node to remove.\n   */\n  safeRemoveChild: function safeRemoveChild(element) {\n    var parentNode = element.parentNode;\n\n    if (parentNode) {\n      parentNode.removeChild(element);\n    }\n  },\n\n  /**\n   * Destroy the element and element wrapper and clear up the DOM and event\n   * hooks.\n   *\n   * @function Highcharts.SVGElement#destroy\n   */\n  destroy: function destroy() {\n    var wrapper = this,\n        element = wrapper.element || {},\n        parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,\n        grandParent,\n        ownerSVGElement = element.ownerSVGElement,\n        i,\n        clipPath = wrapper.clipPath; // remove events\n\n    element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n    stop(wrapper); // stop running animations\n\n    if (clipPath && ownerSVGElement) {\n      // Look for existing references to this clipPath and remove them\n      // before destroying the element (#6196).\n      each( // The upper case version is for Edge\n      ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'), function (el) {\n        var clipPathAttr = el.getAttribute('clip-path'),\n            clipPathId = clipPath.element.id; // Include the closing paranthesis in the test to rule out\n        // id's from 10 and above (#6550). Edge puts quotes inside\n        // the url, others not.\n\n        if (clipPathAttr.indexOf('(#' + clipPathId + ')') > -1 || clipPathAttr.indexOf('(\"#' + clipPathId + '\")') > -1) {\n          el.removeAttribute('clip-path');\n        }\n      });\n      wrapper.clipPath = clipPath.destroy();\n    } // Destroy stops in case this is a gradient object\n\n\n    if (wrapper.stops) {\n      for (i = 0; i < wrapper.stops.length; i++) {\n        wrapper.stops[i] = wrapper.stops[i].destroy();\n      }\n\n      wrapper.stops = null;\n    } // remove element\n\n\n    wrapper.safeRemoveChild(element); // In case of useHTML, clean up empty containers emulating SVG groups\n    // (#1960, #2393, #2697).\n\n    while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n      grandParent = parentToClean.parentGroup;\n      wrapper.safeRemoveChild(parentToClean.div);\n      delete parentToClean.div;\n      parentToClean = grandParent;\n    } // remove from alignObjects\n\n\n    if (wrapper.alignTo) {\n      erase(wrapper.renderer.alignedObjects, wrapper);\n    }\n\n    objectEach(wrapper, function (val, key) {\n      delete wrapper[key];\n    });\n    return null;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#xGetter\n   *\n   * @param {string} key\n   *\n   * @return {number|string|null}\n   */\n  xGetter: function xGetter(key) {\n    if (this.element.nodeName === 'circle') {\n      if (key === 'x') {\n        key = 'cx';\n      } else if (key === 'y') {\n        key = 'cy';\n      }\n    }\n\n    return this._defaultGetter(key);\n  },\n\n  /**\n   * Get the current value of an attribute or pseudo attribute,\n   * used mainly for animation. Called internally from\n   * the {@link Highcharts.SVGRenderer#attr} function.\n   *\n   * @private\n   * @function Highcharts.SVGElement#_defaultGetter\n   *\n   * @param {string} key\n   *        Property key.\n   *\n   * @return {number|string|null}\n   *         Property value.\n   */\n  _defaultGetter: function _defaultGetter(key) {\n    var ret = pick(this[key + 'Value'], // align getter\n    this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n    if (/^[\\-0-9\\.]+$/.test(ret)) {\n      // is numerical\n      ret = parseFloat(ret);\n    }\n\n    return ret;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#dSettter\n   *\n   * @param {number|string|Highcharts.SVGPathArray} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  dSetter: function dSetter(value, key, element) {\n    if (value && value.join) {\n      // join path\n      value = value.join(' ');\n    }\n\n    if (/(NaN| {2}|^$)/.test(value)) {\n      value = 'M 0 0';\n    } // Check for cache before resetting. Resetting causes disturbance in the\n    // DOM, causing flickering in some cases in Edge/IE (#6747). Also\n    // possible performance gain.\n\n\n    if (this[key] !== value) {\n      element.setAttribute(key, value);\n      this[key] = value;\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#alignSetter\n   *\n   * @param {\"start\"|\"middle\"|\"end\"} value\n   */\n  alignSetter: function alignSetter(value) {\n    var convert = {\n      left: 'start',\n      center: 'middle',\n      right: 'end'\n    };\n    this.alignValue = value;\n    this.element.setAttribute('text-anchor', convert[value]);\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#opacitySetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  opacitySetter: function opacitySetter(value, key, element) {\n    this[key] = value;\n    element.setAttribute(key, value);\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#titleSetter\n   *\n   * @param {string} value\n   */\n  titleSetter: function titleSetter(value) {\n    var titleNode = this.element.getElementsByTagName('title')[0];\n\n    if (!titleNode) {\n      titleNode = doc.createElementNS(this.SVG_NS, 'title');\n      this.element.appendChild(titleNode);\n    } // Remove text content if it exists\n\n\n    if (titleNode.firstChild) {\n      titleNode.removeChild(titleNode.firstChild);\n    }\n\n    titleNode.appendChild(doc.createTextNode( // #3276, #3895\n    String(pick(value), '').replace(/<[^>]*>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>')));\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#textSetter\n   *\n   * @param {string} value\n   */\n  textSetter: function textSetter(value) {\n    if (value !== this.textStr) {\n      // Delete bBox memo when the text changes\n      delete this.bBox;\n      this.textStr = value;\n\n      if (this.added) {\n        this.renderer.buildText(this);\n      }\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#fillSetter\n   *\n   * @param {Highcharts.Color|Highcharts.ColorString} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  fillSetter: function fillSetter(value, key, element) {\n    if (typeof value === 'string') {\n      element.setAttribute(key, value);\n    } else if (value) {\n      this.complexColor(value, key, element);\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#visibilitySetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  visibilitySetter: function visibilitySetter(value, key, element) {\n    // IE9-11 doesn't handle visibilty:inherit well, so we remove the\n    // attribute instead (#2881, #3909)\n    if (value === 'inherit') {\n      element.removeAttribute(key);\n    } else if (this[key] !== value) {\n      // #6747\n      element.setAttribute(key, value);\n    }\n\n    this[key] = value;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#zIndexSetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @return {boolean}\n   */\n  zIndexSetter: function zIndexSetter(value, key) {\n    var renderer = this.renderer,\n        parentGroup = this.parentGroup,\n        parentWrapper = parentGroup || renderer,\n        parentNode = parentWrapper.element || renderer.box,\n        childNodes,\n        otherElement,\n        otherZIndex,\n        element = this.element,\n        inserted,\n        undefinedOtherZIndex,\n        svgParent = parentNode === renderer.box,\n        run = this.added,\n        i;\n\n    if (defined(value)) {\n      // So we can read it for other elements in the group\n      element.setAttribute('data-z-index', value);\n      value = +value;\n\n      if (this[key] === value) {\n        // Only update when needed (#3865)\n        run = false;\n      }\n    } else if (defined(this[key])) {\n      element.removeAttribute('data-z-index');\n    }\n\n    this[key] = value; // Insert according to this and other elements' zIndex. Before .add() is\n    // called, nothing is done. Then on add, or by later calls to\n    // zIndexSetter, the node is placed on the right place in the DOM.\n\n    if (run) {\n      value = this.zIndex;\n\n      if (value && parentGroup) {\n        parentGroup.handleZ = true;\n      }\n\n      childNodes = parentNode.childNodes;\n\n      for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {\n        otherElement = childNodes[i];\n        otherZIndex = otherElement.getAttribute('data-z-index');\n        undefinedOtherZIndex = !defined(otherZIndex);\n\n        if (otherElement !== element) {\n          if ( // Negative zIndex versus no zIndex:\n          // On all levels except the highest. If the parent is\n          // <svg>, then we don't want to put items before <desc>\n          // or <defs>\n          value < 0 && undefinedOtherZIndex && !svgParent && !i) {\n            parentNode.insertBefore(element, childNodes[i]);\n            inserted = true;\n          } else if ( // Insert after the first element with a lower zIndex\n          pInt(otherZIndex) <= value || // If negative zIndex, add this before first undefined\n          // zIndex element\n          undefinedOtherZIndex && (!defined(value) || value >= 0)) {\n            parentNode.insertBefore(element, childNodes[i + 1] || null // null for oldIE export\n            );\n            inserted = true;\n          }\n        }\n      }\n\n      if (!inserted) {\n        parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0] || null // null for oldIE\n        );\n        inserted = true;\n      }\n    }\n\n    return inserted;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#_defaultSetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  _defaultSetter: function _defaultSetter(value, key, element) {\n    element.setAttribute(key, value);\n  }\n}); // Some shared setters and getters\n\nSVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\n\nSVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.matrixSetter = function (value, key) {\n  this[key] = value;\n  this.doTransform = true;\n};\n/**\n * Allows direct access to the Highcharts rendering layer in order to draw\n * primitive shapes like circles, rectangles, paths or text directly on a chart,\n * or independent from any chart. The SVGRenderer represents a wrapper object\n * for SVG in modern browsers. Through the VMLRenderer, part of the `oldie.js`\n * module, it also brings vector graphics to IE <= 8.\n *\n * An existing chart's renderer can be accessed through {@link Chart.renderer}.\n * The renderer can also be used completely decoupled from a chart.\n *\n * @sample highcharts/members/renderer-on-chart\n *         Annotating a chart programmatically.\n * @sample highcharts/members/renderer-basic\n *         Independent SVG drawing.\n *\n * @example\n * // Use directly without a chart object.\n * var renderer = new Highcharts.Renderer(parentNode, 600, 400);\n *\n * @class\n * @name Highcharts.SVGRenderer\n *\n * @param {Highcharts.HTMLDOMElement} container\n *        Where to put the SVG in the web page.\n *\n * @param {number} width\n *        The width of the SVG.\n *\n * @param {number} height\n *        The height of the SVG.\n *\n * @param {boolean} [forExport=false]\n *        Whether the rendered content is intended for export.\n *\n * @param {boolean} [allowHTML=true]\n *        Whether the renderer is allowed to include HTML text, which will be\n *        projected on top of the SVG.\n */\n\n\nSVGRenderer = H.SVGRenderer = function () {\n  this.init.apply(this, arguments);\n};\n\nextend(SVGRenderer.prototype,\n/** @lends Highcharts.SVGRenderer.prototype */\n{\n  /**\n   * A pointer to the renderer's associated Element class. The VMLRenderer\n   * will have a pointer to VMLElement here.\n   *\n   * @name Highcharts.SVGRenderer#Element\n   * @type {Highcharts.SVGElement}\n   */\n  Element: SVGElement,\n  SVG_NS: SVG_NS,\n\n  /**\n   * Initialize the SVGRenderer. Overridable initiator function that takes\n   * the same parameters as the constructor.\n   *\n   * @function Highcharts.SVGRenderer#init\n   *\n   * @param {Highcharts.HTMLDOMElement} container\n   *        Where to put the SVG in the web page.\n   *\n   * @param {number} width\n   *        The width of the SVG.\n   *\n   * @param {number} height\n   *        The height of the SVG.\n   *\n   * @param {boolean} [forExport=false]\n   *        Whether the rendered content is intended for export.\n   *\n   * @param {boolean} [allowHTML=true]\n   *        Whether the renderer is allowed to include HTML text, which will\n   *        be projected on top of the SVG.\n   */\n  init: function init(container, width, height, style, forExport, allowHTML) {\n    var renderer = this,\n        boxWrapper,\n        element,\n        desc;\n    boxWrapper = renderer.createElement('svg').attr({\n      'version': '1.1',\n      'class': 'highcharts-root'\n    });\n    element = boxWrapper.element;\n    container.appendChild(element); // Always use ltr on the container, otherwise text-anchor will be\n    // flipped and text appear outside labels, buttons, tooltip etc (#3482)\n\n    attr(container, 'dir', 'ltr'); // For browsers other than IE, add the namespace attribute (#1978)\n\n    if (container.innerHTML.indexOf('xmlns') === -1) {\n      attr(element, 'xmlns', this.SVG_NS);\n    } // object properties\n\n\n    renderer.isSVG = true;\n    /**\n     * The root `svg` node of the renderer.\n     *\n     * @name Highcharts.SVGRenderer#box\n     * @type {Highcharts.SVGDOMElement}\n     */\n\n    this.box = element;\n    /**\n     * The wrapper for the root `svg` node of the renderer.\n     *\n     * @name Highcharts.SVGRenderer#boxWrapper\n     * @type {Highcharts.SVGElement}\n     */\n\n    this.boxWrapper = boxWrapper;\n    renderer.alignedObjects = [];\n    /**\n     * Page url used for internal references.\n     *\n     * @private\n     * @name Highcharts.SVGRenderer#url\n     * @type {string}\n     */\n    // #24, #672, #1070\n\n    this.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ? win.location.href.split('#')[0] // remove the hash\n    .replace(/<[^>]*>/g, '') // wing cut HTML\n    // escape parantheses and quotes\n    .replace(/([\\('\\)])/g, '\\\\$1') // replace spaces (needed for Safari only)\n    .replace(/ /g, '%20') : ''; // Add description\n\n    desc = this.createElement('desc').add();\n    desc.element.appendChild(doc.createTextNode('Created with @product.name@ @product.version@'));\n    /**\n     * A pointer to the `defs` node of the root SVG.\n     *\n     * @name Highcharts.SVGRenderer#defs\n     * @type {Highcharts.SVGElement}\n     */\n\n    renderer.defs = this.createElement('defs').add();\n    renderer.allowHTML = allowHTML;\n    renderer.forExport = forExport;\n    renderer.gradients = {}; // Object where gradient SvgElements are stored\n\n    renderer.cache = {}; // Cache for numerical bounding boxes\n\n    renderer.cacheKeys = [];\n    renderer.imgCount = 0;\n    renderer.setSize(width, height, false); // Issue 110 workaround:\n    // In Firefox, if a div is positioned by percentage, its pixel position\n    // may land between pixels. The container itself doesn't display this,\n    // but an SVG element inside this container will be drawn at subpixel\n    // precision. In order to draw sharp lines, this must be compensated\n    // for. This doesn't seem to work inside iframes though (like in\n    // jsFiddle).\n\n    var subPixelFix, rect;\n\n    if (isFirefox && container.getBoundingClientRect) {\n      subPixelFix = function subPixelFix() {\n        _css(container, {\n          left: 0,\n          top: 0\n        });\n\n        rect = container.getBoundingClientRect();\n\n        _css(container, {\n          left: Math.ceil(rect.left) - rect.left + 'px',\n          top: Math.ceil(rect.top) - rect.top + 'px'\n        });\n      }; // run the fix now\n\n\n      subPixelFix(); // run it on resize\n\n      renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);\n    }\n  },\n\n  /**\n   * General method for adding a definition to the SVG `defs` tag. Can be used\n   * for gradients, fills, filters etc. Styled mode only. A hook for adding\n   * general definitions to the SVG's defs tag. Definitions can be referenced\n   * from the CSS by its `id`. Read more in\n   * {@link https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns|gradients, shadows and patterns}.\n   * Styled mode only.\n   *\n   * @function Highcharts.SVGRenderer#definition\n   *\n   * @param {Highcharts.SVGDefinitionObject} def\n   *        A serialized form of an SVG definition, including children.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The inserted node.\n   */\n  definition: function definition(def) {\n    var ren = this;\n\n    function recurse(config, parent) {\n      var ret;\n      each(splat(config), function (item) {\n        var node = ren.createElement(item.tagName),\n            attr = {}; // Set attributes\n\n        objectEach(item, function (val, key) {\n          if (key !== 'tagName' && key !== 'children' && key !== 'textContent') {\n            attr[key] = val;\n          }\n        });\n        node.attr(attr); // Add to the tree\n\n        node.add(parent || ren.defs); // Add text content\n\n        if (item.textContent) {\n          node.element.appendChild(doc.createTextNode(item.textContent));\n        } // Recurse\n\n\n        recurse(item.children || [], node);\n        ret = node;\n      }); // Return last node added (on top level it's the only one)\n\n      return ret;\n    }\n\n    return recurse(def);\n  },\n\n  /**\n   * Detect whether the renderer is hidden. This happens when one of the\n   * parent elements has `display: none`. Used internally to detect when we\n   * needto render preliminarily in another div to get the text bounding boxes\n   * right.\n   *\n   * @function Highcharts.SVGRenderer#isHidden\n   *\n   * @return {boolean}\n   *         True if it is hidden.\n   */\n  isHidden: function isHidden() {\n    // #608\n    return !this.boxWrapper.getBBox().width;\n  },\n\n  /**\n   * Destroys the renderer and its allocated members.\n   *\n   * @function Highcharts.SVGRenderer#destroy\n   */\n  destroy: function destroy() {\n    var renderer = this,\n        rendererDefs = renderer.defs;\n    renderer.box = null;\n    renderer.boxWrapper = renderer.boxWrapper.destroy(); // Call destroy on all gradient elements\n\n    destroyObjectProperties(renderer.gradients || {});\n    renderer.gradients = null; // Defs are null in VMLRenderer\n    // Otherwise, destroy them here.\n\n    if (rendererDefs) {\n      renderer.defs = rendererDefs.destroy();\n    } // Remove sub pixel fix handler (#982)\n\n\n    if (renderer.unSubPixelFix) {\n      renderer.unSubPixelFix();\n    }\n\n    renderer.alignedObjects = null;\n    return null;\n  },\n\n  /**\n   * Create a wrapper for an SVG element. Serves as a factory for\n   * {@link SVGElement}, but this function is itself mostly called from\n   * primitive factories like {@link SVGRenderer#path}, {@link\n   * SVGRenderer#rect} or {@link SVGRenderer#text}.\n   *\n   * @function Highcharts.SVGRenderer#createElement\n   *\n   * @param {string} nodeName\n   *        The node name, for example `rect`, `g` etc.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated SVGElement.\n   */\n  createElement: function createElement(nodeName) {\n    var wrapper = new this.Element();\n    wrapper.init(this, nodeName);\n    return wrapper;\n  },\n\n  /**\n   * Dummy function for plugins, called every time the renderer is updated.\n   * Prior to Highcharts 5, this was used for the canvg renderer.\n   *\n   * @deprecated\n   * @function Highcharts.SVGRenderer#draw\n   */\n  draw: noop,\n\n  /**\n   * Get converted radial gradient attributes according to the radial\n   * reference. Used internally from the {@link SVGElement#colorGradient}\n   * function.\n   *\n   * @private\n   * @function Highcharts.SVGRenderer#getRadialAttr\n   *\n   * @param {Array<number>} radialReference\n   *\n   * @param {Highcharts.SVGAttributes} gradAttr\n   *\n   * @return {Highcharts.SVGAttributes}\n   */\n  getRadialAttr: function getRadialAttr(radialReference, gradAttr) {\n    return {\n      cx: radialReference[0] - radialReference[2] / 2 + gradAttr.cx * radialReference[2],\n      cy: radialReference[1] - radialReference[2] / 2 + gradAttr.cy * radialReference[2],\n      r: gradAttr.r * radialReference[2]\n    };\n  },\n\n  /**\n   * Truncate the text node contents to a given length. Used when the css\n   * width is set. If the `textOverflow` is `ellipsis`, the text is truncated\n   * character by character to the given length. If not, the text is\n   * word-wrapped line by line.\n   *\n   * @private\n   * @function Highcharts.SVGRenderer#truncate\n   *\n   * @param {Highcharts.SVGElement} wrapper\n   *\n   * @param {Highcharts.SVGDOMElement} tspan\n   *\n   * @param {string} text\n   *\n   * @param {Array.<string>} words\n   *\n   * @param {number} width\n   *\n   * @param {Function} getString\n   *\n   * @return {boolean}\n   *         True if tspan is too long.\n   */\n  truncate: function truncate(wrapper, tspan, text, words, startAt, width, getString) {\n    var renderer = this,\n        rotation = wrapper.rotation,\n        str,\n        // Word wrap can not be truncated to shorter than one word, ellipsis\n    // text can be completely blank.\n    minIndex = words ? 1 : 0,\n        maxIndex = (text || words).length,\n        currentIndex = maxIndex,\n        // Cache the lengths to avoid checking the same twice\n    lengths = [],\n        updateTSpan = function updateTSpan(s) {\n      if (tspan.firstChild) {\n        tspan.removeChild(tspan.firstChild);\n      }\n\n      if (s) {\n        tspan.appendChild(doc.createTextNode(s));\n      }\n    },\n        getSubStringLength = function getSubStringLength(charEnd, concatenatedEnd) {\n      // charEnd is useed when finding the character-by-character\n      // break for ellipsis, concatenatedEnd is used for word-by-word\n      // break for word wrapping.\n      var end = concatenatedEnd || charEnd;\n\n      if (lengths[end] === undefined) {\n        // Modern browsers\n        if (tspan.getSubStringLength) {\n          // Fails with DOM exception on unit-tests/legend/members\n          // of unknown reason. Desired width is 0, text content\n          // is \"5\" and end is 1.\n          try {\n            lengths[end] = startAt + tspan.getSubStringLength(0, words ? end + 1 : end);\n          } catch (e) {} // Legacy\n\n        } else {\n          updateTSpan(getString(text || words, charEnd));\n          lengths[end] = startAt + renderer.getSpanWidth(wrapper, tspan);\n        }\n      }\n\n      return lengths[end];\n    },\n        actualWidth,\n        truncated;\n\n    wrapper.rotation = 0; // discard rotation when computing box\n\n    actualWidth = getSubStringLength(tspan.textContent.length);\n    truncated = startAt + actualWidth > width;\n\n    if (truncated) {\n      // Do a binary search for the index where to truncate the text\n      while (minIndex <= maxIndex) {\n        currentIndex = Math.ceil((minIndex + maxIndex) / 2); // When checking words for word-wrap, we need to build the\n        // string and measure the subStringLength at the concatenated\n        // word length.\n\n        if (words) {\n          str = getString(words, currentIndex);\n        }\n\n        actualWidth = getSubStringLength(currentIndex, str && str.length - 1);\n\n        if (minIndex === maxIndex) {\n          // Complete\n          minIndex = maxIndex + 1;\n        } else if (actualWidth > width) {\n          // Too large. Set max index to current.\n          maxIndex = currentIndex - 1;\n        } else {\n          // Within width. Set min index to current.\n          minIndex = currentIndex;\n        }\n      } // If max index was 0 it means the shortest possible text was also\n      // too large. For ellipsis that means only the ellipsis, while for\n      // word wrap it means the whole first word.\n\n\n      if (maxIndex === 0) {\n        // Remove ellipsis\n        updateTSpan(''); // If the new text length is one less than the original, we don't\n        // need the ellipsis\n      } else if (!(text && maxIndex === text.length - 1)) {\n        updateTSpan(str || getString(text || words, currentIndex));\n      }\n    } // When doing line wrapping, prepare for the next line by removing the\n    // items from this line.\n\n\n    if (words) {\n      words.splice(0, currentIndex);\n    }\n\n    wrapper.actualWidth = actualWidth;\n    wrapper.rotation = rotation; // Apply rotation again.\n\n    return truncated;\n  },\n\n  /**\n   * A collection of characters mapped to HTML entities. When `useHTML` on an\n   * element is true, these entities will be rendered correctly by HTML. In\n   * the SVG pseudo-HTML, they need to be unescaped back to simple characters,\n   * so for example `&lt;` will render as `<`.\n   *\n   * @example\n   * // Add support for unescaping quotes\n   * Highcharts.SVGRenderer.prototype.escapes['\"'] = '&quot;';\n   *\n   * @name Highcharts.SVGRenderer#escapes\n   * @type {Highcharts.Dictionary<string>}\n   */\n  escapes: {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    \"'\": '&#39;',\n    // eslint-disable-line quotes\n    '\"': '&quot;'\n  },\n\n  /**\n   * Parse a simple HTML string into SVG tspans. Called internally when text\n   * is set on an SVGElement. The function supports a subset of HTML tags, CSS\n   * text features like `width`, `text-overflow`, `white-space`, and also\n   * attributes like `href` and `style`.\n   *\n   * @private\n   * @function Highcharts.SVGRenderer#buildText\n   *\n   * @param {Highcharts.SVGElement} wrapper\n   *        The parent SVGElement.\n   */\n  buildText: function buildText(wrapper) {\n    var textNode = wrapper.element,\n        renderer = this,\n        forExport = renderer.forExport,\n        textStr = pick(wrapper.textStr, '').toString(),\n        hasMarkup = textStr.indexOf('<') !== -1,\n        lines,\n        childNodes = textNode.childNodes,\n        truncated,\n        parentX = attr(textNode, 'x'),\n        textStyles = wrapper.styles,\n        width = wrapper.textWidth,\n        textLineHeight = textStyles && textStyles.lineHeight,\n        textOutline = textStyles && textStyles.textOutline,\n        ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n        noWrap = textStyles && textStyles.whiteSpace === 'nowrap',\n        fontSize = textStyles && textStyles.fontSize,\n        textCache,\n        isSubsequentLine,\n        i = childNodes.length,\n        tempParent = width && !wrapper.added && this.box,\n        getLineHeight = function getLineHeight(tspan) {\n      var fontSizeStyle;\n      return textLineHeight ? pInt(textLineHeight) : renderer.fontMetrics(fontSizeStyle, // Get the computed size from parent if not explicit\n      tspan.getAttribute('style') ? tspan : textNode).h;\n    },\n        unescapeEntities = function unescapeEntities(inputStr, except) {\n      objectEach(renderer.escapes, function (value, key) {\n        if (!except || inArray(value, except) === -1) {\n          inputStr = inputStr.toString().replace(new RegExp(value, 'g'), // eslint-disable-line security/detect-non-literal-regexp\n          key);\n        }\n      });\n      return inputStr;\n    },\n        parseAttribute = function parseAttribute(s, attr) {\n      var start, delimiter;\n      start = s.indexOf('<');\n      s = s.substring(start, s.indexOf('>') - start);\n      start = s.indexOf(attr + '=');\n\n      if (start !== -1) {\n        start = start + attr.length + 1;\n        delimiter = s.charAt(start);\n\n        if (delimiter === '\"' || delimiter === \"'\") {\n          // eslint-disable-line quotes\n          s = s.substring(start + 1);\n          return s.substring(0, s.indexOf(delimiter));\n        }\n      }\n    }; // The buildText code is quite heavy, so if we're not changing something\n    // that affects the text, skip it (#6113).\n\n\n    textCache = [textStr, ellipsis, noWrap, textLineHeight, textOutline, fontSize, width].join(',');\n\n    if (textCache === wrapper.textCache) {\n      return;\n    }\n\n    wrapper.textCache = textCache; // Remove old text\n\n    while (i--) {\n      textNode.removeChild(childNodes[i]);\n    } // Skip tspans, add text directly to text node. The forceTSpan is a hook\n    // used in text outline hack.\n\n\n    if (!hasMarkup && !textOutline && !ellipsis && !width && textStr.indexOf(' ') === -1) {\n      textNode.appendChild(doc.createTextNode(unescapeEntities(textStr))); // Complex strings, add more logic\n    } else {\n      if (tempParent) {\n        // attach it to the DOM to read offset width\n        tempParent.appendChild(textNode);\n      }\n\n      if (hasMarkup) {\n        lines = textStr.replace(/<(b|strong)>/g, '<span class=\"highcharts-strong\">').replace(/<(i|em)>/g, '<span class=\"highcharts-emphasized\">').replace(/<a/g, '<span').replace(/<\\/(b|strong|i|em|a)>/g, '</span>').split(/<br.*?>/g);\n      } else {\n        lines = [textStr];\n      } // Trim empty lines (#5261)\n\n\n      lines = grep(lines, function (line) {\n        return line !== '';\n      }); // build the lines\n\n      each(lines, function buildTextLines(line, lineNo) {\n        var spans,\n            spanNo = 0,\n            lineLength = 0;\n        line = line // Trim to prevent useless/costly process on the spaces\n        // (#5258)\n        .replace(/^\\s+|\\s+$/g, '').replace(/<span/g, '|||<span').replace(/<\\/span>/g, '</span>|||');\n        spans = line.split('|||');\n        each(spans, function buildTextSpans(span) {\n          if (span !== '' || spans.length === 1) {\n            var attributes = {},\n                tspan = doc.createElementNS(renderer.SVG_NS, 'tspan'),\n                classAttribute,\n                styleAttribute,\n                // #390\n            hrefAttribute;\n            classAttribute = parseAttribute(span, 'class');\n\n            if (classAttribute) {\n              attr(tspan, 'class', classAttribute);\n            }\n\n            styleAttribute = parseAttribute(span, 'style');\n\n            if (styleAttribute) {\n              styleAttribute = styleAttribute.replace(/(;| |^)color([ :])/, '$1fill$2');\n              attr(tspan, 'style', styleAttribute);\n            } // Not for export - #1529\n\n\n            hrefAttribute = parseAttribute(span, 'href');\n\n            if (hrefAttribute && !forExport) {\n              attr(tspan, 'onclick', 'location.href=\\\"' + hrefAttribute + '\\\"');\n              attr(tspan, 'class', 'highcharts-anchor');\n            } // Strip away unsupported HTML tags (#7126)\n\n\n            span = unescapeEntities(span.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, '') || ' '); // Nested tags aren't supported, and cause crash in\n            // Safari (#1596)\n\n            if (span !== ' ') {\n              // add the text node\n              tspan.appendChild(doc.createTextNode(span)); // First span in a line, align it to the left\n\n              if (!spanNo) {\n                if (lineNo && parentX !== null) {\n                  attributes.x = parentX;\n                }\n              } else {\n                attributes.dx = 0; // #16\n              } // add attributes\n\n\n              attr(tspan, attributes); // Append it\n\n              textNode.appendChild(tspan); // first span on subsequent line, add the line\n              // height\n\n              if (!spanNo && isSubsequentLine) {\n                // allow getting the right offset height in\n                // exporting in IE\n                if (!svg && forExport) {\n                  _css(tspan, {\n                    display: 'block'\n                  });\n                } // Set the line height based on the font size of\n                // either the text element or the tspan element\n\n\n                attr(tspan, 'dy', getLineHeight(tspan));\n              } // Check width and apply soft breaks or ellipsis\n\n\n              if (width) {\n                var words = span.replace(/([^\\^])-/g, '$1- ').split(' '),\n                    // #1273\n                hasWhiteSpace = !noWrap && (spans.length > 1 || lineNo || words.length > 1),\n                    wrapLineNo = 0,\n                    dy = getLineHeight(tspan);\n\n                if (ellipsis) {\n                  truncated = renderer.truncate(wrapper, tspan, span, undefined, 0, // Target width\n                  Math.max(0, // Substract the font face to make\n                  // room for the ellipsis itself\n                  width - parseInt(fontSize || 12, 10)), // Build the text to test for\n                  function (text, currentIndex) {\n                    return text.substring(0, currentIndex) + \"\\u2026\";\n                  });\n                } else if (hasWhiteSpace) {\n                  while (words.length) {\n                    // For subsequent lines, create tspans\n                    // with the same style attributes as the\n                    // parent text node.\n                    if (words.length && !noWrap && wrapLineNo > 0) {\n                      tspan = doc.createElementNS(SVG_NS, 'tspan');\n                      attr(tspan, {\n                        dy: dy,\n                        x: parentX\n                      });\n\n                      if (styleAttribute) {\n                        // #390\n                        attr(tspan, 'style', styleAttribute);\n                      } // Start by appending the full\n                      // remaining text\n\n\n                      tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n                      textNode.appendChild(tspan);\n                    } // For each line, truncate the remaining\n                    // words into the line length.\n\n\n                    renderer.truncate(wrapper, tspan, null, words, wrapLineNo === 0 ? lineLength : 0, width, // Build the text to test for\n                    function (text, currentIndex) {\n                      return words.slice(0, currentIndex).join(' ').replace(/- /g, '-');\n                    });\n                    lineLength = wrapper.actualWidth;\n                    wrapLineNo++;\n                  }\n                }\n              }\n\n              spanNo++;\n            }\n          }\n        }); // To avoid beginning lines that doesn't add to the textNode\n        // (#6144)\n\n        isSubsequentLine = isSubsequentLine || textNode.childNodes.length;\n      });\n\n      if (ellipsis && truncated) {\n        wrapper.attr('title', unescapeEntities(wrapper.textStr, ['&lt;', '&gt;']) // #7179\n        );\n      }\n\n      if (tempParent) {\n        tempParent.removeChild(textNode);\n      } // Apply the text outline\n\n\n      if (textOutline && wrapper.applyTextOutline) {\n        wrapper.applyTextOutline(textOutline);\n      }\n    }\n  },\n\n  /**\n   * Returns white for dark colors and black for bright colors.\n   *\n   * @function Highcharts.SVGRenderer#getContrast\n   *\n   * @param {Highcharts.ColorString} rgba\n   *        The color to get the contrast for.\n   *\n   * @return {string}\n   *         The contrast color, either `#000000` or `#FFFFFF`.\n   */\n  getContrast: function getContrast(rgba) {\n    rgba = color(rgba).rgba; // The threshold may be discussed. Here's a proposal for adding\n    // different weight to the color channels (#6216)\n\n    rgba[0] *= 1; // red\n\n    rgba[1] *= 1.2; // green\n\n    rgba[2] *= 0.5; // blue\n\n    return rgba[0] + rgba[1] + rgba[2] > 1.8 * 255 ? '#000000' : '#FFFFFF';\n  },\n\n  /**\n   * Create a button with preset states.\n   *\n   * @function Highcharts.SVGRenderer#button\n   *\n   * @param {string} text\n   *        The text or HTML to draw.\n   *\n   * @param {number} x\n   *        The x position of the button's left side.\n   *\n   * @param {number} y\n   *        The y position of the button's top side.\n   *\n   * @param {Function} callback\n   *        The function to execute on button click or touch.\n   *\n   * @param {Highcharts.SVGAttributes} [normalState]\n   *        SVG attributes for the normal state.\n   *\n   * @param {Highcharts.SVGAttributes} [hoverState]\n   *        SVG attributes for the hover state.\n   *\n   * @param {Highcharts.SVGAttributes} [pressedState]\n   *        SVG attributes for the pressed state.\n   *\n   * @param {Highcharts.SVGAttributes} [disabledState]\n   *        SVG attributes for the disabled state.\n   *\n   * @param {Highcharts.SymbolKey} [shape=rect]\n   *        The shape type.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The button element.\n   */\n  button: function button(text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n    var label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n        curState = 0; // Default, non-stylable attributes\n\n    label.attr(merge({\n      'padding': 8,\n      'r': 2\n    }, normalState)); // Add the events. IE9 and IE10 need mouseover and mouseout to funciton\n    // (#667).\n\n    addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {\n      if (curState !== 3) {\n        label.setState(1);\n      }\n    });\n    addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {\n      if (curState !== 3) {\n        label.setState(curState);\n      }\n    });\n\n    label.setState = function (state) {\n      // Hover state is temporary, don't record it\n      if (state !== 1) {\n        label.state = curState = state;\n      } // Update visuals\n\n\n      label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);\n    };\n\n    return label.on('click', function (e) {\n      if (curState !== 3) {\n        callback.call(label, e);\n      }\n    });\n  },\n\n  /**\n   * Make a straight line crisper by not spilling out to neighbour pixels.\n   *\n   * @function Highcharts.SVGRenderer#crispLine\n   *\n   * @param {Highcharts.SVGPathArray} points\n   *        The original points on the format `['M', 0, 0, 'L', 100, 0]`.\n   *\n   * @param {number} width\n   *        The width of the line.\n   *\n   * @return {Highcharts.SVGPathArray}\n   *         The original points array, but modified to render crisply.\n   */\n  crispLine: function crispLine(points, width) {\n    // normalize to a crisp line\n    if (points[1] === points[4]) {\n      // Substract due to #1129. Now bottom and left axis gridlines behave\n      // the same.\n      points[1] = points[4] = Math.round(points[1]) - width % 2 / 2;\n    }\n\n    if (points[2] === points[5]) {\n      points[2] = points[5] = Math.round(points[2]) + width % 2 / 2;\n    }\n\n    return points;\n  },\n\n  /**\n   * Draw a path, wraps the SVG `path` element.\n   *\n   * @sample highcharts/members/renderer-path-on-chart/\n   *         Draw a path in a chart\n   * @sample highcharts/members/renderer-path/\n   *         Draw a path independent from a chart\n   *\n   * @example\n   * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])\n   *     .attr({ stroke: '#ff00ff' })\n   *     .add();\n   *\n   * @function Highcharts.SVGRenderer#path\n   *\n   * @param {Highcharts.SVGPathArray} [path]\n   *        An SVG path definition in array form.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   *\n   */\n\n  /**\n  * Draw a path, wraps the SVG `path` element.\n  *\n  * @function Highcharts.SVGRenderer#path\n  *\n  * @param {Highcharts.SVGAttributes} [attribs]\n  *        The initial attributes.\n  *\n  * @return {Highcharts.SVGElement}\n  *         The generated wrapper element.\n  */\n  path: function path(_path) {\n    var attribs = {};\n\n    if (isArray(_path)) {\n      attribs.d = _path;\n    } else if (isObject(_path)) {\n      // attributes\n      extend(attribs, _path);\n    }\n\n    return this.createElement('path').attr(attribs);\n  },\n\n  /**\n   * Draw a circle, wraps the SVG `circle` element.\n   *\n   * @sample highcharts/members/renderer-circle/\n   *         Drawing a circle\n   *\n   * @function Highcharts.SVGRenderer#circle\n   *\n   * @param {number} [x]\n   *        The center x position.\n   *\n   * @param {number} [y]\n   *        The center y position.\n   *\n   * @param {number} [r]\n   *        The radius.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n\n  /**\n  * Draw a circle, wraps the SVG `circle` element.\n  *\n  * @function Highcharts.SVGRenderer#circle\n  *\n  * @param {Highcharts.SVGAttributes} [attribs]\n  *        The initial attributes.\n  *\n  * @return {Highcharts.SVGElement}\n  *         The generated wrapper element.\n  */\n  circle: function circle(x, y, r) {\n    var attribs = isObject(x) ? x : {\n      x: x,\n      y: y,\n      r: r\n    },\n        wrapper = this.createElement('circle'); // Setting x or y translates to cx and cy\n\n    wrapper.xSetter = wrapper.ySetter = function (value, key, element) {\n      element.setAttribute('c' + key, value);\n    };\n\n    return wrapper.attr(attribs);\n  },\n\n  /**\n   * Draw and return an arc.\n   *\n   * @sample highcharts/members/renderer-arc/\n   *         Drawing an arc\n   *\n   * @function Highcharts.SVGRenderer#arc\n   *\n   * @param {number} [x=0]\n   *        Center X position.\n   *\n   * @param {number} [y=0]\n   *        Center Y position.\n   *\n   * @param {number} [r=0]\n   *        The outer radius of the arc.\n   *\n   * @param {number} [innerR=0]\n   *        Inner radius like used in donut charts.\n   *\n   * @param {number} [start=0]\n   *        The starting angle of the arc in radians, where 0 is to the right\n   *         and `-Math.PI/2` is up.\n   *\n   * @param {number} [end=0]\n   *        The ending angle of the arc in radians, where 0 is to the right\n   *        and `-Math.PI/2` is up.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n\n  /**\n  * Draw and return an arc. Overloaded function that takes arguments object.\n  *\n  * @function Highcharts.SVGRenderer#arc\n  *\n  * @param {Highcharts.SVGAttributes} attribs\n  *        Initial SVG attributes.\n  *\n  * @return {Highcharts.SVGElement}\n  *         The generated wrapper element.\n  */\n  arc: function arc(x, y, r, innerR, start, end) {\n    var arc, options;\n\n    if (isObject(x)) {\n      options = x;\n      y = options.y;\n      r = options.r;\n      innerR = options.innerR;\n      start = options.start;\n      end = options.end;\n      x = options.x;\n    } else {\n      options = {\n        innerR: innerR,\n        start: start,\n        end: end\n      };\n    } // Arcs are defined as symbols for the ability to set\n    // attributes in attr and animate\n\n\n    arc = this.symbol('arc', x, y, r, r, options);\n    arc.r = r; // #959\n\n    return arc;\n  },\n\n  /**\n   * Draw and return a rectangle.\n   *\n   * @function Highcharts.SVGRenderer#rect\n   *\n   * @param {number} [x]\n   *        Left position.\n   *\n   * @param {number} [y]\n   *        Top position.\n   *\n   * @param {number} [width]\n   *        Width of the rectangle.\n   *\n   * @param {number} [height]\n   *        Height of the rectangle.\n   *\n   * @param {number} [r]\n   *        Border corner radius.\n   *\n   * @param {number} [strokeWidth]\n   *        A stroke width can be supplied to allow crisp drawing.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n\n  /**\n  * Draw and return a rectangle.\n  *\n  * @sample highcharts/members/renderer-rect-on-chart/\n  *         Draw a rectangle in a chart\n  * @sample highcharts/members/renderer-rect/\n  *         Draw a rectangle independent from a chart\n  *\n  * @function Highcharts.SVGRenderer#rect\n  *\n  * @param {Highcharts.SVGAttributes} [attributes]\n  *        General SVG attributes for the rectangle.\n  *\n  * @return {Highcharts.SVGElement}\n  *         The generated wrapper element.\n  */\n  rect: function rect(x, y, width, height, r, strokeWidth) {\n    r = isObject(x) ? x.r : r;\n    var wrapper = this.createElement('rect'),\n        attribs = isObject(x) ? x : x === undefined ? {} : {\n      x: x,\n      y: y,\n      width: Math.max(width, 0),\n      height: Math.max(height, 0)\n    };\n\n    if (r) {\n      attribs.r = r;\n    }\n\n    wrapper.rSetter = function (value, key, element) {\n      attr(element, {\n        rx: value,\n        ry: value\n      });\n    };\n\n    return wrapper.attr(attribs);\n  },\n\n  /**\n   * Resize the {@link SVGRenderer#box} and re-align all aligned child\n   * elements.\n   *\n   * @sample highcharts/members/renderer-g/\n   *         Show and hide grouped objects\n   *\n   * @function Highcharts.SVGRenderer#setSize\n   *\n   * @param {number} width\n   *        The new pixel width.\n   *\n   * @param {number} height\n   *        The new pixel height.\n   *\n   * @param {boolean|Highcharts.AnimationOptionsObject} [animate=true]\n   *        Whether and how to animate.\n   */\n  setSize: function setSize(width, height, animate) {\n    var renderer = this,\n        alignedObjects = renderer.alignedObjects,\n        i = alignedObjects.length;\n    renderer.width = width;\n    renderer.height = height;\n    renderer.boxWrapper.animate({\n      width: width,\n      height: height\n    }, {\n      step: function step() {\n        this.attr({\n          viewBox: '0 0 ' + this.attr('width') + ' ' + this.attr('height')\n        });\n      },\n      duration: pick(animate, true) ? undefined : 0\n    });\n\n    while (i--) {\n      alignedObjects[i].align();\n    }\n  },\n\n  /**\n   * Create and return an svg group element. Child\n   * {@link Highcharts.SVGElement} objects are added to the group by using the\n   * group as the first parameter in {@link Highcharts.SVGElement#add|add()}.\n   *\n   * @function Highcharts.SVGRenderer#g\n   *\n   * @param {string} [name]\n   *        The group will be given a class name of `highcharts-{name}`. This\n   *        can be used for styling and scripting.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n  g: function g(name) {\n    var elem = this.createElement('g');\n    return name ? elem.attr({\n      'class': 'highcharts-' + name\n    }) : elem;\n  },\n\n  /**\n   * Display an image.\n   *\n   * @sample highcharts/members/renderer-image-on-chart/\n   *         Add an image in a chart\n   * @sample highcharts/members/renderer-image/\n   *         Add an image independent of a chart\n   *\n   * @function Highcharts.SVGRenderer#image\n   *\n   * @param {string} src\n   *        The image source.\n   *\n   * @param {number} [x]\n   *        The X position.\n   *\n   * @param {number} [y]\n   *        The Y position.\n   *\n   * @param {number} [width]\n   *        The image width. If omitted, it defaults to the image file width.\n   *\n   * @param {number} [height]\n   *        The image height. If omitted it defaults to the image file\n   *        height.\n   *\n   * @param {Function} [onload]\n   *        Event handler for image load.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n  image: function image(src, x, y, width, height, onload) {\n    var attribs = {\n      preserveAspectRatio: 'none'\n    },\n        elemWrapper,\n        dummy,\n        setSVGImageSource = function setSVGImageSource(el, src) {\n      // Set the href in the xlink namespace\n      if (el.setAttributeNS) {\n        el.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src);\n      } else {\n        // could be exporting in IE\n        // using href throws \"not supported\" in ie7 and under,\n        // requries regex shim to fix later\n        el.setAttribute('hc-svg-href', src);\n      }\n    },\n        onDummyLoad = function onDummyLoad(e) {\n      setSVGImageSource(elemWrapper.element, src);\n      onload.call(elemWrapper, e);\n    }; // optional properties\n\n\n    if (arguments.length > 1) {\n      extend(attribs, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n\n    elemWrapper = this.createElement('image').attr(attribs); // Add load event if supplied\n\n    if (onload) {\n      // We have to use a dummy HTML image since IE support for SVG image\n      // load events is very buggy. First set a transparent src, wait for\n      // dummy to load, and then add the real src to the SVG image.\n      setSVGImageSource(elemWrapper.element, 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='\n      /* eslint-disable-line */\n      );\n      dummy = new win.Image();\n      addEvent(dummy, 'load', onDummyLoad);\n      dummy.src = src;\n\n      if (dummy.complete) {\n        onDummyLoad({});\n      }\n    } else {\n      setSVGImageSource(elemWrapper.element, src);\n    }\n\n    return elemWrapper;\n  },\n\n  /**\n   * Draw a symbol out of pre-defined shape paths from\n   * {@link SVGRenderer#symbols}.\n   * It is used in Highcharts for point makers, which cake a `symbol` option,\n   * and label and button backgrounds like in the tooltip and stock flags.\n   *\n   * @function Highcharts.SVGRenderer#symbol\n   *\n   * @param {symbol} symbol\n   *        The symbol name.\n   *\n   * @param {number} x\n   *        The X coordinate for the top left position.\n   *\n   * @param {number} y\n   *        The Y coordinate for the top left position.\n   *\n   * @param {number} width\n   *        The pixel width.\n   *\n   * @param {number} height\n   *        The pixel height.\n   *\n   * @param {Highcharts.SymbolOptionsObject} [options]\n   *        Additional options, depending on the actual symbol drawn.\n   *\n   * @return {Highcharts.SVGElement}\n   */\n  symbol: function symbol(_symbol, x, y, width, height, options) {\n    var ren = this,\n        obj,\n        imageRegex = /^url\\((.*?)\\)$/,\n        isImage = imageRegex.test(_symbol),\n        sym = !isImage && (this.symbols[_symbol] ? _symbol : 'circle'),\n        // get the symbol definition function\n    symbolFn = sym && this.symbols[sym],\n        // check if there's a path defined for this symbol\n    path = defined(x) && symbolFn && symbolFn.call(this.symbols, Math.round(x), Math.round(y), width, height, options),\n        imageSrc,\n        centerImage;\n\n    if (symbolFn) {\n      obj = this.path(path); // expando properties for use in animate and attr\n\n      extend(obj, {\n        symbolName: sym,\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n\n      if (options) {\n        extend(obj, options);\n      } // Image symbols\n\n    } else if (isImage) {\n      imageSrc = _symbol.match(imageRegex)[1]; // Create the image synchronously, add attribs async\n\n      obj = this.image(imageSrc); // The image width is not always the same as the symbol width. The\n      // image may be centered within the symbol, as is the case when\n      // image shapes are used as label backgrounds, for example in flags.\n\n      obj.imgwidth = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);\n      obj.imgheight = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);\n      /**\n       * Set the size and position\n       */\n\n      centerImage = function centerImage() {\n        obj.attr({\n          width: obj.width,\n          height: obj.height\n        });\n      };\n      /**\n       * Width and height setters that take both the image's physical size\n       * and the label size into consideration, and translates the image\n       * to center within the label.\n       */\n\n\n      each(['width', 'height'], function (key) {\n        obj[key + 'Setter'] = function (value, key) {\n          var attribs = {},\n              imgSize = this['img' + key],\n              trans = key === 'width' ? 'translateX' : 'translateY';\n          this[key] = value;\n\n          if (defined(imgSize)) {\n            if (this.element) {\n              this.element.setAttribute(key, imgSize);\n            }\n\n            if (!this.alignByTranslate) {\n              attribs[trans] = ((this[key] || 0) - imgSize) / 2;\n              this.attr(attribs);\n            }\n          }\n        };\n      });\n\n      if (defined(x)) {\n        obj.attr({\n          x: x,\n          y: y\n        });\n      }\n\n      obj.isImg = true;\n\n      if (defined(obj.imgwidth) && defined(obj.imgheight)) {\n        centerImage();\n      } else {\n        // Initialize image to be 0 size so export will still function\n        // if there's no cached sizes.\n        obj.attr({\n          width: 0,\n          height: 0\n        }); // Create a dummy JavaScript image to get the width and height.\n\n        createElement('img', {\n          onload: function onload() {\n            var chart = charts[ren.chartIndex]; // Special case for SVGs on IE11, the width is not\n            // accessible until the image is part of the DOM\n            // (#2854).\n\n            if (this.width === 0) {\n              _css(this, {\n                position: 'absolute',\n                top: '-999em'\n              });\n\n              doc.body.appendChild(this);\n            } // Center the image\n\n\n            symbolSizes[imageSrc] = {\n              // Cache for next\n              width: this.width,\n              height: this.height\n            };\n            obj.imgwidth = this.width;\n            obj.imgheight = this.height;\n\n            if (obj.element) {\n              centerImage();\n            } // Clean up after #2854 workaround.\n\n\n            if (this.parentNode) {\n              this.parentNode.removeChild(this);\n            } // Fire the load event when all external images are\n            // loaded\n\n\n            ren.imgCount--;\n\n            if (!ren.imgCount && chart && chart.onload) {\n              chart.onload();\n            }\n          },\n          src: imageSrc\n        });\n        this.imgCount++;\n      }\n    }\n\n    return obj;\n  },\n\n  /**\n   * An extendable collection of functions for defining symbol paths.\n   *\n   * @name Highcharts.SVGRenderer#symbols\n   * @type {Highcharts.SymbolDictionary}\n   */\n  symbols: {\n    'circle': function circle(x, y, w, h) {\n      // Return a full arc\n      return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {\n        start: 0,\n        end: Math.PI * 2,\n        open: false\n      });\n    },\n    'square': function square(x, y, w, h) {\n      return ['M', x, y, 'L', x + w, y, x + w, y + h, x, y + h, 'Z'];\n    },\n    'triangle': function triangle(x, y, w, h) {\n      return ['M', x + w / 2, y, 'L', x + w, y + h, x, y + h, 'Z'];\n    },\n    'triangle-down': function triangleDown(x, y, w, h) {\n      return ['M', x, y, 'L', x + w, y, x + w / 2, y + h, 'Z'];\n    },\n    'diamond': function diamond(x, y, w, h) {\n      return ['M', x + w / 2, y, 'L', x + w, y + h / 2, x + w / 2, y + h, x, y + h / 2, 'Z'];\n    },\n    'arc': function arc(x, y, w, h, options) {\n      var start = options.start,\n          rx = options.r || w,\n          ry = options.r || h || w,\n          proximity = 0.001,\n          fullCircle = Math.abs(options.end - options.start - 2 * Math.PI) < proximity,\n          // Substract a small number to prevent cos and sin of start and\n      // end from becoming equal on 360 arcs (related: #1561)\n      end = options.end - proximity,\n          innerRadius = options.innerR,\n          open = pick(options.open, fullCircle),\n          cosStart = Math.cos(start),\n          sinStart = Math.sin(start),\n          cosEnd = Math.cos(end),\n          sinEnd = Math.sin(end),\n          // Proximity takes care of rounding errors around PI (#6971)\n      longArc = options.end - start - Math.PI < proximity ? 0 : 1,\n          arc;\n      arc = ['M', x + rx * cosStart, y + ry * sinStart, 'A', // arcTo\n      rx, // x radius\n      ry, // y radius\n      0, // slanting\n      longArc, // long or short arc\n      1, // clockwise\n      x + rx * cosEnd, y + ry * sinEnd];\n\n      if (defined(innerRadius)) {\n        arc.push(open ? 'M' : 'L', x + innerRadius * cosEnd, y + innerRadius * sinEnd, 'A', // arcTo\n        innerRadius, // x radius\n        innerRadius, // y radius\n        0, // slanting\n        longArc, // long or short arc\n        0, // clockwise\n        x + innerRadius * cosStart, y + innerRadius * sinStart);\n      }\n\n      arc.push(open ? '' : 'Z'); // close\n\n      return arc;\n    },\n\n    /**\n     * Callout shape used for default tooltips, also used for rounded\n     * rectangles in VML\n     */\n    'callout': function callout(x, y, w, h, options) {\n      var arrowLength = 6,\n          halfDistance = 6,\n          r = Math.min(options && options.r || 0, w, h),\n          safeDistance = r + halfDistance,\n          anchorX = options && options.anchorX,\n          anchorY = options && options.anchorY,\n          path;\n      path = ['M', x + r, y, 'L', x + w - r, y, // top side\n      'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n      'L', x + w, y + h - r, // right side\n      'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-rgt\n      'L', x + r, y + h, // bottom side\n      'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n      'L', x, y + r, // left side\n      'C', x, y, x, y, x + r, y // top-left corner\n      ]; // Anchor on right side\n\n      if (anchorX && anchorX > w) {\n        // Chevron\n        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {\n          path.splice(13, 3, 'L', x + w, anchorY - halfDistance, x + w + arrowLength, anchorY, x + w, anchorY + halfDistance, x + w, y + h - r); // Simple connector\n        } else {\n          path.splice(13, 3, 'L', x + w, h / 2, anchorX, anchorY, x + w, h / 2, x + w, y + h - r);\n        } // Anchor on left side\n\n      } else if (anchorX && anchorX < 0) {\n        // Chevron\n        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {\n          path.splice(33, 3, 'L', x, anchorY + halfDistance, x - arrowLength, anchorY, x, anchorY - halfDistance, x, y + r); // Simple connector\n        } else {\n          path.splice(33, 3, 'L', x, h / 2, anchorX, anchorY, x, h / 2, x, y + r);\n        }\n      } else if ( // replace bottom\n      anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {\n        path.splice(23, 3, 'L', anchorX + halfDistance, y + h, anchorX, y + h + arrowLength, anchorX - halfDistance, y + h, x + r, y + h);\n      } else if ( // replace top\n      anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {\n        path.splice(3, 3, 'L', anchorX - halfDistance, y, anchorX, y - arrowLength, anchorX + halfDistance, y, w - r, y);\n      }\n\n      return path;\n    }\n  },\n\n  /**\n   * Define a clipping rectangle. The clipping rectangle is later applied\n   * to {@link SVGElement} objects through the {@link SVGElement#clip}\n   * function.\n   *\n   * @example\n   * var circle = renderer.circle(100, 100, 100)\n   *     .attr({ fill: 'red' })\n   *     .add();\n   * var clipRect = renderer.clipRect(100, 100, 100, 100);\n   *\n   * // Leave only the lower right quarter visible\n   * circle.clip(clipRect);\n   *\n   * @function Highcharts.SVGRenderer#clipRect\n   *\n   * @param {string} id\n   *\n   * @param {number} x\n   *\n   * @param {number} y\n   *\n   * @param {number} width\n   *\n   * @param {number} height\n   *\n   * @return {Highcharts.ClipRectElement}\n   *         A clipping rectangle.\n   */\n  clipRect: function clipRect(x, y, width, height) {\n    var wrapper,\n        id = H.uniqueKey(),\n        clipPath = this.createElement('clipPath').attr({\n      id: id\n    }).add(this.defs);\n    wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n    wrapper.id = id;\n    wrapper.clipPath = clipPath;\n    wrapper.count = 0;\n    return wrapper;\n  },\n\n  /**\n   * Draw text. The text can contain a subset of HTML, like spans and anchors\n   * and some basic text styling of these. For more advanced features like\n   * border and background, use {@link Highcharts.SVGRenderer#label} instead.\n   * To update the text after render, run `text.attr({ text: 'New text' })`.\n   *\n   * @sample highcharts/members/renderer-text-on-chart/\n   *         Annotate the chart freely\n   * @sample highcharts/members/renderer-on-chart/\n   *         Annotate with a border and in response to the data\n   * @sample highcharts/members/renderer-text/\n   *         Formatted text\n   *\n   * @function Highcharts.SVGRenderer#text\n   *\n   * @param {string} str\n   *        The text of (subset) HTML to draw.\n   *\n   * @param {number} x\n   *        The x position of the text's lower left corner.\n   *\n   * @param {number} y\n   *        The y position of the text's lower left corner.\n   *\n   * @param {boolean} [useHTML=false]\n   *        Use HTML to render the text.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The text object.\n   */\n  text: function text(str, x, y, useHTML) {\n    // declare variables\n    var renderer = this,\n        wrapper,\n        attribs = {};\n\n    if (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n      return renderer.html(str, x, y);\n    }\n\n    attribs.x = Math.round(x || 0); // X always needed for line-wrap logic\n\n    if (y) {\n      attribs.y = Math.round(y);\n    }\n\n    if (str || str === 0) {\n      attribs.text = str;\n    }\n\n    wrapper = renderer.createElement('text').attr(attribs);\n\n    if (!useHTML) {\n      wrapper.xSetter = function (value, key, element) {\n        var tspans = element.getElementsByTagName('tspan'),\n            tspan,\n            parentVal = element.getAttribute(key),\n            i;\n\n        for (i = 0; i < tspans.length; i++) {\n          tspan = tspans[i]; // If the x values are equal, the tspan represents a\n          // linebreak\n\n          if (tspan.getAttribute(key) === parentVal) {\n            tspan.setAttribute(key, value);\n          }\n        }\n\n        element.setAttribute(key, value);\n      };\n    }\n\n    return wrapper;\n  },\n\n  /**\n   * Utility to return the baseline offset and total line height from the font\n   * size.\n   *\n   * @function Highcharts.SVGRenderer#fontMetrics\n   *\n   * @param {string} [fontSize]\n   *        The current font size to inspect. If not given, the font size\n   *        will be found from the DOM element.\n   *\n   * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [elem]\n   *        The element to inspect for a current font size.\n   *\n   * @return {Highcharts.FontMetricsObject}\n   *         The font metrics.\n   */\n  fontMetrics: function fontMetrics(fontSize, elem) {\n    var lineHeight, baseline;\n    fontSize = elem && SVGElement.prototype.getStyle.call(elem, 'font-size'); // Handle different units\n\n    if (/px/.test(fontSize)) {\n      fontSize = pInt(fontSize);\n    } else if (/em/.test(fontSize)) {\n      // The em unit depends on parent items\n      fontSize = parseFloat(fontSize) * (elem ? this.fontMetrics(null, elem.parentNode).f : 16);\n    } else {\n      fontSize = 12;\n    } // Empirical values found by comparing font size and bounding box\n    // height. Applies to the default font family.\n    // https://jsfiddle.net/highcharts/7xvn7/\n\n\n    lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);\n    baseline = Math.round(lineHeight * 0.8);\n    return {\n      h: lineHeight,\n      b: baseline,\n      f: fontSize\n    };\n  },\n\n  /**\n   * Correct X and Y positioning of a label for rotation (#1764).\n   *\n   * @private\n   * @function Highcharts.SVGRenderer#rotCorr\n   *\n   * @param {number} baseline\n   *\n   * @param {number} rotation\n   *\n   * @param {boolean} alterY\n   */\n  rotCorr: function rotCorr(baseline, rotation, alterY) {\n    var y = baseline;\n\n    if (rotation && alterY) {\n      y = Math.max(y * Math.cos(rotation * deg2rad), 4);\n    }\n\n    return {\n      x: -baseline / 3 * Math.sin(rotation * deg2rad),\n      y: y\n    };\n  },\n\n  /**\n   * Draw a label, which is an extended text element with support for border\n   * and background. Highcharts creates a `g` element with a text and a `path`\n   * or `rect` inside, to make it behave somewhat like a HTML div. Border and\n   * background are set through `stroke`, `stroke-width` and `fill` attributes\n   * using the {@link Highcharts.SVGElement#attr|attr} method. To update the\n   * text after render, run `label.attr({ text: 'New text' })`.\n   *\n   * @sample highcharts/members/renderer-label-on-chart/\n   *         A label on the chart\n   *\n   * @function Highcharts.SVGRenderer#label\n   *\n   * @param {string} str\n   *        The initial text string or (subset) HTML to render.\n   *\n   * @param {number} x\n   *        The x position of the label's left side.\n   *\n   * @param {number} y\n   *        The y position of the label's top side or baseline, depending on\n   *        the `baseline` parameter.\n   *\n   * @param {string} [shape='rect']\n   *        The shape of the label's border/background, if any. Defaults to\n   *        `rect`. Other possible values are `callout` or other shapes\n   *        defined in {@link Highcharts.SVGRenderer#symbols}.\n   *\n   * @param {string} [shape='rect']\n   *        The shape of the label's border/background, if any. Defaults to\n   *        `rect`. Other possible values are `callout` or other shapes\n   *        defined in {@link Highcharts.SVGRenderer#symbols}.\n   *\n   * @param {number} [anchorX]\n   *        In case the `shape` has a pointer, like a flag, this is the\n   *        coordinates it should be pinned to.\n   *\n   * @param {number} [anchorY]\n   *        In case the `shape` has a pointer, like a flag, this is the\n   *        coordinates it should be pinned to.\n   *\n   * @param {boolean} [useHTML=false]\n   *        Wether to use HTML to render the label.\n   *\n   * @param {boolean} [baseline=false]\n   *        Whether to position the label relative to the text baseline,\n   *        like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the\n   *        upper border of the rectangle.\n   *\n   * @param {string} [className]\n   *        Class name for the group.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated label.\n   */\n  label: function label(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n    var renderer = this,\n        wrapper = renderer.g(className !== 'button' && 'label'),\n        text = wrapper.text = renderer.text('', 0, 0, useHTML).attr({\n      zIndex: 1\n    }),\n        box,\n        bBox,\n        alignFactor = 0,\n        padding = 3,\n        paddingLeft = 0,\n        width,\n        height,\n        wrapperX,\n        wrapperY,\n        textAlign,\n        deferredAttr = {},\n        strokeWidth,\n        baselineOffset,\n        hasBGImage = /^url\\((.*?)\\)$/.test(shape),\n        needsBox = hasBGImage,\n        getCrispAdjust,\n        updateBoxSize,\n        updateTextPadding,\n        boxAttr;\n\n    if (className) {\n      wrapper.addClass('highcharts-' + className);\n    }\n\n    needsBox = true; // for styling\n\n    getCrispAdjust = function getCrispAdjust() {\n      return box.strokeWidth() % 2 / 2;\n    };\n    /*\n     * This function runs after the label is added to the DOM (when the\n     * bounding box is available), and after the text of the label is\n     * updated to detect the new bounding box and reflect it in the border\n     * box.\n     */\n\n\n    updateBoxSize = function updateBoxSize() {\n      var style = text.element.style,\n          crispAdjust,\n          attribs = {};\n      bBox = (width === undefined || height === undefined || textAlign) && defined(text.textStr) && text.getBBox(); // #3295 && 3514 box failure when string equals 0\n\n      wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n      wrapper.height = (height || bBox.height || 0) + 2 * padding; // Update the label-scoped y offset\n\n      baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n      if (needsBox) {\n        // Create the border box if it is not already present\n        if (!box) {\n          // Symbol definition exists (#5324)\n          wrapper.box = box = renderer.symbols[shape] || hasBGImage ? renderer.symbol(shape) : renderer.rect();\n          box.addClass( // Don't use label className for buttons\n          (className === 'button' ? '' : 'highcharts-label-box') + (className ? ' highcharts-' + className + '-box' : ''));\n          box.add(wrapper);\n          crispAdjust = getCrispAdjust();\n          attribs.x = crispAdjust;\n          attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;\n        } // Apply the box attributes\n\n\n        attribs.width = Math.round(wrapper.width);\n        attribs.height = Math.round(wrapper.height);\n        box.attr(extend(attribs, deferredAttr));\n        deferredAttr = {};\n      }\n    };\n    /*\n     * This function runs after setting text or padding, but only if padding\n     * is changed.\n     */\n\n\n    updateTextPadding = function updateTextPadding() {\n      var textX = paddingLeft + padding,\n          textY; // determin y based on the baseline\n\n      textY = baseline ? 0 : baselineOffset; // compensate for alignment\n\n      if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n        textX += {\n          center: 0.5,\n          right: 1\n        }[textAlign] * (width - bBox.width);\n      } // update if anything changed\n\n\n      if (textX !== text.x || textY !== text.y) {\n        text.attr('x', textX); // #8159 - prevent misplaced data labels in treemap\n        // (useHTML: true)\n\n        if (text.hasBoxWidthChanged) {\n          bBox = text.getBBox(true);\n          updateBoxSize();\n        }\n\n        if (textY !== undefined) {\n          text.attr('y', textY);\n        }\n      } // record current values\n\n\n      text.x = textX;\n      text.y = textY;\n    };\n    /*\n     * Set a box attribute, or defer it if the box is not yet created\n     */\n\n\n    boxAttr = function boxAttr(key, value) {\n      if (box) {\n        box.attr(key, value);\n      } else {\n        deferredAttr[key] = value;\n      }\n    };\n    /*\n     * After the text element is added, get the desired size of the border\n     * box and add it before the text in the DOM.\n     */\n\n\n    wrapper.onAdd = function () {\n      text.add(wrapper);\n      wrapper.attr({\n        // Alignment is available now  (#3295, 0 not rendered if given\n        // as a value)\n        text: str || str === 0 ? str : '',\n        x: x,\n        y: y\n      });\n\n      if (box && defined(anchorX)) {\n        wrapper.attr({\n          anchorX: anchorX,\n          anchorY: anchorY\n        });\n      }\n    };\n    /*\n     * Add specific attribute setters.\n     */\n    // only change local variables\n\n\n    wrapper.widthSetter = function (value) {\n      width = H.isNumber(value) ? value : null; // width:auto => null\n    };\n\n    wrapper.heightSetter = function (value) {\n      height = value;\n    };\n\n    wrapper['text-alignSetter'] = function (value) {\n      textAlign = value;\n    };\n\n    wrapper.paddingSetter = function (value) {\n      if (defined(value) && value !== padding) {\n        padding = wrapper.padding = value;\n        updateTextPadding();\n      }\n    };\n\n    wrapper.paddingLeftSetter = function (value) {\n      if (defined(value) && value !== paddingLeft) {\n        paddingLeft = value;\n        updateTextPadding();\n      }\n    }; // change local variable and prevent setting attribute on the group\n\n\n    wrapper.alignSetter = function (value) {\n      value = {\n        left: 0,\n        center: 0.5,\n        right: 1\n      }[value];\n\n      if (value !== alignFactor) {\n        alignFactor = value; // Bounding box exists, means we're dynamically changing\n\n        if (bBox) {\n          wrapper.attr({\n            x: wrapperX\n          }); // #5134\n        }\n      }\n    }; // apply these to the box and the text alike\n\n\n    wrapper.textSetter = function (value) {\n      if (value !== undefined) {\n        text.textSetter(value);\n      }\n\n      updateBoxSize();\n      updateTextPadding();\n    }; // apply these to the box but not to the text\n\n\n    wrapper['stroke-widthSetter'] = function (value, key) {\n      if (value) {\n        needsBox = true;\n      }\n\n      strokeWidth = this['stroke-width'] = value;\n      boxAttr(key, value);\n    };\n\n    wrapper.rSetter = function (value, key) {\n      boxAttr(key, value);\n    };\n\n    wrapper.anchorXSetter = function (value, key) {\n      anchorX = wrapper.anchorX = value;\n      boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);\n    };\n\n    wrapper.anchorYSetter = function (value, key) {\n      anchorY = wrapper.anchorY = value;\n      boxAttr(key, value - wrapperY);\n    }; // rename attributes\n\n\n    wrapper.xSetter = function (value) {\n      wrapper.x = value; // for animation getter\n\n      if (alignFactor) {\n        value -= alignFactor * ((width || bBox.width) + 2 * padding); // Force animation even when setting to the same value (#7898)\n\n        wrapper['forceAnimate:x'] = true;\n      }\n\n      wrapperX = Math.round(value);\n      wrapper.attr('translateX', wrapperX);\n    };\n\n    wrapper.ySetter = function (value) {\n      wrapperY = wrapper.y = Math.round(value);\n      wrapper.attr('translateY', wrapperY);\n    }; // Redirect certain methods to either the box or the text\n\n\n    var baseCss = wrapper.css;\n    return extend(wrapper, {\n      /*\n       * Pick up some properties and apply them to the text instead of the\n       * wrapper.\n       */\n      css: function css(styles) {\n        if (styles) {\n          var textStyles = {}; // Create a copy to avoid altering the original object\n          // (#537)\n\n          styles = merge(styles);\n          each(wrapper.textProps, function (prop) {\n            if (styles[prop] !== undefined) {\n              textStyles[prop] = styles[prop];\n              delete styles[prop];\n            }\n          });\n          text.css(textStyles);\n\n          if ('width' in textStyles) {\n            updateBoxSize();\n          }\n        }\n\n        return baseCss.call(wrapper, styles);\n      },\n\n      /*\n       * Return the bounding box of the box, not the group.\n       */\n      getBBox: function getBBox() {\n        return {\n          width: bBox.width + 2 * padding,\n          height: bBox.height + 2 * padding,\n          x: bBox.x - padding,\n          y: bBox.y - padding\n        };\n      },\n\n      /*\n       * Destroy and release memory.\n       */\n      destroy: function destroy() {\n        // Added by button implementation\n        removeEvent(wrapper.element, 'mouseenter');\n        removeEvent(wrapper.element, 'mouseleave');\n\n        if (text) {\n          text = text.destroy();\n        }\n\n        if (box) {\n          box = box.destroy();\n        } // Call base implementation to destroy the rest\n\n\n        SVGElement.prototype.destroy.call(wrapper); // Release local pointers (#1298)\n\n        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n      }\n    });\n  }\n}); // end SVGRenderer\n// general renderer\n\nH.Renderer = SVGRenderer;"
    },
    {
     "id": 257,
     "name": "../node_modules/@vaadin/vaadin-license-checker/vaadin-license-checker.js?babel-target=es5",
     "source": "/* This file is autogenerated from src/vaadin-license-checker.tpl.html */\n\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport { runIfDevelopmentMode } from '@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js';\n\nfunction maybeCheckLicenses() {\n  /** vaadin-dev-mode:start\n  (function () {\n  'use strict';\n  var classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n  };\n  var createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n   return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n  }();\n  var inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n   subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n  var possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n   return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n  function _CustomElement() {\n  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);\n  }\n  Object.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);\n  Object.setPrototypeOf(_CustomElement, HTMLElement);\n  var licenseBoxTemplate = document.createElement('template');\n  licenseBoxTemplate.innerHTML = '\\n  <style>\\n    :host {\\n      font: 16px/1.625 -apple-system, BlinkMacSystemFont, \"Roboto\", \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\\n      position: fixed;\\n      top: .5em;\\n      right: .5em;\\n      z-index: 10000;\\n      cursor: pointer;\\n      backface-visibility: hidden;\\n    }\\n\\n    #content {\\n      padding: 1em 1.5em;\\n      margin: 0;\\n      display: flex;\\n      flex-direction:row;\\n      align-items: center;\\n      text-align: left;\\n      font-size: inherit;\\n      line-height: inherit;\\n      font-weight: inherit;\\n      -webkit-font-smoothing: antialiased;\\n      -moz-osx-font-smoothin: grayscale;\\n      white-space: nowrap;\\n      letter-spacing: 0;\\n      border-radius: 5px;\\n    }\\n\\n    #content[type=\"needsvalidation\"] {\\n      background-color: #FFD5D8;\\n      color: #591217;\\n      box-shadow: 0 0 20px 1px rgba(242,51,51,0.10);\\n    }\\n\\n    #content[type=\"ok\"] {\\n      background-color: #B2F5C2;\\n      color: #1C562A;\\n      box-shadow: 0 0 20px 1px rgba(43,193,78,0.10);\\n    }\\n\\n    #content > svg {\\n      display: none;\\n      fill: currentColor;\\n      stroke: currentColor 1px;\\n      padding-left: 1.25em;\\n    }\\n\\n    #content[type=\"needsvalidation\"] > #link {\\n      display: inline;\\n    }\\n\\n    #content[type=\"ok\"] > #close {\\n      display: inline;\\n      vertical-align: -.125em;\\n    }\\n  </style>\\n\\n  <div id=\"content\">\\n    <div></div>\\n    <svg id=\"link\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\\n      <g id=\"external-link\"><path d=\"M8.6 3.5l3.5 3.5h-12.1v2h12.1l-3.5 3.5 1.4 1.4 6-5.9-6-5.9z\"></path></g>\\n    </svg>\\n    <svg id=\"close\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\\n      <g id=\"close-big\"><path d=\"M16 0l-1 0.010-7 6.99-7-6.99-1-0.010v1l7 7-7 7v1h1l7-7 7 7h1v-1l-7-7 7-7v-1z\"></path></g>\\n    </svg>\\n  </div>\\n';\n  window.ShadyCSS && window.ShadyCSS.prepareTemplate(licenseBoxTemplate, 'vaadin-license-box');\n  var LicenseBoxElement = function (_CustomElement2) {\n  inherits(LicenseBoxElement, _CustomElement2);\n   function LicenseBoxElement() {\n    classCallCheck(this, LicenseBoxElement);\n    return possibleConstructorReturn(this, (LicenseBoxElement.__proto__ || Object.getPrototypeOf(LicenseBoxElement)).apply(this, arguments));\n  }\n   createClass(LicenseBoxElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      window.ShadyCSS && window.ShadyCSS.styleElement(this);\n       if (!this.shadowRoot) {\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(document.importNode(licenseBoxTemplate.content, true));\n        this._contentElement = this.shadowRoot.querySelector('#content');\n        this._render();\n      }\n    }\n  }, {\n    key: '_render',\n    value: function _render() {\n      if (!this._contentElement) {\n        return;\n      }\n       if (this._type) {\n        this._contentElement.setAttribute('type', this._type);\n      } else {\n        this._contentElement.removeAttribute('type');\n      }\n       this._contentElement.firstElementChild.innerHTML = this._content;\n    }\n  }, {\n    key: 'type',\n    get: function () {\n      return this._type;\n    },\n    set: function (type) {\n      this._type = type;\n      this._render();\n    }\n  }, {\n    key: 'content',\n    get: function () {\n      return this._content;\n    },\n    set: function (content) {\n      this._content = content;\n      this._render();\n    }\n  }]);\n  return LicenseBoxElement;\n  }(_CustomElement);\n  customElements.define('vaadin-license-box', LicenseBoxElement);\n  var LicenseCheckerLogger = function () {\n  function LicenseCheckerLogger() {\n    classCallCheck(this, LicenseCheckerLogger);\n     this.id = \"vaadin-license-checker\";\n  }\n   createClass(LicenseCheckerLogger, [{\n    key: 'isDebug',\n    value: function isDebug() {\n      return localStorage.getItem(\"vaadin.licenses.debug\");\n    }\n  }, {\n    key: 'debug',\n    value: function debug(msg) {\n      if (this.isDebug()) {\n        console.info(this.id + \": \" + msg);\n      }\n    }\n  }]);\n  return LicenseCheckerLogger;\n  }();\n  var LicenseCheckerStorage = function () {\n  function LicenseCheckerStorage() {\n    classCallCheck(this, LicenseCheckerStorage);\n     this.logger = new LicenseCheckerLogger();\n  }\n   createClass(LicenseCheckerStorage, [{\n    key: 'getLastCheckKey',\n    value: function getLastCheckKey(productInfo) {\n      return \"vaadin.licenses.{product}.lastCheck\".replace(\"{product}\", productInfo.name);\n    }\n  }, {\n    key: 'getLastCheck',\n    value: function getLastCheck(productInfo) {\n      return Number(localStorage.getItem(this.getLastCheckKey(productInfo)));\n    }\n  }, {\n    key: 'setLastCheck',\n    value: function setLastCheck(productInfo, timestamp) {\n      this.logger.debug(\"Setting last check time to \" + new Date(timestamp));\n      localStorage.setItem(this.getLastCheckKey(productInfo), timestamp);\n    }\n  }]);\n  return LicenseCheckerStorage;\n  }();\n  var VaadinLicenseChecker = function () {\n  function VaadinLicenseChecker() {\n    classCallCheck(this, VaadinLicenseChecker);\n     this.okNotifier = new LicenseOkNotifier();\n    this.validationNeededNotifier = new LicenseValidationNeededNotifier();\n    this.storage = new LicenseCheckerStorage();\n    this.checkInterval = 1000 * 60 * 60 * 24;\n    this.firstCheckDelay = 1000 * 60 * 1;\n    this.logger = new LicenseCheckerLogger();\n    this.url = \"https://tools.vaadin.com/vaadin-license-server/licenses/pro\";\n  }\n   createClass(VaadinLicenseChecker, [{\n    key: 'getForcedResponseKey',\n    value: function getForcedResponseKey(productInfo) {\n      return 'vaadin.licenses.{product}.forcedResponse'.replace('{product}', productInfo.name);\n    }\n  }, {\n    key: 'getForcedResponse',\n    value: function getForcedResponse(productInfo) {\n      return localStorage.getItem(this.getForcedResponseKey(productInfo));\n    }\n  }, {\n    key: 'clearForcedResponse',\n    value: function clearForcedResponse(productInfo) {\n      return localStorage.removeItem(this.getForcedResponseKey(productInfo));\n    }\n  }, {\n    key: 'maybeCheck',\n    value: function maybeCheck(productInfo) {\n      this.logger.debug(\"maybeCheck(\" + JSON.stringify(productInfo) + \")\");\n      // Defer first check until interval has expired to avoid interfering with tests etc\n      var now = new Date().getTime();\n      var lastCheck = this.storage.getLastCheck(productInfo);\n      if (!lastCheck) {\n        this.logger.debug(\"Deferring first check until \" + new Date(now + this.firstCheckDelay));\n        this.storage.setLastCheck(productInfo, now - this.checkInterval + this.firstCheckDelay);\n        return;\n      } else {\n        var sinceLastCheck = Math.round((now - lastCheck) / 1000);\n        var nextCheck = Math.round(this.checkInterval / 1000 - sinceLastCheck);\n        if (nextCheck > 0) {\n          // Checked recently\n          var nextCheckDate = new Date(lastCheck + this.checkInterval);\n          this.logger.debug(\"Checked \" + sinceLastCheck + \"s ago. Next check in \" + nextCheck + \"s at \" + nextCheckDate + \".\");\n          return;\n        } else {\n          this.logger.debug(\"Last check was \" + sinceLastCheck + \"s ago.\");\n        }\n      }\n      this.check(productInfo);\n    }\n  }, {\n    key: 'check',\n    value: function check(productInfo) {\n      this.logger.debug(\"check(\" + JSON.stringify(productInfo) + \")\");\n       // Only show an ok notification if the \"validation needed\" notification was shown.\n      // For background checks, show no visual notification if all goes well\n      var showOkOnSuccess = this.validationNeededNotifier.isVisible(productInfo);\n       var checker = this;\n      var onerror = function () {\n        // Offline or blocked, just log to console and let people get work done\n        console.error(\"Unable to validate the license for \" + productInfo.name + \". Check your internet access.\");\n      };\n      var onresponse = function (responseText) {\n        var response = JSON.parse(responseText);\n        if (response.result == \"ok\") {\n          // Everything is fine, stop\n          checker.logger.debug(\"License check ok for \" + JSON.stringify(productInfo));\n          checker.storage.setLastCheck(productInfo, new Date().getTime());\n          if (showOkOnSuccess) {\n            checker.logger.debug(\"Showing validation-ok dialog\");\n            checker.okNotifier.show(productInfo);\n          }\n        } else {\n          checker.logger.debug(\"License check failed for \" + JSON.stringify(productInfo));\n          checker.logger.debug(\"Showing validation-needed dialog\");\n          checker.validationNeededNotifier.show(productInfo);\n        }\n        if (response.message) {\n          console.log(response.message);\n        }\n      };\n       // This is typically hidden already but when receiving a window message it is not\n      this.logger.debug(\"Ensuring validation-needed dialog is hidden\");\n      this.validationNeededNotifier.hide(productInfo);\n       if (this.logger.isDebug() && this.getForcedResponse(productInfo)) {\n        var respJson = this.getForcedResponse(productInfo);\n        this.clearForcedResponse(productInfo);\n        if (JSON.parse(respJson).type == \"error\") {\n          this.logger.debug(\"Forced error for check\");\n          onerror();\n        } else {\n          this.logger.debug(\"Forced response for check: \" + respJson);\n          onresponse(respJson);\n        }\n      } else {\n        this.send(this.url, productInfo, onresponse, onerror);\n      }\n    }\n  }, {\n    key: 'send',\n    value: function send(url, productInfo, onsuccess, onerror) {\n      this.logger.debug(\"Sending request to \" + url);\n      var req = new XMLHttpRequest();\n      req.withCredentials = true;\n      req.addEventListener(\"readystatechange\", function () {\n        if (req.readyState === XMLHttpRequest.DONE && req.status === 200) {\n          onsuccess(req.responseText);\n        }\n      });\n      req.addEventListener(\"error\", function () {\n        onerror();\n      });\n      req.open(\"GET\", url);\n      req.setRequestHeader(\"check-source\", \"webcomponent\");\n      req.setRequestHeader(\"product-name\", productInfo.name);\n      req.setRequestHeader(\"product-version\", productInfo.version);\n       req.send();\n    }\n  }], [{\n    key: 'version',\n    get: function () {\n      return '2.1.2';\n    }\n  }]);\n  return VaadinLicenseChecker;\n  }();\n  var LicenseOkNotifier = function () {\n  function LicenseOkNotifier() {\n    classCallCheck(this, LicenseOkNotifier);\n  }\n   createClass(LicenseOkNotifier, [{\n    key: 'getInstance',\n    value: function getInstance() {\n      return document.getElementById(LicenseOkNotifier.id);\n    }\n  }, {\n    key: 'show',\n    value: function show(productInfo) {\n      // Only show one ok box even if multiple licenses were checked\n      if (this.getInstance()) {\n        // Already shown\n        return;\n      }\n      var instance = document.createElement(\"vaadin-license-box\");\n      instance.id = LicenseOkNotifier.id;\n      instance.type = \"ok\";\n      instance.content = \"Your license has been validated\";\n      document.body.appendChild(instance);\n      instance.addEventListener(\"click\", function () {\n        instance.parentElement.removeChild(instance);\n      });\n    }\n  }], [{\n    key: 'id',\n    get: function () {\n      return 'vaadin-license-validation-ok';\n    }\n  }]);\n  return LicenseOkNotifier;\n  }();\n  var LicenseValidationNeededNotifier = function () {\n  function LicenseValidationNeededNotifier() {\n    classCallCheck(this, LicenseValidationNeededNotifier);\n  }\n   createClass(LicenseValidationNeededNotifier, [{\n    key: 'id',\n    value: function id(productInfo) {\n      return \"vaadin-license-validation-notification-{product}\".replace(\"{product}\", productInfo.name);\n    }\n  }, {\n    key: 'getInstance',\n    value: function getInstance(productInfo) {\n      return document.getElementById(this.id(productInfo));\n    }\n  }, {\n    key: 'show',\n    value: function show(productInfo) {\n      if (this.getInstance(productInfo)) {\n        // Already shown\n        return;\n      }\n      var instance = document.createElement(\"vaadin-license-box\");\n      instance.id = this.id(productInfo);\n      instance.type = \"needsvalidation\";\n      instance.content = \"This application is using components which are part of a Vaadin subscription.<br>Click here to get a trial or validate your subscription\";\n      document.body.appendChild(instance);\n      instance.addEventListener(\"click\", function () {\n        window.open(\"https://vaadin.com/pro/validate-license\", \"_blank\");\n      });\n    }\n  }, {\n    key: 'hide',\n    value: function hide(productInfo) {\n      var instance = this.getInstance(productInfo);\n      if (instance) {\n        instance.parentElement.removeChild(instance);\n      }\n    }\n  }, {\n    key: 'isVisible',\n    value: function isVisible(productInfo) {\n      return !!this.getInstance(productInfo);\n    }\n  }]);\n  return LicenseValidationNeededNotifier;\n  }();\n  var proProducts = [];\n  window.Vaadin = window.Vaadin || {};\n  window.Vaadin.LicenseChecker = window.Vaadin.VaadinLicenseChecker || new VaadinLicenseChecker();\n  window.Vaadin.LicenseCheckerClass = window.Vaadin.LicenseCheckerClass || VaadinLicenseChecker;\n  window.Vaadin.developmentModeCallback = window.Vaadin.developmentModeCallback || {};\n  window.Vaadin.developmentModeCallback[\"vaadin-license-checker\"] = function (cls) {\n  var productInfo = { name: cls.is, version: cls.version };\n  proProducts.push(productInfo);\n  window.addEventListener(\"message\", function (e) {\n    if (e.data == \"validate-license\") {\n      window.Vaadin.LicenseChecker.check(productInfo);\n    }\n  }, false);\n   window.Vaadin.checkLicenses = function () {\n    // Force checking of all licenses to avoid e.g. popups during presentations when the grace period just has ended\n    proProducts.forEach(function (productInfo) {\n      window.Vaadin.LicenseChecker.check(productInfo);\n    });\n  };\n   window.Vaadin.LicenseChecker.maybeCheck(productInfo);\n  };\n  }());\n   vaadin-dev-mode:end **/\n}\n\nif (typeof runIfDevelopmentMode === 'function') {\n  runIfDevelopmentMode(maybeCheckLicenses);\n}"
    },
    {
     "id": 259,
     "name": "../node_modules/highcharts/js/es-modules/parts/Pointer.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * One position in relation to an axis.\n *\n * @typedef Highcharts.PointerAxisCoordinateObject\n *\n * @property {Highcharts.Axis} axis\n *           Related axis.\n *\n * @property {number} value\n *           Axis value.\n */\n\n/**\n * Positions in terms of axis values.\n *\n * @typedef Highcharts.PointerAxisCoordinatesObject\n *\n * @property {Array<Highcharts.PointerAxisCoordinateObject>} xAxis\n *           Positions on the x-axis.\n *\n * @property {Array<Highcharts.PointerAxisCoordinateObject>} yAxis\n *           Positions on the y-axis.\n */\n\n/**\n * Pointer coordinates.\n *\n * @typedef Highcharts.PointerCoordinatesObject\n *\n * @property {number} chartX\n *\n * @property {number} chartY\n */\n\n/**\n * A native browser mouse or touch event, extended with position information\n * relative to the {@link Chart.container}.\n *\n * @typedef {global.PointerEvent} Highcharts.PointerEventObject\n *\n * @property {number} chartX\n *           The X coordinate of the pointer interaction relative to the\n *           chart.\n *\n * @property {number} chartY\n *           The Y coordinate of the pointer interaction relative to the\n *           chart.\n */\n\n/**\n * Axis-specific data of a selection.\n *\n * @typedef Highcharts.SelectDataObject\n *\n * @property {Highcharts.Axis} axis\n *\n * @property {number} min\n *\n * @property {number} max\n */\n\n/**\n * Object for select events.\n *\n * @typedef Highcharts.SelectEventObject\n *\n * @property {global.Event} originalEvent\n *\n * @property {Array<Highcharts.SelectDataObject>} xAxis\n *\n * @property {Array<Highcharts.SelectDataObject>} yAxis\n */\n'use strict';\n\nimport Highcharts from './Globals.js';\nimport './Utilities.js';\nimport './Tooltip.js';\nimport './Color.js';\nvar H = Highcharts,\n    addEvent = H.addEvent,\n    attr = H.attr,\n    charts = H.charts,\n    color = H.color,\n    css = H.css,\n    defined = H.defined,\n    each = H.each,\n    extend = H.extend,\n    find = H.find,\n    fireEvent = H.fireEvent,\n    isNumber = H.isNumber,\n    isObject = H.isObject,\n    offset = H.offset,\n    pick = H.pick,\n    splat = H.splat,\n    Tooltip = H.Tooltip;\n/**\n * The mouse and touch tracker object. Each {@link Chart} item has one\n * assosiated Pointer item that can be accessed from the  {@link Chart.pointer}\n * property.\n *\n * @class\n * @name Highcharts.Pointer\n *\n * @param {Highcharts.Chart} chart\n *        The Chart instance.\n *\n * @param {Highcharts.Options} options\n *        The root options object. The pointer uses options from the chart and\n *        tooltip structures.\n */\n\nHighcharts.Pointer = function (chart, options) {\n  this.init(chart, options);\n};\n\nHighcharts.Pointer.prototype = {\n  /**\n   * Initialize the Pointer.\n   *\n   * @private\n   * @function Highcharts.Pointer#init\n   *\n   * @param {Highcharts.Chart} chart\n   *        The Chart instance.\n   *\n   * @param {Highcharts.Options} options\n   *        The root options object. The pointer uses options from the chart\n   *        and tooltip structures.\n   */\n  init: function init(chart, options) {\n    // Store references\n    this.options = options;\n    this.chart = chart; // Do we need to handle click on a touch device?\n\n    this.runChartClick = options.chart.events && !!options.chart.events.click;\n    this.pinchDown = [];\n    this.lastValidTouch = {};\n\n    if (Tooltip) {\n      /**\n       * Tooltip object for points of series.\n       *\n       * @name Highcharts.Chart#tooltip\n       * @type {Highcharts.Tooltip}\n       */\n      chart.tooltip = new Tooltip(chart, options.tooltip);\n      this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n    }\n\n    this.setDOMEvents();\n  },\n\n  /**\n   * Resolve the zoomType option, this is reset on all touch start and mouse\n   * down events.\n   *\n   * @private\n   * @function Highcharts.Pointer#zoomOption\n   *\n   * @param {global.Event} e\n   *        Event object.\n   */\n  zoomOption: function zoomOption(e) {\n    var chart = this.chart,\n        options = chart.options.chart,\n        zoomType = options.zoomType || '',\n        inverted = chart.inverted,\n        zoomX,\n        zoomY; // Look for the pinchType option\n\n    if (/touch/.test(e.type)) {\n      zoomType = pick(options.pinchType, zoomType);\n    }\n\n    this.zoomX = zoomX = /x/.test(zoomType);\n    this.zoomY = zoomY = /y/.test(zoomType);\n    this.zoomHor = zoomX && !inverted || zoomY && inverted;\n    this.zoomVert = zoomY && !inverted || zoomX && inverted;\n    this.hasZoom = zoomX || zoomY;\n  },\n\n  /**\n   * Takes a browser event object and extends it with custom Highcharts\n   * properties `chartX` and `chartY` in order to work on the internal\n   * coordinate system.\n   *\n   * @function Highcharts.Pointer#normalize\n   *\n   * @param {global.Event} e\n   *        Event object in standard browsers.\n   *\n   * @return {Highcharts.PointerEventObject}\n   *         A browser event with extended properties `chartX` and `chartY`.\n   */\n  normalize: function normalize(e, chartPosition) {\n    var ePos; // iOS (#2757)\n\n    ePos = e.touches ? e.touches.length ? e.touches.item(0) : e.changedTouches[0] : e; // Get mouse position\n\n    if (!chartPosition) {\n      this.chartPosition = chartPosition = offset(this.chart.container);\n    }\n\n    return extend(e, {\n      chartX: Math.round(ePos.pageX - chartPosition.left),\n      chartY: Math.round(ePos.pageY - chartPosition.top)\n    });\n  },\n\n  /**\n   * Get the click position in terms of axis values.\n   *\n   * @function Highcharts.Pointer#getCoordinates\n   *\n   * @param {Highcharts.PointerEventObject} e\n   *        Pointer event, extended with `chartX` and `chartY` properties.\n   *\n   * @return {Highcharts.PointerAxisCoordinatesObject}\n   */\n  getCoordinates: function getCoordinates(e) {\n    var coordinates = {\n      xAxis: [],\n      yAxis: []\n    };\n    each(this.chart.axes, function (axis) {\n      coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n        axis: axis,\n        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n      });\n    });\n    return coordinates;\n  },\n\n  /**\n   * Finds the closest point to a set of coordinates, using the k-d-tree\n   * algorithm.\n   *\n   * @function Highcharts.Pointer#findNearestKDPoints\n   *\n   * @param {Array<Highcharts.Series>} series\n   *        All the series to search in.\n   *\n   * @param {boolean} shared\n   *        Whether it is a shared tooltip or not.\n   *\n   * @param {Highcharts.PointerCoordinatesObject} coordinates\n   *        Chart coordinates of the pointer.\n   *\n   * @return {Point|undefined}\n   *         The point closest to given coordinates.\n   */\n  findNearestKDPoint: function findNearestKDPoint(series, shared, coordinates) {\n    var closest,\n        sort = function sort(p1, p2) {\n      var isCloserX = p1.distX - p2.distX,\n          isCloser = p1.dist - p2.dist,\n          isAbove = (p2.series.group && p2.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex),\n          result; // We have two points which are not in the same place on xAxis\n      // and shared tooltip:\n\n      if (isCloserX !== 0 && shared) {\n        // #5721\n        result = isCloserX; // Points are not exactly in the same place on x/yAxis:\n      } else if (isCloser !== 0) {\n        result = isCloser; // The same xAxis and yAxis position, sort by z-index:\n      } else if (isAbove !== 0) {\n        result = isAbove; // The same zIndex, sort by array index:\n      } else {\n        result = p1.series.index > p2.series.index ? -1 : 1;\n      }\n\n      return result;\n    };\n\n    each(series, function (s) {\n      var noSharedTooltip = s.noSharedTooltip && shared,\n          compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf('y') < 0,\n          point = s.searchPoint(coordinates, compareX);\n\n      if ( // Check that we actually found a point on the series.\n      isObject(point, true) && ( // Use the new point if it is closer.\n      !isObject(closest, true) || sort(closest, point) > 0)) {\n        closest = point;\n      }\n    });\n    return closest;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#getPointFromEvent\n   *\n   * @param {global.Event} e\n   *\n   * @return {Highcharts.Point|undefined}\n   */\n  getPointFromEvent: function getPointFromEvent(e) {\n    var target = e.target,\n        point;\n\n    while (target && !point) {\n      point = target.point;\n      target = target.parentNode;\n    }\n\n    return point;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#getChartCoordinatesFromPoint\n   *\n   * @param {Highcharts.Point} point\n   *\n   * @param {boolean} inverted\n   *\n   * @return {Highcharts.PointerCoordinatesObject}\n   */\n  getChartCoordinatesFromPoint: function getChartCoordinatesFromPoint(point, inverted) {\n    var series = point.series,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis,\n        plotX = pick(point.clientX, point.plotX),\n        shapeArgs = point.shapeArgs;\n\n    if (xAxis && yAxis) {\n      return inverted ? {\n        chartX: xAxis.len + xAxis.pos - plotX,\n        chartY: yAxis.len + yAxis.pos - point.plotY\n      } : {\n        chartX: plotX + xAxis.pos,\n        chartY: point.plotY + yAxis.pos\n      };\n    } else if (shapeArgs && shapeArgs.x && shapeArgs.y) {\n      // E.g. pies do not have axes\n      return {\n        chartX: shapeArgs.x,\n        chartY: shapeArgs.y\n      };\n    }\n  },\n\n  /**\n   * Calculates what is the current hovered point/points and series.\n   *\n   * @private\n   * @function Highcharts.Pointer#getHoverData\n   *\n   * @param {Highcharts.Point|undefined} existingHoverPoint\n   *        The point currrently beeing hovered.\n   *\n   * @param {Highcharts.Series|undefined} existingHoverSeries\n   *        The series currently beeing hovered.\n   *\n   * @param {Array<Highcharts.Series>} series\n   *        All the series in the chart.\n   *\n   * @param {boolean} isDirectTouch\n   *        Is the pointer directly hovering the point.\n   *\n   * @param {boolean} shared\n   *        Whether it is a shared tooltip or not.\n   *\n   * @param {Highcharts.PointerCoordinatesObject} coordinates\n   *        Chart coordinates of the pointer.\n   *\n   * @return {*}\n   *         Object containing resulting hover data: hoverPoint, hoverSeries,\n   *         and hoverPoints.\n   */\n  getHoverData: function getHoverData(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, coordinates, params) {\n    var hoverPoint,\n        hoverPoints = [],\n        hoverSeries = existingHoverSeries,\n        isBoosting = params && params.isBoosting,\n        useExisting = !!(isDirectTouch && existingHoverPoint),\n        notSticky = hoverSeries && !hoverSeries.stickyTracking,\n        filter = function filter(s) {\n      return s.visible && !(!shared && s.directTouch) && // #3821\n      pick(s.options.enableMouseTracking, true);\n    },\n        // Which series to look in for the hover point\n    searchSeries = notSticky ? // Only search on hovered series if it has stickyTracking false\n    [hoverSeries] : // Filter what series to look in.\n    H.grep(series, function (s) {\n      return filter(s) && s.stickyTracking;\n    }); // Use existing hovered point or find the one closest to coordinates.\n\n\n    hoverPoint = useExisting ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, coordinates); // Assign hover series\n\n    hoverSeries = hoverPoint && hoverPoint.series; // If we have a hoverPoint, assign hoverPoints.\n\n    if (hoverPoint) {\n      // When tooltip is shared, it displays more than one point\n      if (shared && !hoverSeries.noSharedTooltip) {\n        searchSeries = H.grep(series, function (s) {\n          return filter(s) && !s.noSharedTooltip;\n        }); // Get all points with the same x value as the hoverPoint\n\n        each(searchSeries, function (s) {\n          var point = find(s.points, function (p) {\n            return p.x === hoverPoint.x && !p.isNull;\n          });\n\n          if (isObject(point)) {\n            /*\n            * Boost returns a minimal point. Convert it to a usable\n            * point for tooltip and states.\n            */\n            if (isBoosting) {\n              point = s.getPoint(point);\n            }\n\n            hoverPoints.push(point);\n          }\n        });\n      } else {\n        hoverPoints.push(hoverPoint);\n      }\n    }\n\n    return {\n      hoverPoint: hoverPoint,\n      hoverSeries: hoverSeries,\n      hoverPoints: hoverPoints\n    };\n  },\n\n  /**\n   * With line type charts with a single tracker, get the point closest to the\n   * mouse. Run Point.onMouseOver and display tooltip for the point or points.\n   *\n   * @private\n   * @function Highcharts.Pointer#runPointActions\n   *\n   * @param {global.Event} e\n   *\n   * @param {Highcharts.Point} p\n   *\n   * @fires Highcharts.Point#event:mouseOut\n   * @fires Highcharts.Point#event:mouseOver\n   */\n  runPointActions: function runPointActions(e, p) {\n    var pointer = this,\n        chart = pointer.chart,\n        series = chart.series,\n        tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : undefined,\n        shared = tooltip ? tooltip.shared : false,\n        hoverPoint = p || chart.hoverPoint,\n        hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,\n        // onMouseOver or already hovering a series with directTouch\n    isDirectTouch = e.type !== 'touchmove' && (!!p || hoverSeries && hoverSeries.directTouch && pointer.isDirectTouch),\n        hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e, {\n      isBoosting: chart.isBoosting\n    }),\n        useSharedTooltip,\n        followPointer,\n        anchor,\n        points; // Update variables from hoverData.\n\n    hoverPoint = hoverData.hoverPoint;\n    points = hoverData.hoverPoints;\n    hoverSeries = hoverData.hoverSeries;\n    followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n    useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip; // Refresh tooltip for kdpoint if new hover point or tooltip was hidden\n    // #3926, #4200\n\n    if (hoverPoint && ( // !(hoverSeries && hoverSeries.directTouch) &&\n    hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {\n      each(chart.hoverPoints || [], function (p) {\n        if (H.inArray(p, points) === -1) {\n          p.setState();\n        }\n      }); // Do mouseover on all points (#3919, #3985, #4410, #5622)\n\n      each(points || [], function (p) {\n        p.setState('hover');\n      }); // set normal state to previous series\n\n      if (chart.hoverSeries !== hoverSeries) {\n        hoverSeries.onMouseOver();\n      } // If tracking is on series in stead of on each point,\n      // fire mouseOver on hover point. // #4448\n\n\n      if (chart.hoverPoint) {\n        chart.hoverPoint.firePointEvent('mouseOut');\n      } // Hover point may have been destroyed in the event handlers (#7127)\n\n\n      if (!hoverPoint.series) {\n        return;\n      }\n\n      hoverPoint.firePointEvent('mouseOver');\n      chart.hoverPoints = points;\n      chart.hoverPoint = hoverPoint; // Draw tooltip if necessary\n\n      if (tooltip) {\n        tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);\n      } // Update positions (regardless of kdpoint or hoverPoint)\n\n    } else if (followPointer && tooltip && !tooltip.isHidden) {\n      anchor = tooltip.getAnchor([{}], e);\n      tooltip.updatePosition({\n        plotX: anchor[0],\n        plotY: anchor[1]\n      });\n    } // Start the event listener to pick up the tooltip and crosshairs\n\n\n    if (!pointer.unDocMouseMove) {\n      pointer.unDocMouseMove = addEvent(chart.container.ownerDocument, 'mousemove', function (e) {\n        var chart = charts[H.hoverChartIndex];\n\n        if (chart) {\n          chart.pointer.onDocumentMouseMove(e);\n        }\n      });\n    } // Issues related to crosshair #4927, #5269 #5066, #5658\n\n\n    each(chart.axes, function drawAxisCrosshair(axis) {\n      var snap = pick(axis.crosshair.snap, true),\n          point = !snap ? undefined : H.find(points, function (p) {\n        return p.series[axis.coll] === axis;\n      }); // Axis has snapping crosshairs, and one of the hover points belongs\n      // to axis. Always call drawCrosshair when it is not snap.\n\n      if (point || !snap) {\n        axis.drawCrosshair(e, point); // Axis has snapping crosshairs, but no hover point belongs to axis\n      } else {\n        axis.hideCrosshair();\n      }\n    });\n  },\n\n  /**\n   * Reset the tracking by hiding the tooltip, the hover series state and the\n   * hover point\n   *\n   * @function Highcharts.Pointer#reset\n   *\n   * @param {boolean} allowMove\n   *        Instead of destroying the tooltip altogether, allow moving it if\n   *        possible.\n   *\n   * @param {number} delay\n   */\n  reset: function reset(allowMove, delay) {\n    var pointer = this,\n        chart = pointer.chart,\n        hoverSeries = chart.hoverSeries,\n        hoverPoint = chart.hoverPoint,\n        hoverPoints = chart.hoverPoints,\n        tooltip = chart.tooltip,\n        tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint; // Check if the points have moved outside the plot area (#1003, #4736,\n    // #5101)\n\n    if (allowMove && tooltipPoints) {\n      each(splat(tooltipPoints), function (point) {\n        if (point.series.isCartesian && point.plotX === undefined) {\n          allowMove = false;\n        }\n      });\n    } // Just move the tooltip, #349\n\n\n    if (allowMove) {\n      if (tooltip && tooltipPoints) {\n        tooltip.refresh(tooltipPoints);\n\n        if (tooltip.shared && hoverPoints) {\n          // #8284\n          each(hoverPoints, function (point) {\n            point.setState(point.state, true);\n\n            if (point.series.xAxis.crosshair) {\n              point.series.xAxis.drawCrosshair(null, point);\n            }\n\n            if (point.series.yAxis.crosshair) {\n              point.series.yAxis.drawCrosshair(null, point);\n            }\n          });\n        } else if (hoverPoint) {\n          // #2500\n          hoverPoint.setState(hoverPoint.state, true);\n          each(chart.axes, function (axis) {\n            if (axis.crosshair) {\n              axis.drawCrosshair(null, hoverPoint);\n            }\n          });\n        }\n      } // Full reset\n\n    } else {\n      if (hoverPoint) {\n        hoverPoint.onMouseOut();\n      }\n\n      if (hoverPoints) {\n        each(hoverPoints, function (point) {\n          point.setState();\n        });\n      }\n\n      if (hoverSeries) {\n        hoverSeries.onMouseOut();\n      }\n\n      if (tooltip) {\n        tooltip.hide(delay);\n      }\n\n      if (pointer.unDocMouseMove) {\n        pointer.unDocMouseMove = pointer.unDocMouseMove();\n      } // Remove crosshairs\n\n\n      each(chart.axes, function (axis) {\n        axis.hideCrosshair();\n      });\n      pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n    }\n  },\n\n  /**\n   * Scale series groups to a certain scale and translation.\n   *\n   * @private\n   * @function Highcharts.Pointer#scaleGroups\n   *\n   * @param {Highcharts.SeriesPlotBoxObject} attribs\n   *\n   * @param {boolean} clip\n   */\n  scaleGroups: function scaleGroups(attribs, clip) {\n    var chart = this.chart,\n        seriesAttribs; // Scale each series\n\n    each(chart.series, function (series) {\n      seriesAttribs = attribs || series.getPlotBox(); // #1701\n\n      if (series.xAxis && series.xAxis.zoomEnabled && series.group) {\n        series.group.attr(seriesAttribs);\n\n        if (series.markerGroup) {\n          series.markerGroup.attr(seriesAttribs);\n          series.markerGroup.clip(clip ? chart.clipRect : null);\n        }\n\n        if (series.dataLabelsGroup) {\n          series.dataLabelsGroup.attr(seriesAttribs);\n        }\n      }\n    }); // Clip\n\n    chart.clipRect.attr(clip || chart.clipBox);\n  },\n\n  /**\n   * Start a drag operation.\n   *\n   * @private\n   * @function Highcharts.Pointer#dragStart\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  dragStart: function dragStart(e) {\n    var chart = this.chart; // Record the start position\n\n    chart.mouseIsDown = e.type;\n    chart.cancelClick = false;\n    chart.mouseDownX = this.mouseDownX = e.chartX;\n    chart.mouseDownY = this.mouseDownY = e.chartY;\n  },\n\n  /**\n   * Perform a drag operation in response to a mousemove event while the mouse\n   * is down.\n   *\n   * @private\n   * @function Highcharts.Pointer#drag\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  drag: function drag(e) {\n    var chart = this.chart,\n        chartOptions = chart.options.chart,\n        chartX = e.chartX,\n        chartY = e.chartY,\n        zoomHor = this.zoomHor,\n        zoomVert = this.zoomVert,\n        plotLeft = chart.plotLeft,\n        plotTop = chart.plotTop,\n        plotWidth = chart.plotWidth,\n        plotHeight = chart.plotHeight,\n        clickedInside,\n        size,\n        selectionMarker = this.selectionMarker,\n        mouseDownX = this.mouseDownX,\n        mouseDownY = this.mouseDownY,\n        panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key']; // If the device supports both touch and mouse (like IE11), and we are\n    // touch-dragging inside the plot area, don't handle the mouse event.\n    // #4339.\n\n    if (selectionMarker && selectionMarker.touch) {\n      return;\n    } // If the mouse is outside the plot area, adjust to cooordinates\n    // inside to prevent the selection marker from going outside\n\n\n    if (chartX < plotLeft) {\n      chartX = plotLeft;\n    } else if (chartX > plotLeft + plotWidth) {\n      chartX = plotLeft + plotWidth;\n    }\n\n    if (chartY < plotTop) {\n      chartY = plotTop;\n    } else if (chartY > plotTop + plotHeight) {\n      chartY = plotTop + plotHeight;\n    } // determine if the mouse has moved more than 10px\n\n\n    this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));\n\n    if (this.hasDragged > 10) {\n      clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop); // make a selection\n\n      if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n        if (!selectionMarker) {\n          this.selectionMarker = selectionMarker = chart.renderer.rect(plotLeft, plotTop, zoomHor ? 1 : plotWidth, zoomVert ? 1 : plotHeight, 0).attr({\n            'class': 'highcharts-selection-marker',\n            'zIndex': 7\n          }).add();\n        }\n      } // adjust the width of the selection marker\n\n\n      if (selectionMarker && zoomHor) {\n        size = chartX - mouseDownX;\n        selectionMarker.attr({\n          width: Math.abs(size),\n          x: (size > 0 ? 0 : size) + mouseDownX\n        });\n      } // adjust the height of the selection marker\n\n\n      if (selectionMarker && zoomVert) {\n        size = chartY - mouseDownY;\n        selectionMarker.attr({\n          height: Math.abs(size),\n          y: (size > 0 ? 0 : size) + mouseDownY\n        });\n      } // panning\n\n\n      if (clickedInside && !selectionMarker && chartOptions.panning) {\n        chart.pan(e, chartOptions.panning);\n      }\n    }\n  },\n\n  /**\n   * On mouse up or touch end across the entire document, drop the selection.\n   *\n   * @private\n   * @function Highcharts.Pointer#drop\n   *\n   * @param {global.Event} e\n   */\n  drop: function drop(e) {\n    var pointer = this,\n        chart = this.chart,\n        hasPinched = this.hasPinched;\n\n    if (this.selectionMarker) {\n      var selectionData = {\n        originalEvent: e,\n        // #4890\n        xAxis: [],\n        yAxis: []\n      },\n          selectionBox = this.selectionMarker,\n          selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n          selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n          selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n          selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n          runZoom; // a selection has been made\n\n      if (this.hasDragged || hasPinched) {\n        // record each axis' min and max\n        each(chart.axes, function (axis) {\n          if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{\n            xAxis: 'zoomX',\n            yAxis: 'zoomY'\n          }[axis.coll]])) {\n            // #859, #3569\n            var horiz = axis.horiz,\n                minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0,\n                // #1207, #3075\n            selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n                selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n            selectionData[axis.coll].push({\n              axis: axis,\n              // Min/max for reversed axes\n              min: Math.min(selectionMin, selectionMax),\n              max: Math.max(selectionMin, selectionMax)\n            });\n            runZoom = true;\n          }\n        });\n\n        if (runZoom) {\n          fireEvent(chart, 'selection', selectionData, function (args) {\n            chart.zoom(extend(args, hasPinched ? {\n              animation: false\n            } : null));\n          });\n        }\n      }\n\n      if (isNumber(chart.index)) {\n        this.selectionMarker = this.selectionMarker.destroy();\n      } // Reset scaling preview\n\n\n      if (hasPinched) {\n        this.scaleGroups();\n      }\n    } // Reset all. Check isNumber because it may be destroyed on mouse up\n    // (#877)\n\n\n    if (chart && isNumber(chart.index)) {\n      css(chart.container, {\n        cursor: chart._cursor\n      });\n      chart.cancelClick = this.hasDragged > 10; // #370\n\n      chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n      this.pinchDown = [];\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseDown\n   *\n   * @param {global.Event} e\n   */\n  onContainerMouseDown: function onContainerMouseDown(e) {\n    // Normalize before the 'if' for the legacy IE (#7850)\n    e = this.normalize(e);\n\n    if (e.button !== 2) {\n      this.zoomOption(e); // issue #295, dragging not always working in Firefox\n\n      if (e.preventDefault) {\n        e.preventDefault();\n      }\n\n      this.dragStart(e);\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#onDocumentMouseUp\n   *\n   * @param {global.Event} e\n   */\n  onDocumentMouseUp: function onDocumentMouseUp(e) {\n    if (charts[H.hoverChartIndex]) {\n      charts[H.hoverChartIndex].pointer.drop(e);\n    }\n  },\n\n  /**\n   * Special handler for mouse move that will hide the tooltip when the mouse\n   * leaves the plotarea. Issue #149 workaround. The mouseleave event does not\n   * always fire.\n   *\n   * @private\n   * @function Highcharts.Pointer#onDocumentMouseMove\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  onDocumentMouseMove: function onDocumentMouseMove(e) {\n    var chart = this.chart,\n        chartPosition = this.chartPosition;\n    e = this.normalize(e, chartPosition); // If we're outside, hide the tooltip\n\n    if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') && !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n      this.reset();\n    }\n  },\n\n  /**\n   * When mouse leaves the container, hide the tooltip.\n   *\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseLeave\n   *\n   * @param {global.Event} e\n   */\n  onContainerMouseLeave: function onContainerMouseLeave(e) {\n    var chart = charts[H.hoverChartIndex]; // #4886, MS Touch end fires mouseleave but with no related target\n\n    if (chart && (e.relatedTarget || e.toElement)) {\n      chart.pointer.reset(); // Also reset the chart position, used in #149 fix\n\n      chart.pointer.chartPosition = null;\n    }\n  },\n\n  /**\n   * The mousemove, touchmove and touchstart event handler\n   *\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseMove\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  onContainerMouseMove: function onContainerMouseMove(e) {\n    var chart = this.chart;\n\n    if (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex] || !charts[H.hoverChartIndex].mouseIsDown) {\n      H.hoverChartIndex = chart.index;\n    }\n\n    e = this.normalize(e);\n    e.returnValue = false; // #2251, #3224\n\n    if (chart.mouseIsDown === 'mousedown') {\n      this.drag(e);\n    } // Show the tooltip and run mouse over events (#977)\n\n\n    if ((this.inClass(e.target, 'highcharts-tracker') || chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n      this.runPointActions(e);\n    }\n  },\n\n  /**\n   * Utility to detect whether an element has, or has a parent with, a\n   * specificclass name. Used on detection of tracker objects and on deciding\n   * whether hovering the tooltip should cause the active series to mouse out.\n   *\n   * @function Highcharts.Pointer#inClass\n   *\n   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n   *        The element to investigate.\n   *\n   * @param {string} className\n   *        The class name to look for.\n   *\n   * @return {boolean}\n   *         True if either the element or one of its parents has the given\n   *         class name.\n   */\n  inClass: function inClass(element, className) {\n    var elemClassName;\n\n    while (element) {\n      elemClassName = attr(element, 'class');\n\n      if (elemClassName) {\n        if (elemClassName.indexOf(className) !== -1) {\n          return true;\n        }\n\n        if (elemClassName.indexOf('highcharts-container') !== -1) {\n          return false;\n        }\n      }\n\n      element = element.parentNode;\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#onTrackerMouseOut\n   *\n   * @param {global.Event} e\n   */\n  onTrackerMouseOut: function onTrackerMouseOut(e) {\n    var series = this.chart.hoverSeries,\n        relatedTarget = e.relatedTarget || e.toElement;\n    this.isDirectTouch = false;\n\n    if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, 'highcharts-tooltip') && (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) || // #2499, #4465\n    !this.inClass(relatedTarget, 'highcharts-tracker') // #5553\n    )) {\n      series.onMouseOut();\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#onContainerClick\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  onContainerClick: function onContainerClick(e) {\n    var chart = this.chart,\n        hoverPoint = chart.hoverPoint,\n        plotLeft = chart.plotLeft,\n        plotTop = chart.plotTop;\n    e = this.normalize(e);\n\n    if (!chart.cancelClick) {\n      // On tracker click, fire the series and point events. #783, #1583\n      if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {\n        // the series click event\n        fireEvent(hoverPoint.series, 'click', extend(e, {\n          point: hoverPoint\n        })); // the point click event\n\n        if (chart.hoverPoint) {\n          // it may be destroyed (#1844)\n          hoverPoint.firePointEvent('click', e);\n        } // When clicking outside a tracker, fire a chart event\n\n      } else {\n        extend(e, this.getCoordinates(e)); // fire a click event in the chart\n\n        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n          fireEvent(chart, 'click', e);\n        }\n      }\n    }\n  },\n\n  /**\n   * Set the JS DOM events on the container and document. This method should\n   * contain a one-to-one assignment between methods and their handlers. Any\n   * advanced logic should be moved to the handler reflecting the event's\n   * name.\n   *\n   * @private\n   * @function Highcharts.Pointer#setDOMEvents\n   */\n  setDOMEvents: function setDOMEvents() {\n    var pointer = this,\n        container = pointer.chart.container,\n        ownerDoc = container.ownerDocument;\n\n    container.onmousedown = function (e) {\n      pointer.onContainerMouseDown(e);\n    };\n\n    container.onmousemove = function (e) {\n      pointer.onContainerMouseMove(e);\n    };\n\n    container.onclick = function (e) {\n      pointer.onContainerClick(e);\n    };\n\n    this.unbindContainerMouseLeave = addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n\n    if (!H.unbindDocumentMouseUp) {\n      H.unbindDocumentMouseUp = addEvent(ownerDoc, 'mouseup', pointer.onDocumentMouseUp);\n    }\n\n    if (H.hasTouch) {\n      container.ontouchstart = function (e) {\n        pointer.onContainerTouchStart(e);\n      };\n\n      container.ontouchmove = function (e) {\n        pointer.onContainerTouchMove(e);\n      };\n\n      if (!H.unbindDocumentTouchEnd) {\n        H.unbindDocumentTouchEnd = addEvent(ownerDoc, 'touchend', pointer.onDocumentTouchEnd);\n      }\n    }\n  },\n\n  /**\n   * Destroys the Pointer object and disconnects DOM events.\n   *\n   * @function Highcharts.Pointer#destroy\n   */\n  destroy: function destroy() {\n    var pointer = this;\n\n    if (pointer.unDocMouseMove) {\n      pointer.unDocMouseMove();\n    }\n\n    this.unbindContainerMouseLeave();\n\n    if (!H.chartCount) {\n      if (H.unbindDocumentMouseUp) {\n        H.unbindDocumentMouseUp = H.unbindDocumentMouseUp();\n      }\n\n      if (H.unbindDocumentTouchEnd) {\n        H.unbindDocumentTouchEnd = H.unbindDocumentTouchEnd();\n      }\n    } // memory and CPU leak\n\n\n    clearInterval(pointer.tooltipTimeout);\n    H.objectEach(pointer, function (val, prop) {\n      pointer[prop] = null;\n    });\n  }\n};"
    },
    {
     "id": 261,
     "name": "../node_modules/@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js?babel-target=es5",
     "source": "import './vaadin-checkbox-styles.js';\nimport '../../src/vaadin-checkbox.js';"
    },
    {
     "id": 266,
     "name": "../node_modules/@vaadin/vaadin-board/src/vaadin-board-row.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n       :host {\\n        display: flex;\\n        flex-flow: row wrap;\\n        align-items: stretch;\\n        --small-size: var(--vaadin-board-width-small, 600px);\\n        --medium-size: var(--vaadin-board-width-medium, 960px);\\n      }\\n\\n       :host ::slotted(*) {\\n        box-sizing: border-box;\\n        flex-grow: 1;\\n        overflow: hidden;\\n      }\\n    </style>\\n    <slot id=\\\"insertionPoint\\\"></slot>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Commercial Vaadin Add-On License 3.0, available at http://vaadin.com/license/cval-3.\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { IronResizableBehavior } from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { DomRepeat } from '@polymer/polymer/lib/elements/dom-repeat.js';\nimport { DomIf } from '@polymer/polymer/lib/elements/dom-if.js';\nimport { mixinBehaviors } from '@polymer/polymer/lib/legacy/class.js';\n/**\n* `<vaadin-board-row>` is a Polymer element that together with `vaadin-board` element allows to create flexible responsive layouts and build nice looking dashboard.\n*\n* Each row can contain up to four elements (fewer if colspan is used) and is automatically responsive. The row changes between `large`, `medium` and `small` modes depending on the available width and the set breakpoints. In `large` mode, typically all content is shown side-by-side, in `medium` half of the content is side by side and in `small` mode, content is laid out vertically.\n*\n* The breakpoints can be set using custom CSS properties. By default the breakpoints are `small: <600px`, `medium: < 960px`, `large >= 960px`.\n*\n*\n* ```html\n* <vaadin-board>\n*   <vaadin-board-row>\n*     <div>This could be chart 1</div>\n*     <div>This could be chart 2</div>\n*     <div>This could be chart 3</div>\n*     <div>This could be chart 4</div>\n*   </vaadin-board-row>\n* </vaadin-board>\n* ```\n*\n* ### Styling\n*\n* The following custom properties are available for styling:\n*\n* Custom property | Description | Default\n* ----------------|-------------|-------------\n* `--vaadin-board-width-small` | Determines the width where mode changes from `small` to `medium` | `600px`\n* `--vaadin-board-width-medium` | Determines the width where mode changes from `medium` to `large` | `960px`\n*\n* @extends PolymerElement\n* @mixes ElementMixin\n* @demo demo/index.html\n*/\n\nvar BoardRowElement = /*#__PURE__*/function (_ElementMixin) {\n  _inherits(BoardRowElement, _ElementMixin);\n\n  var _super = _createSuper(BoardRowElement);\n\n  _createClass(BoardRowElement, null, [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return \"vaadin-board-row\";\n    }\n  }]);\n\n  function BoardRowElement() {\n    var _this;\n\n    _classCallCheck(this, BoardRowElement);\n\n    _this = _super.call(this);\n    _this._onIronResize = _this._onIronResize.bind(_assertThisInitialized(_this));\n    _this._SMALL_VIEWPORT_CLASSNAME = \"small\";\n    _this._MEDIUM_VIEWPORT_CLASSNAME = \"medium\";\n    _this._LARGE_VIEWPORT_CLASSNAME = \"large\";\n    _this._oldWidth = 0;\n    _this._oldBreakpoints = {\n      'smallSize': 600,\n      'mediumSize': 960\n    };\n    _this._oldFlexBasis = [];\n    return _this;\n  }\n  /** @protected */\n\n\n  _createClass(BoardRowElement, [{\n    key: \"ready\",\n    value: function ready() {\n      _get(_getPrototypeOf(BoardRowElement.prototype), \"ready\", this).call(this);\n\n      this.addEventListener('iron-resize', this._onIronResize, true);\n      this.$.insertionPoint.addEventListener('slotchange', this.redraw.bind(this));\n      afterNextRender(this, function () {\n        //force this as an interested resizable of parent\n        this.dispatchEvent(new CustomEvent('iron-request-resize-notifications', {\n          node: this,\n          bubbles: true,\n          cancelable: true,\n          composed: true,\n          detail: {}\n        }));\n      });\n    }\n    /** @protected */\n\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(BoardRowElement.prototype), \"connectedCallback\", this).call(this);\n\n      afterNextRender(this, this._onIronResize);\n    }\n    /**\n     * Adds styles for board row based on width.\n     * @private\n     */\n\n  }, {\n    key: \"_addStyleNames\",\n    value: function _addStyleNames(width, breakpoints) {\n      if (width < breakpoints.smallSize) {\n        this.classList.add(this._SMALL_VIEWPORT_CLASSNAME);\n        this.classList.remove(this._MEDIUM_VIEWPORT_CLASSNAME);\n        this.classList.remove(this._LARGE_VIEWPORT_CLASSNAME);\n      } else if (width < breakpoints.mediumSize) {\n        this.classList.remove(this._SMALL_VIEWPORT_CLASSNAME);\n        this.classList.add(this._MEDIUM_VIEWPORT_CLASSNAME);\n        this.classList.remove(this._LARGE_VIEWPORT_CLASSNAME);\n      } else {\n        this.classList.remove(this._SMALL_VIEWPORT_CLASSNAME);\n        this.classList.remove(this._MEDIUM_VIEWPORT_CLASSNAME);\n        this.classList.add(this._LARGE_VIEWPORT_CLASSNAME);\n      }\n    }\n    /**\n     * Calculates flex basis based on colSpan, width and breakpoints.\n     * @param {number} colSpan colspan value of the row\n     * @param {number} width width of the row in px\n     * @param {number} colsInRow number of columns in the row\n     * @param {object} breakpoints object with smallSize and mediumSize number properties, which tells\n     * where the row should switch rendering size in pixels.\n     * @private\n     */\n\n  }, {\n    key: \"_calculateFlexBasis\",\n    value: function _calculateFlexBasis(colSpan, width, colsInRow, breakpoints) {\n      if (width < breakpoints.smallSize) {\n        colsInRow = 1;\n      } else if (width < breakpoints.mediumSize && colsInRow == 4) {\n        colsInRow = 2;\n      }\n\n      var flexBasis = colSpan / colsInRow * 100;\n      flexBasis = flexBasis > 100 ? 100 : flexBasis;\n      return flexBasis + '%';\n    }\n    /** @private */\n\n  }, {\n    key: \"_reportError\",\n    value: function _reportError() {\n      var errorMessage = \"The column configuration is not valid; column count should add up to 3 or 4.\";\n      console.warn(errorMessage, \"check: \\r\\n\" + this.outerHTML);\n    }\n    /**\n     * Parses board-cols from DOM.\n     * If there is not enough space in the row drop board cols.\n     * @param {!Array<!Node>} nodes array of nodes\n     * @return {!Array<number>} array of boardCols\n     * @private\n     */\n\n  }, {\n    key: \"_parseBoardCols\",\n    value: function _parseBoardCols(nodes) {\n      var boardCols = nodes.map(function (node) {\n        if (node.getAttribute(\"board-cols\")) {\n          return parseInt(node.getAttribute(\"board-cols\"));\n        }\n\n        return 1;\n      });\n      var spaceLeft = 4;\n      var returnBoardCols = [];\n      nodes.forEach(function (node, i) {\n        spaceLeft = spaceLeft - boardCols[i];\n      });\n\n      if (spaceLeft < 0) {\n        this._reportError();\n\n        boardCols.forEach(function (node, i) {\n          returnBoardCols[i] = 1;\n        });\n      } else {\n        returnBoardCols = boardCols.slice(0);\n      }\n\n      return returnBoardCols;\n    }\n    /**\n     * If there is not enough space in the row.\n     * Extra items are dropped from DOM.\n     * @param {!Array<number>} boardCols array of board-cols for every node\n     * @param {!Array<!Node>} nodes array of nodes\n     * @return {!Array<!Node>} filtered array of nodes\n     * @private\n     */\n\n  }, {\n    key: \"_removeExtraNodesFromDOM\",\n    value: function _removeExtraNodesFromDOM(boardCols, nodes) {\n      var _this2 = this;\n\n      var isErrorReported = false;\n      var spaceLeft = 4;\n      var returnNodes = [];\n      nodes.forEach(function (node, i) {\n        spaceLeft = spaceLeft - boardCols[i];\n\n        if (spaceLeft < 0) {\n          if (!isErrorReported) {\n            isErrorReported = true;\n\n            _this2._reportError();\n          }\n\n          _this2.removeChild(node);\n        } else {\n          returnNodes[i] = node;\n        }\n      });\n      return returnNodes;\n    }\n    /**\n     * Redraws the row, if necessary.\n     *\n     * In most cases, a board row will redraw itself if your reconfigure it. If you dynamically change CSS which affects the row, then you need to call this method.\n     */\n\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      this._recalculateFlexBasis(true);\n    }\n    /** @private */\n\n  }, {\n    key: \"_onIronResize\",\n    value: function _onIronResize() {\n      this._recalculateFlexBasis(false);\n    }\n    /** @private */\n\n  }, {\n    key: \"_recalculateFlexBasis\",\n    value: function _recalculateFlexBasis(forceResize) {\n      var _this3 = this;\n\n      var width = this.getBoundingClientRect().width;\n\n      var breakpoints = this._measureBreakpointsInPx();\n\n      if (forceResize || width != this._oldWidth || breakpoints.smallSize != this._oldBreakpoints.smallSize || breakpoints.mediumSize != this._oldBreakpoints.mediumSize) {\n        var nodes = this.$.insertionPoint.assignedNodes({\n          flatten: true\n        });\n\n        var isElementNode = function isElementNode(node) {\n          return !(node.nodeType === node.TEXT_NODE || node instanceof DomRepeat || node instanceof DomIf);\n        };\n\n        var filteredNodes = nodes.filter(isElementNode);\n\n        this._addStyleNames(width, breakpoints);\n\n        var boardCols = this._parseBoardCols(filteredNodes);\n\n        var colsInRow = boardCols.reduce(function (a, b) {\n          return a + b;\n        }, 0);\n\n        this._removeExtraNodesFromDOM(boardCols, filteredNodes).forEach(function (e, i) {\n          var newFlexBasis = _this3._calculateFlexBasis(boardCols[i], width, colsInRow, breakpoints);\n\n          if (forceResize || !_this3._oldFlexBasis[i] || _this3._oldFlexBasis[i] != newFlexBasis) {\n            _this3._oldFlexBasis[i] = newFlexBasis;\n            e.style.flexBasis = newFlexBasis;\n          }\n        });\n\n        this._oldWidth = width;\n        this._oldBreakpoints = breakpoints;\n      }\n    }\n    /**\n     * Measure the breakpoints in pixels.\n     *\n     * The breakpoints for `small` and `medium` can be given in any unit: `px`, `em`, `in` etc.\n     * We need to know them in `px` so that they are comparable with the actual size.\n     *\n     * @return {object} object with smallSize and mediumSize number properties, which tells\n     * where the row should switch rendering size in pixels.\n     * @private\n     */\n\n  }, {\n    key: \"_measureBreakpointsInPx\",\n    value: function _measureBreakpointsInPx() {\n      // Convert minWidth to px units for comparison\n      var breakpoints = {};\n      var tmpStyleProp = 'background-position';\n      var smallSize;\n      var mediumSize;\n\n      if (window.ShadyCSS) {\n        smallSize = window.ShadyCSS.getComputedStyleValue(this, '--small-size');\n        mediumSize = window.ShadyCSS.getComputedStyleValue(this, '--medium-size');\n      } else {\n        smallSize = getComputedStyle(this).getPropertyValue('--small-size');\n        mediumSize = getComputedStyle(this).getPropertyValue('--medium-size');\n      }\n\n      this.style.setProperty(tmpStyleProp, smallSize);\n      breakpoints.smallSize = parseFloat(getComputedStyle(this).getPropertyValue(tmpStyleProp));\n      this.style.setProperty(tmpStyleProp, mediumSize);\n      breakpoints.mediumSize = parseFloat(getComputedStyle(this).getPropertyValue(tmpStyleProp));\n      this.style.removeProperty(tmpStyleProp);\n      return breakpoints;\n    }\n  }]);\n\n  return BoardRowElement;\n}(ElementMixin(mixinBehaviors([IronResizableBehavior], PolymerElement)));\n\ncustomElements.define(BoardRowElement.is, BoardRowElement);\nexport { BoardRowElement };"
    },
    {
     "id": 267,
     "name": "../node_modules/highcharts/js/es-modules/parts/Tick.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nvar correctFloat = H.correctFloat,\n    defined = H.defined,\n    destroyObjectProperties = H.destroyObjectProperties,\n    fireEvent = H.fireEvent,\n    isNumber = H.isNumber,\n    merge = H.merge,\n    pick = H.pick,\n    deg2rad = H.deg2rad;\n/**\n * The Tick class\n * @ignore\n */\n\nH.Tick = function (axis, pos, type, noLabel) {\n  this.axis = axis;\n  this.pos = pos;\n  this.type = type || '';\n  this.isNew = true;\n  this.isNewLabel = true;\n\n  if (!type && !noLabel) {\n    this.addLabel();\n  }\n};\n\nH.Tick.prototype = {\n  /**\n   * Write the tick label\n   */\n  addLabel: function addLabel() {\n    var tick = this,\n        axis = tick.axis,\n        options = axis.options,\n        chart = axis.chart,\n        categories = axis.categories,\n        names = axis.names,\n        pos = tick.pos,\n        labelOptions = options.labels,\n        str,\n        tickPositions = axis.tickPositions,\n        isFirst = pos === tickPositions[0],\n        isLast = pos === tickPositions[tickPositions.length - 1],\n        value = categories ? pick(categories[pos], names[pos], pos) : pos,\n        label = tick.label,\n        tickPositionInfo = tickPositions.info,\n        dateTimeLabelFormat,\n        params; // Set the datetime label format. If a higher rank is set for this\n    // position, use that. If not, use the general format.\n\n    if (axis.isDatetimeAxis && tickPositionInfo) {\n      dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n    } // set properties for access in render method\n\n\n    tick.isFirst = isFirst;\n    tick.isLast = isLast; // Get the string. Provide params both as scope (legacy) and as first\n    // parameter which allows use in arrow functions (#8580).\n\n    params = {\n      axis: axis,\n      chart: chart,\n      isFirst: isFirst,\n      isLast: isLast,\n      dateTimeLabelFormat: dateTimeLabelFormat,\n      value: axis.isLog ? correctFloat(axis.lin2log(value)) : value,\n      pos: pos\n    };\n    str = axis.labelFormatter.call(params, params); // first call\n\n    if (!defined(label)) {\n      tick.label = label = defined(str) && labelOptions.enabled ? chart.renderer.text(str, 0, 0, labelOptions.useHTML).add(axis.labelGroup) : null; // Un-rotated length\n\n      if (label) {\n        label.textPxLength = label.getBBox().width;\n      } // Base value to detect change for new calls to getBBox\n\n\n      tick.rotation = 0; // update\n    } else if (label && label.textStr !== str) {\n      // When resetting text, also reset the width if dynamically set\n      // (#8809)\n      if (label.textWidth && !(labelOptions.style && labelOptions.style.width) && !label.styles.width) {\n        label.css({\n          width: null\n        });\n      }\n\n      label.attr({\n        text: str\n      });\n    }\n  },\n\n  /**\n   * Get the offset height or width of the label\n   */\n  getLabelSize: function getLabelSize() {\n    return this.label ? this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] : 0;\n  },\n\n  /**\n   * Handle the label overflow by adjusting the labels to the left and right\n   * edge, or hide them if they collide into the neighbour label.\n   */\n  handleOverflow: function handleOverflow(xy) {\n    var tick = this,\n        axis = this.axis,\n        labelOptions = axis.options.labels,\n        pxPos = xy.x,\n        chartWidth = axis.chart.chartWidth,\n        spacing = axis.chart.spacing,\n        leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),\n        rightBound = pick(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])),\n        label = this.label,\n        rotation = this.rotation,\n        factor = {\n      left: 0,\n      center: 0.5,\n      right: 1\n    }[axis.labelAlign || label.attr('align')],\n        labelWidth = label.getBBox().width,\n        slotWidth = axis.getSlotWidth(tick),\n        modifiedSlotWidth = slotWidth,\n        xCorrection = factor,\n        goRight = 1,\n        leftPos,\n        rightPos,\n        textWidth,\n        css = {}; // Check if the label overshoots the chart spacing box. If it does, move\n    // it. If it now overshoots the slotWidth, add ellipsis.\n\n    if (!rotation && pick(labelOptions.overflow, 'justify') === 'justify') {\n      leftPos = pxPos - factor * labelWidth;\n      rightPos = pxPos + (1 - factor) * labelWidth;\n\n      if (leftPos < leftBound) {\n        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;\n      } else if (rightPos > rightBound) {\n        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;\n        goRight = -1;\n      }\n\n      modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177\n\n      if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {\n        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));\n      } // If the label width exceeds the available space, set a text width\n      // to be picked up below. Also, if a width has been set before, we\n      // need to set a new one because the reported labelWidth will be\n      // limited by the box (#3938).\n\n\n      if (labelWidth > modifiedSlotWidth || axis.autoRotation && (label.styles || {}).width) {\n        textWidth = modifiedSlotWidth;\n      } // Add ellipsis to prevent rotated labels to be clipped against the edge\n      // of the chart\n\n    } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n      textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);\n    } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n      textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));\n    }\n\n    if (textWidth) {\n      css.width = textWidth;\n\n      if (!(labelOptions.style || {}).textOverflow) {\n        css.textOverflow = 'ellipsis';\n      }\n\n      label.css(css);\n    }\n  },\n\n  /**\n   * Get the x and y position for ticks and labels\n   */\n  getPosition: function getPosition(horiz, tickPos, tickmarkOffset, old) {\n    var axis = this.axis,\n        chart = axis.chart,\n        cHeight = old && chart.oldChartHeight || chart.chartHeight,\n        pos;\n    pos = {\n      x: horiz ? H.correctFloat(axis.translate(tickPos + tickmarkOffset, null, null, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),\n      y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : H.correctFloat(cHeight - axis.translate(tickPos + tickmarkOffset, null, null, old) - axis.transB)\n    };\n    fireEvent(this, 'afterGetPosition', {\n      pos: pos\n    });\n    return pos;\n  },\n\n  /**\n   * Get the x, y position of the tick label\n   */\n  getLabelPosition: function getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n    var axis = this.axis,\n        transA = axis.transA,\n        reversed = axis.reversed,\n        staggerLines = axis.staggerLines,\n        rotCorr = axis.tickRotCorr || {\n      x: 0,\n      y: 0\n    },\n        yOffset = labelOptions.y,\n        // Adjust for label alignment if we use reserveSpace: true (#5286)\n    labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === 'center' ? 0.5 : 1) : 0,\n        line,\n        pos = {};\n\n    if (!defined(yOffset)) {\n      if (axis.side === 0) {\n        yOffset = label.rotation ? -8 : -label.getBBox().height;\n      } else if (axis.side === 2) {\n        yOffset = rotCorr.y + 8;\n      } else {\n        // #3140, #3140\n        yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);\n      }\n    }\n\n    x = x + labelOptions.x + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n    y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0); // Correct for staggered labels\n\n    if (staggerLines) {\n      line = index / (step || 1) % staggerLines;\n\n      if (axis.opposite) {\n        line = staggerLines - line - 1;\n      }\n\n      y += line * (axis.labelOffset / staggerLines);\n    }\n\n    pos.x = x;\n    pos.y = Math.round(y);\n    fireEvent(this, 'afterGetLabelPosition', {\n      pos: pos\n    });\n    return pos;\n  },\n\n  /**\n   * Extendible method to return the path of the marker\n   */\n  getMarkPath: function getMarkPath(x, y, tickLength, tickWidth, horiz, renderer) {\n    return renderer.crispLine(['M', x, y, 'L', x + (horiz ? 0 : -tickLength), y + (horiz ? tickLength : 0)], tickWidth);\n  },\n\n  /**\n   * Renders the gridLine.\n   * @param  {Boolean} old         Whether or not the tick is old\n   * @param  {number} opacity      The opacity of the grid line\n   * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n   * @return {undefined}\n   */\n  renderGridLine: function renderGridLine(old, opacity, reverseCrisp) {\n    var tick = this,\n        axis = tick.axis,\n        options = axis.options,\n        gridLine = tick.gridLine,\n        gridLinePath,\n        attribs = {},\n        pos = tick.pos,\n        type = tick.type,\n        tickmarkOffset = axis.tickmarkOffset,\n        renderer = axis.chart.renderer;\n\n    if (!gridLine) {\n      if (!type) {\n        attribs.zIndex = 1;\n      }\n\n      if (old) {\n        attribs.opacity = 0;\n      }\n\n      tick.gridLine = gridLine = renderer.path().attr(attribs).addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line').add(axis.gridGroup);\n    } // If the parameter 'old' is set, the current call will be followed\n    // by another call, therefore do not do any animations this time\n\n\n    if (!old && gridLine) {\n      gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLine.strokeWidth() * reverseCrisp, old, true);\n\n      if (gridLinePath) {\n        gridLine[tick.isNew ? 'attr' : 'animate']({\n          d: gridLinePath,\n          opacity: opacity\n        });\n      }\n    }\n  },\n\n  /**\n   * Renders the tick mark.\n   * @param  {Object} xy           The position vector of the mark\n   * @param  {number} xy.x         The x position of the mark\n   * @param  {number} xy.y         The y position of the mark\n   * @param  {number} opacity      The opacity of the mark\n   * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n   * @return {undefined}\n   */\n  renderMark: function renderMark(xy, opacity, reverseCrisp) {\n    var tick = this,\n        axis = tick.axis,\n        options = axis.options,\n        renderer = axis.chart.renderer,\n        type = tick.type,\n        tickPrefix = type ? type + 'Tick' : 'tick',\n        tickSize = axis.tickSize(tickPrefix),\n        mark = tick.mark,\n        isNewMark = !mark,\n        x = xy.x,\n        y = xy.y;\n\n    if (tickSize) {\n      // negate the length\n      if (axis.opposite) {\n        tickSize[0] = -tickSize[0];\n      } // First time, create it\n\n\n      if (isNewMark) {\n        tick.mark = mark = renderer.path().addClass('highcharts-' + (type ? type + '-' : '') + 'tick').add(axis.axisGroup);\n      }\n\n      mark[isNewMark ? 'attr' : 'animate']({\n        d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),\n        opacity: opacity\n      });\n    }\n  },\n\n  /**\n   * Renders the tick label.\n   * Note: The label should already be created in init(), so it should only\n   * have to be moved into place.\n   * @param  {Object} xy      The position vector of the label\n   * @param  {number} xy.x    The x position of the label\n   * @param  {number} xy.y    The y position of the label\n   * @param  {Boolean} old    Whether or not the tick is old\n   * @param  {number} opacity The opacity of the label\n   * @param  {number} index   The index of the tick\n   * @return {undefined}\n   */\n  renderLabel: function renderLabel(xy, old, opacity, index) {\n    var tick = this,\n        axis = tick.axis,\n        horiz = axis.horiz,\n        options = axis.options,\n        label = tick.label,\n        labelOptions = options.labels,\n        step = labelOptions.step,\n        tickmarkOffset = axis.tickmarkOffset,\n        show = true,\n        x = xy.x,\n        y = xy.y;\n\n    if (label && isNumber(x)) {\n      label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step); // Apply show first and show last. If the tick is both first and\n      // last, it is a single centered tick, in which case we show the\n      // label anyway (#2100).\n\n      if (tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1) || tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1)) {\n        show = false; // Handle label overflow and show or hide accordingly\n      } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n        tick.handleOverflow(xy);\n      } // apply step\n\n\n      if (step && index % step) {\n        // show those indices dividable by step\n        show = false;\n      } // Set the new position, and show or hide\n\n\n      if (show && isNumber(xy.y)) {\n        xy.opacity = opacity;\n        label[tick.isNewLabel ? 'attr' : 'animate'](xy);\n        tick.isNewLabel = false;\n      } else {\n        label.attr('y', -9999); // #1338\n\n        tick.isNewLabel = true;\n      }\n    }\n  },\n\n  /**\n   * Put everything in place\n   *\n   * @param index {Number}\n   * @param old {Boolean} Use old coordinates to prepare an animation into new\n   *                      position\n   */\n  render: function render(index, old, opacity) {\n    var tick = this,\n        axis = tick.axis,\n        horiz = axis.horiz,\n        pos = tick.pos,\n        tickmarkOffset = axis.tickmarkOffset,\n        xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n        x = xy.x,\n        y = xy.y,\n        reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1; // #1480, #1687\n\n    opacity = pick(opacity, 1);\n    this.isActive = true; // Create the grid line\n\n    this.renderGridLine(old, opacity, reverseCrisp); // create the tick mark\n\n    this.renderMark(xy, opacity, reverseCrisp); // the label is created on init - now move it into place\n\n    this.renderLabel(xy, old, opacity, index);\n    tick.isNew = false;\n    H.fireEvent(this, 'afterRender');\n  },\n\n  /**\n   * Destructor for the tick prototype\n   */\n  destroy: function destroy() {\n    destroyObjectProperties(this, this.axis);\n  }\n};"
    },
    {
     "id": 268,
     "name": "../node_modules/highcharts/js/es-modules/parts/Tooltip.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nvar doc = H.doc,\n    each = H.each,\n    extend = H.extend,\n    format = H.format,\n    isNumber = H.isNumber,\n    map = H.map,\n    merge = H.merge,\n    pick = H.pick,\n    splat = H.splat,\n    syncTimeout = H.syncTimeout,\n    timeUnits = H.timeUnits;\n/**\n * Tooltip of a chart.\n *\n * @class\n * @name Highcharts.Tooltip\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @param {Highcharts.TooltipOptions} options\n *        Tooltip options.\n */\n\nH.Tooltip = function () {\n  this.init.apply(this, arguments);\n};\n\nH.Tooltip.prototype = {\n  /**\n   * @private\n   * @function Highcharts.Tooltip#init\n   *\n   * @param {Highcharts.Chart} chart\n   *        The chart instance.\n   *\n   * @param {Highcharts.TooltipOptions} options\n   *        Tooltip options.\n   */\n  init: function init(chart, options) {\n    /**\n     * Chart of the tooltip.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#chart\n     * @type {Highcharts.Chart}\n     */\n    this.chart = chart;\n    /**\n     * Used tooltip options.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#options\n     * @type {Highcharts.TooltipOptions}\n     */\n\n    this.options = options;\n    /**\n     * List of crosshairs.\n     *\n     * @private\n     * @readonly\n     * @name Highcharts.Tooltip#crosshairs\n     * @type {Array<*>}\n     */\n\n    this.crosshairs = [];\n    /**\n     * Current values of x and y when animating.\n     *\n     * @private\n     * @readonly\n     * @name Highcharts.Tooltip#now\n     * @type {*}\n     */\n\n    this.now = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Tooltips are initially hidden.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#isHidden\n     * @type {boolean}\n     */\n\n    this.isHidden = true;\n    /**\n     * True, if the tooltip is splitted into one label per series, with the\n     * header close to the axis.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#split\n     * @type {boolean}\n     */\n\n    this.split = options.split && !chart.inverted;\n    /**\n     * When the tooltip is shared, the entire plot area will capture mouse\n     * movement or touch events.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#shared\n     * @type {boolean}\n     */\n\n    this.shared = options.shared || this.split;\n    /**\n     * Whether to allow the tooltip to render outside the chart's SVG\n     * element box. By default (false), the tooltip is rendered within the\n     * chart's SVG element, which results in the tooltip being aligned\n     * inside the chart area.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#outside\n     * @type {boolean}\n     *\n     * @todo\n     * Split tooltip does not support outside in the first iteration. Should\n     * not be too complicated to implement.\n     */\n\n    this.outside = options.outside && !this.split;\n  },\n\n  /**\n   * Destroy the single tooltips in a split tooltip.\n   * If the tooltip is active then it is not destroyed, unless forced to.\n   *\n   * @private\n   * @function Highcharts.Tooltip#cleanSplit\n   *\n   * @param {boolean} force\n   *        Force destroy all tooltips.\n   */\n  cleanSplit: function cleanSplit(force) {\n    each(this.chart.series, function (series) {\n      var tt = series && series.tt;\n\n      if (tt) {\n        if (!tt.isActive || force) {\n          series.tt = tt.destroy();\n        } else {\n          tt.isActive = false;\n        }\n      }\n    });\n  },\n\n  /**\n   * In styled mode, apply the default filter for the tooltip drop-shadow. It\n   * needs to have an id specific to the chart, otherwise there will be issues\n   * when one tooltip adopts the filter of a different chart, specifically one\n   * where the container is hidden.\n   *\n   * @private\n   * @function Highcharts.Tooltip#applyFilter\n   */\n  applyFilter: function applyFilter() {\n    var chart = this.chart;\n    chart.renderer.definition({\n      tagName: 'filter',\n      id: 'drop-shadow-' + chart.index,\n      opacity: 0.5,\n      children: [{\n        tagName: 'feGaussianBlur',\n        in: 'SourceAlpha',\n        stdDeviation: 1\n      }, {\n        tagName: 'feOffset',\n        dx: 1,\n        dy: 1\n      }, {\n        tagName: 'feComponentTransfer',\n        children: [{\n          tagName: 'feFuncA',\n          type: 'linear',\n          slope: 0.3\n        }]\n      }, {\n        tagName: 'feMerge',\n        children: [{\n          tagName: 'feMergeNode'\n        }, {\n          tagName: 'feMergeNode',\n          in: 'SourceGraphic'\n        }]\n      }]\n    });\n    chart.renderer.definition({\n      tagName: 'style',\n      textContent: '.highcharts-tooltip-' + chart.index + '{' + 'filter:url(#drop-shadow-' + chart.index + ')' + '}'\n    });\n  },\n\n  /**\n   * Creates the Tooltip label element if it does not exist, then returns it.\n   *\n   * @function Highcharts.Tooltip#getLabel\n   *\n   * @return {Highcharts.SVGElement}\n   */\n  getLabel: function getLabel() {\n    var renderer = this.chart.renderer,\n        options = this.options,\n        container;\n\n    if (!this.label) {\n      if (this.outside) {\n        this.container = container = H.doc.createElement('div');\n        container.className = 'highcharts-tooltip-container';\n        H.css(container, {\n          position: 'absolute',\n          top: '1px',\n          pointerEvents: options.style && options.style.pointerEvents\n        });\n        H.doc.body.appendChild(container);\n        this.renderer = renderer = new H.Renderer(container, 0, 0);\n      } // Create the label\n\n\n      if (this.split) {\n        this.label = renderer.g('tooltip');\n      } else {\n        this.label = renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip').attr({\n          padding: options.padding,\n          r: options.borderRadius\n        });\n      } // Apply the drop-shadow filter\n\n\n      this.applyFilter();\n      this.label.addClass('highcharts-tooltip-' + this.chart.index);\n\n      if (this.outside) {\n        this.label.attr({\n          x: this.distance,\n          y: this.distance\n        });\n\n        this.label.xSetter = function (value) {\n          container.style.left = value + 'px';\n        };\n\n        this.label.ySetter = function (value) {\n          container.style.top = value + 'px';\n        };\n      }\n\n      this.label.attr({\n        zIndex: 8\n      }).add();\n    }\n\n    return this.label;\n  },\n\n  /**\n   * Updates the tooltip with the provided tooltip options.\n   *\n   * @function Highcharts.Tooltip#update\n   *\n   * @param {Highcharts.TooltipOptions} options\n   */\n  update: function update(options) {\n    this.destroy(); // Update user options (#6218)\n\n    merge(true, this.chart.options.tooltip.userOptions, options);\n    this.init(this.chart, merge(true, this.options, options));\n  },\n\n  /**\n   * Removes and destroys the tooltip and its elements.\n   *\n   * @function Highcharts.Tooltip#destroy\n   */\n  destroy: function destroy() {\n    // Destroy and clear local variables\n    if (this.label) {\n      this.label = this.label.destroy();\n    }\n\n    if (this.split && this.tt) {\n      this.cleanSplit(this.chart, true);\n      this.tt = this.tt.destroy();\n    }\n\n    if (this.renderer) {\n      this.renderer = this.renderer.destroy();\n      H.discardElement(this.container);\n    }\n\n    H.clearTimeout(this.hideTimer);\n    H.clearTimeout(this.tooltipTimeout);\n  },\n\n  /**\n   * Moves the tooltip with a soft animation to a new position.\n   *\n   * @function Highcharts.Tooltip#move\n   *\n   * @param {number} x\n   *\n   * @param {number} y\n   *\n   * @param {number} anchorX\n   *\n   * @param {number} anchorY\n   */\n  move: function move(x, y, anchorX, anchorY) {\n    var tooltip = this,\n        now = tooltip.now,\n        animate = tooltip.options.animation !== false && !tooltip.isHidden && ( // When we get close to the target position, abort animation and\n    // land on the right place (#3056)\n    Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),\n        skipAnchor = tooltip.followPointer || tooltip.len > 1; // Get intermediate values for animation\n\n    extend(now, {\n      x: animate ? (2 * now.x + x) / 3 : x,\n      y: animate ? (now.y + y) / 2 : y,\n      anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n      anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY\n    }); // Move to the intermediate value\n\n    tooltip.getLabel().attr(now); // Run on next tick of the mouse tracker\n\n    if (animate) {\n      // Never allow two timeouts\n      H.clearTimeout(this.tooltipTimeout); // Set the fixed interval ticking for the smooth tooltip\n\n      this.tooltipTimeout = setTimeout(function () {\n        // The interval function may still be running during destroy,\n        // so check that the chart is really there before calling.\n        if (tooltip) {\n          tooltip.move(x, y, anchorX, anchorY);\n        }\n      }, 32);\n    }\n  },\n\n  /**\n   * Hides the tooltip with a fade out animation.\n   *\n   * @function Highcharts.Tooltip#hide\n   *\n   * @param {number} [delay]\n   *        The fade out in milliseconds. If no value is provided the value\n   *        of the tooltip.hideDelay option is used. A value of 0 disables\n   *        the fade out animation.\n   */\n  hide: function hide(delay) {\n    var tooltip = this; // disallow duplicate timers (#1728, #1766)\n\n    H.clearTimeout(this.hideTimer);\n    delay = pick(delay, this.options.hideDelay, 500);\n\n    if (!this.isHidden) {\n      this.hideTimer = syncTimeout(function () {\n        tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();\n        tooltip.isHidden = true;\n      }, delay);\n    }\n  },\n\n  /**\n   * Extendable method to get the anchor position of the tooltip\n   * from a point or set of points\n   *\n   * @private\n   * @function Highcharts.Tooltip#getAnchor\n   *\n   * @param {Array<Highchart.Points>} points\n   *\n   * @param {global.Event} [mouseEvent]\n   */\n  getAnchor: function getAnchor(points, mouseEvent) {\n    var ret,\n        chart = this.chart,\n        pointer = chart.pointer,\n        inverted = chart.inverted,\n        plotTop = chart.plotTop,\n        plotLeft = chart.plotLeft,\n        plotX = 0,\n        plotY = 0,\n        yAxis,\n        xAxis;\n    points = splat(points); // When tooltip follows mouse, relate the position to the mouse\n\n    if (this.followPointer && mouseEvent) {\n      if (mouseEvent.chartX === undefined) {\n        mouseEvent = pointer.normalize(mouseEvent);\n      }\n\n      ret = [mouseEvent.chartX - chart.plotLeft, mouseEvent.chartY - plotTop]; // Pie uses a special tooltipPos\n    } else if (points[0].tooltipPos) {\n      ret = points[0].tooltipPos; // When shared, use the average position\n    } else {\n      each(points, function (point) {\n        yAxis = point.series.yAxis;\n        xAxis = point.series.xAxis;\n        plotX += point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0);\n        plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) + (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n      });\n      plotX /= points.length;\n      plotY /= points.length;\n      ret = [inverted ? chart.plotWidth - plotY : plotX, this.shared && !inverted && points.length > 1 && mouseEvent ? // place shared tooltip next to the mouse (#424)\n      mouseEvent.chartY - plotTop : inverted ? chart.plotHeight - plotX : plotY];\n    }\n\n    return map(ret, Math.round);\n  },\n\n  /**\n   * Place the tooltip in a chart without spilling over\n   * and not covering the point it self.\n   *\n   * @private\n   * @function Highcharts.Tooltip#getPosition\n   *\n   * @param {number} boxWidth\n   *\n   * @param {number} boxHeight\n   *\n   * @param {Highcharts.Point} point\n   *\n   * @return {*}\n   */\n  getPosition: function getPosition(boxWidth, boxHeight, point) {\n    var chart = this.chart,\n        distance = this.distance,\n        ret = {},\n        // Don't use h if chart isn't inverted (#7242)\n    h = chart.inverted && point.h || 0,\n        // #4117\n    swapped,\n        outside = this.outside,\n        outerWidth = outside ? // substract distance to prevent scrollbars\n    doc.documentElement.clientWidth - 2 * distance : chart.chartWidth,\n        outerHeight = outside ? Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight, doc.body.offsetHeight, doc.documentElement.offsetHeight, doc.documentElement.clientHeight) : chart.chartHeight,\n        chartPosition = chart.pointer.chartPosition,\n        first = ['y', outerHeight, boxHeight, (outside ? chartPosition.top - distance : 0) + point.plotY + chart.plotTop, outside ? 0 : chart.plotTop, outside ? outerHeight : chart.plotTop + chart.plotHeight],\n        second = ['x', outerWidth, boxWidth, (outside ? chartPosition.left - distance : 0) + point.plotX + chart.plotLeft, outside ? 0 : chart.plotLeft, outside ? outerWidth : chart.plotLeft + chart.plotWidth],\n        // The far side is right or bottom\n    preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative),\n        // #4984\n\n    /*\n     * Handle the preferred dimension. When the preferred dimension is\n     * tooltip on top or bottom of the point, it will look for space\n     * there.\n     *\n     * @private\n     */\n    firstDimension = function firstDimension(dim, outerSize, innerSize, point, min, max) {\n      var roomLeft = innerSize < point - distance,\n          roomRight = point + distance + innerSize < outerSize,\n          alignedLeft = point - distance - innerSize,\n          alignedRight = point + distance;\n\n      if (preferFarSide && roomRight) {\n        ret[dim] = alignedRight;\n      } else if (!preferFarSide && roomLeft) {\n        ret[dim] = alignedLeft;\n      } else if (roomLeft) {\n        ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n      } else if (roomRight) {\n        ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);\n      } else {\n        return false;\n      }\n    },\n\n    /*\n     * Handle the secondary dimension. If the preferred dimension is\n     * tooltip on top or bottom of the point, the second dimension is to\n     * align the tooltip above the point, trying to align center but\n     * allowing left or right align within the chart box.\n     *\n     * @private\n     */\n    secondDimension = function secondDimension(dim, outerSize, innerSize, point) {\n      var retVal; // Too close to the edge, return false and swap dimensions\n\n      if (point < distance || point > outerSize - distance) {\n        retVal = false; // Align left/top\n      } else if (point < innerSize / 2) {\n        ret[dim] = 1; // Align right/bottom\n      } else if (point > outerSize - innerSize / 2) {\n        ret[dim] = outerSize - innerSize - 2; // Align center\n      } else {\n        ret[dim] = point - innerSize / 2;\n      }\n\n      return retVal;\n    },\n\n    /*\n     * Swap the dimensions\n     */\n    swap = function swap(count) {\n      var temp = first;\n      first = second;\n      second = temp;\n      swapped = count;\n    },\n        run = function run() {\n      if (firstDimension.apply(0, first) !== false) {\n        if (secondDimension.apply(0, second) === false && !swapped) {\n          swap(true);\n          run();\n        }\n      } else if (!swapped) {\n        swap(true);\n        run();\n      } else {\n        ret.x = ret.y = 0;\n      }\n    }; // Under these conditions, prefer the tooltip on the side of the point\n\n\n    if (chart.inverted || this.len > 1) {\n      swap();\n    }\n\n    run();\n    return ret;\n  },\n\n  /**\n   * In case no user defined formatter is given, this will be used. Note that\n   * the context here is an object holding point, series, x, y etc.\n   *\n   * @private\n   * @function Highcharts.Tooltip#defaultFormatter\n   *\n   * @param {Highcharts.Tooltip} tooltip\n   *\n   * @return {Array<string>}\n   */\n  defaultFormatter: function defaultFormatter(tooltip) {\n    var items = this.points || splat(this),\n        s; // Build the header\n\n    s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; // build the values\n\n    s = s.concat(tooltip.bodyFormatter(items)); // footer\n\n    s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));\n    return s;\n  },\n\n  /**\n   * Refresh the tooltip's text and position.\n   *\n   * @function Highcharts.Tooltip#refresh\n   *\n   * @param {Highcharts.Point|Array<Highcharts.Point>} pointOrPoints\n   *        Either a point or an array of points.\n   *\n   * @param {global.Event} [mouseEvent]\n   *        Mouse event, that is responsible for the refresh and should be\n   *        used for the tooltip update.\n   */\n  refresh: function refresh(pointOrPoints, mouseEvent) {\n    var tooltip = this,\n        label,\n        options = tooltip.options,\n        x,\n        y,\n        point = pointOrPoints,\n        anchor,\n        textConfig = {},\n        text,\n        pointConfig = [],\n        formatter = options.formatter || tooltip.defaultFormatter,\n        shared = tooltip.shared,\n        currentSeries;\n\n    if (!options.enabled) {\n      return;\n    }\n\n    H.clearTimeout(this.hideTimer); // get the reference point coordinates (pie charts use tooltipPos)\n\n    tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n    anchor = tooltip.getAnchor(point, mouseEvent);\n    x = anchor[0];\n    y = anchor[1]; // shared tooltip, array is sent over\n\n    if (shared && !(point.series && point.series.noSharedTooltip)) {\n      each(point, function (item) {\n        item.setState('hover');\n        pointConfig.push(item.getLabelConfig());\n      });\n      textConfig = {\n        x: point[0].category,\n        y: point[0].y\n      };\n      textConfig.points = pointConfig;\n      point = point[0]; // single point tooltip\n    } else {\n      textConfig = point.getLabelConfig();\n    }\n\n    this.len = pointConfig.length; // #6128\n\n    text = formatter.call(textConfig, tooltip); // register the current series\n\n    currentSeries = point.series;\n    this.distance = pick(currentSeries.tooltipOptions.distance, 16); // update the inner HTML\n\n    if (text === false) {\n      this.hide();\n    } else {\n      label = tooltip.getLabel(); // show it\n\n      if (tooltip.isHidden) {\n        label.attr({\n          opacity: 1\n        }).show();\n      } // update text\n\n\n      if (tooltip.split) {\n        this.renderSplit(text, splat(pointOrPoints));\n      } else {\n        // Prevent the tooltip from flowing over the chart box (#6659)\n        label.css({\n          width: this.chart.spacingBox.width\n        });\n        label.attr({\n          text: text && text.join ? text.join('') : text\n        }); // Set the stroke color of the box to reflect the point\n\n        label.removeClass(/highcharts-color-[\\d]+/g).addClass('highcharts-color-' + pick(point.colorIndex, currentSeries.colorIndex));\n        tooltip.updatePosition({\n          plotX: x,\n          plotY: y,\n          negative: point.negative,\n          ttBelow: point.ttBelow,\n          h: anchor[2] || 0\n        });\n      }\n\n      this.isHidden = false;\n    }\n  },\n\n  /**\n   * Render the split tooltip. Loops over each point's text and adds\n   * a label next to the point, then uses the distribute function to\n   * find best non-overlapping positions.\n   *\n   * @private\n   * @function Highcharts.Tooltip#renderSplit\n   *\n   * @param {Array<Highcharts.Label>} labels\n   *\n   * @param {Array<Highcharts.Point>} points\n   */\n  renderSplit: function renderSplit(labels, points) {\n    var tooltip = this,\n        boxes = [],\n        chart = this.chart,\n        ren = chart.renderer,\n        rightAligned = true,\n        options = this.options,\n        headerHeight = 0,\n        headerTop,\n        tooltipLabel = this.getLabel(),\n        distributionBoxTop = chart.plotTop; // Graceful degradation for legacy formatters\n\n    if (H.isString(labels)) {\n      labels = [false, labels];\n    } // Create the individual labels for header and points, ignore footer\n\n\n    each(labels.slice(0, points.length + 1), function (str, i) {\n      if (str !== false) {\n        var point = points[i - 1] || // Item 0 is the header. Instead of this, we could also\n        // use the crosshair label\n        {\n          isHeader: true,\n          plotX: points[0].plotX\n        },\n            owner = point.series || tooltip,\n            tt = owner.tt,\n            series = point.series || {},\n            colorClass = 'highcharts-color-' + pick(point.colorIndex, series.colorIndex, 'none'),\n            target,\n            x,\n            bBox,\n            boxWidth; // Store the tooltip referance on the series\n\n        if (!tt) {\n          owner.tt = tt = ren.label(null, null, null, 'callout', null, null, options.useHTML).addClass('highcharts-tooltip-box ' + colorClass + (point.isHeader ? ' highcharts-tooltip-header' : '')).attr({\n            'padding': options.padding,\n            'r': options.borderRadius\n          }).add(tooltipLabel);\n        }\n\n        tt.isActive = true;\n        tt.attr({\n          text: str\n        }); // Get X position now, so we can move all to the other side in\n        // case of overflow\n\n        bBox = tt.getBBox();\n        boxWidth = bBox.width + tt.strokeWidth();\n\n        if (point.isHeader) {\n          headerHeight = bBox.height;\n\n          if (chart.xAxis[0].opposite) {\n            headerTop = true;\n            distributionBoxTop -= headerHeight;\n          }\n\n          x = Math.max(0, // No left overflow\n          Math.min(point.plotX + chart.plotLeft - boxWidth / 2, // No right overflow (#5794)\n          chart.chartWidth + ( // Scrollable plot area\n          chart.scrollablePixels ? chart.scrollablePixels - chart.marginRight : 0) - boxWidth));\n        } else {\n          x = point.plotX + chart.plotLeft - pick(options.distance, 16) - boxWidth;\n        } // If overflow left, we don't use this x in the next loop\n\n\n        if (x < 0) {\n          rightAligned = false;\n        } // Prepare for distribution\n\n\n        target = (point.series && point.series.yAxis && point.series.yAxis.pos) + (point.plotY || 0);\n        target -= distributionBoxTop;\n\n        if (point.isHeader) {\n          target = headerTop ? -headerHeight : chart.plotHeight + headerHeight;\n        }\n\n        boxes.push({\n          target: target,\n          rank: point.isHeader ? 1 : 0,\n          size: owner.tt.getBBox().height + 1,\n          point: point,\n          x: x,\n          tt: tt\n        });\n      }\n    }); // Clean previous run (for missing points)\n\n    this.cleanSplit(); // Distribute and put in place\n\n    H.distribute(boxes, chart.plotHeight + headerHeight);\n    each(boxes, function (box) {\n      var point = box.point,\n          series = point.series; // Put the label in place\n\n      box.tt.attr({\n        visibility: box.pos === undefined ? 'hidden' : 'inherit',\n        x: rightAligned || point.isHeader ? box.x : point.plotX + chart.plotLeft + pick(options.distance, 16),\n        y: box.pos + distributionBoxTop,\n        anchorX: point.isHeader ? point.plotX + chart.plotLeft : point.plotX + series.xAxis.pos,\n        anchorY: point.isHeader ? chart.plotTop + chart.plotHeight / 2 : point.plotY + series.yAxis.pos\n      });\n    });\n  },\n\n  /**\n   * Find the new position and perform the move\n   *\n   * @private\n   * @function Highcharts.Tooltip#updatePosition\n   *\n   * @param {Highcharts.Point} point\n   */\n  updatePosition: function updatePosition(point) {\n    var chart = this.chart,\n        label = this.getLabel(),\n        pos = (this.options.positioner || this.getPosition).call(this, label.width, label.height, point),\n        anchorX = point.plotX + chart.plotLeft,\n        anchorY = point.plotY + chart.plotTop,\n        pad; // Set the renderer size dynamically to prevent document size to change\n\n    if (this.outside) {\n      pad = (this.options.borderWidth || 0) + 2 * this.distance;\n      this.renderer.setSize(label.width + pad, label.height + pad, false);\n      anchorX += chart.pointer.chartPosition.left - pos.x;\n      anchorY += chart.pointer.chartPosition.top - pos.y;\n    } // do the move\n\n\n    this.move(Math.round(pos.x), Math.round(pos.y || 0), // can be undefined (#3977)\n    anchorX, anchorY);\n  },\n\n  /**\n   * Get the optimal date format for a point, based on a range.\n   *\n   * @private\n   * @function Highcharts.Tooltip#getDateFormat\n   *\n   * @param {number} range\n   *        The time range\n   *\n   * @param {number|Date} date\n   *        The date of the point in question\n   *\n   * @param {number} startOfWeek\n   *        An integer representing the first day of the week, where 0 is\n   *        Sunday.\n   *\n   * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats\n   *        A map of time units to formats.\n   *\n   * @return {string}\n   *         The optimal date format for a point.\n   */\n  getDateFormat: function getDateFormat(range, date, startOfWeek, dateTimeLabelFormats) {\n    var time = this.chart.time,\n        dateStr = time.dateFormat('%m-%d %H:%M:%S.%L', date),\n        format,\n        n,\n        blank = '01-01 00:00:00.000',\n        strpos = {\n      millisecond: 15,\n      second: 12,\n      minute: 9,\n      hour: 6,\n      day: 3\n    },\n        lastN = 'millisecond'; // for sub-millisecond data, #4223\n\n    for (n in timeUnits) {\n      // If the range is exactly one week and we're looking at a\n      // Sunday/Monday, go for the week format\n      if (range === timeUnits.week && +time.dateFormat('%w', date) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {\n        n = 'week';\n        break;\n      } // The first format that is too great for the range\n\n\n      if (timeUnits[n] > range) {\n        n = lastN;\n        break;\n      } // If the point is placed every day at 23:59, we need to show\n      // the minutes as well. #2637.\n\n\n      if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {\n        break;\n      } // Weeks are outside the hierarchy, only apply them on\n      // Mondays/Sundays like in the first condition\n\n\n      if (n !== 'week') {\n        lastN = n;\n      }\n    }\n\n    if (n) {\n      format = dateTimeLabelFormats[n];\n    }\n\n    return format;\n  },\n\n  /**\n   * Get the best X date format based on the closest point range on the axis.\n   *\n   * @private\n   * @function Highcharts.Tooltip#getXDateFormat\n   *\n   * @param {Highcharts.Point} point\n   *\n   * @param {Highcharts.TooltipOptions} options\n   *\n   * @param {Highcharts.Axis} xAxis\n   *\n   * @return {string}\n   */\n  getXDateFormat: function getXDateFormat(point, options, xAxis) {\n    var xDateFormat,\n        dateTimeLabelFormats = options.dateTimeLabelFormats,\n        closestPointRange = xAxis && xAxis.closestPointRange;\n\n    if (closestPointRange) {\n      xDateFormat = this.getDateFormat(closestPointRange, point.x, xAxis.options.startOfWeek, dateTimeLabelFormats);\n    } else {\n      xDateFormat = dateTimeLabelFormats.day;\n    }\n\n    return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n  },\n\n  /**\n   * Format the footer/header of the tooltip\n   * #3397: abstraction to enable formatting of footer and header\n   *\n   * @private\n   * @function Highcharts.Tooltip#tooltipFooterHeaderFormatter\n   *\n   * @param {*} labelConfig\n   *\n   * @param {boolean} isFooter\n   *\n   * @return {string}\n   */\n  tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(labelConfig, isFooter) {\n    var footOrHead = isFooter ? 'footer' : 'header',\n        series = labelConfig.series,\n        tooltipOptions = series.tooltipOptions,\n        xDateFormat = tooltipOptions.xDateFormat,\n        xAxis = series.xAxis,\n        isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(labelConfig.key),\n        formatString = tooltipOptions[footOrHead + 'Format']; // Guess the best date format based on the closest point distance (#568,\n    // #3418)\n\n    if (isDateTime && !xDateFormat) {\n      xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);\n    } // Insert the footer date format if any\n\n\n    if (isDateTime && xDateFormat) {\n      each(labelConfig.point && labelConfig.point.tooltipDateKeys || ['key'], function (key) {\n        formatString = formatString.replace('{point.' + key + '}', '{point.' + key + ':' + xDateFormat + '}');\n      });\n    }\n\n    return format(formatString, {\n      point: labelConfig,\n      series: series\n    }, this.chart.time);\n  },\n\n  /**\n   * Build the body (lines) of the tooltip by iterating over the items and\n   * returning one entry for each item, abstracting this functionality allows\n   * to easily overwrite and extend it.\n   *\n   * @private\n   * @function Highcharts.Tooltip#bodyFormatter\n   *\n   * @param {Array<Highcharts.Point>} items\n   *\n   * @return {string}\n   */\n  bodyFormatter: function bodyFormatter(items) {\n    return map(items, function (item) {\n      var tooltipOptions = item.series.tooltipOptions;\n      return (tooltipOptions[(item.point.formatPrefix || 'point') + 'Formatter'] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || 'point') + 'Format']);\n    });\n  }\n};"
    },
    {
     "id": 269,
     "name": "../node_modules/highcharts/js/es-modules/parts/ColumnSeries.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Color.js';\nimport './Legend.js';\nimport './Series.js';\nimport './Options.js';\nvar animObject = H.animObject,\n    color = H.color,\n    each = H.each,\n    extend = H.extend,\n    isNumber = H.isNumber,\n    LegendSymbolMixin = H.LegendSymbolMixin,\n    merge = H.merge,\n    noop = H.noop,\n    pick = H.pick,\n    Series = H.Series,\n    seriesType = H.seriesType,\n    svg = H.svg;\n/**\n * The column series type.\n *\n * @constructor seriesTypes.column\n * @augments    Series\n */\n\n/**\n * Column series display one column per value along an X axis.\n *\n * @sample       {highcharts} highcharts/demo/column-basic/ Column chart\n * @sample       {highstock} stock/demo/column/ Column chart\n *\n * @extends      {plotOptions.line}\n * @product      highcharts highstock\n * @excluding    connectNulls,dashStyle,gapSize,gapUnit,linecap,lineWidth,\n *               marker,connectEnds,step\n * @optionparent plotOptions.column\n */\n\nseriesType('column', 'line', {\n  /**\n   * The corner radius of the border surrounding each column or bar.\n   *\n   * @type    {Number}\n   * @sample  {highcharts} highcharts/plotoptions/column-borderradius/\n   *          Rounded columns\n   * @default 0\n   * @product highcharts highstock\n   */\n  borderRadius: 0,\n\n  /**\n   * When using automatic point colors pulled from the global [colors](colors)\n   * or series-specific [plotOptions.column.colors](series.colors)\n   * collections, this option determines whether the chart should receive\n   * one color per series or one color per point.\n   *\n   * In styled mode, the `colors` or `series.colors` arrays are not supported,\n   * and instead this option gives the points individual color class names on\n   * the form `highcharts-color-{n}`.\n   *\n   * @type      {Boolean}\n   * @see       [series colors](#plotOptions.column.colors)\n   * @sample    {highcharts} highcharts/plotoptions/column-colorbypoint-false/\n   *            False by default\n   * @sample    {highcharts} highcharts/plotoptions/column-colorbypoint-true/\n   *            True\n   * @default   false\n   * @since     2.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.colorByPoint\n   */\n\n  /**\n   * A series specific or series type specific color set to apply instead\n   * of the global [colors](#colors) when [colorByPoint](\n   * #plotOptions.column.colorByPoint) is true.\n   *\n   * @type      {Array<Color>}\n   * @since     3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.colors\n   */\n\n  /**\n   * When true, each column edge is rounded to its nearest pixel in order\n   * to render sharp on screen. In some cases, when there are a lot of\n   * densely packed columns, this leads to visible difference in column\n   * widths or distance between columns. In these cases, setting `crisp`\n   * to `false` may look better, even though each column is rendered\n   * blurry.\n   *\n   * @sample  {highcharts} highcharts/plotoptions/column-crisp-false/\n   *          Crisp is false\n   * @since   5.0.10\n   * @product highcharts highstock\n   */\n  crisp: true,\n\n  /**\n   * Padding between each value groups, in x axis units.\n   *\n   * @sample  {highcharts} highcharts/plotoptions/column-grouppadding-default/\n   *          0.2 by default\n   * @sample  {highcharts} highcharts/plotoptions/column-grouppadding-none/\n   *          No group padding - all columns are evenly spaced\n   * @product highcharts highstock\n   */\n  groupPadding: 0.2,\n\n  /**\n   * Whether to group non-stacked columns or to let them render independent\n   * of each other. Non-grouped columns will be laid out individually\n   * and overlap each other.\n   *\n   * @type      {Boolean}\n   * @sample    {highcharts} highcharts/plotoptions/column-grouping-false/\n   *            Grouping disabled\n   * @sample    {highstock} highcharts/plotoptions/column-grouping-false/\n   *            Grouping disabled\n   * @default   true\n   * @since     2.3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.grouping\n   */\n\n  /**\n   * @ignore-option\n   */\n  marker: null,\n  // point options are specified in the base options\n\n  /**\n   * The maximum allowed pixel width for a column, translated to the height\n   * of a bar in a bar chart. This prevents the columns from becoming\n   * too wide when there is a small number of points in the chart.\n   *\n   * @type      {Number}\n   * @see       [pointWidth](#plotOptions.column.pointWidth)\n   * @sample    {highcharts} highcharts/plotoptions/column-maxpointwidth-20/\n   *            Limited to 50\n   * @sample    {highstock} highcharts/plotoptions/column-maxpointwidth-20/\n   *            Limited to 50\n   * @default   null\n   * @since     4.1.8\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.maxPointWidth\n   */\n\n  /**\n   * Padding between each column or bar, in x axis units.\n   *\n   * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-default/\n   *          0.1 by default\n   * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-025/\n   *          0.25\n   * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-none/\n   *          0 for tightly packed columns\n   * @product highcharts highstock\n   */\n  pointPadding: 0.1,\n\n  /**\n   * A pixel value specifying a fixed width for each column or bar. When\n   * `null`, the width is calculated from the `pointPadding` and\n   * `groupPadding`.\n   *\n   * @type      {Number}\n   * @see       [maxPointWidth](#plotOptions.column.maxPointWidth)\n   * @sample    {highcharts} highcharts/plotoptions/column-pointwidth-20/\n   *            20px wide columns regardless of chart width or the amount\n   *            of data points\n   * @default   null\n   * @since     1.2.5\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.pointWidth\n   */\n\n  /**\n   * The minimal height for a column or width for a bar. By default,\n   * 0 values are not shown. To visualize a 0 (or close to zero) point,\n   * set the minimal point length to a pixel value like 3\\. In stacked\n   * column charts, minPointLength might not be respected for tightly\n   * packed values.\n   *\n   * @sample  {highcharts}\n   *          highcharts/plotoptions/column-minpointlength/\n   *          Zero base value\n   * @sample  {highcharts}\n   *          highcharts/plotoptions/column-minpointlength-pos-and-neg/\n   *          Positive and negative close to zero values\n   * @product highcharts highstock\n   */\n  minPointLength: 0,\n\n  /**\n   * When the series contains less points than the crop threshold, all\n   * points are drawn, event if the points fall outside the visible plot\n   * area at the current zoom. The advantage of drawing all points (including\n   * markers and columns), is that animation is performed on updates.\n   * On the other hand, when the series contains more points than the\n   * crop threshold, the series data is cropped to only contain points\n   * that fall within the plot area. The advantage of cropping away invisible\n   * points is to increase performance on large series. .\n   *\n   * @product highcharts highstock\n   */\n  cropThreshold: 50,\n\n  /**\n   * The X axis range that each point is valid for. This determines the\n   * width of the column. On a categorized axis, the range will be 1\n   * by default (one category unit). On linear and datetime axes, the\n   * range will be computed as the distance between the two closest data\n   * points.\n   *\n   * The default `null` means it is computed automatically, but this option\n   * can be used to override the automatic value.\n   *\n   * @type    {Number}\n   * @sample  {highcharts} highcharts/plotoptions/column-pointrange/\n   *          Set the point range to one day on a data set with one week\n   *          between the points\n   * @since   2.3\n   * @product highcharts highstock\n   */\n  pointRange: null,\n  states: {\n    /**\n     * Options for the hovered point. These settings override the normal\n     * state options when a point is moused over or touched.\n     *\n     * @extends   plotOptions.series.states.hover\n     * @excluding halo,lineWidth,lineWidthPlus,marker\n     * @product   highcharts highstock\n     */\n    hover: {\n      /** @ignore-option */\n      halo: false\n      /**\n       * A specific border color for the hovered point. Defaults to\n       * inherit the normal state border color.\n       *\n       * @type      {Color}\n       * @product   highcharts\n       * @apioption plotOptions.column.states.hover.borderColor\n       */\n\n      /**\n       * A specific color for the hovered point.\n       *\n       * @type      {Color}\n       * @default   undefined\n       * @product   highcharts\n       * @apioption plotOptions.column.states.hover.color\n       */\n\n    }\n  },\n  dataLabels: {\n    align: null,\n    // auto\n    verticalAlign: null,\n    // auto\n    y: null\n  },\n\n  /**\n   * When this is true, the series will not cause the Y axis to cross\n   * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n   * unless the data actually crosses the plane.\n   *\n   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n   * 3 will make the Y axis show negative values according to the `minPadding`\n   * option. If `softThreshold` is `true`, the Y axis starts at 0.\n   *\n   * @since   4.1.9\n   * @product highcharts highstock\n   */\n  softThreshold: false,\n  // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/\n\n  /**\n   * @ignore-option\n   */\n  startFromThreshold: true,\n  stickyTracking: false,\n  tooltip: {\n    distance: 6\n  },\n\n  /**\n   * The Y axis value to serve as the base for the columns, for distinguishing\n   * between values above and below a threshold. If `null`, the columns\n   * extend from the padding Y axis minimum.\n   *\n   * @since   2.0\n   * @product highcharts\n   */\n  threshold: 0\n},\n/** @lends seriesTypes.column.prototype */\n{\n  cropShoulder: 0,\n  // When tooltip is not shared, this series (and derivatives) requires direct\n  // touch/hover. KD-tree does not apply.\n  directTouch: true,\n  trackerGroups: ['group', 'dataLabelsGroup'],\n  // use separate negative stacks, unlike area stacks where a negative point\n  // is substracted from previous (#1910)\n  negStacks: true,\n\n  /**\n   * Initialize the series. Extends the basic Series.init method by\n   * marking other series of the same type as dirty.\n   *\n   * @function #init\n   * @memberof seriesTypes.column\n   *\n   */\n  init: function init() {\n    Series.prototype.init.apply(this, arguments);\n    var series = this,\n        chart = series.chart; // if the series is added dynamically, force redraw of other\n    // series affected by a new column\n\n    if (chart.hasRendered) {\n      each(chart.series, function (otherSeries) {\n        if (otherSeries.type === series.type) {\n          otherSeries.isDirty = true;\n        }\n      });\n    }\n  },\n\n  /**\n   * Return the width and x offset of the columns adjusted for grouping,\n   * groupPadding, pointPadding, pointWidth etc.\n   */\n  getColumnMetrics: function getColumnMetrics() {\n    var series = this,\n        options = series.options,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis,\n        reversedStacks = xAxis.options.reversedStacks,\n        // Keep backward compatibility: reversed xAxis had reversed stacks\n    reverseStacks = xAxis.reversed && !reversedStacks || !xAxis.reversed && reversedStacks,\n        stackKey,\n        stackGroups = {},\n        columnCount = 0; // Get the total number of column type series. This is called on every\n    // series. Consider moving this logic to a chart.orderStacks() function\n    // and call it on init, addSeries and removeSeries\n\n    if (options.grouping === false) {\n      columnCount = 1;\n    } else {\n      each(series.chart.series, function (otherSeries) {\n        var otherOptions = otherSeries.options,\n            otherYAxis = otherSeries.yAxis,\n            columnIndex;\n\n        if (otherSeries.type === series.type && (otherSeries.visible || !series.chart.options.chart.ignoreHiddenSeries) && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {\n          // #642, #2086\n          if (otherOptions.stacking) {\n            stackKey = otherSeries.stackKey;\n\n            if (stackGroups[stackKey] === undefined) {\n              stackGroups[stackKey] = columnCount++;\n            }\n\n            columnIndex = stackGroups[stackKey];\n          } else if (otherOptions.grouping !== false) {\n            // #1162\n            columnIndex = columnCount++;\n          }\n\n          otherSeries.columnIndex = columnIndex;\n        }\n      });\n    }\n\n    var categoryWidth = Math.min(Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n    xAxis.len // #1535\n    ),\n        groupPadding = categoryWidth * options.groupPadding,\n        groupWidth = categoryWidth - 2 * groupPadding,\n        pointOffsetWidth = groupWidth / (columnCount || 1),\n        pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))),\n        pointPadding = (pointOffsetWidth - pointWidth) / 2,\n        // #1251, #3737\n    colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0),\n        pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1); // Save it for reading in linked series (Error bars particularly)\n\n    series.columnMetrics = {\n      width: pointWidth,\n      offset: pointXOffset\n    };\n    return series.columnMetrics;\n  },\n\n  /**\n   * Make the columns crisp. The edges are rounded to the nearest full pixel.\n   */\n  crispCol: function crispCol(x, y, w, h) {\n    var chart = this.chart,\n        borderWidth = this.borderWidth,\n        xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n        yCrisp = borderWidth % 2 ? 0.5 : 1,\n        right,\n        bottom,\n        fromTop;\n\n    if (chart.inverted && chart.renderer.isVML) {\n      yCrisp += 1;\n    } // Horizontal. We need to first compute the exact right edge, then round\n    // it and compute the width from there.\n\n\n    if (this.options.crisp) {\n      right = Math.round(x + w) + xCrisp;\n      x = Math.round(x) + xCrisp;\n      w = right - x;\n    } // Vertical\n\n\n    bottom = Math.round(y + h) + yCrisp;\n    fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n\n    y = Math.round(y) + yCrisp;\n    h = bottom - y; // Top edges are exceptions\n\n    if (fromTop && h) {\n      // #5146\n      y -= 1;\n      h += 1;\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: w,\n      height: h\n    };\n  },\n\n  /**\n   * Translate each point to the plot area coordinate system and find shape\n   * positions\n   */\n  translate: function translate() {\n    var series = this,\n        chart = series.chart,\n        options = series.options,\n        dense = series.dense = series.closestPointRange * series.xAxis.transA < 2,\n        borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1 // #3635\n    ),\n        yAxis = series.yAxis,\n        threshold = options.threshold,\n        translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n        minPointLength = pick(options.minPointLength, 5),\n        metrics = series.getColumnMetrics(),\n        pointWidth = metrics.width,\n        // postprocessed for border width\n    seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth),\n        pointXOffset = series.pointXOffset = metrics.offset;\n\n    if (chart.inverted) {\n      translatedThreshold -= 0.5; // #3355\n    } // When the pointPadding is 0, we want the columns to be packed tightly,\n    // so we allow individual columns to have individual sizes. When\n    // pointPadding is greater, we strive for equal-width columns (#2694).\n\n\n    if (options.pointPadding) {\n      seriesBarW = Math.ceil(seriesBarW);\n    }\n\n    Series.prototype.translate.apply(series); // Record the new values\n\n    each(series.points, function (point) {\n      var yBottom = pick(point.yBottom, translatedThreshold),\n          safeDistance = 999 + Math.abs(yBottom),\n          plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance),\n          // Don't draw too far outside plot area (#1303, #2241, #4264)\n      barX = point.plotX + pointXOffset,\n          barW = seriesBarW,\n          barY = Math.min(plotY, yBottom),\n          up,\n          barH = Math.max(plotY, yBottom) - barY; // Handle options.minPointLength\n\n      if (minPointLength && Math.abs(barH) < minPointLength) {\n        barH = minPointLength;\n        up = !yAxis.reversed && !point.negative || yAxis.reversed && point.negative; // Reverse zeros if there's no positive value in the series\n        // in visible range (#7046)\n\n        if (point.y === threshold && series.dataMax <= threshold && yAxis.min < threshold // and if there's room for it (#7311)\n        ) {\n            up = !up;\n          } // If stacked...\n\n\n        barY = Math.abs(barY - translatedThreshold) > minPointLength ? // ...keep position\n        yBottom - minPointLength : // #1485, #4051\n        translatedThreshold - (up ? minPointLength : 0);\n      } // Cache for access in polar\n\n\n      point.barX = barX;\n      point.pointWidth = pointWidth; // Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n\n      point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH]; // Register shape type and arguments to be used in drawPoints\n\n      point.shapeType = 'rect';\n      point.shapeArgs = series.crispCol.apply(series, point.isNull ? // #3169, drilldown from null must have a position to work\n      // from #6585, dataLabel should be placed on xAxis, not\n      // floating in the middle of the chart\n      [barX, translatedThreshold, barW, 0] : [barX, barY, barW, barH]);\n    });\n  },\n  getSymbol: noop,\n\n  /**\n   * Use a solid rectangle like the area series types\n   */\n  drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n  /**\n   * Columns have no graph\n   */\n  drawGraph: function drawGraph() {\n    this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');\n  },\n\n  /**\n   * Draw the columns. For bars, the series.group is rotated, so the same\n   * coordinates apply for columns and bars. This method is inherited by\n   * scatter series.\n   */\n  drawPoints: function drawPoints() {\n    var series = this,\n        chart = this.chart,\n        options = series.options,\n        renderer = chart.renderer,\n        animationLimit = options.animationLimit || 250,\n        shapeArgs; // draw the columns\n\n    each(series.points, function (point) {\n      var plotY = point.plotY,\n          graphic = point.graphic,\n          verb = graphic && chart.pointCount < animationLimit ? 'animate' : 'attr';\n\n      if (isNumber(plotY) && point.y !== null) {\n        shapeArgs = point.shapeArgs;\n\n        if (graphic) {\n          // update\n          graphic[verb](merge(shapeArgs));\n        } else {\n          point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);\n        } // Border radius is not stylable (#6900)\n\n\n        if (options.borderRadius) {\n          graphic.attr({\n            r: options.borderRadius\n          });\n        }\n\n        graphic.addClass(point.getClassName(), true);\n      } else if (graphic) {\n        point.graphic = graphic.destroy(); // #1269\n      }\n    });\n  },\n\n  /**\n   * Animate the column heights one by one from zero\n   * @param {Boolean} init Whether to initialize the animation or run it\n   */\n  animate: function animate(init) {\n    var series = this,\n        yAxis = this.yAxis,\n        options = series.options,\n        inverted = this.chart.inverted,\n        attr = {},\n        translateProp = inverted ? 'translateX' : 'translateY',\n        translateStart,\n        translatedThreshold;\n\n    if (svg) {\n      // VML is too slow anyway\n      if (init) {\n        attr.scaleY = 0.001;\n        translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));\n\n        if (inverted) {\n          attr.translateX = translatedThreshold - yAxis.len;\n        } else {\n          attr.translateY = translatedThreshold;\n        }\n\n        series.group.attr(attr);\n      } else {\n        // run the animation\n        translateStart = series.group.attr(translateProp);\n        series.group.animate({\n          scaleY: 1\n        }, extend(animObject(series.options.animation), {\n          // Do the scale synchronously to ensure smooth updating\n          // (#5030, #7228)\n          step: function step(val, fx) {\n            attr[translateProp] = translateStart + fx.pos * (yAxis.pos - translateStart);\n            series.group.attr(attr);\n          }\n        })); // delete this function to allow it only once\n\n        series.animate = null;\n      }\n    }\n  },\n\n  /**\n   * Remove this series from the chart\n   */\n  remove: function remove() {\n    var series = this,\n        chart = series.chart; // column and bar series affects other series of the same type\n    // as they are either stacked or grouped\n\n    if (chart.hasRendered) {\n      each(chart.series, function (otherSeries) {\n        if (otherSeries.type === series.type) {\n          otherSeries.isDirty = true;\n        }\n      });\n    }\n\n    Series.prototype.remove.apply(series, arguments);\n  }\n});\n/**\n * A `column` series. If the [type](#series.column.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.column\n * @excluding connectNulls,dashStyle,dataParser,dataURL,gapSize,gapUnit,linecap,\n *            lineWidth,marker,connectEnds,step\n * @product   highcharts highstock\n * @apioption series.column\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.column.states.hover\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.column.states.select\n */\n\n/**\n * An array of data points for the series. For the `column` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 6],\n *         [1, 2],\n *         [2, 6]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.column.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 6,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.line.data\n * @excluding marker\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.column.data\n */\n\n/**\n * The color of the border surrounding the column or bar.\n *\n * In styled mode, the border stroke can be set with the `.highcharts-point`\n * rule.\n *\n * @type      {Color}\n * @sample    {highcharts} highcharts/plotoptions/column-bordercolor/\n *            Dark gray border\n * @default   undefined\n * @product   highcharts highstock\n * @apioption series.column.data.borderColor\n */\n\n/**\n * The width of the border surrounding the column or bar.\n *\n * In styled mode, the stroke width can be set with the `.highcharts-point`\n * rule.\n *\n * @type      {Number}\n * @sample    {highcharts} highcharts/plotoptions/column-borderwidth/\n *            2px black border\n * @default   undefined\n * @product   highcharts highstock\n * @apioption series.column.data.borderWidth\n */"
    },
    {
     "id": 271,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid.js?babel-target=es5 + 17 modules"
    },
    {
     "id": 273,
     "name": "../node_modules/@vaadin/vaadin-dialog/src/vaadin-dialog.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 275,
     "name": "../node_modules/@vaadin/vaadin-list-box/theme/lumo/vaadin-list-box.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 280,
     "name": "../node_modules/highcharts/js/es-modules/parts/ScatterSeries.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Options.js';\nimport './Series.js';\nvar Series = H.Series,\n    seriesType = H.seriesType;\n/**\n * A scatter plot uses cartesian coordinates to display values for two variables\n * for a set of data.\n *\n * @sample       {highcharts} highcharts/demo/scatter/\n *               Scatter plot\n * @extends      {plotOptions.line}\n * @excluding    pointPlacement, shadow\n * @product      highcharts highstock\n * @optionparent plotOptions.scatter\n */\n\nseriesType('scatter', 'line', {\n  /**\n   * The width of the line connecting the data points.\n   *\n   * @sample  {highcharts} highcharts/plotoptions/scatter-linewidth-none/\n   *          0 by default\n   * @sample  {highcharts} highcharts/plotoptions/scatter-linewidth-1/\n   *          1px\n   * @product highcharts highstock\n   */\n  lineWidth: 0,\n  findNearestPointBy: 'xy',\n  marker: {\n    enabled: true // Overrides auto-enabling in line series (#3647)\n\n  },\n\n  /**\n   * Sticky tracking of mouse events. When true, the `mouseOut` event\n   * on a series isn't triggered until the mouse moves over another series,\n   * or out of the plot area. When false, the `mouseOut` event on a series\n   * is triggered when the mouse leaves the area around the series' graph\n   * or markers. This also implies the tooltip. When `stickyTracking`\n   * is false and `tooltip.shared` is false, the tooltip will be hidden\n   * when moving the mouse between series.\n   *\n   * @type      {Boolean}\n   * @default   false\n   * @product   highcharts highstock\n   * @apioption plotOptions.scatter.stickyTracking\n   */\n\n  /**\n   * A configuration object for the tooltip rendering of each single\n   * series. Properties are inherited from [tooltip](#tooltip).\n   * Overridable properties are `headerFormat`, `pointFormat`, `yDecimals`,\n   * `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other series, in\n   * a scatter plot the series.name by default shows in the headerFormat\n   * and point.x and point.y in the pointFormat.\n   *\n   * @product highcharts highstock\n   */\n  tooltip: {\n    headerFormat: \"<span class=\\\"highcharts-color-{point.colorIndex}\\\">\\u25CF</span> \" + '<span class=\"highcharts-header\"> {series.name}</span><br/>',\n    pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n  } // Prototype members\n\n}, {\n  sorted: false,\n  requireSorting: false,\n  noSharedTooltip: true,\n  trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n  takeOrdinalPosition: false,\n  // #2342\n  drawGraph: function drawGraph() {\n    if (this.options.lineWidth) {\n      Series.prototype.drawGraph.call(this);\n    }\n  }\n});\n/**\n * A `scatter` series. If the [type](#series.scatter.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.scatter\n * @excluding dataParser,dataURL\n * @product   highcharts highstock\n * @apioption series.scatter\n */\n\n/**\n * An array of data points for the series. For the `scatter` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 0],\n *         [1, 8],\n *         [2, 9]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.scatter.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 2,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 4,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.line.data\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.scatter.data\n */"
    },
    {
     "id": 281,
     "name": "../node_modules/@vaadin/vaadin-checkbox/src/vaadin-checkbox.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: inline-block;\\n      }\\n\\n      :host([hidden]) {\\n        display: none !important;\\n      }\\n\\n      label {\\n        display: inline-flex;\\n        align-items: baseline;\\n        outline: none;\\n      }\\n\\n      [part=\\\"checkbox\\\"] {\\n        position: relative;\\n        display: inline-block;\\n        flex: none;\\n      }\\n\\n      input[type=\\\"checkbox\\\"] {\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        width: 100%;\\n        height: 100%;\\n        opacity: 0;\\n        cursor: inherit;\\n        margin: 0;\\n      }\\n\\n      :host([disabled]) {\\n        -webkit-tap-highlight-color: transparent;\\n      }\\n    </style>\\n\\n    <label>\\n      <span part=\\\"checkbox\\\">\\n        <input type=\\\"checkbox\\\" checked=\\\"{{checked::change}}\\\" disabled$=\\\"[[disabled]]\\\" indeterminate=\\\"{{indeterminate::change}}\\\" role=\\\"presentation\\\" tabindex=\\\"-1\\\">\\n      </span>\\n\\n      <span part=\\\"label\\\">\\n        <slot></slot>\\n      </span>\\n    </label>\\n\"], [\"\\n    <style>\\n      :host {\\n        display: inline-block;\\n      }\\n\\n      :host([hidden]) {\\n        display: none !important;\\n      }\\n\\n      label {\\n        display: inline-flex;\\n        align-items: baseline;\\n        outline: none;\\n      }\\n\\n      [part=\\\"checkbox\\\"] {\\n        position: relative;\\n        display: inline-block;\\n        flex: none;\\n      }\\n\\n      input[type=\\\"checkbox\\\"] {\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        width: 100%;\\n        height: 100%;\\n        opacity: 0;\\n        cursor: inherit;\\n        margin: 0;\\n      }\\n\\n      :host([disabled]) {\\n        -webkit-tap-highlight-color: transparent;\\n      }\\n    </style>\\n\\n    <label>\\n      <span part=\\\"checkbox\\\">\\n        <input type=\\\"checkbox\\\" checked=\\\"{{checked::change}}\\\" disabled\\\\$=\\\"[[disabled]]\\\" indeterminate=\\\"{{indeterminate::change}}\\\" role=\\\"presentation\\\" tabindex=\\\"-1\\\">\\n      </span>\\n\\n      <span part=\\\"label\\\">\\n        <slot></slot>\\n      </span>\\n    </label>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-checkbox>` is a Web Component for customized checkboxes.\n *\n * ```html\n * <vaadin-checkbox>\n *   Make my profile visible\n * </vaadin-checkbox>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name         | Description\n * ------------------|----------------\n * `checkbox`        | The wrapper element for the native <input type=\"checkbox\">\n * `label`           | The wrapper element in which the component's children, namely the label, is slotted\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|--------------\n * `active`     | Set when the checkbox is pressed down, either with mouse, touch or the keyboard. | `:host`\n * `disabled`   | Set when the checkbox is disabled. | `:host`\n * `focus-ring` | Set when the checkbox is focused using the keyboard. | `:host`\n * `focused`    | Set when the checkbox is focused. | `:host`\n * `indeterminate` | Set when the checkbox is in indeterminate mode. | `:host`\n * `checked` | Set when the checkbox is checked. | `:host`\n * `empty` | Set when there is no label provided. | `label`\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ControlStateMixin\n * @mixes ThemableMixin\n * @mixes GestureEventListeners\n * @demo demo/index.html\n */\n\nvar CheckboxElement = /*#__PURE__*/function (_ElementMixin) {\n  _inherits(CheckboxElement, _ElementMixin);\n\n  var _super = _createSuper(CheckboxElement);\n\n  _createClass(CheckboxElement, null, [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-checkbox';\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return '2.5.0';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * True if the checkbox is checked.\n         * @type {boolean}\n         */\n        checked: {\n          type: Boolean,\n          value: false,\n          notify: true,\n          observer: '_checkedChanged',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Indeterminate state of the checkbox when it's neither checked nor unchecked, but undetermined.\n         * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Indeterminate_state_checkboxes\n         * @type {boolean}\n         */\n        indeterminate: {\n          type: Boolean,\n          notify: true,\n          observer: '_indeterminateChanged',\n          reflectToAttribute: true,\n          value: false\n        },\n\n        /**\n         * The value given to the data submitted with the checkbox's name to the server when the control is inside a form.\n         */\n        value: {\n          type: String,\n          value: 'on'\n        },\n\n        /** @private */\n        _nativeCheckbox: {\n          type: Object\n        }\n      };\n    }\n  }]);\n\n  function CheckboxElement() {\n    var _this;\n\n    _classCallCheck(this, CheckboxElement);\n\n    _this = _super.call(this);\n    /**\n     * @type {string}\n     * Name of the element.\n     */\n\n    _this.name;\n    return _this;\n  }\n\n  _createClass(CheckboxElement, [{\n    key: \"ready\",\n    value: function ready() {\n      _get(_getPrototypeOf(CheckboxElement.prototype), \"ready\", this).call(this);\n\n      this.setAttribute('role', 'checkbox');\n      this._nativeCheckbox = this.shadowRoot.querySelector('input[type=\"checkbox\"]');\n      this.addEventListener('click', this._handleClick.bind(this));\n\n      this._addActiveListeners();\n\n      var attrName = this.getAttribute('name');\n\n      if (attrName) {\n        this.name = attrName;\n      }\n\n      this.shadowRoot.querySelector('[part~=\"label\"]').querySelector('slot').addEventListener('slotchange', this._updateLabelAttribute.bind(this));\n\n      this._updateLabelAttribute();\n    }\n    /** @private */\n\n  }, {\n    key: \"_updateLabelAttribute\",\n    value: function _updateLabelAttribute() {\n      var label = this.shadowRoot.querySelector('[part~=\"label\"]');\n      var assignedNodes = label.firstElementChild.assignedNodes();\n\n      if (this._isAssignedNodesEmpty(assignedNodes)) {\n        label.setAttribute('empty', '');\n      } else {\n        label.removeAttribute('empty');\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_isAssignedNodesEmpty\",\n    value: function _isAssignedNodesEmpty(nodes) {\n      // The assigned nodes considered to be empty if there is no slotted content or only one empty text node\n      return nodes.length === 0 || nodes.length == 1 && nodes[0].nodeType == Node.TEXT_NODE && nodes[0].textContent.trim() === '';\n    }\n    /** @private */\n\n  }, {\n    key: \"_checkedChanged\",\n    value: function _checkedChanged(checked) {\n      if (this.indeterminate) {\n        this.setAttribute('aria-checked', 'mixed');\n      } else {\n        this.setAttribute('aria-checked', Boolean(checked));\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_indeterminateChanged\",\n    value: function _indeterminateChanged(indeterminate) {\n      if (indeterminate) {\n        this.setAttribute('aria-checked', 'mixed');\n      } else {\n        this.setAttribute('aria-checked', this.checked);\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_addActiveListeners\",\n    value: function _addActiveListeners() {\n      var _this2 = this;\n\n      // DOWN\n      this._addEventListenerToNode(this, 'down', function (e) {\n        if (_this2.__interactionsAllowed(e)) {\n          _this2.setAttribute('active', '');\n        }\n      }); // UP\n\n\n      this._addEventListenerToNode(this, 'up', function () {\n        return _this2.removeAttribute('active');\n      }); // KEYDOWN\n\n\n      this.addEventListener('keydown', function (e) {\n        if (_this2.__interactionsAllowed(e) && e.keyCode === 32) {\n          e.preventDefault();\n\n          _this2.setAttribute('active', '');\n        }\n      }); // KEYUP\n\n      this.addEventListener('keyup', function (e) {\n        if (_this2.__interactionsAllowed(e) && e.keyCode === 32) {\n          e.preventDefault();\n\n          _this2._toggleChecked();\n\n          _this2.removeAttribute('active');\n\n          if (_this2.indeterminate) {\n            _this2.indeterminate = false;\n          }\n        }\n      });\n    }\n    /**\n     * @return {!HTMLInputElement}\n     * @protected\n     */\n\n  }, {\n    key: \"__interactionsAllowed\",\n\n    /**\n     * True if users' interactions (mouse or keyboard)\n     * should toggle the checkbox\n     */\n    value: function __interactionsAllowed(e) {\n      if (this.disabled) {\n        return false;\n      } // https://github.com/vaadin/vaadin-checkbox/issues/63\n\n\n      if (e.target.localName === 'a') {\n        return false;\n      }\n\n      return true;\n    }\n    /** @private */\n\n  }, {\n    key: \"_handleClick\",\n    value: function _handleClick(e) {\n      if (this.__interactionsAllowed(e)) {\n        if (!this.indeterminate) {\n          if (e.composedPath()[0] !== this._nativeCheckbox) {\n            e.preventDefault();\n\n            this._toggleChecked();\n          }\n        } else {\n          /*\n           * Required for IE 11 and Edge.\n           * See issue here: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7344418/\n           */\n          this.indeterminate = false;\n          e.preventDefault();\n\n          this._toggleChecked();\n        }\n      }\n    }\n    /** @protected */\n\n  }, {\n    key: \"_toggleChecked\",\n    value: function _toggleChecked() {\n      this.checked = !this.checked;\n      this.dispatchEvent(new CustomEvent('change', {\n        composed: false,\n        bubbles: true\n      }));\n    }\n    /**\n     * Fired when the user commits a value change.\n     *\n     * @event change\n     */\n\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.checked ? this._storedName : '';\n    },\n    set: function set(name) {\n      this._storedName = name;\n    }\n  }, {\n    key: \"focusElement\",\n    get: function get() {\n      return this.shadowRoot.querySelector('input');\n    }\n  }]);\n\n  return CheckboxElement;\n}(ElementMixin(ControlStateMixin(ThemableMixin(GestureEventListeners(PolymerElement)))));\n\ncustomElements.define(CheckboxElement.is, CheckboxElement);\nexport { CheckboxElement };"
    },
    {
     "id": 282,
     "name": "../node_modules/@vaadin/vaadin-confirm-dialog/src/vaadin-confirm-dialog.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: none;\\n        --_vaadin-confirm-dialog-content-width: auto;\\n        --_vaadin-confirm-dialog-content-height: auto;\\n        --_vaadin-confirm-dialog-footer-height: auto;\\n      }\\n    </style>\\n    <vaadin-dialog id=\\\"dialog\\\" opened=\\\"{{opened}}\\\" aria-label=\\\"[[_getAriaLabel(header)]]\\\" theme$=\\\"_vaadin-confirm-dialog-dialog-overlay-theme [[theme]]\\\" no-close-on-outside-click=\\\"\\\" no-close-on-esc=\\\"[[noCloseOnEsc]]\\\">\\n      <template>\\n        <div id=\\\"content\\\">\\n          <div part=\\\"header\\\">\\n            <slot name=\\\"header\\\">\\n              <h3 class=\\\"header\\\">[[header]]</h3>\\n            </slot>\\n          </div>\\n\\n          <div part=\\\"message\\\" id=\\\"message\\\">\\n            <slot></slot>\\n            [[message]]\\n          </div>\\n        </div>\\n\\n        <div part=\\\"footer\\\">\\n          <div class=\\\"cancel-button\\\">\\n            <slot name=\\\"cancel-button\\\">\\n              <vaadin-button id=\\\"cancel\\\" theme$=\\\"[[cancelTheme]]\\\" on-click=\\\"_cancel\\\" hidden$=\\\"[[!cancel]]\\\" aria-describedby=\\\"message\\\">\\n                [[cancelText]]\\n              </vaadin-button>\\n            </slot>\\n          </div>\\n          <div class=\\\"reject-button\\\">\\n            <slot name=\\\"reject-button\\\">\\n              <vaadin-button id=\\\"reject\\\" theme$=\\\"[[rejectTheme]]\\\" on-click=\\\"_reject\\\" hidden$=\\\"[[!reject]]\\\" aria-describedby=\\\"message\\\">\\n                [[rejectText]]\\n              </vaadin-button>\\n            </slot>\\n          </div>\\n          <div class=\\\"confirm-button\\\">\\n            <slot name=\\\"confirm-button\\\">\\n              <vaadin-button id=\\\"confirm\\\" theme$=\\\"[[confirmTheme]]\\\" on-click=\\\"_confirm\\\" aria-describedby=\\\"message\\\">\\n                [[confirmText]]\\n              </vaadin-button>\\n            </slot>\\n          </div>\\n        </div>\\n      </template>\\n    </vaadin-dialog>\\n\"], [\"\\n    <style>\\n      :host {\\n        display: none;\\n        --_vaadin-confirm-dialog-content-width: auto;\\n        --_vaadin-confirm-dialog-content-height: auto;\\n        --_vaadin-confirm-dialog-footer-height: auto;\\n      }\\n    </style>\\n    <vaadin-dialog id=\\\"dialog\\\" opened=\\\"{{opened}}\\\" aria-label=\\\"[[_getAriaLabel(header)]]\\\" theme\\\\$=\\\"_vaadin-confirm-dialog-dialog-overlay-theme [[theme]]\\\" no-close-on-outside-click=\\\"\\\" no-close-on-esc=\\\"[[noCloseOnEsc]]\\\">\\n      <template>\\n        <div id=\\\"content\\\">\\n          <div part=\\\"header\\\">\\n            <slot name=\\\"header\\\">\\n              <h3 class=\\\"header\\\">[[header]]</h3>\\n            </slot>\\n          </div>\\n\\n          <div part=\\\"message\\\" id=\\\"message\\\">\\n            <slot></slot>\\n            [[message]]\\n          </div>\\n        </div>\\n\\n        <div part=\\\"footer\\\">\\n          <div class=\\\"cancel-button\\\">\\n            <slot name=\\\"cancel-button\\\">\\n              <vaadin-button id=\\\"cancel\\\" theme\\\\$=\\\"[[cancelTheme]]\\\" on-click=\\\"_cancel\\\" hidden\\\\$=\\\"[[!cancel]]\\\" aria-describedby=\\\"message\\\">\\n                [[cancelText]]\\n              </vaadin-button>\\n            </slot>\\n          </div>\\n          <div class=\\\"reject-button\\\">\\n            <slot name=\\\"reject-button\\\">\\n              <vaadin-button id=\\\"reject\\\" theme\\\\$=\\\"[[rejectTheme]]\\\" on-click=\\\"_reject\\\" hidden\\\\$=\\\"[[!reject]]\\\" aria-describedby=\\\"message\\\">\\n                [[rejectText]]\\n              </vaadin-button>\\n            </slot>\\n          </div>\\n          <div class=\\\"confirm-button\\\">\\n            <slot name=\\\"confirm-button\\\">\\n              <vaadin-button id=\\\"confirm\\\" theme\\\\$=\\\"[[confirmTheme]]\\\" on-click=\\\"_confirm\\\" aria-describedby=\\\"message\\\">\\n                [[confirmText]]\\n              </vaadin-button>\\n            </slot>\\n          </div>\\n        </div>\\n      </template>\\n    </vaadin-dialog>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2018 Vaadin Ltd.\nThis program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).\n\nSee <a href=\"https://vaadin.com/license/cval-3\">the website</a> for the complete license.\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport '@vaadin/vaadin-license-checker/vaadin-license-checker.js';\nimport '@vaadin/vaadin-button/src/vaadin-button.js';\nimport '@vaadin/vaadin-dialog/src/vaadin-dialog.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { beforeNextRender } from '@polymer/polymer/lib/utils/render-status.js';\n/**\n * `<vaadin-confirm-dialog>` is a Web Component for showing alerts and asking for user confirmation.\n *\n * ```\n * <vaadin-confirm-dialog on-confirm=\"_doConfirm\">\n *  Sample confirmation question\n * </vaadin-confirm-dialog>\n * ```\n *\n * ### Styling\n *\n * The following Shadow DOM parts are available for styling the dialog parts:\n *\n * Part name  | Description\n * -----------|---------------------------------------------------------|\n * `header`   | Header of the confirmation dialog\n * `message`  | Container for the message of the dialog\n * `footer`   | Container for the buttons\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * ### Custom content\n *\n * The following parts are available for replacement:\n *\n * Slot name         | Description\n * ------------------|---------------------------------------------------------|\n * `header`          | Header of the confirmation dialog\n * `message`         | Container for the message of the dialog\n * `cancel-button`   | Container for the Cancel button\n * `reject-button`   | Container for the Reject button\n * `confirm-button`  | Container for the Confirm button\n *\n * See examples of setting custom buttons into slots in the live demos.\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nvar ConfirmDialogElement = /*#__PURE__*/function (_ElementMixin) {\n  _inherits(ConfirmDialogElement, _ElementMixin);\n\n  var _super = _createSuper(ConfirmDialogElement);\n\n  function ConfirmDialogElement() {\n    _classCallCheck(this, ConfirmDialogElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ConfirmDialogElement, [{\n    key: \"ready\",\n\n    /** @protected */\n    value: function ready() {\n      var _this = this;\n\n      _get(_getPrototypeOf(ConfirmDialogElement.prototype), \"ready\", this).call(this);\n\n      this.$.dialog.$.overlay.addEventListener('vaadin-overlay-escape-press', this._escPressed.bind(this));\n\n      if (this._dimensions) {\n        Object.keys(this._dimensions).forEach(function (name) {\n          _this._setDimension(name, _this._dimensions[name]);\n        });\n      }\n    }\n    /**\n     * @param {string} name\n     * @param {?string} oldValue\n     * @param {?string} newValue\n     * @protected\n     */\n\n  }, {\n    key: \"attributeChangedCallback\",\n    value: function attributeChangedCallback(name, oldValue, newValue) {\n      _get(_getPrototypeOf(ConfirmDialogElement.prototype), \"attributeChangedCallback\", this).call(this, name, oldValue, newValue);\n\n      if (name === 'dir') {\n        var value = newValue === 'rtl';\n        this.__isRTL = value;\n        this.opened && this.__toggleContentRTL(value);\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"__toggleContentRTL\",\n    value: function __toggleContentRTL(rtl) {\n      var contentBlock = this.$.dialog.$.overlay.content.querySelector('#content');\n      var footerBlock = this.$.dialog.$.overlay.content.querySelector('[part=footer]');\n\n      if (rtl) {\n        contentBlock.setAttribute('dir', 'rtl');\n        footerBlock.setAttribute('dir', 'rtl');\n      } else {\n        contentBlock.removeAttribute('dir');\n        footerBlock.removeAttribute('dir');\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_openedChanged\",\n    value: function _openedChanged() {\n      var _this2 = this;\n\n      if (!this.opened) {\n        return;\n      }\n\n      Array.from(this.childNodes).forEach(function (c) {\n        var newChild = _this2.$.dialog.$.overlay.$.content.appendChild(c);\n\n        if (newChild.getAttribute && newChild.getAttribute('slot') == 'confirm-button' && newChild.focus) {\n          _this2._confirmButton = newChild;\n        }\n      });\n      this.opened && this.__toggleContentRTL(this.__isRTL);\n      beforeNextRender(this, function () {\n        var confirmButton = _this2._confirmButton || _this2.$.dialog.$.overlay.content.querySelector('#confirm');\n\n        confirmButton.focus();\n\n        var _getComputedStyle = getComputedStyle(_this2.$.dialog.$.overlay.content.querySelector('[part=footer]')),\n            height = _getComputedStyle.height;\n\n        if (height != _this2._footerHeight) {\n          window.ShadyCSS.styleSubtree(_this2.$.dialog.$.overlay, {\n            '--_vaadin-confirm-dialog-footer-height': height\n          });\n          _this2._footerHeight = height;\n        }\n      });\n    }\n    /** @private */\n\n  }, {\n    key: \"_escPressed\",\n    value: function _escPressed(event) {\n      if (!event.defaultPrevented) {\n        this._cancel();\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_confirm\",\n    value: function _confirm() {\n      this.dispatchEvent(new CustomEvent('confirm'));\n      this.opened = false;\n    }\n    /** @private */\n\n  }, {\n    key: \"_cancel\",\n    value: function _cancel() {\n      this.dispatchEvent(new CustomEvent('cancel'));\n      this.opened = false;\n    }\n    /** @private */\n\n  }, {\n    key: \"_reject\",\n    value: function _reject() {\n      this.dispatchEvent(new CustomEvent('reject'));\n      this.opened = false;\n    }\n    /** @private */\n\n  }, {\n    key: \"_getAriaLabel\",\n    value: function _getAriaLabel(header) {\n      return header || 'confirmation';\n    }\n    /** @private */\n\n  }, {\n    key: \"_setWidth\",\n    value: function _setWidth(width) {\n      this._setDimensionIfAttached('width', width);\n    }\n    /** @private */\n\n  }, {\n    key: \"_setHeight\",\n    value: function _setHeight(height) {\n      this._setDimensionIfAttached('height', height);\n    }\n    /** @private */\n\n  }, {\n    key: \"_setDimensionIfAttached\",\n    value: function _setDimensionIfAttached(name, value) {\n      if (this.$ && this.$.dialog) {\n        this._setDimension(name, value);\n      } else {\n        this._dimensions = this._dimensions || {};\n        this._dimensions[name] = value;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_setDimension\",\n    value: function _setDimension(name, value) {\n      var _this3 = this;\n\n      this._propsToUpdate = this._propsToUpdate || {};\n      this._propsToUpdate[\"--_vaadin-confirm-dialog-content-\".concat(name)] = value; // To prevent multiple calls to update CSS props\n\n      beforeNextRender(this, function () {\n        if (_this3._propsToUpdate) {\n          window.ShadyCSS.styleSubtree(_this3.$.dialog.$.overlay, _this3._propsToUpdate);\n          _this3._propsToUpdate = null;\n        }\n      });\n    }\n    /**\n     * @event confirm\n     * fired when Confirm button was pressed.\n     */\n\n    /**\n     * @event cancel\n     * fired when Cancel button or Escape key was pressed.\n     */\n\n    /**\n     * @event reject\n     * fired when Reject button was pressed.\n     */\n\n  }], [{\n    key: \"_finalizeClass\",\n\n    /** @protected */\n    value: function _finalizeClass() {\n      _get(_getPrototypeOf(ConfirmDialogElement), \"_finalizeClass\", this).call(this);\n\n      var devModeCallback = window.Vaadin.developmentModeCallback;\n      var licenseChecker = devModeCallback && devModeCallback['vaadin-license-checker'];\n\n      if (typeof licenseChecker === 'function') {\n        licenseChecker(ConfirmDialogElement);\n      }\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-confirm-dialog';\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return '1.3.0';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * True if the overlay is currently displayed.\n         * @type {boolean}\n         */\n        opened: {\n          type: Boolean,\n          value: false,\n          notify: true,\n          observer: '_openedChanged'\n        },\n\n        /**\n         * Set the confirmation dialog title.\n         * @type {string}\n         */\n        header: {\n          type: String,\n          value: ''\n        },\n\n        /**\n         * Set the message or confirmation question.\n         */\n        message: {\n          type: String\n        },\n\n        /**\n         * Text displayed on confirm-button.\n         * @attr {string} confirm-text\n         * @type {string}\n         */\n        confirmText: {\n          type: String,\n          value: 'Confirm'\n        },\n\n        /**\n         * Theme for a confirm-button.\n         * @attr {string} confirm-theme\n         * @type {string}\n         */\n        confirmTheme: {\n          type: String,\n          value: 'primary'\n        },\n\n        /**\n         * Set to true to disable closing dialog on Escape press\n         * @attr {boolean} no-close-on-esc\n         * @type {boolean}\n         */\n        noCloseOnEsc: {\n          type: Boolean,\n          value: false\n        },\n\n        /**\n         * Whether to show cancel button or not.\n         * @type {boolean}\n         */\n        reject: {\n          type: Boolean,\n          reflectToAttribute: true,\n          value: false,\n          notify: true\n        },\n\n        /**\n         * Text displayed on reject-button.\n         * @attr {string} reject-text\n         * @type {string}\n         */\n        rejectText: {\n          type: String,\n          value: 'Reject'\n        },\n\n        /**\n         * Theme for a reject-button.\n         * @attr {string} reject-theme\n         * @type {string}\n         */\n        rejectTheme: {\n          type: String,\n          value: 'error tertiary'\n        },\n\n        /**\n         * Whether to show cancel button or not.\n         * @type {boolean}\n         */\n        cancel: {\n          type: Boolean,\n          reflectToAttribute: true,\n          value: false,\n          notify: true\n        },\n\n        /**\n         * Text displayed on cancel-button.\n         * @attr {string} cancel-text\n         * @type {string}\n         */\n        cancelText: {\n          type: String,\n          value: 'Cancel'\n        },\n\n        /**\n         * Theme for a cancel-button.\n         * @attr {string} cancel-theme\n         * @type {string}\n         */\n        cancelTheme: {\n          type: String,\n          value: 'tertiary'\n        },\n\n        /** @private */\n        _confirmButton: {\n          type: Element\n        }\n      };\n    }\n  }]);\n\n  return ConfirmDialogElement;\n}(ElementMixin(ThemableMixin(PolymerElement)));\n\ncustomElements.define(ConfirmDialogElement.is, ConfirmDialogElement);\nexport { ConfirmDialogElement };"
    },
    {
     "id": 283,
     "name": "../node_modules/@vaadin/vaadin-login/src/vaadin-login-mixin.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nVaadin Login\nCopyright (C) 2018 Vaadin Ltd\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/**\n * @polymerMixin\n */\nexport var LoginMixin = function LoginMixin(superClass) {\n  return /*#__PURE__*/function (_superClass) {\n    _inherits(LoginMixin, _superClass);\n\n    var _super = _createSuper(LoginMixin);\n\n    function LoginMixin() {\n      _classCallCheck(this, LoginMixin);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(LoginMixin, [{\n      key: \"_retargetEvent\",\n\n      /**\n       * @param {!Event} e\n       * @protected\n       */\n      value: function _retargetEvent(e) {\n        e.stopPropagation();\n        var detail = e.detail,\n            composed = e.composed,\n            cancelable = e.cancelable,\n            bubbles = e.bubbles;\n        var firedEvent = this.dispatchEvent(new CustomEvent(e.type, {\n          bubbles: bubbles,\n          cancelable: cancelable,\n          composed: composed,\n          detail: detail\n        })); // Check if `eventTarget.preventDefault()` was called to prevent default in the original event\n\n        if (!firedEvent) {\n          e.preventDefault();\n        }\n      }\n    }], [{\n      key: \"properties\",\n\n      /**\n       * Fired when user clicks on the \"Forgot password\" button.\n       *\n       * @event forgot-password\n       */\n\n      /**\n       * Fired when an user submits the login.\n       * The event contains `username` and `password` values in the `detail` property.\n       *\n       * @event login\n       *\n       */\n      get: function get() {\n        return {\n          /**\n           * If set, a synchronous POST call will be fired to the path defined.\n           * The `login` event is also dispatched, so `event.preventDefault()` can be called to prevent the POST call.\n           * @type {string | null}\n          */\n          action: {\n            type: String,\n            value: null,\n            notify: true\n          },\n\n          /**\n           * If set, disable the \"Log in\" button and prevent user from submitting login form.\n           * It is re-enabled automatically, when error is set to true, allowing form resubmission\n           * after user makes changes.\n           * @type {boolean}\n           */\n          disabled: {\n            type: Boolean,\n            value: false,\n            notify: true\n          },\n\n          /**\n           * If set, the error message is shown. The message is hidden by default.\n           * When set, it changes the disabled state of the submit button.\n           * @type {boolean}\n           */\n          error: {\n            type: Boolean,\n            value: false,\n            reflectToAttribute: true,\n            notify: true\n          },\n\n          /**\n           * Whether to hide the forgot password button. The button is visible by default.\n           * @type {boolean}\n           */\n          noForgotPassword: {\n            type: Boolean,\n            value: false,\n            notify: true\n          },\n\n          /**\n           * The object used to localize this component.\n           * For changing the default localization, change the entire\n           * _i18n_ object or just the property you want to modify.\n           *\n           * The object has the following JSON structure (by default it doesn't include `additionalInformation`\n           * and `header` sections, `header` can be added to override `title` and `description` properties\n           * in `vaadin-login-overlay`):\n             {\n              header: {\n                title: 'App name',\n                description: 'Inspiring application description'\n              },\n              form: {\n                title: 'Log in',\n                username: 'Username',\n                password: 'Password',\n                submit: 'Log in',\n                forgotPassword: 'Forgot password'\n              },\n              errorMessage: {\n                title: 'Incorrect username or password',\n                message: 'Check that you have entered the correct username and password and try again.'\n              },\n              additionalInformation: 'In case you need to provide some additional info for the user.'\n            }\n           * @type {!LoginI18n}\n           * @default {English/US}\n           */\n          i18n: {\n            type: Object,\n            value: function value() {\n              return {\n                form: {\n                  title: 'Log in',\n                  username: 'Username',\n                  password: 'Password',\n                  submit: 'Log in',\n                  forgotPassword: 'Forgot password'\n                },\n                errorMessage: {\n                  title: 'Incorrect username or password',\n                  message: 'Check that you have entered the correct username and password and try again.'\n                }\n              };\n            },\n            notify: true\n          },\n\n          /**\n           * If set, prevents auto enabling the component when error property is set to true.\n           * @private\n           */\n          _preventAutoEnable: {\n            type: Boolean,\n            value: false\n          }\n        };\n      }\n    }]);\n\n    return LoginMixin;\n  }(superClass);\n};"
    },
    {
     "id": 287,
     "name": "../node_modules/@vaadin/vaadin-confirm-dialog/theme/lumo/vaadin-confirm-dialog.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 288,
     "name": "../node_modules/@vaadin/vaadin-dialog/theme/lumo/vaadin-dialog.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 289,
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-password-field.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 291,
     "name": "../node_modules/@vaadin/vaadin-list-box/src/vaadin-list-box.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 321,
     "name": "../node_modules/@vaadin/flow-frontend/comboBoxConnector.js?babel-target=es5",
     "source": "import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\n// Not using ES6 imports in this file yet because the connector in V14 must\n// still work in Legacy bower projects. See: `comboBoxConnector-es6.js` for\n// the Polymer3 approach.\n(function () {\n  var tryCatchWrapper = function tryCatchWrapper(callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Combo Box', 'vaadin-combo-box-flow');\n  };\n\n  window.Vaadin.Flow.Legacy = window.Vaadin.Flow.Legacy || {};\n  window.Vaadin.Flow.comboBoxConnector = {\n    initLazy: function initLazy(comboBox) {\n      return tryCatchWrapper(function (comboBox) {\n        // Check whether the connector was already initialized for the ComboBox\n        if (comboBox.$connector) {\n          return;\n        }\n\n        if (window.Polymer) {\n          // Polymer2 approach.\n          window.Vaadin.Flow.Legacy.Debouncer = window.Vaadin.Flow.Legacy.Debouncer || Polymer.Debouncer;\n          window.Vaadin.Flow.Legacy.timeOut = window.Vaadin.Flow.Legacy.timeOut || Polymer.Async.timeOut;\n        } else if (!window.Vaadin.Flow.Legacy.Debouncer) {\n          console.log(\"ComboBox is unable to load Polymer helpers.\");\n          return;\n        }\n\n        var Debouncer = window.Vaadin.Flow.Legacy.Debouncer;\n        var timeOut = window.Vaadin.Flow.Legacy.timeOut;\n        comboBox.$connector = {}; // holds pageIndex -> callback pairs of subsequent indexes (current active range)\n\n        var pageCallbacks = {};\n        var cache = {};\n        var lastFilter = '';\n        var placeHolder = new Vaadin.ComboBoxPlaceholder();\n        var MAX_RANGE_COUNT = Math.max(comboBox.pageSize * 2, 500); // Max item count in active range\n\n        var serverFacade = function () {\n          // Private variables\n          var lastFilterSentToServer = '';\n          var dataCommunicatorResetNeeded = false; // Public methods\n\n          var needsDataCommunicatorReset = function needsDataCommunicatorReset() {\n            return dataCommunicatorResetNeeded = true;\n          };\n\n          var getLastFilterSentToServer = function getLastFilterSentToServer() {\n            return lastFilterSentToServer;\n          };\n\n          var requestData = function requestData(startIndex, endIndex, params) {\n            var count = endIndex - startIndex;\n            var filter = params.filter;\n            comboBox.$server.setRequestedRange(startIndex, count, filter);\n            lastFilterSentToServer = filter;\n\n            if (dataCommunicatorResetNeeded) {\n              comboBox.$server.resetDataCommunicator();\n              dataCommunicatorResetNeeded = false;\n            }\n          };\n\n          return {\n            needsDataCommunicatorReset: needsDataCommunicatorReset,\n            getLastFilterSentToServer: getLastFilterSentToServer,\n            requestData: requestData\n          };\n        }();\n\n        var clearPageCallbacks = function clearPageCallbacks() {\n          var pages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(pageCallbacks);\n          // Flush and empty the existing requests\n          pages.forEach(function (page) {\n            pageCallbacks[page]([], comboBox.size);\n            delete pageCallbacks[page]; // Empty the comboBox's internal cache without invoking observers by filling\n            // the filteredItems array with placeholders (comboBox will request for data when it\n            // encounters a placeholder)\n\n            var pageStart = parseInt(page) * comboBox.pageSize;\n            var pageEnd = pageStart + comboBox.pageSize;\n            var end = Math.min(pageEnd, comboBox.filteredItems.length);\n\n            for (var i = pageStart; i < end; i++) {\n              comboBox.filteredItems[i] = placeHolder;\n            }\n          });\n        };\n\n        comboBox.dataProvider = function (params, callback) {\n          if (params.pageSize != comboBox.pageSize) {\n            throw 'Invalid pageSize';\n          }\n\n          if (comboBox._clientSideFilter) {\n            // For clientside filter we first make sure we have all data which we also\n            // filter based on comboBox.filter. While later we only filter clientside data.\n            if (cache[0]) {\n              performClientSideFilter(cache[0], callback);\n              return;\n            } else {\n              // If client side filter is enabled then we need to first ask all data\n              // and filter it on client side, otherwise next time when user will\n              // input another filter, eg. continue to type, the local cache will be only\n              // what was received for the first filter, which may not be the whole\n              // data from server (keep in mind that client side filter is enabled only\n              // when the items count does not exceed one page).\n              params.filter = \"\";\n            }\n          }\n\n          var filterChanged = params.filter !== lastFilter;\n\n          if (filterChanged) {\n            cache = {};\n            lastFilter = params.filter;\n            this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(500), function () {\n              if (serverFacade.getLastFilterSentToServer() === params.filter) {\n                // Fixes the case when the filter changes\n                // to something else and back to the original value\n                // within debounce timeout, and the\n                // DataCommunicator thinks it doesn't need to send data\n                serverFacade.needsDataCommunicatorReset();\n              }\n\n              if (params.filter !== lastFilter) {\n                throw new Error(\"Expected params.filter to be '\" + lastFilter + \"' but was '\" + params.filter + \"'\");\n              } // Call the method again after debounce.\n\n\n              clearPageCallbacks();\n              comboBox.dataProvider(params, callback);\n            });\n            return;\n          }\n\n          if (cache[params.page]) {\n            // This may happen after skipping pages by scrolling fast\n            commitPage(params.page, callback);\n          } else {\n            pageCallbacks[params.page] = callback;\n            var activePages = Object.keys(pageCallbacks).map(function (page) {\n              return parseInt(page);\n            });\n            var rangeMin = Math.min.apply(Math, _toConsumableArray(activePages));\n            var rangeMax = Math.max.apply(Math, _toConsumableArray(activePages));\n\n            if (activePages.length * params.pageSize > MAX_RANGE_COUNT) {\n              if (params.page === rangeMin) {\n                clearPageCallbacks([String(rangeMax)]);\n              } else {\n                clearPageCallbacks([String(rangeMin)]);\n              }\n\n              comboBox.dataProvider(params, callback);\n            } else if (rangeMax - rangeMin + 1 !== activePages.length) {\n              // Wasn't a sequential page index, clear the cache so combo-box will request for new pages\n              clearPageCallbacks();\n            } else {\n              // The requested page was sequential, extend the requested range\n              var startIndex = params.pageSize * rangeMin;\n              var endIndex = params.pageSize * (rangeMax + 1);\n\n              if (!this._debouncer || !this._debouncer.isActive()) {\n                serverFacade.requestData(startIndex, endIndex, params);\n              } else {\n                this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(200), function () {\n                  return serverFacade.requestData(startIndex, endIndex, params);\n                });\n              }\n            }\n          }\n        };\n\n        comboBox.$connector.filter = tryCatchWrapper(function (item, filter) {\n          filter = filter ? filter.toString().toLowerCase() : '';\n          return comboBox._getItemLabel(item).toString().toLowerCase().indexOf(filter) > -1;\n        });\n        comboBox.$connector.set = tryCatchWrapper(function (index, items, filter) {\n          if (filter != serverFacade.getLastFilterSentToServer()) {\n            return;\n          }\n\n          if (index % comboBox.pageSize != 0) {\n            throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + comboBox.pageSize;\n          }\n\n          if (index === 0 && items.length === 0 && pageCallbacks[0]) {\n            // Makes sure that the dataProvider callback is called even when server\n            // returns empty data set (no items match the filter).\n            cache[0] = [];\n            return;\n          }\n\n          var firstPageToSet = index / comboBox.pageSize;\n          var updatedPageCount = Math.ceil(items.length / comboBox.pageSize);\n\n          for (var i = 0; i < updatedPageCount; i++) {\n            var page = firstPageToSet + i;\n            var slice = items.slice(i * comboBox.pageSize, (i + 1) * comboBox.pageSize);\n            cache[page] = slice;\n          }\n        });\n        comboBox.$connector.updateData = tryCatchWrapper(function (items) {\n          // IE11 doesn't work with the transpiled version of the forEach.\n          for (var i = 0; i < items.length; i++) {\n            var item = items[i];\n\n            for (var j = 0; j < comboBox.filteredItems.length; j++) {\n              if (comboBox.filteredItems[j].key === item.key) {\n                comboBox.set('filteredItems.' + j, item);\n                break;\n              }\n            }\n          }\n        });\n        comboBox.$connector.updateSize = tryCatchWrapper(function (newSize) {\n          if (!comboBox._clientSideFilter) {\n            // FIXME: It may be that this size set is unnecessary, since when\n            // providing data to combobox via callback we may use data's size.\n            // However, if this size reflect the whole data size, including\n            // data not fetched yet into client side, and combobox expect it\n            // to be set as such, the at least, we don't need it in case the\n            // filter is clientSide only, since it'll increase the height of\n            // the popup at only at first user filter to this size, while the\n            // filtered items count are less.\n            comboBox.size = newSize;\n          }\n        });\n        comboBox.$connector.reset = tryCatchWrapper(function () {\n          clearPageCallbacks();\n          cache = {};\n          comboBox.clearCache();\n        });\n        comboBox.$connector.confirm = tryCatchWrapper(function (id, filter) {\n          if (filter != serverFacade.getLastFilterSentToServer()) {\n            return;\n          } // We're done applying changes from this batch, resolve pending\n          // callbacks\n\n\n          var activePages = Object.getOwnPropertyNames(pageCallbacks);\n\n          for (var i = 0; i < activePages.length; i++) {\n            var page = activePages[i];\n\n            if (cache[page]) {\n              commitPage(page, pageCallbacks[page]);\n            }\n          } // Let server know we're done\n\n\n          comboBox.$server.confirmUpdate(id);\n        });\n        customElements.whenDefined('vaadin-combo-box').then(tryCatchWrapper(function () {\n          var _isItemSelected = comboBox.$.overlay._isItemSelected; // Override comboBox's _isItemSelected logic to handle remapped items\n\n          comboBox.$.overlay._isItemSelected = function (item, selectedItem, itemIdPath) {\n            var selected = _isItemSelected.call(comboBox, item, selectedItem, itemIdPath);\n\n            if (comboBox._selectedKey) {\n              if (comboBox.filteredItems.indexOf(selectedItem) > -1) {\n                delete comboBox._selectedKey;\n              } else {\n                selected = selected || item.key === comboBox._selectedKey;\n              }\n            }\n\n            return selected;\n          };\n        }));\n        comboBox.$connector.enableClientValidation = tryCatchWrapper(function (enable) {\n          var input = null;\n\n          if (comboBox.$) {\n            input = comboBox.$[\"input\"];\n          }\n\n          if (input) {\n            if (enable) {\n              enableClientValidation(comboBox);\n              enableTextFieldClientValidation(input);\n            } else {\n              disableClientValidation(comboBox);\n              disableTextFieldClientValidation(input, comboBox);\n            }\n\n            comboBox.validate();\n          } else {\n            setTimeout(function () {\n              comboBox.$connector.enableClientValidation(enable);\n            }, 10);\n          }\n        });\n        var disableClientValidation = tryCatchWrapper(function (combo) {\n          if (typeof combo.$checkValidity == 'undefined') {\n            combo.$checkValidity = combo.checkValidity;\n\n            combo.checkValidity = function () {\n              return !comboBox.invalid;\n            };\n          }\n\n          if (typeof combo.$validate == 'undefined') {\n            combo.$validate = combo.validate;\n\n            combo.validate = function () {\n              return !(comboBox.focusElement.invalid = comboBox.invalid);\n            };\n          }\n        });\n        var disableTextFieldClientValidation = tryCatchWrapper(function (field, comboBox) {\n          if (typeof field.$checkValidity == 'undefined') {\n            field.$checkValidity = field.checkValidity;\n\n            field.checkValidity = function () {\n              return !comboBox.invalid;\n            };\n          }\n        });\n        var enableTextFieldClientValidation = tryCatchWrapper(function (field) {\n          if (field.$checkValidity) {\n            field.checkValidity = field.$checkValidity;\n            delete field.$checkValidity;\n          }\n        });\n        var enableClientValidation = tryCatchWrapper(function (combo) {\n          if (combo.$checkValidity) {\n            combo.checkValidity = combo.$checkValidity;\n            delete combo.$checkValidity;\n          }\n\n          if (combo.$validate) {\n            combo.validate = combo.$validate;\n            delete combo.$validate;\n          }\n        });\n        var commitPage = tryCatchWrapper(function (page, callback) {\n          var data = cache[page];\n\n          if (comboBox._clientSideFilter) {\n            performClientSideFilter(data, callback);\n          } else {\n            // Remove the data if server-side filtering, but keep it for client-side\n            // filtering\n            delete cache[page]; // FIXME: It may be that we ought to provide data.length instead of\n            // comboBox.size and remove updateSize function.\n\n            callback(data, comboBox.size);\n          }\n        }); // Perform filter on client side (here) using the items from specified page\n        // and submitting the filtered items to specified callback.\n        // The filter used is the one from combobox, not the lastFilter stored since\n        // that may not reflect user's input.\n\n        var performClientSideFilter = tryCatchWrapper(function (page, callback) {\n          var filteredItems = page;\n\n          if (comboBox.filter) {\n            filteredItems = page.filter(function (item) {\n              return comboBox.$connector.filter(item, comboBox.filter);\n            });\n          }\n\n          callback(filteredItems, filteredItems.length);\n        }); // https://github.com/vaadin/vaadin-combo-box-flow/issues/232\n\n        comboBox.addEventListener('opened-changed', tryCatchWrapper(function (e) {\n          e.detail.value && (comboBox.$.overlay._selector._manageFocus = function () {});\n        })); // Prevent setting the custom value as the 'value'-prop automatically\n\n        comboBox.addEventListener('custom-value-set', tryCatchWrapper(function (e) {\n          return e.preventDefault();\n        }));\n      })(comboBox);\n    }\n  };\n})();"
    },
    {
     "id": 322,
     "name": "../node_modules/@vaadin/flow-frontend/contextMenuConnector.js?babel-target=es5",
     "source": "// Not using ES6 imports in this file yet because the connector in V14 must\n// still work in Legacy bower projects. See: `contextMenuConnector-es6.js` for\n// the Polymer3 approach.\n(function () {\n  var tryCatchWrapper = function tryCatchWrapper(callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Context Menu', 'vaadin-context-menu-flow');\n  };\n\n  window.Vaadin.Flow.Legacy = window.Vaadin.Flow.Legacy || {};\n  window.Vaadin.Flow.contextMenuConnector = {\n    // NOTE: This is for the TARGET component, not for the <vaadin-context-menu> itself\n    init: function init(target) {\n      return tryCatchWrapper(function (target) {\n        if (target.$contextMenuConnector) {\n          return;\n        }\n\n        if (window.Polymer) {\n          // Polymer2 approach.\n          window.Vaadin.Flow.Legacy.GestureEventListeners = window.Vaadin.Flow.Legacy.GestureEventListeners || Polymer.GestureEventListeners;\n          window.Vaadin.Flow.Legacy.Gestures = window.Vaadin.Flow.Legacy.Gestures || Polymer.Gestures;\n        } else if (!window.Vaadin.Flow.Legacy.Gestures) {\n          console.log(\"ContextMenu is unable to load Polymer helpers.\");\n          return;\n        }\n\n        var GestureEventListeners = window.Vaadin.Flow.Legacy.GestureEventListeners;\n        var Gestures = window.Vaadin.Flow.Legacy.Gestures;\n        target.$contextMenuConnector = {\n          openOnHandler: tryCatchWrapper(function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.$contextMenuConnector.openEvent = e;\n            var detail = {};\n\n            if (target.getContextMenuBeforeOpenDetail) {\n              detail = target.getContextMenuBeforeOpenDetail(e);\n            }\n\n            target.dispatchEvent(new CustomEvent('vaadin-context-menu-before-open', {\n              detail: detail\n            }));\n          }),\n          updateOpenOn: tryCatchWrapper(function (eventType) {\n            var _this = this;\n\n            this.removeListener();\n            this.openOnEventType = eventType;\n            customElements.whenDefined('vaadin-context-menu').then(tryCatchWrapper(function () {\n              if (Gestures.gestures[eventType]) {\n                Gestures.addListener(target, eventType, _this.openOnHandler);\n              } else {\n                target.addEventListener(eventType, _this.openOnHandler);\n              }\n            }));\n          }),\n          removeListener: tryCatchWrapper(function () {\n            if (this.openOnEventType) {\n              if (Gestures.gestures[this.openOnEventType]) {\n                Gestures.removeListener(target, this.openOnEventType, this.openOnHandler);\n              } else {\n                target.removeEventListener(this.openOnEventType, this.openOnHandler);\n              }\n            }\n          }),\n          openMenu: tryCatchWrapper(function (contextMenu) {\n            contextMenu.open(this.openEvent);\n          }),\n          removeConnector: tryCatchWrapper(function () {\n            this.removeListener();\n            target.$contextMenuConnector = undefined;\n          })\n        };\n      })(target);\n    },\n    generateItems: function generateItems(menu, appId, nodeId) {\n      return tryCatchWrapper(function (menu, appId, nodeId) {\n        menu._containerNodeId = nodeId;\n\n        var getContainer = function getContainer(nodeId) {\n          try {\n            return window.Vaadin.Flow.clients[appId].getByNodeId(nodeId);\n          } catch (error) {\n            console.error(\"Could not get node %s from app %s\", nodeId, appId);\n            console.error(error);\n          }\n        };\n\n        var getChildItems = function getChildItems(parent) {\n          var container = getContainer(parent._containerNodeId);\n          var items = container && Array.from(container.children).map(function (child) {\n            var item = {\n              component: child,\n              checked: child._checked\n            };\n\n            if (child.tagName == \"VAADIN-CONTEXT-MENU-ITEM\" && child._containerNodeId) {\n              item.children = getChildItems(child);\n            }\n\n            child._item = item;\n            return item;\n          });\n          return items;\n        };\n\n        var items = getChildItems(menu);\n        menu.items = items;\n      })(menu, appId, nodeId);\n    },\n    setChecked: function setChecked(component, checked) {\n      return tryCatchWrapper(function (component, checked) {\n        if (component._item) {\n          component._item.checked = checked;\n        }\n      })(component, checked);\n    }\n  };\n})();"
    },
    {
     "id": 323,
     "name": "../node_modules/@vaadin/flow-frontend/dndConnector.js?babel-target=es5",
     "source": "window.Vaadin = window.Vaadin || {};\nwindow.Vaadin.Flow = window.Vaadin.Flow || {};\nwindow.Vaadin.Flow.dndConnector = {\n  __ondragenterListener: function __ondragenterListener(event) {\n    // TODO filter by data type\n    // TODO prevent dropping on itself (by default)\n    var effect = event.currentTarget['__dropEffect'];\n\n    if (!event.currentTarget.hasAttribute('disabled')) {\n      if (effect) {\n        event.dataTransfer.dropEffect = effect;\n      }\n\n      if (effect && effect !== 'none') {\n        /* #7108: if drag moves on top of drop target's children, first another ondragenter event\n         * is fired and then a ondragleave event. This happens again once the drag\n         * moves on top of another children, or back on top of the drop target element.\n         * Thus need to \"cancel\" the following ondragleave, to not remove class name.\n         * Drop event will happen even when dropped to a child element. */\n        if (event.currentTarget.classList.contains(\"v-drag-over-target\")) {\n          event.currentTarget['__skip-leave'] = true;\n        } else {\n          event.currentTarget.classList.add(\"v-drag-over-target\");\n        } // enables browser specific pseudo classes (at least FF)\n\n\n        event.preventDefault();\n        event.stopPropagation(); // don't let parents know\n      }\n    }\n  },\n  __ondragoverListener: function __ondragoverListener(event) {\n    // TODO filter by data type\n    // TODO filter by effectAllowed != dropEffect due to Safari & IE11 ?\n    if (!event.currentTarget.hasAttribute('disabled')) {\n      var effect = event.currentTarget['__dropEffect'];\n\n      if (effect) {\n        event.dataTransfer.dropEffect = effect;\n      } // allows the drop && don't let parents know\n\n\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  },\n  __ondragleaveListener: function __ondragleaveListener(event) {\n    if (event.currentTarget['__skip-leave']) {\n      event.currentTarget['__skip-leave'] = false;\n    } else {\n      event.currentTarget.classList.remove(\"v-drag-over-target\");\n    } // #7109 need to stop or any parent drop target might not get highlighted,\n    // as ondragenter for it is fired before the child gets dragleave.\n\n\n    event.stopPropagation();\n  },\n  __ondropListener: function __ondropListener(event) {\n    var effect = event.currentTarget['__dropEffect'];\n\n    if (effect) {\n      event.dataTransfer.dropEffect = effect;\n    }\n\n    event.currentTarget.classList.remove(\"v-drag-over-target\"); // prevent browser handling && don't let parents know\n\n    event.preventDefault();\n    event.stopPropagation();\n  },\n  updateDropTarget: function updateDropTarget(element) {\n    if (element['__active']) {\n      element.addEventListener('dragenter', this.__ondragenterListener, false);\n      element.addEventListener('dragover', this.__ondragoverListener, false);\n      element.addEventListener('dragleave', this.__ondragleaveListener, false);\n      element.addEventListener('drop', this.__ondropListener, false);\n    } else {\n      element.removeEventListener('dragenter', this.__ondragenterListener, false);\n      element.removeEventListener('dragover', this.__ondragoverListener, false);\n      element.removeEventListener('dragleave', this.__ondragleaveListener, false);\n      element.removeEventListener('drop', this.__ondropListener, false);\n      element.classList.remove(\"v-drag-over-target\");\n    }\n  },\n\n  /** DRAG SOURCE METHODS: */\n  __dragstartListener: function __dragstartListener(event) {\n    event.stopPropagation();\n    event.dataTransfer.setData(\"text/plain\", \"\");\n\n    if (event.currentTarget.hasAttribute('disabled')) {\n      event.preventDefault();\n    } else {\n      if (event.currentTarget['__effectAllowed']) {\n        event.dataTransfer.effectAllowed = event.currentTarget['__effectAllowed'];\n      }\n\n      event.currentTarget.classList.add('v-dragged');\n    }\n  },\n  __dragendListener: function __dragendListener(event) {\n    event.currentTarget.classList.remove('v-dragged');\n  },\n  updateDragSource: function updateDragSource(element) {\n    if (element['draggable']) {\n      element.addEventListener('dragstart', this.__dragstartListener, false);\n      element.addEventListener('dragend', this.__dragendListener, false);\n    } else {\n      element.removeEventListener('dragstart', this.__dragstartListener, false);\n      element.removeEventListener('dragend', this.__dragendListener, false);\n    }\n  }\n};"
    },
    {
     "id": 324,
     "name": "../node_modules/@babel/runtime/helpers/defineProperty.js?babel-target=es5",
     "source": "function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;"
    },
    {
     "id": 325,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-active-item-mixin.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/**\n * @polymerMixin\n */\nexport var ActiveItemMixin = function ActiveItemMixin(superClass) {\n  return /*#__PURE__*/function (_superClass) {\n    _inherits(ActiveItemMixin, _superClass);\n\n    var _super = _createSuper(ActiveItemMixin);\n\n    function ActiveItemMixin() {\n      _classCallCheck(this, ActiveItemMixin);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(ActiveItemMixin, [{\n      key: \"ready\",\n      value: function ready() {\n        _get(_getPrototypeOf(ActiveItemMixin.prototype), \"ready\", this).call(this);\n\n        this.$.scroller.addEventListener('click', this._onClick.bind(this));\n        this.addEventListener('cell-activate', this._activateItem.bind(this));\n      }\n      /** @private */\n\n    }, {\n      key: \"_activateItem\",\n      value: function _activateItem(e) {\n        var model = e.detail.model;\n        var clickedItem = model ? model.item : null;\n\n        if (clickedItem) {\n          this.activeItem = !this._itemsEqual(this.activeItem, clickedItem) ? clickedItem : null;\n        }\n      }\n      /**\n       * We need to listen to click instead of tap because on mobile safari, the\n       * document.activeElement has not been updated (focus has not been shifted)\n       * yet at the point when tap event is being executed.\n       * @param {!MouseEvent} e\n       * @protected\n       */\n\n    }, {\n      key: \"_onClick\",\n      value: function _onClick(e) {\n        if (e.defaultPrevented) {\n          // Something has handled this click already, e. g., <vaadin-grid-sorter>\n          return;\n        }\n\n        var path = e.composedPath();\n        var cell = path[path.indexOf(this.$.table) - 3];\n\n        if (!cell || cell.getAttribute('part').indexOf('details-cell') > -1) {\n          return;\n        }\n\n        var cellContent = cell._content;\n        var activeElement = this.getRootNode().activeElement;\n\n        var cellContentHasFocus = cellContent.contains(activeElement) && ( // MSIE bug: flex children receive focus. Make type & attributes check.\n        !this._ie || this._isFocusable(activeElement));\n\n        if (!cellContentHasFocus && !this._isFocusable(e.target)) {\n          this.dispatchEvent(new CustomEvent('cell-activate', {\n            detail: {\n              model: this.__getRowModel(cell.parentElement)\n            }\n          }));\n        }\n      }\n      /**\n       * @param {!Element} target\n       * @return {boolean}\n       * @protected\n       */\n\n    }, {\n      key: \"_isFocusable\",\n      value: function _isFocusable(target) {\n        return isFocusable(target);\n      }\n    }], [{\n      key: \"properties\",\n      get: function get() {\n        return {\n          /**\n           * The item user has last interacted with. Turns to `null` after user deactivates\n           * the item by re-interacting with the currently active item.\n           * @type {GridItem}\n           */\n          activeItem: {\n            type: Object,\n            notify: true,\n            value: null\n          }\n        };\n      }\n    }]);\n\n    return ActiveItemMixin;\n  }(superClass);\n};\n/**\n * @param {!Element} target\n * @return {boolean}\n * @protected\n */\n\nexport var isFocusable = function isFocusable(target) {\n  if (!target.parentNode) {\n    return false;\n  }\n\n  var focusables = Array.from(target.parentNode.querySelectorAll('[tabindex], button, input, select, textarea, object, iframe, label, a[href], area[href]')).filter(function (element) {\n    return element.getAttribute('part') !== 'cell body-cell';\n  });\n  var isFocusableElement = focusables.indexOf(target) !== -1;\n  return !target.disabled && isFocusableElement;\n};"
    },
    {
     "id": 326,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-data-provider-mixin.js?babel-target=es5",
     "source": "import _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nexport var ItemCache = /*#__PURE__*/function () {\n  /**\n   * @param {!HTMLElement} grid\n   * @param {!ItemCache | undefined} parentCache\n   * @param {!GridItem | undefined} parentItem\n   */\n  function ItemCache(grid, parentCache, parentItem) {\n    _classCallCheck(this, ItemCache);\n\n    /** @type {!HTMLElement} */\n    this.grid = grid;\n    /** @type {!ItemCache | undefined} */\n\n    this.parentCache = parentCache;\n    /** @type {!GridItem | undefined} */\n\n    this.parentItem = parentItem;\n    /** @type {object} */\n\n    this.itemCaches = {};\n    /** @type {object} */\n\n    this.items = {};\n    /** @type {number} */\n\n    this.effectiveSize = 0;\n    /** @type {number} */\n\n    this.size = 0;\n    /** @type {object} */\n\n    this.pendingRequests = {};\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  _createClass(ItemCache, [{\n    key: \"isLoading\",\n    value: function isLoading() {\n      var _this = this;\n\n      return Boolean(Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(function (index) {\n        return _this.itemCaches[index].isLoading();\n      })[0]);\n    }\n    /**\n     * @param {number} index\n     * @return {!GridItem | undefined}\n     */\n\n  }, {\n    key: \"getItemForIndex\",\n    value: function getItemForIndex(index) {\n      var _this$getCacheAndInde = this.getCacheAndIndex(index),\n          cache = _this$getCacheAndInde.cache,\n          scaledIndex = _this$getCacheAndInde.scaledIndex;\n\n      return cache.items[scaledIndex];\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize() {\n      var _this2 = this;\n\n      this.effectiveSize = !this.parentItem || this.grid._isExpanded(this.parentItem) ? this.size + Object.keys(this.itemCaches).reduce(function (prev, curr) {\n        var subCache = _this2.itemCaches[curr];\n        subCache.updateSize();\n        return prev + subCache.effectiveSize;\n      }, 0) : 0;\n    }\n    /**\n     * @param {number} scaledIndex\n     */\n\n  }, {\n    key: \"ensureSubCacheForScaledIndex\",\n    value: function ensureSubCacheForScaledIndex(scaledIndex) {\n      if (!this.itemCaches[scaledIndex]) {\n        var subCache = new ItemCache(this.grid, this, this.items[scaledIndex]);\n        this.itemCaches[scaledIndex] = subCache;\n\n        this.grid._loadPage(0, subCache);\n      }\n    }\n    /**\n     * @param {number} index\n     * @return {{cache: !ItemCache, scaledIndex: number}}\n     */\n\n  }, {\n    key: \"getCacheAndIndex\",\n    value: function getCacheAndIndex(index) {\n      var thisLevelIndex = index;\n      var keys = Object.keys(this.itemCaches);\n\n      for (var i = 0; i < keys.length; i++) {\n        var expandedIndex = Number(keys[i]);\n        var subCache = this.itemCaches[expandedIndex];\n\n        if (thisLevelIndex <= expandedIndex) {\n          return {\n            cache: this,\n            scaledIndex: thisLevelIndex\n          };\n        } else if (thisLevelIndex <= expandedIndex + subCache.effectiveSize) {\n          return subCache.getCacheAndIndex(thisLevelIndex - expandedIndex - 1);\n        }\n\n        thisLevelIndex -= subCache.effectiveSize;\n      }\n\n      return {\n        cache: this,\n        scaledIndex: thisLevelIndex\n      };\n    }\n  }]);\n\n  return ItemCache;\n}();\n/**\n * @polymerMixin\n */\n\nexport var DataProviderMixin = function DataProviderMixin(superClass) {\n  return /*#__PURE__*/function (_superClass) {\n    _inherits(DataProviderMixin, _superClass);\n\n    var _super = _createSuper(DataProviderMixin);\n\n    function DataProviderMixin() {\n      _classCallCheck(this, DataProviderMixin);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(DataProviderMixin, [{\n      key: \"_sizeChanged\",\n\n      /** @private */\n      value: function _sizeChanged(size) {\n        var delta = size - this._cache.size;\n        this._cache.size += delta;\n        this._cache.effectiveSize += delta;\n        this._effectiveSize = this._cache.effectiveSize;\n\n        this._increasePoolIfNeeded(0);\n\n        this._debounceIncreasePool && this._debounceIncreasePool.flush();\n      }\n      /**\n       * @param {number} index\n       * @param {HTMLElement} el\n       * @protected\n       */\n\n    }, {\n      key: \"_getItem\",\n      value: function _getItem(index, el) {\n        if (index >= this._effectiveSize) {\n          return;\n        }\n\n        el.index = index;\n\n        var _this$_cache$getCache = this._cache.getCacheAndIndex(index),\n            cache = _this$_cache$getCache.cache,\n            scaledIndex = _this$_cache$getCache.scaledIndex;\n\n        var item = cache.items[scaledIndex];\n\n        if (item) {\n          this._toggleAttribute('loading', false, el);\n\n          this._updateItem(el, item);\n\n          if (this._isExpanded(item)) {\n            cache.ensureSubCacheForScaledIndex(scaledIndex);\n          }\n        } else {\n          this._toggleAttribute('loading', true, el);\n\n          this._loadPage(this._getPageForIndex(scaledIndex), cache);\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"_expandedInstanceChangedCallback\",\n      value: function _expandedInstanceChangedCallback(inst, value) {\n        if (inst.item === undefined) {\n          return;\n        }\n\n        if (value) {\n          this.expandItem(inst.item);\n        } else {\n          this.collapseItem(inst.item);\n        }\n      }\n      /**\n       * Returns a value that identifies the item. Uses `itemIdPath` if available.\n       * Can be customized by overriding.\n       * @param {!GridItem} item\n       * @return {!GridItem | !unknown}\n       */\n\n    }, {\n      key: \"getItemId\",\n      value: function getItemId(item) {\n        return this.itemIdPath ? this.get(this.itemIdPath, item) : item;\n      }\n      /**\n       * @param {!GridItem} item\n       * @return {boolean}\n       * @protected\n       */\n\n    }, {\n      key: \"_isExpanded\",\n      value: function _isExpanded(item) {\n        return this.__expandedKeys.has(this.getItemId(item));\n      }\n      /** @private */\n\n    }, {\n      key: \"_expandedItemsChanged\",\n      value: function _expandedItemsChanged(e) {\n        this.__cacheExpandedKeys();\n\n        this._cache.updateSize();\n\n        this._effectiveSize = this._cache.effectiveSize;\n\n        this._assignModels();\n      }\n      /** @private */\n\n    }, {\n      key: \"_itemIdPathChanged\",\n      value: function _itemIdPathChanged(e) {\n        this.__cacheExpandedKeys();\n      }\n      /** @private */\n\n    }, {\n      key: \"__cacheExpandedKeys\",\n      value: function __cacheExpandedKeys() {\n        var _this3 = this;\n\n        if (this.expandedItems) {\n          this.__expandedKeys = new Set();\n          this.expandedItems.forEach(function (item) {\n            _this3.__expandedKeys.add(_this3.getItemId(item));\n          });\n        }\n      }\n      /**\n       * Expands the given item tree.\n       * @param {!GridItem} item\n       */\n\n    }, {\n      key: \"expandItem\",\n      value: function expandItem(item) {\n        if (!this._isExpanded(item)) {\n          this.push('expandedItems', item);\n        }\n      }\n      /**\n       * Collapses the given item tree.\n       * @param {!GridItem} item\n       */\n\n    }, {\n      key: \"collapseItem\",\n      value: function collapseItem(item) {\n        if (this._isExpanded(item)) {\n          this.splice('expandedItems', this._getItemIndexInArray(item, this.expandedItems), 1);\n        }\n      }\n      /**\n       * @param {number} index\n       * @return {number}\n       * @protected\n       */\n\n    }, {\n      key: \"_getIndexLevel\",\n      value: function _getIndexLevel(index) {\n        var _this$_cache$getCache2 = this._cache.getCacheAndIndex(index),\n            cache = _this$_cache$getCache2.cache;\n\n        var level = 0;\n\n        while (cache.parentCache) {\n          cache = cache.parentCache;\n          level++;\n        }\n\n        return level;\n      }\n      /**\n       * @return {boolean}\n       * @protected\n       */\n\n    }, {\n      key: \"_canPopulate\",\n      value: function _canPopulate() {\n        return Boolean(this._hasData && this._columnTree);\n      }\n      /**\n       * @param {number} page\n       * @param {ItemCache} cache\n       * @protected\n       */\n\n    }, {\n      key: \"_loadPage\",\n      value: function _loadPage(page, cache) {\n        var _this4 = this;\n\n        // make sure same page isn't requested multiple times.\n        if (!cache.pendingRequests[page] && this.dataProvider) {\n          this._setLoading(true);\n\n          cache.pendingRequests[page] = true;\n          var params = {\n            page: page,\n            pageSize: this.pageSize,\n            sortOrders: this._mapSorters(),\n            filters: this._mapFilters(),\n            parentItem: cache.parentItem\n          };\n          this.dataProvider(params, function (items, size) {\n            if (size !== undefined) {\n              cache.size = size;\n            } else {\n              if (params.parentItem) {\n                cache.size = items.length;\n              }\n            }\n\n            var currentItems = Array.from(_this4.$.items.children).map(function (row) {\n              return row._item;\n            }); // Populate the cache with new items\n\n            items.forEach(function (item, itemsIndex) {\n              var itemIndex = page * _this4.pageSize + itemsIndex;\n              cache.items[itemIndex] = item;\n\n              if (_this4._isExpanded(item) && currentItems.indexOf(item) > -1) {\n                // Force synchronous data request for expanded item sub-cache\n                cache.ensureSubCacheForScaledIndex(itemIndex);\n              }\n            });\n            _this4._hasData = true;\n            delete cache.pendingRequests[page];\n            _this4._debouncerApplyCachedData = Debouncer.debounce(_this4._debouncerApplyCachedData, timeOut.after(0), function () {\n              _this4._setLoading(false);\n\n              _this4._cache.updateSize();\n\n              _this4._effectiveSize = _this4._cache.effectiveSize;\n              Array.from(_this4.$.items.children).filter(function (row) {\n                return !row.hidden;\n              }).forEach(function (row) {\n                var cachedItem = _this4._cache.getItemForIndex(row.index);\n\n                if (cachedItem) {\n                  _this4._getItem(row.index, row);\n                }\n              });\n\n              _this4._increasePoolIfNeeded(0);\n\n              _this4.__scrollToPendingIndex();\n            });\n\n            if (!_this4._cache.isLoading()) {\n              _this4._debouncerApplyCachedData.flush();\n            }\n\n            _this4.__itemsReceived();\n          });\n        }\n      }\n      /**\n       * @param {number} index\n       * @return {number}\n       * @private\n       */\n\n    }, {\n      key: \"_getPageForIndex\",\n      value: function _getPageForIndex(index) {\n        return Math.floor(index / this.pageSize);\n      }\n      /**\n       * Clears the cached pages and reloads data from dataprovider when needed.\n       */\n\n    }, {\n      key: \"clearCache\",\n      value: function clearCache() {\n        this._cache = new ItemCache(this);\n        Array.from(this.$.items.children).forEach(function (row) {\n          Array.from(row.children).forEach(function (cell) {\n            // Force data system to pick up subproperty changes\n            cell._instance && cell._instance._setPendingProperty('item', {}, false);\n          });\n        });\n        this._cache.size = this.size || 0;\n\n        this._cache.updateSize();\n\n        this._hasData = false;\n\n        this._assignModels();\n\n        if (!this._effectiveSize) {\n          this._loadPage(0, this._cache);\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"_pageSizeChanged\",\n      value: function _pageSizeChanged(pageSize, oldPageSize) {\n        if (oldPageSize !== undefined && pageSize !== oldPageSize) {\n          this.clearCache();\n        }\n      }\n      /** @protected */\n\n    }, {\n      key: \"_checkSize\",\n      value: function _checkSize() {\n        if (this.size === undefined && this._effectiveSize === 0) {\n          console.warn('The <vaadin-grid> needs the total number of items' + ' in order to display rows. Set the total number of items' + ' to the `size` property, or provide the total number of items' + ' in the second argument of the `dataProvider`s `callback` call.');\n        }\n      }\n      /** @private */\n\n    }, {\n      key: \"_dataProviderChanged\",\n      value: function _dataProviderChanged(dataProvider, oldDataProvider) {\n        if (oldDataProvider !== undefined) {\n          this.clearCache();\n        }\n\n        if (dataProvider && this.items && this.items.length) {\n          // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>\n          this._scrollToIndex(this._firstVisibleIndex);\n        }\n\n        this._ensureFirstPageLoaded();\n\n        this._debouncerCheckSize = Debouncer.debounce(this._debouncerCheckSize, timeOut.after(2000), this._checkSize.bind(this));\n\n        this._scrollHandler();\n      }\n      /** @protected */\n\n    }, {\n      key: \"_ensureFirstPageLoaded\",\n      value: function _ensureFirstPageLoaded() {\n        if (!this._hasData) {\n          // load data before adding rows to make sure they have content when\n          // rendered for the first time.\n          this._loadPage(0, this._cache);\n        }\n      }\n      /**\n       * @param {!GridItem} item1\n       * @param {!GridItem} item2\n       * @return {boolean}\n       * @protected\n       */\n\n    }, {\n      key: \"_itemsEqual\",\n      value: function _itemsEqual(item1, item2) {\n        return this.getItemId(item1) === this.getItemId(item2);\n      }\n      /**\n       * @param {!GridItem} item\n       * @param {!Array<!GridItem>} array\n       * @return {number}\n       * @protected\n       */\n\n    }, {\n      key: \"_getItemIndexInArray\",\n      value: function _getItemIndexInArray(item, array) {\n        var _this5 = this;\n\n        var result = -1;\n        array.forEach(function (i, idx) {\n          if (_this5._itemsEqual(i, item)) {\n            result = idx;\n          }\n        });\n        return result;\n      }\n    }, {\n      key: \"scrollToIndex\",\n      value: function scrollToIndex(index) {\n        _get(_getPrototypeOf(DataProviderMixin.prototype), \"scrollToIndex\", this).call(this, index);\n\n        if (!isNaN(index) && (this._cache.isLoading() || !this.clientHeight)) {\n          this.__pendingScrollToIndex = index;\n        }\n      }\n    }, {\n      key: \"__scrollToPendingIndex\",\n      value: function __scrollToPendingIndex() {\n        if (this.__pendingScrollToIndex && this.$.items.children.length) {\n          var index = this.__pendingScrollToIndex;\n          delete this.__pendingScrollToIndex;\n          this.scrollToIndex(index);\n        }\n      }\n    }], [{\n      key: \"properties\",\n      get: function get() {\n        return {\n          /**\n           * Number of items fetched at a time from the dataprovider.\n           * @attr {number} page-size\n           * @type {number}\n           */\n          pageSize: {\n            type: Number,\n            value: 50,\n            observer: '_pageSizeChanged'\n          },\n\n          /**\n           * Function that provides items lazily. Receives arguments `params`, `callback`\n           *\n           * `params.page` Requested page index\n           *\n           * `params.pageSize` Current page size\n           *\n           * `params.filters` Currently applied filters\n           *\n           * `params.sortOrders` Currently applied sorting orders\n           *\n           * `params.parentItem` When tree is used, and sublevel items\n           * are requested, reference to parent item of the requested sublevel.\n           * Otherwise `undefined`.\n           *\n           * `callback(items, size)` Callback function with arguments:\n           *   - `items` Current page of items\n           *   - `size` Total number of items. When tree sublevel items\n           *     are requested, total number of items in the requested sublevel.\n           *     Optional when tree is not used, required for tree.\n           *\n           * @type {GridDataProvider | null | undefined}\n           */\n          dataProvider: {\n            type: Object,\n            notify: true,\n            observer: '_dataProviderChanged'\n          },\n\n          /**\n           * `true` while data is being requested from the data provider.\n           */\n          loading: {\n            type: Boolean,\n            notify: true,\n            readOnly: true,\n            reflectToAttribute: true\n          },\n\n          /**\n           * @type {!ItemCache}\n           * @protected\n           */\n          _cache: {\n            type: Object,\n            value: function value() {\n              var cache = new ItemCache(this);\n              return cache;\n            }\n          },\n\n          /**\n           * Path to an item sub-property that identifies the item.\n           * @attr {string} item-id-path\n           */\n          itemIdPath: {\n            type: String,\n            value: null\n          },\n\n          /**\n           * An array that contains the expanded items.\n           * @type {!Array<!GridItem>}\n           */\n          expandedItems: {\n            type: Object,\n            notify: true,\n            value: function value() {\n              return [];\n            }\n          }\n        };\n      }\n    }, {\n      key: \"observers\",\n      get: function get() {\n        return ['_sizeChanged(size)', '_itemIdPathChanged(itemIdPath)', '_expandedItemsChanged(expandedItems.*)'];\n      }\n    }]);\n\n    return DataProviderMixin;\n  }(superClass);\n};"
    },
    {
     "id": 327,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-templatizer.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { templatize } from '@polymer/polymer/lib/utils/templatize.js';\n/**\n * `vaadin-grid-templatizer` is a helper element for the `vaadin-grid` that is preparing and\n * stamping instances of cells and columns templates\n *\n * @extends PolymerElement\n * @private\n */\n\nvar GridTemplatizer = /*#__PURE__*/function (_ref) {\n  _inherits(GridTemplatizer, _ref);\n\n  var _super = _createSuper(GridTemplatizer);\n\n  _createClass(GridTemplatizer, null, [{\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-grid-templatizer';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        dataHost: Object,\n        template: Object,\n        _templateInstances: {\n          type: Array,\n          value: function value() {\n            return [];\n          }\n        },\n        _parentPathValues: {\n          value: function value() {\n            return {};\n          }\n        },\n        _grid: Object\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['_templateInstancesChanged(_templateInstances.*, _parentPathValues.*)'];\n    }\n  }]);\n\n  function GridTemplatizer() {\n    var _this;\n\n    _classCallCheck(this, GridTemplatizer);\n\n    _this = _super.call(this);\n    _this._instanceProps = {\n      detailsOpened: true,\n      index: true,\n      item: true,\n      selected: true,\n      expanded: true,\n      level: true\n    };\n    return _this;\n  }\n\n  _createClass(GridTemplatizer, [{\n    key: \"createInstance\",\n    value: function createInstance() {\n      this._ensureTemplatized();\n\n      var instance = new this._TemplateClass({});\n      this.addInstance(instance);\n      return instance;\n    }\n  }, {\n    key: \"addInstance\",\n    value: function addInstance(instance) {\n      var _this2 = this;\n\n      if (this._templateInstances.indexOf(instance) === -1) {\n        this._templateInstances.push(instance);\n\n        requestAnimationFrame(function () {\n          return _this2.notifyPath('_templateInstances.*', _this2._templateInstances);\n        });\n      }\n    }\n  }, {\n    key: \"removeInstance\",\n    value: function removeInstance(instance) {\n      var index = this._templateInstances.indexOf(instance);\n\n      this.splice('_templateInstances', index, 1);\n    }\n  }, {\n    key: \"_ensureTemplatized\",\n    value: function _ensureTemplatized() {\n      if (!this._TemplateClass) {\n        this._TemplateClass = templatize(this.template, this, {\n          instanceProps: this._instanceProps,\n          parentModel: true,\n          forwardHostProp: function forwardHostProp(prop, value) {\n            this._forwardParentProp(prop, value);\n\n            if (this._templateInstances) {\n              this._templateInstances.forEach(function (inst) {\n                return inst.notifyPath(prop, value);\n              });\n            }\n          },\n          notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {\n            var _this3 = this;\n\n            if (prop === 'index' || prop === 'item') {\n              // We dont need a change notification for these.\n              return;\n            }\n\n            var originalProp = \"__\".concat(prop, \"__\"); // Notify for only user-action changes, not for scrolling updates. E. g.,\n            // if `detailsOpened` is different from `__detailsOpened__`, which was set during render.\n\n            if (inst[originalProp] === value) {\n              return;\n            }\n\n            inst[originalProp] = value;\n            var row = Array.from(this._grid.$.items.children).filter(function (row) {\n              return _this3._grid._itemsEqual(row._item, inst.item);\n            })[0];\n\n            if (row) {\n              Array.from(row.children).forEach(function (cell) {\n                if (cell._instance) {\n                  cell._instance[originalProp] = value;\n\n                  cell._instance.notifyPath(prop, value);\n                }\n              });\n            }\n\n            var itemPrefix = 'item.';\n\n            if (Array.isArray(this._grid.items) && prop.indexOf(itemPrefix) === 0) {\n              var itemsIndex = this._grid.items.indexOf(inst.item);\n\n              var path = prop.slice(itemPrefix.length);\n\n              this._grid.notifyPath(\"items.\".concat(itemsIndex, \".\").concat(path), value);\n            }\n\n            var gridCallback = \"_\".concat(prop, \"InstanceChangedCallback\");\n\n            if (this._grid && this._grid[gridCallback]) {\n              this._grid[gridCallback](inst, value);\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_forwardParentProp\",\n    value: function _forwardParentProp(prop, value) {\n      this._parentPathValues[prop] = value;\n\n      this._templateInstances.forEach(function (inst) {\n        return inst.notifyPath(prop, value);\n      });\n    }\n  }, {\n    key: \"_templateInstancesChanged\",\n    value: function _templateInstancesChanged(t, p) {\n      var _this4 = this;\n\n      var index, count;\n\n      if (t.path === '_templateInstances') {\n        // Iterate all instances\n        index = 0;\n        count = this._templateInstances.length;\n      } else if (t.path === '_templateInstances.splices') {\n        // Iterate only new instances\n        index = t.value.index;\n        count = t.value.addedCount;\n      } else {\n        return;\n      }\n\n      Object.keys(this._parentPathValues || {}).forEach(function (keyName) {\n        for (var i = index; i < index + count; i++) {\n          _this4._templateInstances[i].set(keyName, _this4._parentPathValues[keyName]);\n        }\n      });\n    }\n  }]);\n\n  return GridTemplatizer;\n}( /*#__PURE__*/function (_PolymerElement) {\n  _inherits(_class, _PolymerElement);\n\n  var _super2 = _createSuper(_class);\n\n  function _class() {\n    _classCallCheck(this, _class);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return _class;\n}(PolymerElement));\n\ncustomElements.define(GridTemplatizer.is, GridTemplatizer);\nexport { GridTemplatizer as Templatizer };"
    },
    {
     "id": 328,
     "name": "../node_modules/@vaadin/flow-frontend/gridConnector.js?babel-target=es5",
     "source": "// Not using ES6 imports in this file yet because the connector in V14 must\n// still work in Legacy bower projects. See: `gridConnector-es6.js` for\n// the Polymer3 approach.\n(function () {\n  var tryCatchWrapper = function tryCatchWrapper(callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Grid', 'vaadin-grid-flow');\n  };\n\n  window.Vaadin.Flow.Legacy = window.Vaadin.Flow.Legacy || {};\n  var isItemCacheInitialized = false;\n  window.Vaadin.Flow.gridConnector = {\n    initLazy: function initLazy(grid) {\n      return tryCatchWrapper(function (grid) {\n        // Check whether the connector was already initialized for the grid\n        if (grid.$connector) {\n          return;\n        } // Polymer\n\n\n        if (window.Polymer) {\n          // Polymer2 approach.\n          window.Vaadin.Flow.Legacy.Debouncer = Polymer.Debouncer;\n          window.Vaadin.Flow.Legacy.timeOut = Polymer.Async.timeOut;\n          window.Vaadin.Flow.Legacy.animationFrame = Polymer.Async.animationFrame;\n          window.Vaadin.Flow.Legacy.GridElement = Vaadin.GridElement;\n          window.Vaadin.Flow.Legacy.ItemCache = Vaadin.Grid.ItemCache;\n        } else if (!window.Vaadin.Flow.Legacy.Debouncer) {\n          console.log(\"Grid is unable to load Polymer helpers.\");\n          return;\n        }\n\n        var Debouncer = window.Vaadin.Flow.Legacy.Debouncer;\n        var timeOut = window.Vaadin.Flow.Legacy.timeOut;\n        var animationFrame = window.Vaadin.Flow.Legacy.animationFrame;\n        var GridElement = window.Vaadin.Flow.Legacy.GridElement;\n        var ItemCache = window.Vaadin.Flow.Legacy.ItemCache; // Make sure ItemCache patching is done only once, but delay it for when\n        // a server grid is initialized\n\n        if (!isItemCacheInitialized) {\n          isItemCacheInitialized = true; // Storing original implementation of the method to be used for client\n          // side only grids\n\n          ItemCache.prototype.ensureSubCacheForScaledIndexOriginal = ItemCache.prototype.ensureSubCacheForScaledIndex;\n          ItemCache.prototype.ensureSubCacheForScaledIndex = tryCatchWrapper(function (scaledIndex) {\n            if (!this.grid.$connector) {\n              this.ensureSubCacheForScaledIndexOriginal(scaledIndex);\n              return;\n            }\n\n            if (!this.itemCaches[scaledIndex]) {\n              this.grid.$connector.beforeEnsureSubCacheForScaledIndex(this, scaledIndex);\n            }\n          });\n          ItemCache.prototype.isLoading = tryCatchWrapper(function () {\n            var _this = this;\n\n            return Boolean(ensureSubCacheQueue.length || Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(function (index) {\n              return _this.itemCaches[index].isLoading();\n            })[0]);\n          });\n          ItemCache.prototype.doEnsureSubCacheForScaledIndex = tryCatchWrapper(function (scaledIndex) {\n            if (!this.itemCaches[scaledIndex]) {\n              var subCache = new ItemCache.prototype.constructor(this.grid, this, this.items[scaledIndex]);\n              subCache.itemkeyCaches = {};\n\n              if (!this.itemkeyCaches) {\n                this.itemkeyCaches = {};\n              }\n\n              this.itemCaches[scaledIndex] = subCache;\n              this.itemkeyCaches[this.grid.getItemId(subCache.parentItem)] = subCache;\n\n              this.grid._loadPage(0, subCache);\n            }\n          });\n          ItemCache.prototype.getCacheAndIndexByKey = tryCatchWrapper(function (key) {\n            for (var index in this.items) {\n              if (this.grid.getItemId(this.items[index]) === key) {\n                return {\n                  cache: this,\n                  scaledIndex: index\n                };\n              }\n            }\n\n            var keys = Object.keys(this.itemkeyCaches);\n\n            for (var i = 0; i < keys.length; i++) {\n              var expandedKey = keys[i];\n              var subCache = this.itemkeyCaches[expandedKey];\n              var cacheAndIndex = subCache.getCacheAndIndexByKey(key);\n\n              if (cacheAndIndex) {\n                return cacheAndIndex;\n              }\n            }\n\n            return undefined;\n          });\n          ItemCache.prototype.getLevel = tryCatchWrapper(function () {\n            var cache = this;\n            var level = 0;\n\n            while (cache.parentCache) {\n              cache = cache.parentCache;\n              level++;\n            }\n\n            return level;\n          });\n        }\n\n        var rootPageCallbacks = {};\n        var treePageCallbacks = {};\n        var cache = {};\n        /* parentRequestDelay - optimizes parent requests by batching several requests\n        *  into one request. Delay in milliseconds. Disable by setting to 0.\n        *  parentRequestBatchMaxSize - maximum size of the batch.\n        */\n\n        var parentRequestDelay = 50;\n        var parentRequestBatchMaxSize = 20;\n        var parentRequestQueue = [];\n        var parentRequestDebouncer;\n        var ensureSubCacheQueue = [];\n        var ensureSubCacheDebouncer;\n        var rootRequestDelay = 150;\n        var rootRequestDebouncer;\n        var lastRequestedRanges = {};\n        var root = 'null';\n        lastRequestedRanges[root] = [0, 0];\n        var validSelectionModes = ['SINGLE', 'NONE', 'MULTI'];\n        var selectedKeys = {};\n        var selectionMode = 'SINGLE';\n        var detailsVisibleOnClick = true;\n        var sorterDirectionsSetFromServer = false;\n        grid.size = 0; // To avoid NaN here and there before we get proper data\n\n        grid.itemIdPath = 'key';\n        grid.$connector = {};\n        grid.$connector.hasEnsureSubCacheQueue = tryCatchWrapper(function () {\n          return ensureSubCacheQueue.length > 0;\n        });\n        grid.$connector.hasParentRequestQueue = tryCatchWrapper(function () {\n          return parentRequestQueue.length > 0;\n        });\n        grid.$connector.hasRootRequestQueue = tryCatchWrapper(function () {\n          return Object.keys(rootPageCallbacks).length > 0 || rootRequestDebouncer && rootRequestDebouncer.isActive();\n        });\n        grid.$connector.beforeEnsureSubCacheForScaledIndex = tryCatchWrapper(function (targetCache, scaledIndex) {\n          // add call to queue\n          ensureSubCacheQueue.push({\n            cache: targetCache,\n            scaledIndex: scaledIndex,\n            itemkey: grid.getItemId(targetCache.items[scaledIndex]),\n            level: targetCache.getLevel()\n          }); // sort by ascending scaledIndex and level\n\n          ensureSubCacheQueue.sort(function (a, b) {\n            return a.scaledIndex - b.scaledIndex || a.level - b.level;\n          });\n          ensureSubCacheDebouncer = Debouncer.debounce(ensureSubCacheDebouncer, animationFrame, function () {\n            while (ensureSubCacheQueue.length) {\n              grid.$connector.flushEnsureSubCache();\n            }\n          });\n        });\n        grid.$connector.doSelection = tryCatchWrapper(function (items, userOriginated) {\n          if (selectionMode === 'NONE' || !items.length || userOriginated && grid.hasAttribute('disabled')) {\n            return;\n          }\n\n          if (selectionMode === 'SINGLE') {\n            grid.selectedItems = [];\n            selectedKeys = {};\n          }\n\n          grid.selectedItems = grid.selectedItems.concat(items);\n          items.forEach(function (item) {\n            if (item) {\n              selectedKeys[item.key] = item;\n\n              if (userOriginated) {\n                item.selected = true;\n                grid.$server.select(item.key);\n              }\n            }\n\n            var isSelectedItemDifferentOrNull = !grid.activeItem || !item || item.key != grid.activeItem.key;\n\n            if (!userOriginated && selectionMode === 'SINGLE' && isSelectedItemDifferentOrNull) {\n              grid.activeItem = item;\n              grid.$connector.activeItem = item;\n            }\n          });\n        });\n        grid.$connector.doDeselection = tryCatchWrapper(function (items, userOriginated) {\n          if (selectionMode === 'NONE' || !items.length || userOriginated && grid.hasAttribute('disabled')) {\n            return;\n          }\n\n          var updatedSelectedItems = grid.selectedItems.slice();\n\n          while (items.length) {\n            var itemToDeselect = items.shift();\n\n            for (var i = 0; i < updatedSelectedItems.length; i++) {\n              var selectedItem = updatedSelectedItems[i];\n\n              if (itemToDeselect && itemToDeselect.key === selectedItem.key) {\n                updatedSelectedItems.splice(i, 1);\n                break;\n              }\n            }\n\n            if (itemToDeselect) {\n              delete selectedKeys[itemToDeselect.key];\n\n              if (userOriginated) {\n                delete itemToDeselect.selected;\n                grid.$server.deselect(itemToDeselect.key);\n              }\n            }\n          }\n\n          grid.selectedItems = updatedSelectedItems;\n        });\n        grid.__activeItemChanged = tryCatchWrapper(function (newVal, oldVal) {\n          if (selectionMode != 'SINGLE') {\n            return;\n          }\n\n          if (!newVal) {\n            if (oldVal && selectedKeys[oldVal.key]) {\n              if (!grid.$connector.deselectAllowed) {\n                grid.activeItem = oldVal;\n              } else {\n                grid.$connector.doDeselection([oldVal], true);\n              }\n            }\n          } else if (!selectedKeys[newVal.key]) {\n            grid.$connector.doSelection([newVal], true);\n          }\n        });\n\n        grid._createPropertyObserver('activeItem', '__activeItemChanged', true);\n\n        grid.__activeItemChangedDetails = tryCatchWrapper(function (newVal, oldVal) {\n          if (!detailsVisibleOnClick) {\n            return;\n          } // when grid is attached, newVal is not set and oldVal is undefined\n          // do nothing\n\n\n          if (newVal == null && oldVal === undefined) {\n            return;\n          }\n\n          if (newVal && !newVal.detailsOpened) {\n            grid.$server.setDetailsVisible(newVal.key);\n          } else {\n            grid.$server.setDetailsVisible(null);\n          }\n        });\n\n        grid._createPropertyObserver('activeItem', '__activeItemChangedDetails', true);\n\n        grid.$connector.setDetailsVisibleOnClick = tryCatchWrapper(function (visibleOnClick) {\n          detailsVisibleOnClick = visibleOnClick;\n        });\n        grid.$connector._getPageIfSameLevel = tryCatchWrapper(function (parentKey, index, defaultPage) {\n          var cacheAndIndex = grid._cache.getCacheAndIndex(index);\n\n          var parentItem = cacheAndIndex.cache.parentItem;\n          var parentKeyOfIndex = parentItem ? grid.getItemId(parentItem) : root;\n\n          if (parentKey !== parentKeyOfIndex) {\n            return defaultPage;\n          } else {\n            return grid._getPageForIndex(cacheAndIndex.scaledIndex);\n          }\n        });\n        grid.$connector.getCacheByKey = tryCatchWrapper(function (key) {\n          var cacheAndIndex = grid._cache.getCacheAndIndexByKey(key);\n\n          if (cacheAndIndex) {\n            return cacheAndIndex.cache;\n          }\n\n          return undefined;\n        });\n        grid.$connector.flushEnsureSubCache = tryCatchWrapper(function () {\n          var pendingFetch = ensureSubCacheQueue.splice(0, 1)[0];\n          var itemkey = pendingFetch.itemkey;\n          var start = grid._virtualStart;\n          var end = grid._virtualEnd;\n          var buffer = end - start;\n          var firstNeededIndex = Math.max(0, start + grid._vidxOffset - buffer);\n          var lastNeededIndex = Math.min(end + grid._vidxOffset + buffer, grid._effectiveSize); // only fetch if given item is still in visible range\n\n          for (var index = firstNeededIndex; index <= lastNeededIndex; index++) {\n            var item = grid._cache.getItemForIndex(index);\n\n            if (grid.getItemId(item) === itemkey) {\n              if (grid._isExpanded(item)) {\n                pendingFetch.cache.doEnsureSubCacheForScaledIndex(pendingFetch.scaledIndex);\n                return true;\n              } else {\n                break;\n              }\n            }\n          }\n\n          return false;\n        });\n        grid.$connector.flushParentRequests = tryCatchWrapper(function () {\n          var pendingFetches = parentRequestQueue.splice(0, parentRequestBatchMaxSize);\n\n          if (pendingFetches.length) {\n            grid.$server.setParentRequestedRanges(pendingFetches);\n            return true;\n          }\n\n          return false;\n        });\n        grid.$connector.beforeParentRequest = tryCatchWrapper(function (firstIndex, size, parentKey) {\n          // add request in queue\n          parentRequestQueue.push({\n            firstIndex: firstIndex,\n            size: size,\n            parentKey: parentKey\n          });\n          parentRequestDebouncer = Debouncer.debounce(parentRequestDebouncer, timeOut.after(parentRequestDelay), function () {\n            while (parentRequestQueue.length) {\n              grid.$connector.flushParentRequests();\n            }\n          });\n        });\n        grid.$connector.fetchPage = tryCatchWrapper(function (fetch, page, parentKey) {\n          // Determine what to fetch based on scroll position and not only\n          // what grid asked for\n          // The buffer size could be multiplied by some constant defined by the user,\n          // if he needs to reduce the number of items sent to the Grid to improve performance\n          // or to increase it to make Grid smoother when scrolling\n          var start = grid._virtualStart;\n          var end = grid._virtualEnd;\n          var buffer = end - start;\n          var firstNeededIndex = Math.max(0, start + grid._vidxOffset - buffer);\n          var lastNeededIndex = Math.min(end + grid._vidxOffset + buffer, grid._effectiveSize);\n          var firstNeededPage = page;\n          var lastNeededPage = page;\n\n          for (var idx = firstNeededIndex; idx <= lastNeededIndex; idx++) {\n            firstNeededPage = Math.min(firstNeededPage, grid.$connector._getPageIfSameLevel(parentKey, idx, firstNeededPage));\n            lastNeededPage = Math.max(lastNeededPage, grid.$connector._getPageIfSameLevel(parentKey, idx, lastNeededPage));\n          }\n\n          var firstPage = Math.max(0, firstNeededPage);\n          var lastPage = parentKey !== root ? lastNeededPage : Math.min(lastNeededPage, Math.floor(grid.size / grid.pageSize));\n          var lastRequestedRange = lastRequestedRanges[parentKey];\n\n          if (!lastRequestedRange) {\n            lastRequestedRange = [-1, -1];\n          }\n\n          if (lastRequestedRange[0] != firstPage || lastRequestedRange[1] != lastPage) {\n            lastRequestedRange = [firstPage, lastPage];\n            lastRequestedRanges[parentKey] = lastRequestedRange;\n            var count = lastPage - firstPage + 1;\n            fetch(firstPage * grid.pageSize, count * grid.pageSize);\n          }\n        }); // Need to flush FlattenedNodesObserver in order to update `grid._columnTree`\n        // before `_dataProviderChanged` is called. Otherwise, the first page won't\n        // be correctly loaded because of `_canPopulate` returns incorrect result.\n\n        grid._observer.flush();\n\n        grid.dataProvider = tryCatchWrapper(function (params, callback) {\n          if (params.pageSize != grid.pageSize) {\n            throw 'Invalid pageSize';\n          }\n\n          var page = params.page;\n\n          if (params.parentItem) {\n            var parentUniqueKey = grid.getItemId(params.parentItem);\n\n            if (!treePageCallbacks[parentUniqueKey]) {\n              treePageCallbacks[parentUniqueKey] = {};\n            }\n\n            var parentCache = grid.$connector.getCacheByKey(parentUniqueKey);\n            var itemCache = parentCache && parentCache.itemkeyCaches ? parentCache.itemkeyCaches[parentUniqueKey] : undefined;\n\n            if (cache[parentUniqueKey] && cache[parentUniqueKey][page] && itemCache) {\n              // workaround: sometimes grid-element gives page index that overflows\n              page = Math.min(page, Math.floor(cache[parentUniqueKey].size / grid.pageSize));\n              callback(cache[parentUniqueKey][page], cache[parentUniqueKey].size);\n            } else {\n              treePageCallbacks[parentUniqueKey][page] = callback;\n            }\n\n            grid.$connector.fetchPage(function (firstIndex, size) {\n              return grid.$connector.beforeParentRequest(firstIndex, size, params.parentItem.key);\n            }, page, parentUniqueKey);\n          } else {\n            // workaround: sometimes grid-element gives page index that overflows\n            page = Math.min(page, Math.floor(grid.size / grid.pageSize));\n\n            if (cache[root] && cache[root][page]) {\n              callback(cache[root][page]);\n            } else {\n              rootPageCallbacks[page] = callback;\n            }\n\n            rootRequestDebouncer = Debouncer.debounce(rootRequestDebouncer, timeOut.after(grid._hasData ? rootRequestDelay : 0), function () {\n              grid.$connector.fetchPage(function (firstIndex, size) {\n                return grid.$server.setRequestedRange(firstIndex, size);\n              }, page, root);\n            });\n          }\n        });\n        var sorterChangeListener = tryCatchWrapper(function (_, oldValue) {\n          if (oldValue !== undefined && !sorterDirectionsSetFromServer) {\n            grid.$server.sortersChanged(grid._sorters.map(function (sorter) {\n              return {\n                path: sorter.path,\n                direction: sorter.direction\n              };\n            }));\n          }\n        });\n        grid.$connector.setSorterDirections = tryCatchWrapper(function (directions) {\n          sorterDirectionsSetFromServer = true;\n          setTimeout(tryCatchWrapper(function () {\n            try {\n              var sorters = Array.from(grid.querySelectorAll('vaadin-grid-sorter'));\n              sorters.forEach(function (sorter) {\n                if (!directions.filter(function (d) {\n                  return d.column === sorter.getAttribute('path');\n                })[0]) {\n                  sorter.direction = null;\n                }\n              });\n              directions.reverse().forEach(function (_ref) {\n                var column = _ref.column,\n                    direction = _ref.direction;\n                sorters.forEach(function (sorter) {\n                  if (sorter.getAttribute('path') === column && sorter.direction !== direction) {\n                    sorter.direction = direction;\n                  }\n                });\n              });\n            } finally {\n              sorterDirectionsSetFromServer = false;\n            }\n          }));\n        });\n\n        grid._createPropertyObserver(\"_previousSorters\", sorterChangeListener);\n\n        grid._updateItem = tryCatchWrapper(function (row, item) {\n          GridElement.prototype._updateItem.call(grid, row, item); // There might be inactive component renderers on hidden rows that still refer to the\n          // same component instance as one of the renderers on a visible row. Making the\n          // inactive/hidden renderer attach the component might steal it from a visible/active one.\n\n\n          if (!row.hidden) {\n            // make sure that component renderers are updated\n            Array.from(row.children).forEach(function (cell) {\n              if (cell._instance && cell._instance.children) {\n                Array.from(cell._instance.children).forEach(function (content) {\n                  if (content._attachRenderedComponentIfAble) {\n                    content._attachRenderedComponentIfAble();\n                  } // In hierarchy column of tree grid, the component renderer is inside its content,\n                  // this updates it renderer from innerContent\n\n\n                  if (content.children) {\n                    Array.from(content.children).forEach(function (innerContent) {\n                      if (innerContent._attachRenderedComponentIfAble) {\n                        innerContent._attachRenderedComponentIfAble();\n                      }\n                    });\n                  }\n                });\n              }\n            });\n          }\n        });\n        grid._expandedInstanceChangedCallback = tryCatchWrapper(function (inst, value) {\n          // method available only for the TreeGrid server-side component\n          if (inst.item == undefined || grid.$server.updateExpandedState == undefined) {\n            return;\n          }\n\n          var parentKey = grid.getItemId(inst.item);\n          grid.$server.updateExpandedState(parentKey, value);\n\n          if (value) {\n            this.expandItem(inst.item);\n          } else {\n            delete cache[parentKey];\n            var parentCache = grid.$connector.getCacheByKey(parentKey);\n\n            if (parentCache && parentCache.itemkeyCaches && parentCache.itemkeyCaches[parentKey]) {\n              delete parentCache.itemkeyCaches[parentKey];\n            }\n\n            if (parentCache && parentCache.itemkeyCaches) {\n              Object.keys(parentCache.itemCaches).filter(function (idx) {\n                return parentCache.items[idx].key === parentKey;\n              }).forEach(function (idx) {\n                return delete parentCache.itemCaches[idx];\n              });\n            }\n\n            delete lastRequestedRanges[parentKey];\n            this.collapseItem(inst.item);\n          }\n        });\n\n        var itemsUpdated = function itemsUpdated(items) {\n          if (!items || !Array.isArray(items)) {\n            throw 'Attempted to call itemsUpdated with an invalid value: ' + JSON.stringify(items);\n          }\n\n          var detailsOpenedItems = Array.from(grid.detailsOpenedItems);\n          var updatedSelectedItem = false;\n\n          for (var i = 0; i < items.length; ++i) {\n            var item = items[i];\n\n            if (!item) {\n              continue;\n            }\n\n            if (item.detailsOpened) {\n              if (grid._getItemIndexInArray(item, detailsOpenedItems) < 0) {\n                detailsOpenedItems.push(item);\n              }\n            } else if (grid._getItemIndexInArray(item, detailsOpenedItems) >= 0) {\n              detailsOpenedItems.splice(grid._getItemIndexInArray(item, detailsOpenedItems), 1);\n            }\n\n            if (selectedKeys[item.key]) {\n              selectedKeys[item.key] = item;\n              item.selected = true;\n              updatedSelectedItem = true;\n            }\n          }\n\n          grid.detailsOpenedItems = detailsOpenedItems;\n\n          if (updatedSelectedItem) {\n            // IE 11 Object doesn't support method values\n            grid.selectedItems = Object.keys(selectedKeys).map(function (e) {\n              return selectedKeys[e];\n            });\n          }\n        };\n        /**\n         * Updates the cache for the given page for grid or tree-grid.\n         *\n         * @param page index of the page to update\n         * @param parentKey the key of the parent item for the page\n         * @returns an array of the updated items for the page, or undefined if no items were cached for the page\n         */\n\n\n        var updateGridCache = function updateGridCache(page, parentKey) {\n          var items;\n\n          if ((parentKey || root) !== root) {\n            items = cache[parentKey][page];\n            var parentCache = grid.$connector.getCacheByKey(parentKey);\n\n            if (parentCache && parentCache.itemkeyCaches) {\n              var _cache = parentCache.itemkeyCaches[parentKey];\n              var callbacksForParentKey = treePageCallbacks[parentKey];\n              var callback = callbacksForParentKey && callbacksForParentKey[page];\n\n              _updateGridCache(page, items, callback, _cache);\n            }\n          } else {\n            items = cache[root][page];\n\n            _updateGridCache(page, items, rootPageCallbacks[page], grid._cache);\n          }\n\n          return items;\n        };\n\n        var _updateGridCache = function _updateGridCache(page, items, callback, levelcache) {\n          // Force update unless there's a callback waiting\n          if (!callback) {\n            var rangeStart = page * grid.pageSize;\n            var rangeEnd = rangeStart + grid.pageSize;\n\n            if (!items) {\n              if (levelcache && levelcache.items) {\n                for (var idx = rangeStart; idx < rangeEnd; idx++) {\n                  delete levelcache.items[idx];\n                }\n              }\n            } else {\n              if (levelcache && levelcache.items) {\n                for (var _idx = rangeStart; _idx < rangeEnd; _idx++) {\n                  if (levelcache.items[_idx]) {\n                    levelcache.items[_idx] = items[_idx - rangeStart];\n                  }\n                }\n              }\n            }\n          }\n        };\n        /**\n         * Updates all visible grid rows in DOM.\n         */\n\n\n        var updateAllGridRowsInDomBasedOnCache = function updateAllGridRowsInDomBasedOnCache() {\n          grid._cache.updateSize();\n\n          grid._effectiveSize = grid._cache.effectiveSize;\n\n          grid._assignModels();\n        };\n        /**\n         * Update the given items in DOM if currently visible.\n         *\n         * @param array items the items to update in DOM\n         */\n\n\n        var updateGridItemsInDomBasedOnCache = function updateGridItemsInDomBasedOnCache(items) {\n          if (!items || !grid._physicalItems) {\n            return;\n          }\n          /**\n           * Calls the _assignModels function from GridScrollerElement, that triggers\n           * the internal revalidation of the items based on the _cache of the DataProviderMixin.\n           * First mapping the item to physical (iron list) indexes, so that we update\n           * only items in with the correct index that are cached in the iron list.\n           */\n\n\n          var itemKeys = items.map(function (item) {\n            return item.key;\n          });\n\n          var indexes = grid._physicalItems.map(function (tr, index) {\n            return tr._item && tr._item.key && itemKeys.indexOf(tr._item.key) > -1 ? index : null;\n          }).filter(function (idx) {\n            return idx !== null;\n          });\n\n          if (indexes.length > 0) {\n            grid._assignModels(indexes);\n          }\n        };\n\n        grid.$connector.set = tryCatchWrapper(function (index, items, parentKey) {\n          if (index % grid.pageSize != 0) {\n            throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + grid.pageSize;\n          }\n\n          var pkey = parentKey || root;\n          var firstPage = index / grid.pageSize;\n          var updatedPageCount = Math.ceil(items.length / grid.pageSize);\n\n          for (var i = 0; i < updatedPageCount; i++) {\n            var page = firstPage + i;\n            var slice = items.slice(i * grid.pageSize, (i + 1) * grid.pageSize);\n\n            if (!cache[pkey]) {\n              cache[pkey] = {};\n            }\n\n            cache[pkey][page] = slice;\n            grid.$connector.doSelection(slice.filter(function (item) {\n              return item.selected && !isSelectedOnGrid(item);\n            }));\n            grid.$connector.doDeselection(slice.filter(function (item) {\n              return !item.selected && (selectedKeys[item.key] || isSelectedOnGrid(item));\n            }));\n            var updatedItems = updateGridCache(page, pkey);\n\n            if (updatedItems) {\n              itemsUpdated(updatedItems);\n              updateGridItemsInDomBasedOnCache(updatedItems);\n            }\n          }\n        });\n\n        var itemToCacheLocation = function itemToCacheLocation(item) {\n          var parent = item.parentUniqueKey || root;\n\n          if (cache[parent]) {\n            for (var page in cache[parent]) {\n              for (var index in cache[parent][page]) {\n                if (grid.getItemId(cache[parent][page][index]) === grid.getItemId(item)) {\n                  return {\n                    page: page,\n                    index: index,\n                    parentKey: parent\n                  };\n                }\n              }\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Updates the given items for a hierarchical grid.\n         *\n         * @param updatedItems the updated items array\n         */\n\n\n        grid.$connector.updateHierarchicalData = tryCatchWrapper(function (updatedItems) {\n          var pagesToUpdate = []; // locate and update the items in cache\n          // find pages that need updating\n\n          for (var i = 0; i < updatedItems.length; i++) {\n            var cacheLocation = itemToCacheLocation(updatedItems[i]);\n\n            if (cacheLocation) {\n              cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];\n              var key = cacheLocation.parentKey + ':' + cacheLocation.page;\n\n              if (!pagesToUpdate[key]) {\n                pagesToUpdate[key] = {\n                  parentKey: cacheLocation.parentKey,\n                  page: cacheLocation.page\n                };\n              }\n            }\n          } // IE11 doesn't work with the transpiled version of the forEach.\n\n\n          var keys = Object.keys(pagesToUpdate);\n\n          for (var _i = 0; _i < keys.length; _i++) {\n            var pageToUpdate = pagesToUpdate[keys[_i]];\n            var affectedUpdatedItems = updateGridCache(pageToUpdate.page, pageToUpdate.parentKey);\n\n            if (affectedUpdatedItems) {\n              itemsUpdated(affectedUpdatedItems);\n              updateGridItemsInDomBasedOnCache(affectedUpdatedItems);\n            }\n          }\n        });\n        /**\n         * Updates the given items for a non-hierarchical grid.\n         *\n         * @param updatedItems the updated items array\n         */\n\n        grid.$connector.updateFlatData = tryCatchWrapper(function (updatedItems) {\n          // update (flat) caches\n          for (var i = 0; i < updatedItems.length; i++) {\n            var cacheLocation = itemToCacheLocation(updatedItems[i]);\n\n            if (cacheLocation) {\n              // update connector cache\n              cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i]; // update grid's cache\n\n              var index = parseInt(cacheLocation.page) * grid.pageSize + parseInt(cacheLocation.index);\n\n              if (grid._cache.items[index]) {\n                grid._cache.items[index] = updatedItems[i];\n              }\n            }\n          }\n\n          itemsUpdated(updatedItems);\n          updateGridItemsInDomBasedOnCache(updatedItems);\n        });\n        grid.$connector.clearExpanded = tryCatchWrapper(function () {\n          grid.expandedItems = [];\n          ensureSubCacheQueue = [];\n          parentRequestQueue = [];\n        });\n        grid.$connector.clear = tryCatchWrapper(function (index, length, parentKey) {\n          var pkey = parentKey || root;\n\n          if (!cache[pkey] || Object.keys(cache[pkey]).length === 0) {\n            return;\n          }\n\n          if (index % grid.pageSize != 0) {\n            throw 'Got cleared data for index ' + index + ' which is not aligned with the page size of ' + grid.pageSize;\n          }\n\n          var firstPage = Math.floor(index / grid.pageSize);\n          var updatedPageCount = Math.ceil(length / grid.pageSize);\n\n          for (var i = 0; i < updatedPageCount; i++) {\n            var page = firstPage + i;\n            var items = cache[pkey][page];\n            grid.$connector.doDeselection(items.filter(function (item) {\n              return selectedKeys[item.key];\n            }));\n            delete cache[pkey][page];\n            var updatedItems = updateGridCache(page, parentKey);\n\n            if (updatedItems) {\n              itemsUpdated(updatedItems);\n            }\n\n            updateGridItemsInDomBasedOnCache(items);\n          }\n        });\n\n        var isSelectedOnGrid = function isSelectedOnGrid(item) {\n          var selectedItems = grid.selectedItems;\n\n          for (var i = 0; i < selectedItems; i++) {\n            var selectedItem = selectedItems[i];\n\n            if (selectedItem.key === item.key) {\n              return true;\n            }\n          }\n\n          return false;\n        };\n\n        grid.$connector.reset = tryCatchWrapper(function () {\n          grid.size = 0;\n          deleteObjectContents(cache);\n          deleteObjectContents(grid._cache.items);\n          deleteObjectContents(lastRequestedRanges);\n\n          if (ensureSubCacheDebouncer) {\n            ensureSubCacheDebouncer.cancel();\n          }\n\n          if (parentRequestDebouncer) {\n            parentRequestDebouncer.cancel();\n          }\n\n          if (rootRequestDebouncer) {\n            rootRequestDebouncer.cancel();\n          }\n\n          ensureSubCacheDebouncer = undefined;\n          parentRequestDebouncer = undefined;\n          ensureSubCacheQueue = [];\n          parentRequestQueue = [];\n          updateAllGridRowsInDomBasedOnCache();\n        });\n\n        var deleteObjectContents = function deleteObjectContents(obj) {\n          return Object.keys(obj).forEach(function (key) {\n            return delete obj[key];\n          });\n        };\n\n        grid.$connector.updateSize = function (newSize) {\n          return grid.size = newSize;\n        };\n\n        grid.$connector.updateUniqueItemIdPath = function (path) {\n          return grid.itemIdPath = path;\n        };\n\n        grid.$connector.expandItems = tryCatchWrapper(function (items) {\n          var newExpandedItems = Array.from(grid.expandedItems);\n          items.filter(function (item) {\n            return !grid._isExpanded(item);\n          }).forEach(function (item) {\n            return newExpandedItems.push(item);\n          });\n          grid.expandedItems = newExpandedItems;\n        });\n        grid.$connector.collapseItems = tryCatchWrapper(function (items) {\n          var newExpandedItems = Array.from(grid.expandedItems);\n          items.forEach(function (item) {\n            var index = grid._getItemIndexInArray(item, newExpandedItems);\n\n            if (index >= 0) {\n              newExpandedItems.splice(index, 1);\n            }\n          });\n          grid.expandedItems = newExpandedItems;\n          items.forEach(function (item) {\n            return grid.$connector.removeFromQueue(item);\n          });\n        });\n        grid.$connector.removeFromQueue = tryCatchWrapper(function (item) {\n          var itemId = grid.getItemId(item);\n          delete treePageCallbacks[itemId];\n          grid.$connector.removeFromArray(ensureSubCacheQueue, function (item) {\n            return item.itemkey === itemId;\n          });\n          grid.$connector.removeFromArray(parentRequestQueue, function (item) {\n            return item.parentKey === itemId;\n          });\n        });\n        grid.$connector.removeFromArray = tryCatchWrapper(function (array, removeTest) {\n          if (array.length) {\n            for (var index = array.length - 1; index--;) {\n              if (removeTest(array[index])) {\n                array.splice(index, 1);\n              }\n            }\n          }\n        });\n        grid.$connector.confirmParent = tryCatchWrapper(function (id, parentKey, levelSize) {\n          if (!treePageCallbacks[parentKey]) {\n            return;\n          }\n\n          if (cache[parentKey]) {\n            cache[parentKey].size = levelSize;\n          }\n\n          var outstandingRequests = Object.getOwnPropertyNames(treePageCallbacks[parentKey]);\n\n          for (var i = 0; i < outstandingRequests.length; i++) {\n            var page = outstandingRequests[i];\n            var lastRequestedRange = lastRequestedRanges[parentKey] || [0, 0];\n            var callback = treePageCallbacks[parentKey][page];\n\n            if (cache[parentKey] && cache[parentKey][page] || page < lastRequestedRange[0] || page > lastRequestedRange[1]) {\n              delete treePageCallbacks[parentKey][page];\n              var items = cache[parentKey][page] || new Array(levelSize);\n              callback(items, levelSize);\n            } else if (callback && levelSize === 0) {\n              // The parent item has 0 child items => resolve the callback with an empty array\n              delete treePageCallbacks[parentKey][page];\n              callback([], levelSize);\n            }\n          } // Let server know we're done\n\n\n          grid.$server.confirmParentUpdate(id, parentKey);\n\n          if (!grid.loading) {\n            grid._assignModels();\n          }\n        });\n        grid.$connector.confirm = tryCatchWrapper(function (id) {\n          // We're done applying changes from this batch, resolve outstanding\n          // callbacks\n          var outstandingRequests = Object.getOwnPropertyNames(rootPageCallbacks);\n\n          for (var i = 0; i < outstandingRequests.length; i++) {\n            var page = outstandingRequests[i];\n            var lastRequestedRange = lastRequestedRanges[root] || [0, 0];\n            var lastAvailablePage = grid.size ? Math.ceil(grid.size / grid.pageSize) - 1 : 0; // It's possible that the lastRequestedRange includes a page that's beyond lastAvailablePage if the grid's size got reduced during an ongoing data request\n\n            var lastRequestedRangeEnd = Math.min(lastRequestedRange[1], lastAvailablePage); // Resolve if we have data or if we don't expect to get data\n\n            var callback = rootPageCallbacks[page];\n\n            if (cache[root] && cache[root][page] || page < lastRequestedRange[0] || +page > lastRequestedRangeEnd) {\n              delete rootPageCallbacks[page];\n              callback(cache[root][page] || new Array(grid.pageSize)); // Makes sure to push all new rows before this stack execution is done so any timeout expiration called after will be applied on a fully updated grid\n              //Resolves https://github.com/vaadin/vaadin-grid-flow/issues/511\n\n              if (grid._debounceIncreasePool) {\n                grid._debounceIncreasePool.flush();\n              }\n            } else if (callback && grid.size === 0) {\n              // The grid has 0 items => resolve the callback with an empty array\n              delete rootPageCallbacks[page];\n              callback([]);\n            }\n          } // Let server know we're done\n\n\n          grid.$server.confirmUpdate(id);\n        });\n        grid.$connector.ensureHierarchy = tryCatchWrapper(function () {\n          for (var parentKey in cache) {\n            if (parentKey !== root) {\n              delete cache[parentKey];\n            }\n          }\n\n          deleteObjectContents(lastRequestedRanges);\n          grid._cache.itemCaches = {};\n          grid._cache.itemkeyCaches = {};\n          updateAllGridRowsInDomBasedOnCache();\n        });\n        grid.$connector.setSelectionMode = tryCatchWrapper(function (mode) {\n          if ((typeof mode === 'string' || mode instanceof String) && validSelectionModes.indexOf(mode) >= 0) {\n            selectionMode = mode;\n            selectedKeys = {};\n          } else {\n            throw 'Attempted to set an invalid selection mode';\n          }\n        });\n        grid.$connector.deselectAllowed = true; // TODO: should be removed once https://github.com/vaadin/vaadin-grid/issues/1471 gets implemented\n\n        grid.$connector.setVerticalScrollingEnabled = tryCatchWrapper(function (enabled) {\n          setVerticalScrollingEnabled(grid.$.table, enabled); // Since the scrollbars were toggled, there might have been some changes to layout\n          // size. Notify grid of the resize to ensure everything is in place.\n\n          grid.notifyResize();\n        });\n\n        var setVerticalScrollingEnabled = function setVerticalScrollingEnabled(scrollable, enabled) {\n          // Prevent Y axis scrolling with CSS. This will hide the vertical scrollbar.\n          scrollable.style.overflowY = enabled ? '' : 'hidden'; // Clean up an existing listener\n\n          scrollable.removeEventListener('wheel', scrollable.__wheelListener); // Add a wheel event listener with the horizontal scrolling prevention logic\n\n          !enabled && scrollable.addEventListener('wheel', scrollable.__wheelListener = tryCatchWrapper(function (e) {\n            if (e.deltaX) {\n              // If there was some horizontal delta related to the wheel event, force the vertical\n              // delta to 0 and let grid process the wheel event normally\n              Object.defineProperty(e, 'deltaY', {\n                value: 0\n              });\n            } else {\n              // If there was verical delta only, skip the grid's wheel event processing to\n              // enable scrolling the page even if grid isn't scrolled to end\n              e.stopImmediatePropagation();\n            }\n          }));\n        };\n\n        var contextMenuListener = function contextMenuListener(e) {\n          var eventContext = grid.getEventContext(e);\n          var key = eventContext.item && eventContext.item.key;\n          var colId = eventContext.column && eventContext.column.id;\n          grid.$server.updateContextMenuTargetItem(key, colId);\n        };\n\n        grid.addEventListener('vaadin-context-menu-before-open', tryCatchWrapper(function (e) {\n          contextMenuListener(grid.$contextMenuConnector.openEvent);\n        }));\n        grid.getContextMenuBeforeOpenDetail = tryCatchWrapper(function (event) {\n          var eventContext = grid.getEventContext(event);\n          return {\n            key: eventContext.item && eventContext.item.key || \"\"\n          };\n        });\n        grid.addEventListener('cell-activate', tryCatchWrapper(function (e) {\n          grid.$connector.activeItem = e.detail.model.item;\n          setTimeout(function () {\n            return grid.$connector.activeItem = undefined;\n          });\n        }));\n        grid.addEventListener('click', tryCatchWrapper(function (e) {\n          return _fireClickEvent(e, 'item-click');\n        }));\n        grid.addEventListener('dblclick', tryCatchWrapper(function (e) {\n          return _fireClickEvent(e, 'item-double-click');\n        }));\n        grid.addEventListener('column-resize', tryCatchWrapper(function (e) {\n          var cols = grid._getColumnsInOrder().filter(function (col) {\n            return !col.hidden;\n          });\n\n          cols.forEach(function (col) {\n            col.dispatchEvent(new CustomEvent('column-drag-resize'));\n          });\n          grid.dispatchEvent(new CustomEvent('column-drag-resize', {\n            detail: {\n              resizedColumnKey: e.detail.resizedColumn._flowId\n            }\n          }));\n        }));\n        grid.addEventListener('column-reorder', tryCatchWrapper(function (e) {\n          var columns = grid._columnTree.slice(0).pop().filter(function (c) {\n            return c._flowId;\n          }).sort(function (b, a) {\n            return b._order - a._order;\n          }).map(function (c) {\n            return c._flowId;\n          });\n\n          grid.dispatchEvent(new CustomEvent('column-reorder-all-columns', {\n            detail: {\n              columns: columns\n            }\n          }));\n        }));\n\n        function _fireClickEvent(event, eventName) {\n          if (grid.$connector.activeItem) {\n            event.itemKey = grid.$connector.activeItem.key;\n            var eventContext = grid.getEventContext(event); // if you have a details-renderer, getEventContext().column is undefined\n\n            if (eventContext.column) {\n              event.internalColumnId = eventContext.column._flowId;\n            }\n\n            grid.dispatchEvent(new CustomEvent(eventName, {\n              detail: event\n            }));\n          }\n        }\n\n        grid.cellClassNameGenerator = tryCatchWrapper(function (column, rowData) {\n          var style = rowData.item.style;\n\n          if (!style) {\n            return;\n          }\n\n          return (style.row || '') + ' ' + (column && style[column._flowId] || '');\n        });\n        grid.dropFilter = tryCatchWrapper(function (rowData) {\n          return !rowData.item.dropDisabled;\n        });\n        grid.dragFilter = tryCatchWrapper(function (rowData) {\n          return !rowData.item.dragDisabled;\n        });\n        grid.addEventListener('grid-dragstart', tryCatchWrapper(function (e) {\n          if (grid._isSelected(e.detail.draggedItems[0])) {\n            // Dragging selected (possibly multiple) items\n            if (grid.__selectionDragData) {\n              Object.keys(grid.__selectionDragData).forEach(function (type) {\n                e.detail.setDragData(type, grid.__selectionDragData[type]);\n              });\n            } else {\n              (grid.__dragDataTypes || []).forEach(function (type) {\n                e.detail.setDragData(type, e.detail.draggedItems.map(function (item) {\n                  return item.dragData[type];\n                }).join('\\n'));\n              });\n            }\n\n            if (grid.__selectionDraggedItemsCount > 1) {\n              e.detail.setDraggedItemsCount(grid.__selectionDraggedItemsCount);\n            }\n          } else {\n            // Dragging just one (non-selected) item\n            (grid.__dragDataTypes || []).forEach(function (type) {\n              e.detail.setDragData(type, e.detail.draggedItems[0].dragData[type]);\n            });\n          }\n        }));\n      })(grid);\n    }\n  };\n})();"
    },
    {
     "id": 329,
     "name": "../node_modules/@vaadin/flow-frontend/ironListConnector.js?babel-target=es5",
     "source": "// Not using ES6 imports in this file yet because the connector in V14 must\n// still work in Legacy bower projects. See: `ironListConnector-es6.js` for \n// the Polymer3 approach.\nwindow.Vaadin.Flow.Legacy = window.Vaadin.Flow.Legacy || {};\nwindow.Vaadin.Flow.ironListConnector = {\n  initLazy: function initLazy(list) {\n    // Check whether the connector was already initialized for the Iron list\n    if (list.$connector) {\n      return;\n    }\n\n    if (window.Polymer) {\n      // Polymer2 approach.\n      window.Vaadin.Flow.Legacy.Debouncer = window.Vaadin.Flow.Legacy.Debouncer || Polymer.Debouncer;\n      window.Vaadin.Flow.Legacy.timeOut = window.Vaadin.Flow.Legacy.timeOut || Polymer.Async.timeOut;\n    } else if (!window.Vaadin.Flow.Legacy.Debouncer) {\n      console.log(\"IronList is unable to load Polymer helpers.\");\n      return;\n    }\n\n    var Debouncer = window.Vaadin.Flow.Legacy.Debouncer;\n    var timeOut = window.Vaadin.Flow.Legacy.timeOut;\n    var extraItemsBuffer = 20;\n    var lastRequestedRange = [0, 0];\n    list.$connector = {};\n    list.$connector.placeholderItem = {\n      __placeholder: true\n    };\n\n    var updateRequestedItem = function updateRequestedItem() {\n      /*\n       * TODO Iron list seems to do a small index adjustment after scrolling\n       * has stopped. This causes a redundant request to be sent to make a\n       * corresponding minimal change to the buffer. We should avoid these\n       * requests by making the logic skip doing a request if the available\n       * buffer is within some tolerance compared to the requested buffer.\n       */\n      var firstNeededItem = list._virtualStart;\n      var lastNeededItem = list._virtualEnd;\n      var first = Math.max(0, firstNeededItem - extraItemsBuffer);\n      var last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);\n\n      if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {\n        lastRequestedRange = [first, last];\n        var count = 1 + last - first;\n        list.$server.setRequestedRange(first, count);\n      }\n    };\n\n    var requestDebounce;\n\n    var scheduleUpdateRequest = function scheduleUpdateRequest() {\n      requestDebounce = Debouncer.debounce(requestDebounce, timeOut.after(10), updateRequestedItem);\n    };\n    /*\n     * Ensure all items that iron list will be looking at are actually defined.\n     * If this is not done, the component will keep looking ahead through the\n     * array until finding enough present items to render. In our case, that's\n     * a really slow way of achieving nothing since the rest of the array is\n     * empty.\n     */\n\n\n    var originalAssign = list._assignModels;\n\n    list._assignModels = function () {\n      var tempItems = [];\n      var start = list._virtualStart;\n      var count = Math.min(list.items.length, list._physicalCount);\n\n      for (var i = 0; i < count; i++) {\n        if (list.items[start + i] === undefined) {\n          tempItems.push(i);\n          list.items[start + i] = list.$connector.placeholderItem;\n        }\n      }\n\n      originalAssign.apply(list, arguments);\n      /*\n       * TODO: Keep track of placeholder items in the \"active\" range and\n       * avoid deleting them so that the next pass will be faster. Instead,\n       * the end of each pass should only delete placeholders that are no\n       * longer needed.\n       */\n\n      for (var _i = 0; _i < tempItems.length; _i++) {\n        delete list.items[start + tempItems[_i]];\n      }\n      /*\n       * Check if we need to do anything once things have settled down.\n       * This method is called multiple times in sequence for the same user\n       * action, but we only want to do the check once.\n       */\n\n\n      scheduleUpdateRequest();\n    };\n\n    list.items = [];\n\n    list.$connector.set = function (index, items) {\n      for (var i = 0; i < items.length; i++) {\n        var itemsIndex = index + i;\n        list.items[itemsIndex] = items[i];\n      } // Do a full render since dirty detection for splices is broken\n\n\n      list._render();\n    };\n\n    list.$connector.updateData = function (items) {\n      // Find the items by key inside the list update them\n      var oldItems = list.items;\n      var mapByKey = {};\n      var leftToUpdate = items.length;\n\n      for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n        mapByKey[item.key] = item;\n      }\n\n      for (var _i2 = 0; _i2 < oldItems.length; _i2++) {\n        var oldItem = oldItems[_i2];\n        var newItem = mapByKey[oldItem.key];\n\n        if (newItem) {\n          list.items[_i2] = newItem;\n          list.notifyPath(\"items.\" + _i2);\n          leftToUpdate--;\n\n          if (leftToUpdate == 0) {\n            break;\n          }\n        }\n      }\n    };\n\n    list.$connector.clear = function (index, length) {\n      for (var i = 0; i < length; i++) {\n        var itemsIndex = index + i;\n        delete list.items[itemsIndex]; // Most likely a no-op since the affected index isn't in view\n\n        list.notifyPath(\"items.\" + itemsIndex);\n      }\n    };\n\n    list.$connector.updateSize = function (newSize) {\n      var delta = newSize - list.items.length;\n\n      if (delta > 0) {\n        list.items.length = newSize;\n        list.notifySplices(\"items\", [{\n          index: newSize - delta,\n          removed: [],\n          addedCount: delta,\n          object: list.items,\n          type: \"splice\"\n        }]);\n      } else if (delta < 0) {\n        var removed = list.items.slice(newSize, list.items.length);\n        list.items.splice(newSize);\n        list.notifySplices(\"items\", [{\n          index: newSize,\n          removed: removed,\n          addedCount: 0,\n          object: list.items,\n          type: \"splice\"\n        }]);\n      }\n    };\n\n    list.$connector.setPlaceholderItem = function (placeholderItem) {\n      if (!placeholderItem) {\n        placeholderItem = {};\n      }\n\n      placeholderItem.__placeholder = true;\n      list.$connector.placeholderItem = placeholderItem;\n    };\n  }\n};"
    },
    {
     "id": 330,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column.js?babel-target=es5",
     "source": "import '../../src/vaadin-grid-column.js';"
    },
    {
     "id": 331,
     "name": "../node_modules/@vaadin/vaadin-details/theme/lumo/vaadin-details-styles.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"<dom-module id=\\\"lumo-details\\\" theme-for=\\\"vaadin-details\\\">\\n  <template>\\n    <style>\\n      :host {\\n        margin: var(--lumo-space-xs) 0;\\n        outline: none;\\n      }\\n\\n      [part=\\\"summary\\\"] {\\n        display: flex;\\n        align-items: center;\\n        width: 100%;\\n        outline: none;\\n        padding: var(--lumo-space-s) 0;\\n        box-sizing: border-box;\\n        font-family: var(--lumo-font-family);\\n        font-size: var(--lumo-font-size-m);\\n        font-weight: 500;\\n        line-height: var(--lumo-line-height-xs);\\n        color: var(--lumo-secondary-text-color);\\n        background-color: inherit;\\n        border-radius: var(--lumo-border-radius-m);\\n        cursor: default;\\n        -webkit-tap-highlight-color: transparent;\\n        -webkit-font-smoothing: antialiased;\\n        -moz-osx-font-smoothing: grayscale;\\n      }\\n\\n      :host([focus-ring]) [part=\\\"summary\\\"] {\\n        box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);\\n      }\\n\\n      [part=\\\"toggle\\\"] {\\n        display: block;\\n        width: 1em;\\n        height: 1em;\\n        margin-left: calc(var(--lumo-space-xs) * -1);\\n        margin-right: var(--lumo-space-xs);\\n        font-size: var(--lumo-icon-size-s);\\n        line-height: 1;\\n        color: var(--lumo-contrast-60pct);\\n        font-family: \\\"lumo-icons\\\";\\n      }\\n\\n      :host([disabled]) [part=\\\"summary\\\"],\\n      :host([disabled]) [part=\\\"toggle\\\"] {\\n        color: var(--lumo-disabled-text-color);\\n      }\\n\\n      @media (hover: hover) {\\n        :host(:not([disabled])) [part=\\\"summary\\\"]:hover,\\n        :host(:not([disabled])) [part=\\\"summary\\\"]:hover [part=\\\"toggle\\\"] {\\n          color: var(--lumo-contrast-80pct);\\n        }\\n      }\\n\\n      [part=\\\"toggle\\\"]::before {\\n        content: var(--lumo-icons-angle-right);\\n      }\\n\\n      :host([opened]) [part=\\\"toggle\\\"] {\\n        transform: rotate(90deg);\\n      }\\n\\n      [part=\\\"content\\\"] {\\n        padding: var(--lumo-space-xs) 0 var(--lumo-space-s);\\n        font-size: var(--lumo-font-size-m);\\n        line-height: var(--lumo-line-height-m);\\n      }\\n\\n      :host([theme~=\\\"filled\\\"]) {\\n        background-color: var(--lumo-contrast-5pct);\\n        border-radius: var(--lumo-border-radius-m);\\n      }\\n\\n      :host([theme~=\\\"filled\\\"]) [part=\\\"summary\\\"] {\\n        padding: var(--lumo-space-s) calc(var(--lumo-space-s) + var(--lumo-space-xs) / 2);\\n      }\\n\\n      :host([theme~=\\\"filled\\\"]) [part=\\\"content\\\"] {\\n        padding-left: var(--lumo-space-m);\\n        padding-right: var(--lumo-space-m);\\n      }\\n\\n      :host([theme~=\\\"small\\\"]) [part=\\\"summary\\\"] {\\n        padding-top: var(--lumo-space-xs);\\n        padding-bottom: var(--lumo-space-xs);\\n      }\\n\\n      :host([theme~=\\\"small\\\"]) [part=\\\"toggle\\\"] {\\n        margin-right: calc(var(--lumo-space-xs) / 2);\\n      }\\n\\n      :host([theme~=\\\"small\\\"]) [part$=\\\"content\\\"] {\\n        font-size: var(--lumo-font-size-s);\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"]) [part=\\\"summary\\\"] {\\n        justify-content: space-between;\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"]) [part=\\\"toggle\\\"] {\\n        order: 1;\\n        margin-right: 0;\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"][theme~=\\\"filled\\\"]) [part=\\\"summary\\\"] {\\n        padding-left: var(--lumo-space-m);\\n      }\\n\\n      /* RTL specific styles */\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"] {\\n        margin-left: var(--lumo-space-xs);\\n        margin-right: calc(var(--lumo-space-xs) * -1);\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"]::before {\\n        content: var(--lumo-icons-angle-left);\\n      }\\n\\n      :host([opened][dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"] {\\n        transform: rotate(-90deg);\\n      }\\n\\n      :host([theme~=\\\"small\\\"][dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"] {\\n        margin-left: calc(var(--lumo-space-xs) / 2);\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"][dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"] {\\n        margin-left: 0;\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"][theme~=\\\"filled\\\"][dir=\\\"rtl\\\"]) [part=\\\"summary\\\"] {\\n        padding-right: var(--lumo-space-m);\\n      }\\n\\n    </style>\\n  </template>\\n</dom-module>\"], [\"<dom-module id=\\\"lumo-details\\\" theme-for=\\\"vaadin-details\\\">\\n  <template>\\n    <style>\\n      :host {\\n        margin: var(--lumo-space-xs) 0;\\n        outline: none;\\n      }\\n\\n      [part=\\\"summary\\\"] {\\n        display: flex;\\n        align-items: center;\\n        width: 100%;\\n        outline: none;\\n        padding: var(--lumo-space-s) 0;\\n        box-sizing: border-box;\\n        font-family: var(--lumo-font-family);\\n        font-size: var(--lumo-font-size-m);\\n        font-weight: 500;\\n        line-height: var(--lumo-line-height-xs);\\n        color: var(--lumo-secondary-text-color);\\n        background-color: inherit;\\n        border-radius: var(--lumo-border-radius-m);\\n        cursor: default;\\n        -webkit-tap-highlight-color: transparent;\\n        -webkit-font-smoothing: antialiased;\\n        -moz-osx-font-smoothing: grayscale;\\n      }\\n\\n      :host([focus-ring]) [part=\\\"summary\\\"] {\\n        box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);\\n      }\\n\\n      [part=\\\"toggle\\\"] {\\n        display: block;\\n        width: 1em;\\n        height: 1em;\\n        margin-left: calc(var(--lumo-space-xs) * -1);\\n        margin-right: var(--lumo-space-xs);\\n        font-size: var(--lumo-icon-size-s);\\n        line-height: 1;\\n        color: var(--lumo-contrast-60pct);\\n        font-family: \\\"lumo-icons\\\";\\n      }\\n\\n      :host([disabled]) [part=\\\"summary\\\"],\\n      :host([disabled]) [part=\\\"toggle\\\"] {\\n        color: var(--lumo-disabled-text-color);\\n      }\\n\\n      @media (hover: hover) {\\n        :host(:not([disabled])) [part=\\\"summary\\\"]:hover,\\n        :host(:not([disabled])) [part=\\\"summary\\\"]:hover [part=\\\"toggle\\\"] {\\n          color: var(--lumo-contrast-80pct);\\n        }\\n      }\\n\\n      [part=\\\"toggle\\\"]::before {\\n        content: var(--lumo-icons-angle-right);\\n      }\\n\\n      :host([opened]) [part=\\\"toggle\\\"] {\\n        transform: rotate(90deg);\\n      }\\n\\n      [part=\\\"content\\\"] {\\n        padding: var(--lumo-space-xs) 0 var(--lumo-space-s);\\n        font-size: var(--lumo-font-size-m);\\n        line-height: var(--lumo-line-height-m);\\n      }\\n\\n      :host([theme~=\\\"filled\\\"]) {\\n        background-color: var(--lumo-contrast-5pct);\\n        border-radius: var(--lumo-border-radius-m);\\n      }\\n\\n      :host([theme~=\\\"filled\\\"]) [part=\\\"summary\\\"] {\\n        padding: var(--lumo-space-s) calc(var(--lumo-space-s) + var(--lumo-space-xs) / 2);\\n      }\\n\\n      :host([theme~=\\\"filled\\\"]) [part=\\\"content\\\"] {\\n        padding-left: var(--lumo-space-m);\\n        padding-right: var(--lumo-space-m);\\n      }\\n\\n      :host([theme~=\\\"small\\\"]) [part=\\\"summary\\\"] {\\n        padding-top: var(--lumo-space-xs);\\n        padding-bottom: var(--lumo-space-xs);\\n      }\\n\\n      :host([theme~=\\\"small\\\"]) [part=\\\"toggle\\\"] {\\n        margin-right: calc(var(--lumo-space-xs) / 2);\\n      }\\n\\n      :host([theme~=\\\"small\\\"]) [part\\\\$=\\\"content\\\"] {\\n        font-size: var(--lumo-font-size-s);\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"]) [part=\\\"summary\\\"] {\\n        justify-content: space-between;\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"]) [part=\\\"toggle\\\"] {\\n        order: 1;\\n        margin-right: 0;\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"][theme~=\\\"filled\\\"]) [part=\\\"summary\\\"] {\\n        padding-left: var(--lumo-space-m);\\n      }\\n\\n      /* RTL specific styles */\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"] {\\n        margin-left: var(--lumo-space-xs);\\n        margin-right: calc(var(--lumo-space-xs) * -1);\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"]::before {\\n        content: var(--lumo-icons-angle-left);\\n      }\\n\\n      :host([opened][dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"] {\\n        transform: rotate(-90deg);\\n      }\\n\\n      :host([theme~=\\\"small\\\"][dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"] {\\n        margin-left: calc(var(--lumo-space-xs) / 2);\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"][dir=\\\"rtl\\\"]) [part=\\\"toggle\\\"] {\\n        margin-left: 0;\\n      }\\n\\n      :host([theme~=\\\"reverse\\\"][theme~=\\\"filled\\\"][dir=\\\"rtl\\\"]) [part=\\\"summary\\\"] {\\n        padding-right: var(--lumo-space-m);\\n      }\\n\\n    </style>\\n  </template>\\n</dom-module>\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html(_templateObject());\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 332,
     "name": "../node_modules/@vaadin/vaadin-details/src/vaadin-details.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: block;\\n      }\\n\\n      :host([hidden]) {\\n        display: none !important;\\n      }\\n\\n      [part=\\\"content\\\"] {\\n        display: none;\\n        overflow: hidden;\\n      }\\n\\n      [part=\\\"summary\\\"][disabled] {\\n        pointer-events: none;\\n      }\\n\\n      :host([opened]) [part=\\\"content\\\"] {\\n        display: block;\\n        overflow: visible;\\n      }\\n    </style>\\n    <div role=\\\"heading\\\">\\n      <div role=\\\"button\\\" part=\\\"summary\\\" on-click=\\\"_onToggleClick\\\" on-keydown=\\\"_onToggleKeyDown\\\" disabled$=\\\"[[disabled]]\\\" aria-expanded$=\\\"[[_getAriaExpanded(opened)]]\\\">\\n        <span part=\\\"toggle\\\"></span>\\n        <span part=\\\"summary-content\\\"><slot name=\\\"summary\\\"></slot></span>\\n      </div>\\n    </div>\\n    <div part=\\\"content\\\" aria-hidden$=\\\"[[_getAriaHidden(opened)]]\\\">\\n      <slot></slot>\\n    </div>\\n\"], [\"\\n    <style>\\n      :host {\\n        display: block;\\n      }\\n\\n      :host([hidden]) {\\n        display: none !important;\\n      }\\n\\n      [part=\\\"content\\\"] {\\n        display: none;\\n        overflow: hidden;\\n      }\\n\\n      [part=\\\"summary\\\"][disabled] {\\n        pointer-events: none;\\n      }\\n\\n      :host([opened]) [part=\\\"content\\\"] {\\n        display: block;\\n        overflow: visible;\\n      }\\n    </style>\\n    <div role=\\\"heading\\\">\\n      <div role=\\\"button\\\" part=\\\"summary\\\" on-click=\\\"_onToggleClick\\\" on-keydown=\\\"_onToggleKeyDown\\\" disabled\\\\$=\\\"[[disabled]]\\\" aria-expanded\\\\$=\\\"[[_getAriaExpanded(opened)]]\\\">\\n        <span part=\\\"toggle\\\"></span>\\n        <span part=\\\"summary-content\\\"><slot name=\\\"summary\\\"></slot></span>\\n      </div>\\n    </div>\\n    <div part=\\\"content\\\" aria-hidden\\\\$=\\\"[[_getAriaHidden(opened)]]\\\">\\n      <slot></slot>\\n    </div>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2019 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-details>` is a Web Component which the creates an\n * expandable panel similar to `<details>` HTML element.\n *\n * ```\n * <vaadin-details>\n *   <div slot=\"summary\">Expandable Details</div>\n *   Toggle using mouse, Enter and Space keys.\n * </vaadin-details>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are exposed for styling:\n *\n * Part name        | Description\n * -----------------|----------------\n * `summary`        | The element used to open and close collapsible content.\n * `toggle`         | The element used as indicator, can represent an icon.\n * `summary-content`| The wrapper for the slotted summary content.\n * `content`        | The wrapper for the collapsible details content.\n *\n * The following attributes are exposed for styling:\n *\n * Attribute    | Description\n * -------------| -----------\n * `opened`     | Set when the collapsible content is expanded and visible.\n * `disabled`   | Set when the element is disabled.\n * `focus-ring` | Set when the element is focused using the keyboard.\n * `focused`    | Set when the element is focused.\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ControlStateMixin\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nvar DetailsElement = /*#__PURE__*/function (_ControlStateMixin) {\n  _inherits(DetailsElement, _ControlStateMixin);\n\n  var _super = _createSuper(DetailsElement);\n\n  function DetailsElement() {\n    _classCallCheck(this, DetailsElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(DetailsElement, [{\n    key: \"ready\",\n    value: function ready() {\n      _get(_getPrototypeOf(DetailsElement.prototype), \"ready\", this).call(this); // prevent Shift + Tab on content from host blur\n\n\n      this._collapsible.addEventListener('keydown', function (e) {\n        if (e.shiftKey && e.keyCode === 9) {\n          e.stopPropagation();\n        }\n      });\n    }\n    /** @private */\n\n  }, {\n    key: \"_getAriaExpanded\",\n    value: function _getAriaExpanded(opened) {\n      return opened ? 'true' : 'false';\n    }\n    /** @private */\n\n  }, {\n    key: \"_getAriaHidden\",\n    value: function _getAriaHidden(opened) {\n      return opened ? 'false' : 'true';\n    }\n    /** @private */\n\n  }, {\n    key: \"_openedChanged\",\n    value: function _openedChanged(opened) {\n      this._collapsible.style.maxHeight = opened ? '' : '0px';\n    }\n    /**\n     * @param {!MouseEvent} e\n     * @protected\n     */\n\n  }, {\n    key: \"_onToggleClick\",\n    value: function _onToggleClick(e) {\n      this.opened = !this.opened;\n    }\n    /**\n     * @param {!KeyboardEvent} e\n     * @protected\n     */\n\n  }, {\n    key: \"_onToggleKeyDown\",\n    value: function _onToggleKeyDown(e) {\n      if ([13, 32].indexOf(e.keyCode) > -1) {\n        e.preventDefault();\n        this.opened = !this.opened;\n      }\n    }\n  }, {\n    key: \"_collapsible\",\n\n    /**\n     * @return {!HTMLElement}\n     * @protected\n     */\n    get: function get() {\n      return this.shadowRoot.querySelector('[part=\"content\"]');\n    }\n    /**\n     * Focusable element used by vaadin-control-state-mixin\n     * @return {!HTMLElement}\n     * @protected\n     */\n\n  }, {\n    key: \"focusElement\",\n    get: function get() {\n      return this.shadowRoot.querySelector('[part=\"summary\"]');\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-details';\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return '1.2.0';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * If true, the details content is visible.\n         * @type {boolean}\n         */\n        opened: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true,\n          notify: true,\n          observer: '_openedChanged'\n        }\n      };\n    }\n  }]);\n\n  return DetailsElement;\n}(ControlStateMixin(ElementMixin(ThemableMixin(PolymerElement))));\n\ncustomElements.define(DetailsElement.is, DetailsElement);\nexport { DetailsElement };"
    },
    {
     "id": 333,
     "name": "../node_modules/@vaadin/vaadin-board/theme/lumo/vaadin-board-row.js?babel-target=es5",
     "source": "import '../../src/vaadin-board-row.js';"
    },
    {
     "id": 334,
     "name": "../node_modules/@vaadin/vaadin-charts/src/vaadin-chart.js?babel-target=es5",
     "source": "import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: block;\\n        width: 100%;\\n        overflow: hidden;\\n      }\\n\\n      :host([hidden]) {\\n        display: none !important;\\n      }\\n    </style>\\n    <div id=\\\"chart\\\"></div>\\n    <slot id=\\\"slot\\\"></slot>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nVaadin Charts\nCopyright (C) 2015 Vaadin Ltd\nThis program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).\nSee the file LICENSE.md distributed with this software for more information about licensing.\nSee <a href=\"https://vaadin.com/license/cval-3\">the website</a> for the complete license.\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { beforeNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport '@vaadin/vaadin-license-checker/vaadin-license-checker.js';\nimport { ChartSeriesElement } from './vaadin-chart-series.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { nativeShadow } from '@webcomponents/shadycss/src/style-settings.js';\nimport ScopingShim from '@webcomponents/shadycss/src/scoping-shim.js';\nimport Highcharts from 'highcharts/js/es-modules/masters/highstock.src.js';\nimport 'highcharts/js/es-modules/masters/modules/accessibility.src.js';\nimport 'highcharts/js/es-modules/masters/highcharts-more.src.js';\nimport 'highcharts/js/es-modules/masters/highcharts-3d.src.js';\nimport 'highcharts/js/es-modules/masters/modules/data.src.js';\nimport 'highcharts/js/es-modules/masters/modules/drilldown.src.js';\nimport 'highcharts/js/es-modules/masters/modules/exporting.src.js';\nimport 'highcharts/js/es-modules/masters/modules/funnel.src.js';\nimport 'highcharts/js/es-modules/masters/modules/heatmap.src.js';\nimport 'highcharts/js/es-modules/masters/modules/solid-gauge.src.js';\nimport 'highcharts/js/es-modules/masters/modules/treemap.src.js';\nimport 'highcharts/js/es-modules/masters/modules/no-data-to-display.src.js';\n/** @private */\n// eslint-disable-next-line no-unused-vars\n\nexport var ChartDeepMerger = function () {\n  return /*#__PURE__*/function () {\n    function _class() {\n      _classCallCheck(this, _class);\n    }\n\n    _createClass(_class, null, [{\n      key: \"__isObject\",\n      value: function __isObject(item) {\n        return item && _typeof(item) === 'object' && !Array.isArray(item);\n      }\n    }, {\n      key: \"__deepMerge\",\n      value: function __deepMerge(target, source) {\n        if (this.__isObject(source) && this.__isObject(target)) {\n          for (var key in source) {\n            if (this.__isObject(source[key])) {\n              if (!target[key]) {\n                Object.assign(target, _defineProperty({}, key, {}));\n              }\n\n              this.__deepMerge(target[key], source[key]);\n            } else {\n              Object.assign(target, _defineProperty({}, key, source[key]));\n            }\n          }\n        }\n\n        return target;\n      }\n    }]);\n\n    return _class;\n  }();\n}();\n\nif (Highcharts) {\n  ['exportChart', 'exportChartLocal', 'getSVG'].forEach(function (methodName) {\n    Highcharts.wrap(Highcharts.Chart.prototype, methodName, function (proceed) {\n      Highcharts.fireEvent(this, 'beforeExport');\n      var result = proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n      Highcharts.fireEvent(this, 'afterExport');\n      return result;\n    });\n  });\n}\n\nif (Highcharts) {\n  Highcharts.wrap(Highcharts.seriesTypes.column.prototype, 'plotGroup', function (proceed, prop, name, visibility, zIndex, parent) {\n    if (this.chart.is3d() && this[prop]) {\n      delete this[prop];\n    }\n\n    return proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n  });\n}\n\nif (!PolymerElement) {\n  console.warn(\"Unexpected Polymer version \".concat(Polymer.version, \" is used, expected v2.0.0 or later.\"));\n}\n/**\n * `<vaadin-chart>` is a Web Component for creating high quality charts.\n *\n * ### Quick Start\n *\n * #### Polymer 2 App\n *\n * 1. Create a Polymer application using [Polymer CLI](https://www.polymer-project.org/2.0/docs/tools/polymer-cli)\n * ```\n * mkdir my-app\n * cd my-app\n * polymer init\n * select `polymer-2-application`\n * ```\n * 1. Install Vaadin Charts\n * ```\n * bower install --save vaadin-charts#6.3.1\n * ```\n * 1. Import `<vaadin-chart>` to your app\n * Edit the file `src/my-app/my-app.html` and add the following snipped before the `<dom-module>` tag\n * ```html\n * <link rel=\"import\" href=\"../../bower_components/vaadin-charts/vaadin-chart.html\">\n * ```\n * 1. Add your first `<vaadin-chart>`\n * Also in `my-app.html` add the following snippet before the `</template>` closing tag\n * ```html\n * <vaadin-chart></vaadin-chart>\n * ```\n * 1. Run your app with:\n * ```\n * polymer serve --open\n * ```\n *\n * #### Polymer 3 App\n *\n * * 1. Create a Polymer application using [Polymer CLI](https://www.polymer-project.org/3.0/docs/tools/polymer-cli)\n * ```\n * mkdir my-app\n * cd my-app\n * polymer init\n * select `polymer-3-application`\n * ```\n * 1. Install Vaadin Charts\n * ```\n * npm i @vaadin/vaadin-charts@6.3.0 --save\n * ```\n * 1. Import `<vaadin-chart>` to your app\n * Edit the file `src/my-app/my-app.js` and add the following snipped on the top, after the first `import` declaration\n * ```js\n * import '@vaadin/vaadin-charts';\n * ```\n * 1. Add your first `<vaadin-chart>`\n * Also in `my-app.js`, at the template getter, add the following snippet after the `</h2>` closing tag\n * ```html\n * <vaadin-chart></vaadin-chart>\n * ```\n * 1. Run your app with:\n * ```\n * polymer serve --npm --open\n * ```\n *\n * Congratulations! You have your first Vaadin Chart setup.\n *\n * ### Basic use\n *\n * Now that we covered the basic steps to create an empty chart, let us show how you can configure it.\n *\n * There are two ways of configuring your `<vaadin-chart>` element: **HTML API**, **JS API** and **JSON API**.\n * Note that you can make use of all APIs in your element.\n *\n * #### Configuring your chart using HTML API\n *\n * `vaadin-chart` has a set of attributes to make it easier for you to customize your chart.\n * Using as a base the project created with in Quick Start:\n *\n * ```html\n *  <vaadin-chart title=\"The chart title\" subtitle=\"The chart subtitle\">\n *    <vaadin-chart-series\n *          type=\"column\"\n *          title=\"The series title\"\n *          values=\"[10,20,30]\">\n *    </vaadin-chart-series>\n *  </vaadin-chart>\n * ```\n *\n * > Note that while you can set type for each series individually, for some types, such as `'bar'`, `'gauge'` and `'solidgauge'`, you\n * > have to set it as the default series type on `<vaadin-chart>` in order to work properly.\n *\n * #### Configuring your chart using JS API\n *\n * Using as a base the project created with in Quick Start\n *\n * Do the following changes in `my-app.html`\n *\n * 1. Set and id for the `<vaadin-chart>` in the template\n * ```html\n *     <vaadin-chart id=\"mychart\"></vaadin-chart>\n * ```\n * 1. Add a function that uses `configuration` property (JS Api) to set chart title, categories and data\n * ```js\n * initChartWithJSApi() {\n *     Polymer.RenderStatus.beforeNextRender(this, () => {\n *        const configuration = this.$.mychart.configuration;\n *        configuration.setTitle({ text: 'The chart title' });\n *        // By default there is one x axis, it is referenced by configuration.xAxis[0].\n *        configuration.xAxis[0].setCategories(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);\n *        configuration.addSeries({\n *            type: 'column',\n *            data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]\n *        });\n *     });\n * }\n * ```\n * 1. Call that function from connectedCallback (when the element is added to a document)\n * ```js\n * connectedCallback() {\n *     super.connectedCallback();\n *     this.initChartWithJSApi();\n * }\n * ```\n * 1. And finally run your app with:\n * ```\n * polymer serve --open\n * ```\n *\n *\n * #### Configuring your chart using JS JSON API\n *\n * JS JSON API is a simple alternative to the JS API.\n *\n * Using as a base the project created with in Quick Start\n *\n * Do the following changes in `my-app.html`\n *\n * 1. Set and id for the `<vaadin-chart>` in the template\n * ```html\n *     <vaadin-chart id=\"mychart\"></vaadin-chart>\n * ```\n * 1. Add a function that uses `update` method (JS JSON Api) to set chart title, categories and data\n * ```js\n * initChartWithJSJSONApi() {\n *     this.$.mychart.update({\n *       title: {\n *         text: 'The chart title'\n *       },\n *       subtitle: {\n *         text: 'Subtitle'\n *       },\n *       xAxis: {\n *         categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n *       },\n *       series: [{\n *         type: 'column',\n *         data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]\n *       }]\n *     });\n * }\n * ```\n * 1. Call that function from connectedCallback (when the element is added to a document)\n * ```js\n * connectedCallback() {\n *     super.connectedCallback();\n *     this.initChartWithJSJSONApi();\n * }\n * ```\n * 1. And finally run your app with:\n * ```\n * polymer serve --open\n * ```\n *\n * It should be noted that chart style customization cannot be done via the JS or JSON API.\n * Styling properties in the JSON configuration will be ignored. The following section discusses chart styling.\n *\n *\n * ### CSS Styling\n * Chart appearance is primarily controlled by CSS style rules.\n * A comprehensive list of the supported style classes can be found at\n * https://www.highcharts.com/docs/chart-design-and-style/style-by-css\n *\n *\n * ### Steps for styling a chart\n *\n * 1. Create a theme file (for example `shared-styles.html`). The theme's dom-module must declare `theme-for=vaadin-chart`.\n * 2. Import `vaadin-chart-default-theme.html` and declare `include=\"vaadin-chart-default-theme\"`\n * on the theme module's style tag to customize Chart's default theme. If there are multiple theme\n * modules *only one* of them should declare this `include`.\n * 3. Specify the desired CSS rules in the theme file.\n * 4. If multiple charts are present, each one can be specifically targeted using the host selector e.g `:host(.my-chart-class)`.\n * 5. Import the theme file.\n *\n *\n * ### Example: Two Charts with a Red Title but only one with a Blue Subtitle\n *\n * ```html\n * <link rel=\"import\" href=\"shared-styles.html\">\n * ...\n * <vaadin-chart title=\"Red Title\" subtitle=\"Not Styled\">\n *   <vaadin-chart-series values=\"[19,12,9,24,5]\"></vaadin-chart-series>\n * </vaadin-chart>\n *\n * <vaadin-chart class=\"blue-subtitle\" title=\"Red Title\" subtitle=\"Blue Subtitle\">\n *   <vaadin-chart-series values=\"[19,12,9,24,5]\"></vaadin-chart-series>\n * </vaadin-chart>\n * ```\n *\n * shared-styles.html\n *\n * ```html\n * <link rel=\"import\" href=\"../bower_components/vaadin-charts/theme/vaadin-chart-default-theme.html\">\n *\n * <dom-module id=\"css-style-example\" theme-for=\"vaadin-chart\">\n *    <template>\n *      <style include=\"vaadin-chart-default-theme\">\n *        .highcharts-title {\n *          fill: red;\n *          font-size: xx-large;\n *        }\n *\n *        :host(.blue-subtitle) .highcharts-subtitle {\n *          fill: blue;\n *        }\n *      </style>\n *    </template>\n * </dom-module>\n * ```\n *\n * ### RTL support\n *\n * `vaadin-charts` as well as [Highcharts](https://www.highcharts.com/) by itself are not adjusting the layout\n * based on the `dir` attribute. In order to make `vaadin-charts` display RTL content properly additional\n * JSON configuration should be used.\n * Each chart should be updated based on the specific needs, but general recommendations are:\n *\n *  1. Set `reversed` to true for xAxis (https://api.highcharts.com/highcharts/xAxis.reversed).\n *  2. Set `useHTML` to true for text elements, i.e. `tooltip` (https://api.highcharts.com/highcharts/tooltip.useHTML).\n *  3. Set `rtl` to true for `legend` (https://api.highcharts.com/highcharts/legend.rtl).\n *\n * Using as a base the project created with in Quick Start and an `additionalOptions` in order to make RTL adjustments:\n *\n * ```html\n *  <vaadin-chart title=\"-  \" subtitle=\"-   \"\n *    additional-options='{\"title\": {\"useHTML\": true}, \"tooltip\": {\"useHTML\": true}, \"subtitle\": {\"useHTML\": true},\n *    \"legend\": {\"rtl\": true}, \"yAxis\": [{\"id\": \"- \", \"title\": {\"text\": \"- \", \"useHTML\": true}}],\n *    \"xAxis\": {\"reversed\": true}}'>\n *    <vaadin-chart-series\n *          type= \"column\"\n *          title=\"-  \"\n *          unit=\"- \"\n *          values=\"[10,20,30]\">\n *    </vaadin-chart-series>\n *  </vaadin-chart>\n * ```\n *\n * ### Setting colors\n *\n * Although charts can be styled as described above, there is a simpler way for setting colors.\n * Colors can be set using CSS custom properties `--vaadin-charts-color-{n}` (where `n` goes from `0 - 9`).\n *\n * For example `--vaadin-charts-color-0` sets the color of the first series on a chart.\n *\n * ### Validating your License\n * After one day using Vaadin Charts in a development environment you will see a pop-up that asks you\n * to validate your license by signing in to vaadin.com.\n *\n * @extends PolymerElement\n * @demo demo/index.html\n */\n\n\nvar ChartElement = /*#__PURE__*/function (_ElementMixin) {\n  _inherits(ChartElement, _ElementMixin);\n\n  var _super = _createSuper(ChartElement);\n\n  _createClass(ChartElement, null, [{\n    key: \"_finalizeClass\",\n\n    /**\n     * @protected\n     */\n    value: function _finalizeClass() {\n      _get(_getPrototypeOf(ChartElement), \"_finalizeClass\", this).call(this);\n\n      var devModeCallback = window.Vaadin.developmentModeCallback;\n      var licenseChecker = devModeCallback && devModeCallback['vaadin-license-checker'];\n\n      if (typeof licenseChecker === 'function') {\n        licenseChecker(ChartElement);\n      }\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-chart';\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return '6.3.0';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * Configuration object that exposes the JS Api to configure the chart.\n         *\n         * Most important methods are:\n         * - `addSeries (Object options, [Boolean redraw], [Mixed animation])`\n         * - `addAxis (Object options, [Boolean isX], [Boolean redraw], [Mixed animation])`\n         * - `setTitle (Object title, object subtitle, Boolean redraw)`\n         *\n         * Most important properties are:\n         * - `configuration.series`: An array of the chart's series. Detailed API for Series object is\n         *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Series)\n         * - `configuration.xAxis`: An array of the chart's x axes. Detailed API for Axis object is\n         *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)\n         * - `configuration.yAxis`: An array of the chart's y axes. Detailed API for Axis object is\n         *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)\n         * - `configuration.title`: The chart title.\n         *\n         * For detailed documentation of available API check the [API site](http://api.highcharts.com/class-reference/classes.list)\n         * @readonly\n         * @public\n         * @type {Object}\n         */\n        configuration: Object,\n\n        /**\n         * If categories are present names are used instead of numbers for the category axis.\n         * The format of categories can be an `Array` with a list of categories, such as `['2010', '2011', '2012']`\n         * or a mapping `Object`, like `{0:'1',9:'Target (10)', 15: 'Max'}`.\n         */\n        categories: {\n          type: Object,\n          reflectToAttribute: true,\n          observer: '__updateCategories'\n        },\n\n        /**\n         * Category-axis maximum value. Defaults to `undefined`.\n         */\n        categoryMax: {\n          type: Number,\n          observer: '__updateCategoryMax',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Category-axis minimum value. Defaults to `undefined`.\n         */\n        categoryMin: {\n          type: Number,\n          observer: '__updateCategoryMin',\n          reflectToAttribute: true\n        },\n\n        /**\n         * The position of the category axis. Acceptable values are `left`, `right`, `top` and `bottom`\n         * except for bar charts which only accept `left` and `right`.\n         * With the default value, charts appear as though they have `category-position=\"bottom\"`\n         * except for bar charts that appear as though they have `category-position=\"left\"`.\n         *\n         * Defaults to `undefined`\n         */\n        categoryPosition: {\n          type: String,\n          observer: '__updateCategoryPosition',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Specifies whether to hide legend or show.\n         * Legend configuration can be set up via additionalOptions property\n         */\n        noLegend: {\n          type: Boolean,\n          observer: '__hideLegend',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Specifies how series are stacked on top of each other.\n         * Possible values are null, \"normal\" or \"percent\".\n         * If \"stack\" property is not defined on the vaadin-chart-series elements, then series will be put into\n         * the default stack.\n         */\n        stacking: {\n          type: String,\n          observer: '__stackingObserver',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Specifies whether the chart is a normal chart or a timeline chart.\n         */\n        timeline: {\n          type: Boolean,\n          reflectToAttribute: true\n        },\n\n        /**\n         * Represents the title of the chart.\n         */\n        title: {\n          type: String,\n          observer: '__updateTitle',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Whether or not to show tooltip when hovering data points.\n         */\n        tooltip: {\n          type: Boolean,\n          observer: '__tooltipObserver',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Sets the default series type of the chart.\n         * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type.\n         */\n        type: {\n          type: String,\n          observer: '__updateType',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Represents the subtitle of the chart.\n         */\n        subtitle: {\n          type: String,\n          observer: '__updateSubtitle',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Specifies whether to show chart in 3 or in 2 dimensions.\n         * Some display angles are added by default to the \"chart.options3d\" (`{alpha: 15, beta: 15, depth: 50}`).\n         * 3D display options can be modified via `additionalOptions`.\n         * The thickness of a Pie chart can be set on `additionalOptions` through `plotOptions.pie.depth`.\n         * 3D is supported by Bar, Column, Pie and Scatter3D charts.\n         * More info available at [Highcharts](https://www.highcharts.com/docs/chart-concepts/3d-charts).\n         */\n        chart3d: {\n          type: Boolean,\n          observer: '__chart3dObserver',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Specifies the message displayed on a chart without displayable data.\n         */\n        emptyText: {\n          type: String,\n          value: ' ',\n          observer: '__emptyTextObserver',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Represents additional JSON configuration.\n         */\n        additionalOptions: {\n          type: Object,\n          reflectToAttribute: true\n        },\n\n        /**\n         * When present, cartesian charts like line, spline, area and column are transformed\n         * into the polar coordinate system.\n         */\n        polar: {\n          type: Boolean,\n          reflectToAttribute: true,\n          observer: '__polarObserver'\n        }\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['__updateAdditionalOptions(additionalOptions.*)'];\n    }\n  }]);\n\n  function ChartElement() {\n    var _this;\n\n    _classCallCheck(this, ChartElement);\n\n    _this = _super.call(this);\n    /**\n     * List of properties that will always be copied from the chart element to the container div\n     **/\n\n    _this._copyStyleProperties = ['flex', '-webkit-flex', '-ms-flex'];\n    _this._baseConfig = {\n      credits: {\n        enabled: false\n      },\n      exporting: {\n        enabled: false\n      },\n      title: {\n        text: null\n      },\n      series: [],\n      xAxis: {},\n      yAxis: {\n        axisGenerated: true\n      }\n    };\n    _this._baseChart3d = {\n      enabled: true,\n      alpha: 15,\n      beta: 15,\n      depth: 50\n    };\n    _this.__mutationCallback = _this.__mutationCallback.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /** @private */\n\n\n  _createClass(ChartElement, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(ChartElement.prototype), \"connectedCallback\", this).call(this);\n\n      this.__updateStyles();\n\n      beforeNextRender(this, function () {\n        // Detect if the chart had already been initialized. This might happen in\n        // environments where the chart is lazily attached (e.g Grid).\n        if (_this2.configuration) {\n          _this2.__reflow();\n\n          return;\n        }\n\n        var options = Object.assign({}, _this2.options, _this2._jsonConfigurationBuffer);\n        _this2._jsonConfigurationBuffer = null;\n\n        _this2.__initChart(options);\n\n        _this2.__addChildObserver();\n\n        var config = {\n          attributes: true,\n          characterData: true\n        };\n        _this2.__mutationObserver = new MutationObserver(_this2.__mutationCallback);\n\n        _this2.__mutationObserver.observe(_this2, config);\n      });\n    }\n  }, {\n    key: \"__reflow\",\n    value: function __reflow() {\n      var _this3 = this;\n\n      if (!this.configuration) {\n        return;\n      }\n\n      beforeNextRender(this, function () {\n        _this3.configuration.reflow();\n      });\n    }\n  }, {\n    key: \"__mutationCallback\",\n    value: function __mutationCallback() {\n      var _this$getBoundingClie = this.getBoundingClientRect(),\n          componentHeight = _this$getBoundingClie.height;\n\n      var chartHeight = this.configuration.chartHeight;\n\n      if (componentHeight !== chartHeight) {\n        this.__reflow();\n      }\n    }\n  }, {\n    key: \"__addChildObserver\",\n    value: function __addChildObserver() {\n      var _this4 = this;\n\n      beforeNextRender(this, function () {\n        _this4._childObserver = new FlattenedNodesObserver(_this4.$.slot, function (info) {\n          _this4.__addSeries(info.addedNodes.filter(_this4.__filterSeriesNodes));\n\n          _this4.__removeSeries(info.removedNodes.filter(_this4.__filterSeriesNodes));\n\n          _this4.__cleanupAfterSeriesRemoved(info.removedNodes.filter(_this4.__filterSeriesNodes));\n        });\n      });\n    }\n  }, {\n    key: \"__filterSeriesNodes\",\n    value: function __filterSeriesNodes(node) {\n      return node.nodeType === Node.ELEMENT_NODE && node instanceof ChartSeriesElement;\n    }\n  }, {\n    key: \"__addSeries\",\n    value: function __addSeries(series) {\n      if (this.__isSeriesEmpty(series)) {\n        return;\n      }\n\n      var seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);\n      var yAxes = this.configuration.yAxis.reduce(function (acc, axis, index) {\n        acc[axis.options.id || index] = axis;\n        return acc;\n      }, {});\n\n      for (var i = 0, len = series.length; i < len; i++) {\n        var seriesElement = series[i];\n        var _seriesElement$option = seriesElement.options,\n            unit = _seriesElement$option.yAxis,\n            valueMin = _seriesElement$option.yAxisValueMin,\n            valueMax = _seriesElement$option.yAxisValueMax;\n        var idxOnChildList = seriesNodes.indexOf(seriesElement);\n\n        if (!unit && !this.configuration.yAxis.some(function (e) {\n          return e.userOptions.id === undefined;\n        })) {\n          yAxes[unit] = this.__addAxis({\n            axisGenerated: true\n          });\n        } else if (unit && !yAxes[unit]) {\n          yAxes[unit] = this.__addAxis({\n            id: unit,\n            title: {\n              text: unit\n            },\n            axisGenerated: true\n          });\n        }\n\n        if (isFinite(valueMin)) {\n          this.__setYAxisProps(yAxes, unit, {\n            min: valueMin\n          });\n        }\n\n        if (isFinite(valueMax)) {\n          this.__setYAxisProps(yAxes, unit, {\n            max: valueMax\n          });\n        }\n\n        var seriesConfiguration = this.__updateOrAddSeriesInstance(seriesElement.options, idxOnChildList);\n\n        seriesElement.setSeries(seriesConfiguration);\n      }\n\n      this.__removeAxisIfEmpty();\n    }\n  }, {\n    key: \"__removeSeries\",\n    value: function __removeSeries(seriesNodes) {\n      if (this.__isSeriesEmpty(seriesNodes)) {\n        return;\n      }\n\n      seriesNodes.forEach(function (series) {\n        if (series instanceof ChartSeriesElement) {\n          series._series.remove();\n        }\n      });\n    }\n  }, {\n    key: \"__setYAxisProps\",\n    value: function __setYAxisProps(yAxes, yAxisId, props) {\n      if (yAxisId) {\n        yAxes[yAxisId].update(props);\n      } else {\n        this.configuration.yAxis[0].update(props);\n      }\n    }\n  }, {\n    key: \"__isSeriesEmpty\",\n    value: function __isSeriesEmpty(series) {\n      return series === null || series.length === 0;\n    }\n  }, {\n    key: \"__cleanupAfterSeriesRemoved\",\n    value: function __cleanupAfterSeriesRemoved(series) {\n      if (this.__isSeriesEmpty(series)) {\n        return;\n      }\n\n      this.__removeAxisIfEmpty(); // Best effort to make chart display custom empty-text messages when series are removed.\n      // This is needed because Highcharts currently doesn't react. A condition not catered for is\n      // when all points are removed from all series without removing any series.\n\n\n      var isEmpty = this.configuration.series.length === 0 || this.configuration.series.map(function (e) {\n        return e.data.length === 0;\n      }).reduce(function (e1, e2) {\n        return e1 && e2;\n      }, true);\n\n      if (isEmpty) {\n        this.configuration.hideNoData();\n        this.configuration.showNoData(this.emptyText);\n      }\n    }\n  }, {\n    key: \"__initChart\",\n    value: function __initChart(options) {\n      this.__initEventsListeners(options); // Workaround for https://github.com/highcharts/highcharts/issues/7523\n\n\n      this.__ensureObjectPath(options, 'drilldown.activeDataLabelStyle');\n\n      if (this.timeline) {\n        this.configuration = Highcharts.stockChart(this.$.chart, options);\n      } else {\n        this.configuration = Highcharts.chart(this.$.chart, options);\n      } // Workaround for https://github.com/highcharts/highcharts/issues/9978\n\n\n      var elementsToChange = [].concat(_toConsumableArray(Array.from(this.$.chart.getElementsByTagName('h4')).filter(function (el) {\n        return el.style.left === '-9999px';\n      })), [this.configuration.screenReaderRegion, this.configuration.tabExitAnchor]);\n      elementsToChange.forEach(function (el) {\n        if (el && el.style) {\n          el.style.left = '';\n          el.style.top = '-999em';\n        }\n      });\n    }\n    /** @private */\n\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(ChartElement.prototype), \"disconnectedCallback\", this).call(this);\n\n      this.__mutationObserver && this.__mutationObserver.disconnect();\n      this._childObserver && this._childObserver.disconnect();\n    }\n    /**\n     * Search for axis with given `id`.\n     *\n     * @param {String} id contains the id that will be searched\n     * @param {Boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.\n     */\n\n  }, {\n    key: \"__getAxis\",\n    value: function __getAxis(id, isXAxis) {\n      id = Number.parseInt(id) || id;\n\n      if (this.configuration) {\n        return (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).find(function (axis) {\n          return axis.options.id === id;\n        });\n      }\n    }\n    /**\n     * Add an axis with given options\n     *\n     * @param {Object} options axis options\n     * @param {Boolean} isXAxis indicates if axis is X (`true`) or Y (`false`). Defaults to `false`.\n     */\n\n  }, {\n    key: \"__addAxis\",\n    value: function __addAxis(options, isXAxis) {\n      if (this.configuration) {\n        this.__createEventListeners(isXAxis ? this.__xAxesEventNames : this.__yAxesEventNames, options, 'events', 'axis');\n\n        return this.configuration.addAxis(options, isXAxis);\n      }\n    }\n    /**\n     * Iterates over axes (y or x) and removes whenever it doesn't contain any series and was created for unit\n     *\n     * @param {Boolean}  isXAxis indicates if it will remove x or y axes. Defaults to `false`.\n     */\n\n  }, {\n    key: \"__removeAxisIfEmpty\",\n    value: function __removeAxisIfEmpty(isXAxis) {\n      if (this.configuration) {\n        (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).forEach(function (axis) {\n          if (axis.userOptions.axisGenerated && axis.series.length === 0) {\n            axis.remove();\n          }\n        });\n      }\n    }\n    /**\n     * Update the chart configuration.\n     * This JSON API provides a simple single-argument alternative to the configuration property.\n     *\n     * Styling properties specified in this configuration will be ignored. To learn about chart styling\n     * please see the CSS Styling section above.\n     *\n     * @param {Object} jsonConfiguration Object chart configuration. Most important properties are:\n     *\n     * - chart `Object` with options regarding the chart area and plot area as well as general chart options.\n     *    Detailed API for chart object is available in [API Site](http://api.highcharts.com/highcharts/chart)\n     * - credits `Object` with options regarding the chart area and plot area as well as general chart options.\n     *    Detailed API for credits object is available in [API Site](http://api.highcharts.com/highcharts/credits)\n     * - labels `Object[]` with HTML labels that can be positioned anywhere in the chart area\n     *    Detailed API for labels object is available in [API Site](http://api.highcharts.com/highcharts/labels)\n     * - plotOptions `Object` wrapper for config objects for each series type.\n     *    Detailed API for plotOptions object is available in [API Site](http://api.highcharts.com/highcharts/plotOptions)\n     * - series `Object[]` the actual series to append to the chart.\n     *    Detailed API for series object is available in [API Site](http://api.highcharts.com/highcharts/series)\n     * - subtitle `Object` the chart's subtitle.\n     *    Detailed API for subtitle object is available in [API Site](http://api.highcharts.com/highcharts/subtitle)\n     * - title `Object` the chart's main title.\n     *    Detailed API for title object is available in [API Site](http://api.highcharts.com/highcharts/title)\n     * - tooltip `Object` Options for the tooltip that appears when the user hovers over a series or point.\n     *    Detailed API for tooltip object is available in [API Site](http://api.highcharts.com/highcharts/tooltip)\n     * - xAxis `Object[]` The X axis or category axis. Normally this is the horizontal axis.\n     *    Detailed API for xAxis object is available in [API Site](http://api.highcharts.com/highcharts/xAxis)\n     * - yAxis `Object[]` The Y axis or value axis. Normally this is the vertical axis.\n     *    Detailed API for yAxis object is available in [API Site](http://api.highcharts.com/highcharts/yAxis)\n     * - zAxis `Object[]` The Z axis or depth axis for 3D plots.\n     *    Detailed API for zAxis object is available in [API Site](http://api.highcharts.com/highcharts/zAxis)\n     *\n     * @param {Boolean} resetConfiguration Optional boolean that should be set to true if no other chart configuration was set before or\n     *    if existing configuration should be discarded.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(jsonConfiguration, resetConfiguration) {\n      var _this5 = this;\n\n      if (resetConfiguration || !this._jsonConfigurationBuffer) {\n        this._jsonConfigurationBuffer = {};\n      }\n\n      var configCopy = ChartDeepMerger.__deepMerge({}, jsonConfiguration);\n\n      this.__inflateFunctions(configCopy);\n\n      this._jsonConfigurationBuffer = this.__makeConfigurationBuffer(this._jsonConfigurationBuffer, configCopy);\n      beforeNextRender(this, function () {\n        if (!_this5.configuration || !_this5._jsonConfigurationBuffer) {\n          return;\n        }\n\n        if (resetConfiguration) {\n          var initialOptions = Object.assign({}, _this5.options, _this5._jsonConfigurationBuffer);\n\n          _this5.__initChart(initialOptions);\n\n          _this5._jsonConfigurationBuffer = null;\n          return;\n        }\n\n        _this5.configuration.update(_this5._jsonConfigurationBuffer);\n\n        if (_this5._jsonConfigurationBuffer.credits) {\n          _this5.__updateOrAddCredits(_this5._jsonConfigurationBuffer.credits);\n        }\n\n        if (_this5._jsonConfigurationBuffer.xAxis) {\n          _this5.__updateOrAddAxes(_this5._jsonConfigurationBuffer.xAxis, true);\n        }\n\n        if (_this5._jsonConfigurationBuffer.yAxis) {\n          _this5.__updateOrAddAxes(_this5._jsonConfigurationBuffer.yAxis, false);\n        }\n\n        if (_this5._jsonConfigurationBuffer.series) {\n          _this5.__updateOrAddSeries(_this5._jsonConfigurationBuffer.series);\n        }\n\n        _this5._jsonConfigurationBuffer = null;\n      });\n    }\n  }, {\n    key: \"__makeConfigurationBuffer\",\n    value: function __makeConfigurationBuffer(target, source) {\n      var _source = Highcharts.merge(source);\n\n      var _target = Highcharts.merge(target);\n\n      this.__mergeConfigurationArray(_target, _source, 'series');\n\n      this.__mergeConfigurationArray(_target, _source, 'xAxis');\n\n      this.__mergeConfigurationArray(_target, _source, 'yAxis');\n\n      return Highcharts.merge(_target, _source);\n    }\n  }, {\n    key: \"__mergeConfigurationArray\",\n    value: function __mergeConfigurationArray(target, configuration, entry) {\n      if (!configuration || !configuration[entry] || !Array.isArray(configuration[entry])) {\n        return;\n      }\n\n      if (!target[entry]) {\n        target[entry] = Array.from(configuration[entry]);\n        return;\n      }\n\n      var maxLength = Math.max(target[entry].length, configuration[entry].length);\n\n      for (var i = 0; i < maxLength; i++) {\n        target[entry][i] = Highcharts.merge(target[entry][i], configuration[entry][i]);\n      }\n\n      delete configuration[entry];\n    }\n  }, {\n    key: \"__inflateFunctions\",\n    value: function __inflateFunctions(jsonConfiguration) {\n      for (var attr in jsonConfiguration) {\n        if (jsonConfiguration.hasOwnProperty(attr)) {\n          var targetProperty = jsonConfiguration[attr];\n\n          if (attr.indexOf('_fn_') === 0 && (typeof targetProperty === 'string' || targetProperty instanceof String)) {\n            try {\n              jsonConfiguration[attr.substr(4)] = eval('(' + targetProperty + ')');\n            } catch (e) {\n              jsonConfiguration[attr.substr(4)] = eval('(function(){' + targetProperty + '})');\n            }\n\n            delete jsonConfiguration[attr];\n          } else if (targetProperty instanceof Object) {\n            this.__inflateFunctions(targetProperty);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"__initEventsListeners\",\n    value: function __initEventsListeners(configuration) {\n      this.__initChartEventsListeners(configuration);\n\n      this.__initSeriesEventsListeners(configuration);\n\n      this.__initPointsEventsListeners(configuration);\n\n      this.__initAxisEventsListeners(configuration, true);\n\n      this.__initAxisEventsListeners(configuration, false);\n    }\n  }, {\n    key: \"__initChartEventsListeners\",\n    value: function __initChartEventsListeners(configuration) {\n      this.__createEventListeners(this.__chartEventNames, configuration, 'chart.events', 'chart');\n    }\n  }, {\n    key: \"__initSeriesEventsListeners\",\n    value: function __initSeriesEventsListeners(configuration) {\n      this.__createEventListeners(this.__seriesEventNames, configuration, 'plotOptions.series.events', 'series');\n    }\n  }, {\n    key: \"__initPointsEventsListeners\",\n    value: function __initPointsEventsListeners(configuration) {\n      this.__createEventListeners(this.__pointEventNames, configuration, 'plotOptions.series.point.events', 'point');\n    }\n  }, {\n    key: \"__initAxisEventsListeners\",\n    value: function __initAxisEventsListeners(configuration, isXAxis) {\n      var _this6 = this;\n\n      var eventNames, axes;\n\n      if (isXAxis) {\n        eventNames = this.__xAxesEventNames;\n        axes = configuration.xAxis;\n      } else {\n        eventNames = this.__yAxesEventNames;\n        axes = configuration.yAxis;\n      }\n\n      if (Array.isArray(axes)) {\n        axes.forEach(function (axis) {\n          return _this6.__createEventListeners(eventNames, axis, 'events', 'axis');\n        });\n      } else {\n        this.__createEventListeners(eventNames, axes, 'events', 'axis');\n      }\n    }\n  }, {\n    key: \"__createEventListeners\",\n    value: function __createEventListeners(eventList, configuration, pathToAdd, eventType) {\n      var _this7 = this;\n\n      var self = this;\n\n      var eventObject = this.__ensureObjectPath(configuration, pathToAdd);\n\n      var _loop = function _loop(keys, i) {\n        var key = keys[i];\n\n        if (!eventObject[key]) {\n          var chart = _this7;\n\n          eventObject[key] = function (event) {\n            var customEvent = {\n              bubbles: false,\n              composed: true,\n              detail: _defineProperty({\n                originalEvent: event\n              }, eventType, this)\n            };\n\n            if (event.type === 'afterSetExtremes') {\n              if (event.min == null || event.max == null) {\n                return;\n              }\n            } // Workaround for vaadin-charts-flow because of https://github.com/vaadin/flow/issues/3102\n\n\n            if (event.type === 'selection') {\n              if (event.xAxis && event.xAxis[0]) {\n                customEvent.detail.xAxisMin = event.xAxis[0].min;\n                customEvent.detail.xAxisMax = event.xAxis[0].max;\n              }\n\n              if (event.yAxis && event.yAxis[0]) {\n                customEvent.detail.yAxisMin = event.yAxis[0].min;\n                customEvent.detail.yAxisMax = event.yAxis[0].max;\n              }\n            }\n\n            if (event.type === 'click') {\n              if (event.xAxis && event.xAxis[0]) {\n                customEvent.detail.xValue = event.xAxis[0].value;\n              }\n\n              if (event.yAxis && event.yAxis[0]) {\n                customEvent.detail.yValue = event.yAxis[0].value;\n              }\n            } // Workaround for https://github.com/vaadin/vaadin-charts/issues/389\n            // Hook into beforePrint and beforeExport to ensure correct styling\n\n\n            if (['beforePrint', 'beforeExport'].indexOf(event.type) >= 0) {\n              // Guard against another print 'before print' event coming before\n              // the 'after print' event.\n              if (!this.tempBodyStyle) {\n                var effectiveCss = '';\n\n                if (nativeShadow) {\n                  var shadowStyles = self.shadowRoot.querySelectorAll('style');\n\n                  for (var _i = 0; _i < shadowStyles.length; _i++) {\n                    effectiveCss = effectiveCss + shadowStyles[_i].textContent;\n                  } // Strip off host selectors that target individual instances\n\n\n                  effectiveCss = effectiveCss.replace(/:host\\(.+?\\)/g, function (match) {\n                    var selector = match.substr(6, match.length - 7);\n                    var matchesFn = self.matches || self.msMatchesSelector;\n                    return matchesFn.call(self, selector) ? '' : match;\n                  });\n                } else {\n                  effectiveCss = ScopingShim.prototype.styleAstToString(ScopingShim.prototype._styleInfoForNode(self)._getStyleRules()); // Remove the style scopes added by ShadyCSS\n                  // e.g. '.vaadin-chart-1 .highcharts-container.vaadin-chart'\n                  //   -> '.highcharts-container'\n                  // 1. Web Component instance scope\n\n                  var match = self.className.match(/\\bvaadin-chart-\\d+\\b/);\n\n                  if (match) {\n                    effectiveCss = effectiveCss.replace(new RegExp('\\\\.' + match[0], 'g'), '');\n                  } // 2. Web Component tag scope\n\n\n                  effectiveCss = effectiveCss.replace(/\\.vaadin-chart/g, '');\n                } // Zoom out a bit to avoid clipping the chart's edge on paper\n\n\n                effectiveCss = effectiveCss + +'body {' + '    -moz-transform: scale(0.9, 0.9);' + // Mozilla\n                '    zoom: 0.9;' + // Others\n                '    zoom: 90%;' + // Webkit\n                '}';\n                this.tempBodyStyle = document.createElement('style');\n                this.tempBodyStyle.textContent = effectiveCss;\n                document.body.appendChild(this.tempBodyStyle);\n              }\n            } // Hook into afterPrint and afterExport to revert changes made before\n\n\n            if (['afterPrint', 'afterExport'].indexOf(event.type) >= 0) {\n              if (this.tempBodyStyle) {\n                document.body.removeChild(this.tempBodyStyle);\n                delete this.tempBodyStyle;\n              }\n            }\n\n            self.dispatchEvent(new CustomEvent(eventList[key], customEvent));\n\n            if (event.type === 'legendItemClick' && chart['_visibilityTogglingDisabled']) {\n              return false;\n            }\n          };\n        }\n      };\n\n      for (var keys = Object.keys(eventList), i = 0; i < keys.length; i++) {\n        _loop(keys, i);\n      }\n    }\n  }, {\n    key: \"__ensureObjectPath\",\n    value: function __ensureObjectPath(object, path) {\n      if (typeof path !== 'string') {\n        return;\n      }\n\n      path = path.split('.');\n      return path.reduce(function (obj, key) {\n        obj[key] = obj[key] || {};\n        return obj[key];\n      }, object);\n    }\n  }, {\n    key: \"__updateOrAddCredits\",\n    value: function __updateOrAddCredits(credits) {\n      if (this.configuration.credits) {\n        this.configuration.credits.update(credits);\n      } else {\n        this.configuration.addCredits(credits);\n      }\n    }\n  }, {\n    key: \"__updateOrAddAxes\",\n    value: function __updateOrAddAxes(axes, isX) {\n      if (!Array.isArray(axes)) {\n        axes = [axes];\n      }\n\n      var confAxes = isX ? this.configuration.xAxis : this.configuration.yAxis;\n\n      for (var i = 0; i < axes.length; i++) {\n        var axis = axes[i];\n\n        if (confAxes[i]) {\n          confAxes[i].update(axis);\n        } else {\n          this.configuration.addAxis(axis, isX);\n        }\n      }\n    }\n  }, {\n    key: \"__updateOrAddSeries\",\n    value: function __updateOrAddSeries(series) {\n      if (!Array.isArray(series)) {\n        throw new Error('The type of jsonConfiguration.series should be Object[]');\n      }\n\n      for (var i = 0; i < series.length; i++) {\n        var currentSeries = series[i];\n\n        this.__updateOrAddSeriesInstance(currentSeries, i);\n      }\n    }\n  }, {\n    key: \"__updateOrAddSeriesInstance\",\n    value: function __updateOrAddSeriesInstance(seriesOptions, position) {\n      if (this.configuration.series[position]) {\n        this.configuration.series[position].update(seriesOptions);\n      } else {\n        this.configuration.addSeries(seriesOptions);\n      }\n\n      return this.configuration.series[position];\n    }\n  }, {\n    key: \"__updateCategories\",\n    value: function __updateCategories() {\n      if (!this.configuration) {\n        return;\n      }\n\n      this.__updateOrAddAxes([{\n        categories: this.categories\n      }], true);\n    }\n  }, {\n    key: \"__updateCategoryMax\",\n    value: function __updateCategoryMax() {\n      if (!this.configuration) {\n        return;\n      }\n\n      if (!isFinite(this.categoryMax)) {\n        console.warn('<vaadin-chart> Acceptable value for \"category-max\" are Numbers or null');\n        return;\n      }\n\n      this.__updateOrAddAxes([{\n        max: this.categoryMax\n      }], true);\n    }\n  }, {\n    key: \"__updateCategoryMin\",\n    value: function __updateCategoryMin() {\n      if (!this.configuration) {\n        return;\n      }\n\n      if (!isFinite(this.categoryMin)) {\n        console.warn('<vaadin-chart> Acceptable value for \"category-min\" are Numbers or null');\n        return;\n      }\n\n      this.__updateOrAddAxes([{\n        min: this.categoryMin\n      }], true);\n    }\n  }, {\n    key: \"__shouldInvert\",\n    value: function __shouldInvert() {\n      // A bar chart will never be inverted, consider using a column chart.\n      // See https://stackoverflow.com/questions/11235251#answer-21739793\n      if (this.type === 'bar' && ['top', 'bottom'].indexOf(this.categoryPosition) >= 0) {\n        console.warn(\"<vaadin-chart> Acceptable \\\"category-position\\\" values for bar charts are\\n          \\\"left\\\" and \\\"right\\\". For \\\"top\\\" and \\\"bottom\\\" positions please consider using a column chart.\");\n        return;\n      }\n\n      var inverted = ['left', 'right'];\n      return inverted.indexOf(this.categoryPosition) >= 0;\n    }\n  }, {\n    key: \"__shouldFlipOpposite\",\n    value: function __shouldFlipOpposite() {\n      var opposite = ['top', 'right'];\n      var oppositeBar = ['right'];\n      return (this.type === 'bar' ? oppositeBar : opposite).indexOf(this.categoryPosition) >= 0;\n    }\n  }, {\n    key: \"__updateCategoryPosition\",\n    value: function __updateCategoryPosition() {\n      var _this8 = this;\n\n      if (!this.configuration) {\n        return;\n      }\n\n      var validPositions = ['left', 'right', 'top', 'bottom'];\n\n      if (validPositions.indexOf(this.categoryPosition) < 0) {\n        console.warn(\"<vaadin-chart> Acceptable \\\"category-position\\\" values are \".concat(validPositions));\n        return;\n      }\n\n      this.configuration.update({\n        chart: {\n          inverted: this.__shouldInvert()\n        }\n      });\n      this.configuration.xAxis.forEach(function (e) {\n        return e.update({\n          opposite: _this8.__shouldFlipOpposite()\n        });\n      });\n    }\n  }, {\n    key: \"__hideLegend\",\n    value: function __hideLegend(newValue) {\n      if (!this.configuration) {\n        return;\n      }\n\n      if (this.configuration.legend) {\n        this.configuration.legend.update({\n          enabled: !newValue\n        });\n      } else {\n        this.configuration.legend = {\n          enabled: !newValue\n        };\n      }\n    }\n  }, {\n    key: \"__updateTitle\",\n    value: function __updateTitle(newValue) {\n      if (!this.configuration) {\n        return;\n      }\n\n      if (newValue && newValue.length > 0) {\n        this.configuration.title.update({\n          text: newValue\n        });\n      }\n    }\n  }, {\n    key: \"__tooltipObserver\",\n    value: function __tooltipObserver(newValue) {\n      if (!this.configuration) {\n        return;\n      }\n\n      this.configuration.tooltip.update({\n        enabled: this.tooltip\n      });\n    }\n  }, {\n    key: \"__updateType\",\n    value: function __updateType(newValue) {\n      if (!this.configuration) {\n        return;\n      }\n\n      if (newValue && newValue.length > 0) {\n        this.configuration.update({\n          chart: {\n            type: newValue\n          }\n        });\n      }\n    }\n  }, {\n    key: \"__updateSubtitle\",\n    value: function __updateSubtitle(newValue) {\n      if (!this.configuration) {\n        return;\n      }\n\n      if (newValue && newValue.length > 0) {\n        if (!this.configuration.subtitle) {\n          this.configuration.setSubtitle({\n            text: newValue\n          });\n        } else {\n          this.configuration.subtitle.update({\n            text: newValue\n          });\n        }\n      }\n    }\n  }, {\n    key: \"__updateAdditionalOptions\",\n    value: function __updateAdditionalOptions() {\n      if (this.configuration) {\n        this.update(this.additionalOptions);\n      }\n    }\n  }, {\n    key: \"__isStackingValid\",\n    value: function __isStackingValid() {\n      if (['normal', 'percent', null].indexOf(this.stacking) === -1) {\n        this.__showWarn('stacking', '\"normal\", \"percent\" or null');\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"__stackingObserver\",\n    value: function __stackingObserver() {\n      if (!this.configuration) {\n        return;\n      }\n\n      if (!this.__isStackingValid()) {\n        this.stacking = null;\n        return;\n      }\n\n      this.configuration.update({\n        plotOptions: {\n          series: {\n            stacking: this.stacking\n          }\n        }\n      });\n    }\n  }, {\n    key: \"__chart3dObserver\",\n    value: function __chart3dObserver() {\n      if (!this.configuration) {\n        return;\n      }\n\n      if (this.chart3d) {\n        this.configuration.update({\n          chart: {\n            options3d: Object.assign({}, this._baseChart3d, this.additionalOptions && this.additionalOptions.chart && this.additionalOptions.chart.options3d, {\n              enabled: true\n            })\n          }\n        });\n      } else {\n        this.configuration.update({\n          chart: {\n            options3d: {\n              enabled: false\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: \"__polarObserver\",\n    value: function __polarObserver() {\n      if (!this.configuration) {\n        return;\n      }\n\n      this.configuration.update({\n        chart: {\n          polar: this.polar\n        }\n      });\n    }\n  }, {\n    key: \"__emptyTextObserver\",\n    value: function __emptyTextObserver() {\n      if (!this.configuration) {\n        return;\n      }\n\n      this.configuration.update({\n        lang: {\n          noData: this.emptyText\n        }\n      });\n      this.configuration.hideNoData();\n      this.configuration.showNoData(this.emptyText);\n    }\n  }, {\n    key: \"__callChartFunction\",\n    value: function __callChartFunction(functionName) {\n      if (this.configuration) {\n        var functionToCall = this.configuration[functionName];\n        var argumentsForCall = Array.prototype.splice.call(arguments, 1);\n\n        if (functionToCall && typeof functionToCall === 'function') {\n          functionToCall.apply(this.configuration, argumentsForCall);\n        }\n      }\n    }\n  }, {\n    key: \"__callSeriesFunction\",\n    value: function __callSeriesFunction(functionName, seriesIndex) {\n      if (this.configuration && this.configuration.series[seriesIndex]) {\n        var series = this.configuration.series[seriesIndex];\n        var functionToCall = series[functionName];\n        var argumentsForCall = Array.prototype.splice.call(arguments, 2);\n\n        if (functionToCall && typeof functionToCall === 'function') {\n          functionToCall.apply(series, argumentsForCall);\n        }\n      }\n    }\n  }, {\n    key: \"__callAxisFunction\",\n    value: function __callAxisFunction(functionName, axisCategory, axisIndex) {\n      /*\n       * axisCategory:\n       * 0 - xAxis\n       * 1 - yAxis\n       * 2 - zAxis\n       * 3 - colorAxis\n       */\n      if (this.configuration) {\n        var axes;\n\n        switch (axisCategory) {\n          case 0:\n            axes = this.configuration.xAxis;\n            break;\n\n          case 1:\n            axes = this.configuration.yAxis;\n            break;\n\n          case 2:\n            axes = this.configuration.zAxis;\n            break;\n\n          case 3:\n            axes = this.configuration.colorAxis;\n            break;\n        }\n\n        if (axes && axes[axisIndex]) {\n          var axis = axes[axisIndex];\n          var functionToCall = axis[functionName];\n          var argumentsForCall = Array.prototype.splice.call(arguments, 3);\n\n          if (functionToCall && typeof functionToCall === 'function') {\n            functionToCall.apply(axis, argumentsForCall);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"__callPointFunction\",\n    value: function __callPointFunction(functionName, seriesIndex, pointIndex) {\n      if (this.configuration && this.configuration.series[seriesIndex] && this.configuration.series[seriesIndex].data[pointIndex]) {\n        var point = this.configuration.series[seriesIndex].data[pointIndex];\n        var functionToCall = point[functionName];\n        var argumentsForCall = Array.prototype.splice.call(arguments, 3);\n\n        if (functionToCall && typeof functionToCall === 'function') {\n          functionToCall.apply(point, argumentsForCall);\n        }\n      }\n    }\n    /**\n     * Updates chart container and current chart style property depending on flex status\n     */\n\n  }, {\n    key: \"__updateStyles\",\n    value: function __updateStyles() {\n      var _this9 = this;\n\n      // Chrome returns default value if property is not set\n      // check if flex is defined for chart, and different than default value\n      var isFlex = this._copyStyleProperties.some(function (property) {\n        return getComputedStyle(_this9)[property] && getComputedStyle(_this9)[property] != '0 1 auto';\n      }, this); // If chart element is a flexible item the chartContainer should be flex too\n\n\n      if (isFlex) {\n        this.$.chart.setAttribute('style', 'flex: 1; -webkit-flex: 1; -ms-flex: 1; ');\n        var style = '';\n\n        if (this.hasAttribute('style')) {\n          style = this.getAttribute('style');\n\n          if (style.charAt(style.length - 1) !== ';') {\n            style += ';';\n          }\n        }\n\n        style += 'display: -ms-flexbox; display: -webkit-flex; display: flex;';\n        this.setAttribute('style', style);\n      } else {\n        this.$.chart.setAttribute('style', 'height:100%; width:100%;');\n      }\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      var _this10 = this;\n\n      var options = Object.assign({}, this._baseConfig);\n\n      ChartDeepMerger.__deepMerge(options, this.additionalOptions);\n\n      if (this.type) {\n        options.chart = options.chart || {};\n        options.chart.type = this.type;\n      }\n\n      if (this.polar) {\n        options.chart = options.chart || {};\n        options.chart.polar = true;\n      }\n\n      if (this.title) {\n        options.title = {\n          text: this.title\n        };\n      }\n\n      if (!options.tooltip) {\n        // Workaround for highcharts#7398 to make updating tooltip works\n        options.tooltip = {};\n\n        if (!this.tooltip) {\n          options.tooltip.enabled = false;\n        }\n      }\n\n      if (this.subtitle) {\n        options.subtitle = {\n          text: this.subtitle\n        };\n      }\n\n      if (this.categories) {\n        options.xAxis = options.xAxis || {};\n\n        if (Array.isArray(options.xAxis)) {\n          // Set categories on first x axis\n          options.xAxis[0].categories = this.categories;\n        } else {\n          options.xAxis.categories = this.categories;\n        }\n      }\n\n      if (isFinite(this.categoryMin)) {\n        options.xAxis = options.xAxis || {};\n\n        if (Array.isArray(options.xAxis)) {\n          // Set category-min on first x axis\n          options.xAxis[0].min = this.categoryMin;\n        } else {\n          options.xAxis.min = this.categoryMin;\n        }\n      }\n\n      if (isFinite(this.categoryMax)) {\n        options.xAxis = options.xAxis || {};\n\n        if (Array.isArray(options.xAxis)) {\n          // Set category-max on first x axis\n          options.xAxis[0].max = this.categoryMax;\n        } else {\n          options.xAxis.max = this.categoryMax;\n        }\n      }\n\n      if (this.noLegend) {\n        options.legend = {\n          enabled: false\n        };\n      }\n\n      if (this.emptyText) {\n        options.lang = options.lang || {};\n        options.lang.noData = this.emptyText;\n      }\n\n      if (this.categoryPosition) {\n        options.chart = options.chart || {};\n        options.chart.inverted = this.__shouldInvert();\n\n        if (Array.isArray(options.xAxis)) {\n          options.xAxis.forEach(function (e) {\n            return e.opposite = _this10.__shouldFlipOpposite();\n          });\n        } else if (options.xAxis) {\n          options.xAxis.opposite = this.__shouldFlipOpposite();\n        }\n      }\n\n      if (this.stacking) {\n        options.plotOptions = options.plotOptions || {};\n        options.plotOptions.series = options.plotOptions.series || {};\n        options.plotOptions.series.stacking = this.stacking;\n      }\n\n      if (this.chart3d) {\n        options.chart = options.chart || {};\n        options.chart.options3d = Object.assign({}, this._baseChart3d, options.chart.options3d);\n      }\n\n      return options;\n    }\n    /**\n     *  Name of the chart events to add to the configuration and its corresponding event for the chart element\n     **/\n\n  }, {\n    key: \"__chartEventNames\",\n    get: function get() {\n      return {\n        /**\n         *\n         * @event chart-add-series  Fired when a new series is added\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        addSeries: 'chart-add-series',\n\n        /**\n         *\n         * @event chart-after-export  Fired after a chart is exported\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        afterExport: 'chart-after-export',\n\n        /**\n         *\n         * @event chart-after-print  Fired after a chart is printed\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        afterPrint: 'chart-after-print',\n\n        /**\n         *\n         * @event chart-before-export  Fired before a chart is exported\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        beforeExport: 'chart-before-export',\n\n        /**\n         *\n         * @event chart-before-print  Fired before a chart is printed\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        beforePrint: 'chart-before-print',\n\n        /**\n         *\n         * @event chart-click  Fired when clicking on the plot background\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        click: 'chart-click',\n\n        /**\n         *\n         * @event chart-drilldown  Fired when drilldown point is clicked\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        drilldown: 'chart-drilldown',\n\n        /**\n         *\n         * @event chart-drillup  Fired when drilling up from a drilldown series\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        drillup: 'chart-drillup',\n\n        /**\n         *\n         * @event chart-drillupall  Fired after all the series  has been drilled up\n         *                          if chart has multiple drilldown series\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        drillupall: 'chart-drillupall',\n\n        /**\n         *\n         * @event chart-load  Fired when the chart is finished loading\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        load: 'chart-load',\n\n        /**\n         *\n         * @event chart-redraw  Fired when the chart is redraw. Can be called after a `Chart.configuration.redraw()`\n         *                      or after an axis, series or point is modified with the `redraw` option set to `true`\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        redraw: 'chart-redraw',\n\n        /**\n         *\n         * @event chart-selection  Fired when an area of the chart has been selected\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} chart Chart object where the event was sent from\n         */\n        selection: 'chart-selection'\n      };\n    }\n    /**\n     *  Name of the series events to add to the configuration and its corresponding event for the chart element\n     **/\n\n  }, {\n    key: \"__seriesEventNames\",\n    get: function get() {\n      return {\n        /**\n         *\n         * @event series-after-animate  Fired when the series has finished its initial animation\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} series Series object where the event was sent from\n         */\n        afterAnimate: 'series-after-animate',\n\n        /**\n         *\n         * @event series-checkbox-click  Fired when the checkbox next to the series' name in the legend is clicked\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} series Series object where the event was sent from\n         */\n        checkboxClick: 'series-checkbox-click',\n\n        /**\n         *\n         * @event series-click  Fired when the series is clicked\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} series Series object where the event was sent from\n         */\n        click: 'series-click',\n\n        /**\n         *\n         * @event series-hide  Fired when the series is hidden after chart generation time\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} series Series object where the event was sent from\n         */\n        hide: 'series-hide',\n\n        /**\n         *\n         * @event series-legend-item-click  Fired when the legend item belonging to the series is clicked\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} series Series object where the event was sent from\n         */\n        legendItemClick: 'series-legend-item-click',\n\n        /**\n         *\n         * @event series-mouse-out  Fired when the mouses leave the graph\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} series Series object where the event was sent from\n         */\n        mouseOut: 'series-mouse-out',\n\n        /**\n         *\n         * @event series-mouse-over  Fired when the mouse enters the graph\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} series Series object where the event was sent from\n         */\n        mouseOver: 'series-mouse-over',\n\n        /**\n         *\n         * @event series-show  Fired when the series is show after chart generation time\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} series Series object where the event was sent from\n         */\n        show: 'series-show'\n      };\n    }\n    /**\n     *  Name of the point events to add to the configuration and its corresponding event for the chart element\n     **/\n\n  }, {\n    key: \"__pointEventNames\",\n    get: function get() {\n      return {\n        /**\n         *\n         * @event point-click  Fired when the point is clicked\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} point Point object where the event was sent from\n         */\n        click: 'point-click',\n\n        /**\n         *\n         * @event point-legend-item-click  Fired when the legend item belonging to the point is clicked\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} point Point object where the event was sent from\n         */\n        legendItemClick: 'point-legend-item-click',\n\n        /**\n         *\n         * @event point-mouse-out  Fired when the mouse leaves the area close to the point\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} point Point object where the event was sent from\n         */\n        mouseOut: 'point-mouse-out',\n\n        /**\n         *\n         * @event point-mouse-over  Fired when the mouse enters the area close to the point\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} point Point object where the event was sent from\n         */\n        mouseOver: 'point-mouse-over',\n\n        /**\n         *\n         * @event point-remove  Fired when the point is removed from the series\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} point Point object where the event was sent from\n         */\n        remove: 'point-remove',\n\n        /**\n         *\n         * @event point-select  Fired when the point is selected etheir programmatically or by clicking on the point\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} point Point object where the event was sent from\n         */\n        select: 'point-select',\n\n        /**\n         *\n         * @event point-unselect  Fired when the point is unselected etheir programmatically or by clicking on the point\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} point Point object where the event was sent from\n         */\n        unselect: 'point-unselect',\n\n        /**\n         *\n         * @event point-update  Fired when the point is updated programmatically through `.update()` method\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} point Point object where the event was sent from\n         */\n        update: 'point-update'\n      };\n    }\n  }, {\n    key: \"__xAxesEventNames\",\n    get: function get() {\n      return {\n        /**\n         *\n         * @event xaxes-extremes-set  Fired when when the minimum and maximum is set for the x axis\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} axis Point object where the event was sent from\n         */\n        afterSetExtremes: 'xaxes-extremes-set'\n      };\n    }\n  }, {\n    key: \"__yAxesEventNames\",\n    get: function get() {\n      return {\n        /**\n         *\n         * @event yaxes-extremes-set  Fired when when the minimum and maximum is set for the y axis\n         * @param {Object} detail.originalEvent object with details about the event sent\n         * @param {Object} axis Point object where the event was sent from\n         */\n        afterSetExtremes: 'yaxes-extremes-set'\n      };\n    }\n  }]);\n\n  return ChartElement;\n}(ElementMixin(ThemableMixin(PolymerElement)));\n\ncustomElements.define(ChartElement.is, ChartElement);\nexport { ChartElement };"
    },
    {
     "id": 335,
     "name": "../node_modules/highcharts/js/es-modules/mixins/centered-series.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * @private\n * @typedef Highcharts.RadianAngles\n *\n * @property {number} start\n *\n * @property {number} end\n */\n'use strict';\n\nimport H from '../parts/Globals.js';\nimport '../parts/Utilities.js';\nvar deg2rad = H.deg2rad,\n    isNumber = H.isNumber,\n    pick = H.pick,\n    relativeLength = H.relativeLength;\n/**\n * @private\n * @mixin Highcharts.CenteredSeriesMixin\n */\n\nH.CenteredSeriesMixin = {\n  /**\n   * Get the center of the pie based on the size and center options relative\n   * to the plot area. Borrowed by the polar and gauge series types.\n   *\n   * @private\n   * @function Highcharts.CenteredSeriesMixin.getCenter\n   *\n   * @return {Array<number>}\n   */\n  getCenter: function getCenter() {\n    var options = this.options,\n        chart = this.chart,\n        slicingRoom = 2 * (options.slicedOffset || 0),\n        handleSlicingRoom,\n        plotWidth = chart.plotWidth - 2 * slicingRoom,\n        plotHeight = chart.plotHeight - 2 * slicingRoom,\n        centerOption = options.center,\n        positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n        smallestSize = Math.min(plotWidth, plotHeight),\n        i,\n        value;\n\n    for (i = 0; i < 4; ++i) {\n      value = positions[i];\n      handleSlicingRoom = i < 2 || i === 2 && /%$/.test(value); // i == 0: centerX, relative to width\n      // i == 1: centerY, relative to height\n      // i == 2: size, relative to smallestSize\n      // i == 3: innerSize, relative to size\n\n      positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);\n    } // innerSize cannot be larger than size (#3632)\n\n\n    if (positions[3] > positions[2]) {\n      positions[3] = positions[2];\n    }\n\n    return positions;\n  },\n\n  /**\n   * getStartAndEndRadians - Calculates start and end angles in radians.\n   * Used in series types such as pie and sunburst.\n   *\n   * @private\n   * @function Highcharts.CenteredSeriesMixin.getStartAndEndRadians\n   *\n   * @param {number} start\n   *        Start angle in degrees.\n   *\n   * @param {number} end\n   *        Start angle in degrees.\n   *\n   * @return {Highcharts.RadianAngles}\n   *         Returns an object containing start and end angles as radians.\n   */\n  getStartAndEndRadians: function getStartAndEndRadians(start, end) {\n    var startAngle = isNumber(start) ? start : 0,\n        // must be a number\n    endAngle = isNumber(end) && // must be a number\n    end > startAngle && // must be larger than the start angle\n    // difference must be less than 360 degrees\n    end - startAngle < 360 ? end : startAngle + 360,\n        correction = -90;\n    return {\n      start: deg2rad * (startAngle + correction),\n      end: deg2rad * (endAngle + correction)\n    };\n  }\n};"
    },
    {
     "id": 336,
     "name": "../node_modules/highcharts/js/es-modules/parts/Interaction.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Chart.js';\nimport './Options.js';\nimport './Legend.js';\nimport './Point.js';\nimport './Series.js';\nvar addEvent = H.addEvent,\n    Chart = H.Chart,\n    createElement = H.createElement,\n    css = H.css,\n    defaultOptions = H.defaultOptions,\n    defaultPlotOptions = H.defaultPlotOptions,\n    each = H.each,\n    extend = H.extend,\n    fireEvent = H.fireEvent,\n    hasTouch = H.hasTouch,\n    inArray = H.inArray,\n    isObject = H.isObject,\n    Legend = H.Legend,\n    merge = H.merge,\n    pick = H.pick,\n    Point = H.Point,\n    Series = H.Series,\n    seriesTypes = H.seriesTypes,\n    svg = H.svg,\n    TrackerMixin;\n/**\n * TrackerMixin for points and graphs.\n *\n * @ignore\n */\n\nTrackerMixin = H.TrackerMixin = {\n  /**\n   * Draw the tracker for a point.\n   */\n  drawTrackerPoint: function drawTrackerPoint() {\n    var series = this,\n        chart = series.chart,\n        pointer = chart.pointer,\n        onMouseOver = function onMouseOver(e) {\n      var point = pointer.getPointFromEvent(e); // undefined on graph in scatterchart\n\n      if (point !== undefined) {\n        pointer.isDirectTouch = true;\n        point.onMouseOver(e);\n      }\n    }; // Add reference to the point\n\n\n    each(series.points, function (point) {\n      if (point.graphic) {\n        point.graphic.element.point = point;\n      }\n\n      if (point.dataLabel) {\n        if (point.dataLabel.div) {\n          point.dataLabel.div.point = point;\n        } else {\n          point.dataLabel.element.point = point;\n        }\n      }\n    }); // Add the event listeners, we need to do this only once\n\n    if (!series._hasTracking) {\n      each(series.trackerGroups, function (key) {\n        if (series[key]) {\n          // we don't always have dataLabelsGroup\n          series[key].addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function (e) {\n            pointer.onTrackerMouseOut(e);\n          });\n\n          if (hasTouch) {\n            series[key].on('touchstart', onMouseOver);\n          }\n        }\n      });\n      series._hasTracking = true;\n    }\n\n    fireEvent(this, 'afterDrawTracker');\n  },\n\n  /**\n   * Draw the tracker object that sits above all data labels and markers to\n   * track mouse events on the graph or points. For the line type charts\n   * the tracker uses the same graphPath, but with a greater stroke width\n   * for better control.\n   */\n  drawTrackerGraph: function drawTrackerGraph() {\n    var series = this,\n        options = series.options,\n        trackByArea = options.trackByArea,\n        trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n        trackerPathLength = trackerPath.length,\n        chart = series.chart,\n        pointer = chart.pointer,\n        renderer = chart.renderer,\n        snap = chart.options.tooltip.snap,\n        tracker = series.tracker,\n        i,\n        onMouseOver = function onMouseOver() {\n      if (chart.hoverSeries !== series) {\n        series.onMouseOver();\n      }\n    },\n\n    /*\n     * Empirical lowest possible opacities for TRACKER_FILL for an\n     * element to stay invisible but clickable\n     * IE6: 0.002\n     * IE7: 0.002\n     * IE8: 0.002\n     * IE9: 0.00000000001 (unlimited)\n     * IE10: 0.0001 (exporting only)\n     * FF: 0.00000000001 (unlimited)\n     * Chrome: 0.000001\n     * Safari: 0.000001\n     * Opera: 0.00000000001 (unlimited)\n     */\n    TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')'; // Extend end points. A better way would be to use round linecaps,\n    // but those are not clickable in VML.\n\n\n    if (trackerPathLength && !trackByArea) {\n      i = trackerPathLength + 1;\n\n      while (i--) {\n        if (trackerPath[i] === 'M') {\n          // extend left side\n          trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');\n        }\n\n        if (i && trackerPath[i] === 'M' || i === trackerPathLength) {\n          // extend right side\n          trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);\n        }\n      }\n    } // draw the tracker\n\n\n    if (tracker) {\n      tracker.attr({\n        d: trackerPath\n      });\n    } else if (series.graph) {\n      // create\n      series.tracker = renderer.path(trackerPath).attr({\n        visibility: series.visible ? 'visible' : 'hidden',\n        zIndex: 2\n      }).addClass(trackByArea ? 'highcharts-tracker-area' : 'highcharts-tracker-line').add(series.group); // The tracker is added to the series group, which is clipped, but\n      // is covered by the marker group. So the marker group also needs to\n      // capture events.\n\n      each([series.tracker, series.markerGroup], function (tracker) {\n        tracker.addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function (e) {\n          pointer.onTrackerMouseOut(e);\n        });\n\n        if (hasTouch) {\n          tracker.on('touchstart', onMouseOver);\n        }\n      });\n    }\n\n    fireEvent(this, 'afterDrawTracker');\n  }\n};\n/* End TrackerMixin */\n\n/**\n * Add tracking event listener to the series group, so the point graphics\n * themselves act as trackers\n */\n\nif (seriesTypes.column) {\n  seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\nif (seriesTypes.pie) {\n  seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\nif (seriesTypes.scatter) {\n  seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n/*\n * Extend Legend for item events\n */\n\n\nextend(Legend.prototype, {\n  setItemEvents: function setItemEvents(item, legendItem, useHTML) {\n    var legend = this,\n        boxWrapper = legend.chart.renderer.boxWrapper,\n        activeClass = 'highcharts-legend-' + (item instanceof Point ? 'point' : 'series') + '-active'; // Set the events on the item group, or in case of useHTML, the item\n    // itself (#1249)\n\n    (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n      item.setState('hover'); // A CSS class to dim or hide other than the hovered series\n\n      boxWrapper.addClass(activeClass);\n    }).on('mouseout', function () {\n      // A CSS class to dim or hide other than the hovered series\n      boxWrapper.removeClass(activeClass);\n      item.setState();\n    }).on('click', function (event) {\n      var strLegendItemClick = 'legendItemClick',\n          fnLegendItemClick = function fnLegendItemClick() {\n        if (item.setVisible) {\n          item.setVisible();\n        }\n      }; // A CSS class to dim or hide other than the hovered series. Event\n      // handling in iOS causes the activeClass to be added prior to click\n      // in some cases (#7418).\n\n\n      boxWrapper.removeClass(activeClass); // Pass over the click/touch event. #4.\n\n      event = {\n        browserEvent: event\n      }; // click the name or symbol\n\n      if (item.firePointEvent) {\n        // point\n        item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n      } else {\n        fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n      }\n    });\n  },\n  createCheckboxForItem: function createCheckboxForItem(item) {\n    var legend = this;\n    item.checkbox = createElement('input', {\n      type: 'checkbox',\n      className: 'highcharts-legend-checkbox',\n      checked: item.selected,\n      defaultChecked: item.selected // required by IE7\n\n    }, legend.options.itemCheckboxStyle, legend.chart.container);\n    addEvent(item.checkbox, 'click', function (event) {\n      var target = event.target;\n      fireEvent(item.series || item, 'checkboxClick', {\n        // #3712\n        checked: target.checked,\n        item: item\n      }, function () {\n        item.select();\n      });\n    });\n  }\n});\n/*\n * Extend the Chart object with interaction\n */\n\nextend(Chart.prototype,\n/** @lends Chart.prototype */\n{\n  /**\n   * Display the zoom button.\n   *\n   * @private\n   */\n  showResetZoom: function showResetZoom() {\n    var chart = this,\n        lang = defaultOptions.lang,\n        btnOptions = chart.options.chart.resetZoomButton,\n        theme = btnOptions.theme,\n        states = theme.states,\n        alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\n    function zoomOut() {\n      chart.zoomOut();\n    }\n\n    fireEvent(this, 'beforeShowResetZoom', null, function () {\n      chart.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover).attr({\n        align: btnOptions.position.align,\n        title: lang.resetZoomTitle\n      }).addClass('highcharts-reset-zoom').add().align(btnOptions.position, false, alignTo);\n    });\n  },\n\n  /**\n   * Zoom the chart out after a user has zoomed in. See also\n   * [Axis.setExtremes](/class-reference/Highcharts.Axis#setExtremes).\n   */\n  zoomOut: function zoomOut() {\n    fireEvent(this, 'selection', {\n      resetSelection: true\n    }, this.zoom);\n  },\n\n  /**\n   * Zoom into a given portion of the chart given by axis coordinates.\n   * @param {Object} event\n   *\n   * @private\n   */\n  zoom: function zoom(event) {\n    var chart = this,\n        hasZoomed,\n        pointer = chart.pointer,\n        displayButton = false,\n        resetZoomButton; // If zoom is called with no arguments, reset the axes\n\n    if (!event || event.resetSelection) {\n      each(chart.axes, function (axis) {\n        hasZoomed = axis.zoom();\n      });\n      pointer.initiated = false; // #6804\n    } else {\n      // else, zoom in on all axes\n      each(event.xAxis.concat(event.yAxis), function (axisData) {\n        var axis = axisData.axis,\n            isXAxis = axis.isXAxis; // don't zoom more than minRange\n\n        if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {\n          hasZoomed = axis.zoom(axisData.min, axisData.max);\n\n          if (axis.displayBtn) {\n            displayButton = true;\n          }\n        }\n      });\n    } // Show or hide the Reset zoom button\n\n\n    resetZoomButton = chart.resetZoomButton;\n\n    if (displayButton && !resetZoomButton) {\n      chart.showResetZoom();\n    } else if (!displayButton && isObject(resetZoomButton)) {\n      chart.resetZoomButton = resetZoomButton.destroy();\n    } // Redraw\n\n\n    if (hasZoomed) {\n      chart.redraw(pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));\n    }\n  },\n\n  /**\n   * Pan the chart by dragging the mouse across the pane. This function is\n   * called on mouse move, and the distance to pan is computed from chartX\n   * compared to the first chartX position in the dragging operation.\n   *\n   * @private\n   */\n  pan: function pan(e, panning) {\n    var chart = this,\n        hoverPoints = chart.hoverPoints,\n        doRedraw; // remove active points for shared tooltip\n\n    if (hoverPoints) {\n      each(hoverPoints, function (point) {\n        point.setState();\n      });\n    } // xy is used in maps\n\n\n    each(panning === 'xy' ? [1, 0] : [1], function (isX) {\n      var axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n          horiz = axis.horiz,\n          mousePos = e[horiz ? 'chartX' : 'chartY'],\n          mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',\n          startPos = chart[mouseDown],\n          halfPointRange = (axis.pointRange || 0) / 2,\n          pointRangeDirection = axis.reversed && !chart.inverted || !axis.reversed && chart.inverted ? -1 : 1,\n          extremes = axis.getExtremes(),\n          panMin = axis.toValue(startPos - mousePos, true) + halfPointRange * pointRangeDirection,\n          panMax = axis.toValue(startPos + axis.len - mousePos, true) - halfPointRange * pointRangeDirection,\n          flipped = panMax < panMin,\n          newMin = flipped ? panMax : panMin,\n          newMax = flipped ? panMin : panMax,\n          paddedMin = Math.min(extremes.dataMin, halfPointRange ? extremes.min : axis.toValue(axis.toPixels(extremes.min) - axis.minPixelPadding)),\n          paddedMax = Math.max(extremes.dataMax, halfPointRange ? extremes.max : axis.toValue(axis.toPixels(extremes.max) + axis.minPixelPadding)),\n          spill; // If the new range spills over, either to the min or max, adjust\n      // the new range.\n\n      spill = paddedMin - newMin;\n\n      if (spill > 0) {\n        newMax += spill;\n        newMin = paddedMin;\n      }\n\n      spill = newMax - paddedMax;\n\n      if (spill > 0) {\n        newMax = paddedMax;\n        newMin -= spill;\n      } // Set new extremes if they are actually new\n\n\n      if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max) {\n        axis.setExtremes(newMin, newMax, false, false, {\n          trigger: 'pan'\n        });\n        doRedraw = true;\n      }\n\n      chart[mouseDown] = mousePos; // set new reference for next run\n    });\n\n    if (doRedraw) {\n      chart.redraw(false);\n    }\n\n    css(chart.container, {\n      cursor: 'move'\n    });\n  }\n});\n/*\n * Extend the Point object with interaction\n */\n\nextend(Point.prototype,\n/** @lends Highcharts.Point.prototype */\n{\n  /**\n   * Toggle the selection status of a point.\n   * @param  {Boolean} [selected]\n   *         When `true`, the point is selected. When `false`, the point is\n   *         unselected. When `null` or `undefined`, the selection state is\n   *         toggled.\n   * @param  {Boolean} [accumulate=false]\n   *         When `true`, the selection is added to other selected points.\n   *         When `false`, other selected points are deselected. Internally in\n   *         Highcharts, when {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}\n   *         is `true`, selected points are accumulated on Control, Shift or\n   *         Cmd clicking the point.\n   *\n   * @see    Highcharts.Chart#getSelectedPoints\n   *\n   * @sample highcharts/members/point-select/\n   *         Select a point from a button\n   * @sample highcharts/chart/events-selection-points/\n   *         Select a range of points through a drag selection\n   * @sample maps/series/data-id/\n   *         Select a point in Highmaps\n   */\n  select: function select(selected, accumulate) {\n    var point = this,\n        series = point.series,\n        chart = series.chart;\n    selected = pick(selected, !point.selected); // fire the event with the default handler\n\n    point.firePointEvent(selected ? 'select' : 'unselect', {\n      accumulate: accumulate\n    }, function () {\n      /**\n       * Whether the point is selected or not.\n       * @see Point#select\n       * @see Chart#getSelectedPoints\n       * @memberof Point\n       * @name selected\n       * @type {Boolean}\n       */\n      point.selected = point.options.selected = selected;\n      series.options.data[inArray(point, series.data)] = point.options;\n      point.setState(selected && 'select'); // unselect all other points unless Ctrl or Cmd + click\n\n      if (!accumulate) {\n        each(chart.getSelectedPoints(), function (loopPoint) {\n          if (loopPoint.selected && loopPoint !== point) {\n            loopPoint.selected = loopPoint.options.selected = false;\n            series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n            loopPoint.setState('');\n            loopPoint.firePointEvent('unselect');\n          }\n        });\n      }\n    });\n  },\n\n  /**\n   * Runs on mouse over the point. Called internally from mouse and touch\n   * events.\n   *\n   * @param {Object} e The event arguments\n   */\n  onMouseOver: function onMouseOver(e) {\n    var point = this,\n        series = point.series,\n        chart = series.chart,\n        pointer = chart.pointer;\n    e = e ? pointer.normalize(e) : // In cases where onMouseOver is called directly without an event\n    pointer.getChartCoordinatesFromPoint(point, chart.inverted);\n    pointer.runPointActions(e, point);\n  },\n\n  /**\n   * Runs on mouse out from the point. Called internally from mouse and touch\n   * events.\n   */\n  onMouseOut: function onMouseOut() {\n    var point = this,\n        chart = point.series.chart;\n    point.firePointEvent('mouseOut');\n    each(chart.hoverPoints || [], function (p) {\n      p.setState();\n    });\n    chart.hoverPoints = chart.hoverPoint = null;\n  },\n\n  /**\n   * Import events from the series' and point's options. Only do it on\n   * demand, to save processing time on hovering.\n   *\n   * @private\n   */\n  importEvents: function importEvents() {\n    if (!this.hasImportedEvents) {\n      var point = this,\n          options = merge(point.series.options.point, point.options),\n          events = options.events;\n      point.events = events;\n      H.objectEach(events, function (event, eventType) {\n        addEvent(point, eventType, event);\n      });\n      this.hasImportedEvents = true;\n    }\n  },\n\n  /**\n   * Set the point's state.\n   * @param  {String} [state]\n   *         The new state, can be one of `''` (an empty string), `hover` or\n   *         `select`.\n   */\n  setState: function setState(state, move) {\n    var point = this,\n        plotX = Math.floor(point.plotX),\n        // #4586\n    plotY = point.plotY,\n        series = point.series,\n        stateOptions = series.options.states[state || 'normal'] || {},\n        markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,\n        normalDisabled = markerOptions && markerOptions.enabled === false,\n        markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || 'normal'] || {},\n        stateDisabled = markerStateOptions.enabled === false,\n        stateMarkerGraphic = series.stateMarkerGraphic,\n        pointMarker = point.marker || {},\n        chart = series.chart,\n        halo = series.halo,\n        haloOptions,\n        markerAttribs,\n        hasMarkers = markerOptions && series.markerAttribs,\n        newSymbol;\n    state = state || ''; // empty string\n\n    if ( // already has this state\n    state === point.state && !move || // selected points don't respond to hover\n    point.selected && state !== 'select' || // series' state options is disabled\n    stateOptions.enabled === false || // general point marker's state options is disabled\n    state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || // individual point marker's state options is disabled\n    state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false // #1610\n    ) {\n        return;\n      }\n\n    if (hasMarkers) {\n      markerAttribs = series.markerAttribs(point, state);\n    } // Apply hover styles to the existing point\n\n\n    if (point.graphic) {\n      if (point.state) {\n        point.graphic.removeClass('highcharts-point-' + point.state);\n      }\n\n      if (state) {\n        point.graphic.addClass('highcharts-point-' + state);\n      }\n\n      if (markerAttribs) {\n        point.graphic.animate(markerAttribs, pick(chart.options.chart.animation, // Turn off globally\n        markerStateOptions.animation, markerOptions.animation));\n      } // Zooming in from a range with no markers to a range with markers\n\n\n      if (stateMarkerGraphic) {\n        stateMarkerGraphic.hide();\n      }\n    } else {\n      // if a graphic is not applied to each point in the normal state,\n      // create a shared graphic for the hover state\n      if (state && markerStateOptions) {\n        newSymbol = pointMarker.symbol || series.symbol; // If the point has another symbol than the previous one, throw\n        // away the state marker graphic and force a new one (#1459)\n\n        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n          stateMarkerGraphic = stateMarkerGraphic.destroy();\n        } // Add a new state marker graphic\n\n\n        if (!stateMarkerGraphic) {\n          if (newSymbol) {\n            series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);\n            stateMarkerGraphic.currentSymbol = newSymbol;\n          } // Move the existing graphic\n\n        } else {\n          stateMarkerGraphic[move ? 'animate' : 'attr']({\n            // #1054\n            x: markerAttribs.x,\n            y: markerAttribs.y\n          });\n        }\n      }\n\n      if (stateMarkerGraphic) {\n        stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n\n        stateMarkerGraphic.element.point = point; // #4310\n      }\n    } // Show me your halo\n\n\n    haloOptions = stateOptions.halo;\n\n    if (haloOptions && haloOptions.size) {\n      if (!halo) {\n        series.halo = halo = chart.renderer.path() // #5818, #5903, #6705\n        .add((point.graphic || stateMarkerGraphic).parentGroup);\n      }\n\n      halo.show()[move ? 'animate' : 'attr']({\n        d: point.haloPath(haloOptions.size)\n      });\n      halo.attr({\n        'class': 'highcharts-halo highcharts-color-' + pick(point.colorIndex, series.colorIndex) + (point.className ? ' ' + point.className : ''),\n        'zIndex': -1 // #4929, #8276\n\n      });\n      halo.point = point; // #6055\n    } else if (halo && halo.point && halo.point.haloPath) {\n      // Animate back to 0 on the current halo point (#6055)\n      halo.animate({\n        d: halo.point.haloPath(0)\n      }, null, // Hide after unhovering. The `complete` callback runs in the\n      // halo's context (#7681).\n      halo.hide);\n    }\n\n    point.state = state;\n    fireEvent(point, 'afterSetState');\n  },\n\n  /**\n   * Get the path definition for the halo, which is usually a shadow-like\n   * circle around the currently hovered point.\n   * @param  {Number} size\n   *         The radius of the circular halo.\n   * @return {Array} The path definition\n   */\n  haloPath: function haloPath(size) {\n    var series = this.series,\n        chart = series.chart;\n    return chart.renderer.symbols.circle(Math.floor(this.plotX) - size, this.plotY - size, size * 2, size * 2);\n  }\n});\n/*\n * Extend the Series object with interaction\n */\n\nextend(Series.prototype,\n/** @lends Highcharts.Series.prototype */\n{\n  /**\n   * Runs on mouse over the series graphical items.\n   */\n  onMouseOver: function onMouseOver() {\n    var series = this,\n        chart = series.chart,\n        hoverSeries = chart.hoverSeries; // set normal state to previous series\n\n    if (hoverSeries && hoverSeries !== series) {\n      hoverSeries.onMouseOut();\n    } // trigger the event, but to save processing time,\n    // only if defined\n\n\n    if (series.options.events.mouseOver) {\n      fireEvent(series, 'mouseOver');\n    } // hover this\n\n\n    series.setState('hover');\n    chart.hoverSeries = series;\n  },\n\n  /**\n   * Runs on mouse out of the series graphical items.\n   */\n  onMouseOut: function onMouseOut() {\n    // trigger the event only if listeners exist\n    var series = this,\n        options = series.options,\n        chart = series.chart,\n        tooltip = chart.tooltip,\n        hoverPoint = chart.hoverPoint; // #182, set to null before the mouseOut event fires\n\n    chart.hoverSeries = null; // trigger mouse out on the point, which must be in this series\n\n    if (hoverPoint) {\n      hoverPoint.onMouseOut();\n    } // fire the mouse out event\n\n\n    if (series && options.events.mouseOut) {\n      fireEvent(series, 'mouseOut');\n    } // hide the tooltip\n\n\n    if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n      tooltip.hide();\n    } // set normal state\n\n\n    series.setState();\n  },\n\n  /**\n   * Set the state of the series. Called internally on mouse interaction\n   * operations, but it can also be called directly to visually\n   * highlight a series.\n   *\n   * @param  {String} [state]\n   *         Can be either `hover` or undefined to set to normal\n   *         state.\n   */\n  setState: function setState(state) {\n    var series = this,\n        options = series.options,\n        graph = series.graph,\n        stateOptions = options.states,\n        lineWidth = options.lineWidth,\n        attribs,\n        i = 0;\n    state = state || '';\n\n    if (series.state !== state) {\n      // Toggle class names\n      each([series.group, series.markerGroup, series.dataLabelsGroup], function (group) {\n        if (group) {\n          // Old state\n          if (series.state) {\n            group.removeClass('highcharts-series-' + series.state);\n          } // New state\n\n\n          if (state) {\n            group.addClass('highcharts-series-' + state);\n          }\n        }\n      });\n      series.state = state;\n    }\n  },\n\n  /**\n   * Show or hide the series.\n   *\n   * @param  {Boolean} [visible]\n   *         True to show the series, false to hide. If undefined, the\n   *         visibility is toggled.\n   * @param  {Boolean} [redraw=true]\n   *         Whether to redraw the chart after the series is altered. If doing\n   *         more operations on the chart, it is a good idea to set redraw to\n   *         false and call {@link Chart#redraw|chart.redraw()} after.\n   */\n  setVisible: function setVisible(vis, redraw) {\n    var series = this,\n        chart = series.chart,\n        legendItem = series.legendItem,\n        showOrHide,\n        ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n        oldVisibility = series.visible; // if called without an argument, toggle visibility\n\n    series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis; // #5618\n\n    showOrHide = vis ? 'show' : 'hide'; // show or hide elements\n\n    each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'], function (key) {\n      if (series[key]) {\n        series[key][showOrHide]();\n      }\n    }); // hide tooltip (#1361)\n\n    if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n      series.onMouseOut();\n    }\n\n    if (legendItem) {\n      chart.legend.colorizeItem(series, vis);\n    } // rescale or adapt to resized chart\n\n\n    series.isDirty = true; // in a stack, all other series are affected\n\n    if (series.options.stacking) {\n      each(chart.series, function (otherSeries) {\n        if (otherSeries.options.stacking && otherSeries.visible) {\n          otherSeries.isDirty = true;\n        }\n      });\n    } // show or hide linked series\n\n\n    each(series.linkedSeries, function (otherSeries) {\n      otherSeries.setVisible(vis, false);\n    });\n\n    if (ignoreHiddenSeries) {\n      chart.isDirtyBox = true;\n    }\n\n    fireEvent(series, showOrHide);\n\n    if (redraw !== false) {\n      chart.redraw();\n    }\n  },\n\n  /**\n   * Show the series if hidden.\n   *\n   * @sample highcharts/members/series-hide/\n   *         Toggle visibility from a button\n   */\n  show: function show() {\n    this.setVisible(true);\n  },\n\n  /**\n   * Hide the series if visible. If the {@link\n   * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|\n   * chart.ignoreHiddenSeries} option is true, the chart is redrawn without\n   * this series.\n   *\n   * @sample highcharts/members/series-hide/\n   *         Toggle visibility from a button\n   */\n  hide: function hide() {\n    this.setVisible(false);\n  },\n\n  /**\n   * Select or unselect the series. This means its {@link\n   * Highcharts.Series.selected|selected} property is set, the checkbox in the\n   * legend is toggled and when selected, the series is returned by the\n   * {@link Highcharts.Chart#getSelectedSeries} function.\n   *\n   * @param  {Boolean} [selected]\n   *         True to select the series, false to unselect. If undefined, the\n   *         selection state is toggled.\n   *\n   * @sample highcharts/members/series-select/\n   *         Select a series from a button\n   */\n  select: function select(selected) {\n    var series = this;\n    series.selected = selected = selected === undefined ? !series.selected : selected;\n\n    if (series.checkbox) {\n      series.checkbox.checked = selected;\n    }\n\n    fireEvent(series, selected ? 'select' : 'unselect');\n  },\n  drawTracker: TrackerMixin.drawTrackerGraph\n});"
    },
    {
     "id": 337,
     "name": "../node_modules/highcharts/js/es-modules/parts-more/GaugeSeries.js?babel-target=es5",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from '../parts/Globals.js';\nimport '../parts/Utilities.js';\nimport '../parts/Options.js';\nimport '../parts/Point.js';\nimport '../parts/Series.js';\nimport '../parts/Interaction.js';\nvar each = H.each,\n    isNumber = H.isNumber,\n    merge = H.merge,\n    noop = H.noop,\n    pick = H.pick,\n    pInt = H.pInt,\n    Series = H.Series,\n    seriesType = H.seriesType,\n    TrackerMixin = H.TrackerMixin;\n/**\n * Gauges are circular plots displaying one or more values with a dial pointing\n * to values along the perimeter.\n *\n * @sample       highcharts/demo/gauge-speedometer/ Gauge chart\n * @extends      {plotOptions.line}\n * @excluding    animationLimit,boostThreshold,connectEnds,connectNulls,\n *               cropThreshold,dashStyle,findNearestPointBy,getExtremesFromAll,\n *               marker,negativeColor,pointPlacement,shadow,softThreshold,\n *               stacking,states,step,threshold,turboThreshold,xAxis,zoneAxis,\n *               zones\n * @product      highcharts\n * @optionparent plotOptions.gauge\n */\n\nseriesType('gauge', 'line', {\n  /**\n   * When this option is `true`, the dial will wrap around the axes. For\n   * instance, in a full-range gauge going from 0 to 360, a value of 400\n   * will point to 40\\. When `wrap` is `false`, the dial stops at 360.\n   *\n   * @type      {Boolean}\n   * @see       [overshoot](#plotOptions.gauge.overshoot)\n   * @default   true\n   * @since     3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.wrap\n   */\n\n  /**\n   * Data labels for the gauge. For gauges, the data labels are enabled\n   * by default and shown in a bordered box below the point.\n   *\n   * @type    {Object}\n   * @extends plotOptions.series.dataLabels\n   * @since   2.3.0\n   * @product highcharts\n   */\n  dataLabels: {\n    /**\n     * Enable or disable the data labels.\n     *\n     * @since   2.3.0\n     * @product highcharts highmaps\n     */\n    enabled: true,\n    defer: false,\n\n    /**\n     * The y position offset of the label relative to the center of the\n     * gauge.\n     *\n     * @since   2.3.0\n     * @product highcharts highmaps\n     */\n    y: 15,\n\n    /**\n     * The border radius in pixels for the gauge's data label.\n     *\n     * @since   2.3.0\n     * @product highcharts highmaps\n     */\n    borderRadius: 3,\n    crop: false,\n\n    /**\n     * The vertical alignment of the data label.\n     *\n     * @product highcharts highmaps\n     */\n    verticalAlign: 'top',\n\n    /**\n     * The Z index of the data labels. A value of 2 display them behind\n     * the dial.\n     *\n     * @since   2.1.5\n     * @product highcharts highmaps\n     */\n    zIndex: 2\n  },\n\n  /**\n   * Options for the dial or arrow pointer of the gauge.\n   *\n   * In styled mode, the dial is styled with the\n   * `.highcharts-gauge-series .highcharts-dial` rule.\n   *\n   * @type    {Object}\n   * @sample  {highcharts} highcharts/css/gauge/ Styled mode\n   * @since   2.3.0\n   * @product highcharts\n   */\n  dial: {},\n\n  /**\n   * The length of the dial's base part, relative to the total radius\n   * or length of the dial.\n   *\n   * @type      {String}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   70%\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.baseLength\n   */\n\n  /**\n   * The pixel width of the base of the gauge dial. The base is the part\n   * closest to the pivot, defined by baseLength.\n   *\n   * @type      {Number}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   3\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.baseWidth\n   */\n\n  /**\n   * The radius or length of the dial, in percentages relative to the\n   * radius of the gauge itself.\n   *\n   * @type      {String}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   80%\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.radius\n   */\n\n  /**\n   * The length of the dial's rear end, the part that extends out on the\n   * other side of the pivot. Relative to the dial's length.\n   *\n   * @type      {String}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   10%\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.rearLength\n   */\n\n  /**\n   * The width of the top of the dial, closest to the perimeter. The pivot\n   * narrows in from the base to the top.\n   *\n   * @type      {Number}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   1\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.topWidth\n   */\n\n  /**\n   * Allow the dial to overshoot the end of the perimeter axis by this\n   * many degrees. Say if the gauge axis goes from 0 to 60, a value of\n   * 100, or 1000, will show 5 degrees beyond the end of the axis when this\n   * option is set to 5.\n   *\n   * @type      {Number}\n   * @see       [wrap](#plotOptions.gauge.wrap)\n   * @sample    {highcharts} highcharts/plotoptions/gauge-overshoot/\n   *            Allow 5 degrees overshoot\n   * @default   0\n   * @since     3.0.10\n   * @product   highcharts\n   * @apioption plotOptions.gauge.overshoot\n   */\n\n  /**\n   * Options for the pivot or the center point of the gauge.\n   *\n   * In styled mode, the pivot is styled with the\n   * `.highcharts-gauge-series .highcharts-pivot` rule.\n   *\n   * @type    {Object}\n   * @sample  {highcharts} highcharts/css/gauge/ Styled mode\n   * @since   2.3.0\n   * @product highcharts\n   */\n  pivot: {},\n\n  /**\n   * The pixel radius of the pivot.\n   *\n   * @type      {Number}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-pivot/\n   *            Pivot options demonstrated\n   * @default   5\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.pivot.radius\n   */\n  tooltip: {\n    headerFormat: ''\n  },\n\n  /**\n   * Whether to display this particular series or series type in the\n   * legend. Defaults to false for gauge series.\n   *\n   * @since   2.3.0\n   * @product highcharts\n   */\n  showInLegend: false // Prototype members\n\n}, {\n  // chart.angular will be set to true when a gauge series is present,\n  // and this will be used on the axes\n  angular: true,\n  directTouch: true,\n  // #5063\n  drawGraph: noop,\n  fixedBox: true,\n  forceDL: true,\n  noSharedTooltip: true,\n  trackerGroups: ['group', 'dataLabelsGroup'],\n\n  /**\n   * Calculate paths etc\n   */\n  translate: function translate() {\n    var series = this,\n        yAxis = series.yAxis,\n        options = series.options,\n        center = yAxis.center;\n    series.generatePoints();\n    each(series.points, function (point) {\n      var dialOptions = merge(options.dial, point.dial),\n          radius = pInt(pick(dialOptions.radius, 80)) * center[2] / 200,\n          baseLength = pInt(pick(dialOptions.baseLength, 70)) * radius / 100,\n          rearLength = pInt(pick(dialOptions.rearLength, 10)) * radius / 100,\n          baseWidth = dialOptions.baseWidth || 3,\n          topWidth = dialOptions.topWidth || 1,\n          overshoot = options.overshoot,\n          rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true); // Handle the wrap and overshoot options\n\n      if (isNumber(overshoot)) {\n        overshoot = overshoot / 180 * Math.PI;\n        rotation = Math.max(yAxis.startAngleRad - overshoot, Math.min(yAxis.endAngleRad + overshoot, rotation));\n      } else if (options.wrap === false) {\n        rotation = Math.max(yAxis.startAngleRad, Math.min(yAxis.endAngleRad, rotation));\n      }\n\n      rotation = rotation * 180 / Math.PI;\n      point.shapeType = 'path';\n      point.shapeArgs = {\n        d: dialOptions.path || ['M', -rearLength, -baseWidth / 2, 'L', baseLength, -baseWidth / 2, radius, -topWidth / 2, radius, topWidth / 2, baseLength, baseWidth / 2, -rearLength, baseWidth / 2, 'z'],\n        translateX: center[0],\n        translateY: center[1],\n        rotation: rotation\n      }; // Positions for data label\n\n      point.plotX = center[0];\n      point.plotY = center[1];\n    });\n  },\n\n  /**\n   * Draw the points where each point is one needle\n   */\n  drawPoints: function drawPoints() {\n    var series = this,\n        center = series.yAxis.center,\n        pivot = series.pivot,\n        options = series.options,\n        pivotOptions = options.pivot,\n        renderer = series.chart.renderer;\n    each(series.points, function (point) {\n      var graphic = point.graphic,\n          shapeArgs = point.shapeArgs,\n          d = shapeArgs.d,\n          dialOptions = merge(options.dial, point.dial); // #1233\n\n      if (graphic) {\n        graphic.animate(shapeArgs);\n        shapeArgs.d = d; // animate alters it\n      } else {\n        point.graphic = renderer[point.shapeType](shapeArgs).attr({\n          // required by VML when animation is false\n          rotation: shapeArgs.rotation,\n          zIndex: 1\n        }).addClass('highcharts-dial').add(series.group);\n      }\n    }); // Add or move the pivot\n\n    if (pivot) {\n      pivot.animate({\n        // #1235\n        translateX: center[0],\n        translateY: center[1]\n      });\n    } else {\n      series.pivot = renderer.circle(0, 0, pick(pivotOptions.radius, 5)).attr({\n        zIndex: 2\n      }).addClass('highcharts-pivot').translate(center[0], center[1]).add(series.group);\n    }\n  },\n\n  /**\n   * Animate the arrow up from startAngle\n   */\n  animate: function animate(init) {\n    var series = this;\n\n    if (!init) {\n      each(series.points, function (point) {\n        var graphic = point.graphic;\n\n        if (graphic) {\n          // start value\n          graphic.attr({\n            rotation: series.yAxis.startAngleRad * 180 / Math.PI\n          }); // animate\n\n          graphic.animate({\n            rotation: point.shapeArgs.rotation\n          }, series.options.animation);\n        }\n      }); // delete this function to allow it only once\n\n      series.animate = null;\n    }\n  },\n  render: function render() {\n    this.group = this.plotGroup('group', 'series', this.visible ? 'visible' : 'hidden', this.options.zIndex, this.chart.seriesGroup);\n    Series.prototype.render.call(this);\n    this.group.clip(this.chart.clipRect);\n  },\n\n  /**\n   * Extend the basic setData method by running processData and generatePoints\n   * immediately, in order to access the points from the legend.\n   */\n  setData: function setData(data, redraw) {\n    Series.prototype.setData.call(this, data, false);\n    this.processData();\n    this.generatePoints();\n\n    if (pick(redraw, true)) {\n      this.chart.redraw();\n    }\n  },\n\n  /**\n   * If the tracking module is loaded, add the point tracker\n   */\n  drawTracker: TrackerMixin && TrackerMixin.drawTrackerPoint // Point members\n\n}, {\n  /**\n   * Don't do any hover colors or anything\n   */\n  setState: function setState(state) {\n    this.state = state;\n  }\n});\n/**\n * A `gauge` series. If the [type](#series.gauge.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.gauge\n * @excluding animationLimit,boostThreshold,connectEnds,connectNulls,\n *            cropThreshold,dashStyle,dataParser,dataURL,findNearestPointBy,\n *            getExtremesFromAll,marker,negativeColor,pointPlacement,shadow,\n *            softThreshold,stack,stacking,states,step,threshold,\n *            turboThreshold,zoneAxis,zones\n * @product   highcharts\n * @apioption series.gauge\n */\n\n/**\n * An array of data points for the series. For the `gauge` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.gauge.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *     y: 6,\n *     name: \"Point2\",\n *     color: \"#00FF00\"\n * }, {\n *     y: 8,\n *     name: \"Point1\",\n *     color: \"#FF00FF\"\n * }]</pre>\n *\n * The typical gauge only contains a single data value.\n *\n * @type      {Array<Object|Number>}\n * @extends   series.line.data\n * @excluding drilldown,marker,x\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.gauge.data\n */"
    },
    {
     "id": 338,
     "name": "../node_modules/@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox-styles.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"<dom-module id=\\\"lumo-checkbox\\\" theme-for=\\\"vaadin-checkbox\\\">\\n  <template>\\n    <style include=\\\"lumo-checkbox-style lumo-checkbox-effects\\\">\\n      /* IE11 only */\\n      ::-ms-backdrop,\\n      [part=\\\"checkbox\\\"] {\\n        line-height: 1;\\n      }\\n    </style>\\n  </template>\\n</dom-module><dom-module id=\\\"lumo-checkbox-style\\\">\\n  <template>\\n    <style>\\n      :host {\\n        -webkit-tap-highlight-color: transparent;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        cursor: default;\\n        outline: none;\\n      }\\n\\n      [part=\\\"label\\\"]:not([empty]) {\\n        margin: 0.1875em 0.875em 0.1875em 0.375em;\\n      }\\n\\n      [part=\\\"checkbox\\\"] {\\n        width: calc(1em + 2px);\\n        height: calc(1em + 2px);\\n        margin: 0.1875em;\\n        position: relative;\\n        border-radius: var(--lumo-border-radius-s);\\n        background-color: var(--lumo-contrast-20pct);\\n        transition: transform 0.2s cubic-bezier(.12, .32, .54, 2), background-color 0.15s;\\n        pointer-events: none;\\n        line-height: 1.2;\\n      }\\n\\n      :host([indeterminate]) [part=\\\"checkbox\\\"],\\n      :host([checked]) [part=\\\"checkbox\\\"] {\\n        background-color: var(--lumo-primary-color);\\n      }\\n\\n      /* Needed to align the checkbox nicely on the baseline */\\n      [part=\\\"checkbox\\\"]::before {\\n        content: \\\"\\\\2003\\\";\\n      }\\n\\n      /* Checkmark */\\n      [part=\\\"checkbox\\\"]::after {\\n        content: \\\"\\\";\\n        display: inline-block;\\n        width: 0;\\n        height: 0;\\n        border: 0 solid var(--lumo-primary-contrast-color);\\n        border-width: 0.1875em 0 0 0.1875em;\\n        box-sizing: border-box;\\n        transform-origin: 0 0;\\n        position: absolute;\\n        top: 0.8125em;\\n        left: 0.5em;\\n        transform: scale(0.55) rotate(-135deg);\\n        opacity: 0;\\n      }\\n\\n      :host([checked]) [part=\\\"checkbox\\\"]::after {\\n        opacity: 1;\\n        width: 0.625em;\\n        height: 1.0625em;\\n      }\\n\\n      /* Indeterminate checkmark */\\n\\n      :host([indeterminate]) [part=\\\"checkbox\\\"]::after {\\n        transform: none;\\n        opacity: 1;\\n        top: 45%;\\n        height: 10%;\\n        left: 22%;\\n        right: 22%;\\n        width: auto;\\n        border: 0;\\n        background-color: var(--lumo-primary-contrast-color);\\n        transition: opacity 0.25s;\\n      }\\n\\n      /* Focus ring */\\n\\n      :host([focus-ring]) [part=\\\"checkbox\\\"] {\\n        box-shadow: 0 0 0 3px var(--lumo-primary-color-50pct);\\n      }\\n\\n      /* Disabled */\\n\\n      :host([disabled]) {\\n        pointer-events: none;\\n        color: var(--lumo-disabled-text-color);\\n      }\\n\\n      :host([disabled]) [part=\\\"label\\\"] ::slotted(*) {\\n        color: inherit;\\n      }\\n\\n      :host([disabled]) [part=\\\"checkbox\\\"] {\\n        background-color: var(--lumo-contrast-10pct);\\n      }\\n\\n      :host([disabled]) [part=\\\"checkbox\\\"]::after {\\n        border-color: var(--lumo-contrast-30pct);\\n      }\\n\\n      :host([indeterminate][disabled]) [part=\\\"checkbox\\\"]::after {\\n        background-color: var(--lumo-contrast-30pct);\\n      }\\n\\n      /* RTL specific styles */\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"label\\\"]:not([empty]) {\\n        margin: 0.1875em 0.375em 0.1875em 0.875em;\\n      }\\n    </style>\\n  </template>\\n</dom-module><dom-module id=\\\"lumo-checkbox-effects\\\">\\n  <template>\\n    <style>\\n      /* Transition the checkmark if activated with the mouse (disabled for grid select-all this way) */\\n      :host(:hover) [part=\\\"checkbox\\\"]::after {\\n        transition: width 0.1s, height 0.25s;\\n      }\\n\\n      /* Used for activation \\\"halo\\\" */\\n      [part=\\\"checkbox\\\"]::before {\\n        color: transparent;\\n        display: inline-block;\\n        width: 100%;\\n        height: 100%;\\n        border-radius: inherit;\\n        background-color: inherit;\\n        transform: scale(1.4);\\n        opacity: 0;\\n        transition: transform 0.1s, opacity 0.8s;\\n      }\\n\\n      /* Hover */\\n\\n      :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part=\\\"checkbox\\\"] {\\n        background-color: var(--lumo-contrast-30pct);\\n      }\\n\\n      /* Disable hover for touch devices */\\n      @media (pointer: coarse) {\\n        :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part=\\\"checkbox\\\"] {\\n          background-color: var(--lumo-contrast-20pct);\\n        }\\n      }\\n\\n      /* Active */\\n\\n      :host([active]) [part=\\\"checkbox\\\"] {\\n        transform: scale(0.9);\\n        transition-duration: 0.05s;\\n      }\\n\\n      :host([active][checked]) [part=\\\"checkbox\\\"] {\\n        transform: scale(1.1);\\n      }\\n\\n      :host([active]:not([checked])) [part=\\\"checkbox\\\"]::before {\\n        transition-duration: 0.01s, 0.01s;\\n        transform: scale(0);\\n        opacity: 0.4;\\n      }\\n    </style>\\n  </template>\\n</dom-module>\"], [\"<dom-module id=\\\"lumo-checkbox\\\" theme-for=\\\"vaadin-checkbox\\\">\\n  <template>\\n    <style include=\\\"lumo-checkbox-style lumo-checkbox-effects\\\">\\n      /* IE11 only */\\n      ::-ms-backdrop,\\n      [part=\\\"checkbox\\\"] {\\n        line-height: 1;\\n      }\\n    </style>\\n  </template>\\n</dom-module><dom-module id=\\\"lumo-checkbox-style\\\">\\n  <template>\\n    <style>\\n      :host {\\n        -webkit-tap-highlight-color: transparent;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        cursor: default;\\n        outline: none;\\n      }\\n\\n      [part=\\\"label\\\"]:not([empty]) {\\n        margin: 0.1875em 0.875em 0.1875em 0.375em;\\n      }\\n\\n      [part=\\\"checkbox\\\"] {\\n        width: calc(1em + 2px);\\n        height: calc(1em + 2px);\\n        margin: 0.1875em;\\n        position: relative;\\n        border-radius: var(--lumo-border-radius-s);\\n        background-color: var(--lumo-contrast-20pct);\\n        transition: transform 0.2s cubic-bezier(.12, .32, .54, 2), background-color 0.15s;\\n        pointer-events: none;\\n        line-height: 1.2;\\n      }\\n\\n      :host([indeterminate]) [part=\\\"checkbox\\\"],\\n      :host([checked]) [part=\\\"checkbox\\\"] {\\n        background-color: var(--lumo-primary-color);\\n      }\\n\\n      /* Needed to align the checkbox nicely on the baseline */\\n      [part=\\\"checkbox\\\"]::before {\\n        content: \\\"\\\\\\\\2003\\\";\\n      }\\n\\n      /* Checkmark */\\n      [part=\\\"checkbox\\\"]::after {\\n        content: \\\"\\\";\\n        display: inline-block;\\n        width: 0;\\n        height: 0;\\n        border: 0 solid var(--lumo-primary-contrast-color);\\n        border-width: 0.1875em 0 0 0.1875em;\\n        box-sizing: border-box;\\n        transform-origin: 0 0;\\n        position: absolute;\\n        top: 0.8125em;\\n        left: 0.5em;\\n        transform: scale(0.55) rotate(-135deg);\\n        opacity: 0;\\n      }\\n\\n      :host([checked]) [part=\\\"checkbox\\\"]::after {\\n        opacity: 1;\\n        width: 0.625em;\\n        height: 1.0625em;\\n      }\\n\\n      /* Indeterminate checkmark */\\n\\n      :host([indeterminate]) [part=\\\"checkbox\\\"]::after {\\n        transform: none;\\n        opacity: 1;\\n        top: 45%;\\n        height: 10%;\\n        left: 22%;\\n        right: 22%;\\n        width: auto;\\n        border: 0;\\n        background-color: var(--lumo-primary-contrast-color);\\n        transition: opacity 0.25s;\\n      }\\n\\n      /* Focus ring */\\n\\n      :host([focus-ring]) [part=\\\"checkbox\\\"] {\\n        box-shadow: 0 0 0 3px var(--lumo-primary-color-50pct);\\n      }\\n\\n      /* Disabled */\\n\\n      :host([disabled]) {\\n        pointer-events: none;\\n        color: var(--lumo-disabled-text-color);\\n      }\\n\\n      :host([disabled]) [part=\\\"label\\\"] ::slotted(*) {\\n        color: inherit;\\n      }\\n\\n      :host([disabled]) [part=\\\"checkbox\\\"] {\\n        background-color: var(--lumo-contrast-10pct);\\n      }\\n\\n      :host([disabled]) [part=\\\"checkbox\\\"]::after {\\n        border-color: var(--lumo-contrast-30pct);\\n      }\\n\\n      :host([indeterminate][disabled]) [part=\\\"checkbox\\\"]::after {\\n        background-color: var(--lumo-contrast-30pct);\\n      }\\n\\n      /* RTL specific styles */\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"label\\\"]:not([empty]) {\\n        margin: 0.1875em 0.375em 0.1875em 0.875em;\\n      }\\n    </style>\\n  </template>\\n</dom-module><dom-module id=\\\"lumo-checkbox-effects\\\">\\n  <template>\\n    <style>\\n      /* Transition the checkmark if activated with the mouse (disabled for grid select-all this way) */\\n      :host(:hover) [part=\\\"checkbox\\\"]::after {\\n        transition: width 0.1s, height 0.25s;\\n      }\\n\\n      /* Used for activation \\\"halo\\\" */\\n      [part=\\\"checkbox\\\"]::before {\\n        color: transparent;\\n        display: inline-block;\\n        width: 100%;\\n        height: 100%;\\n        border-radius: inherit;\\n        background-color: inherit;\\n        transform: scale(1.4);\\n        opacity: 0;\\n        transition: transform 0.1s, opacity 0.8s;\\n      }\\n\\n      /* Hover */\\n\\n      :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part=\\\"checkbox\\\"] {\\n        background-color: var(--lumo-contrast-30pct);\\n      }\\n\\n      /* Disable hover for touch devices */\\n      @media (pointer: coarse) {\\n        :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part=\\\"checkbox\\\"] {\\n          background-color: var(--lumo-contrast-20pct);\\n        }\\n      }\\n\\n      /* Active */\\n\\n      :host([active]) [part=\\\"checkbox\\\"] {\\n        transform: scale(0.9);\\n        transition-duration: 0.05s;\\n      }\\n\\n      :host([active][checked]) [part=\\\"checkbox\\\"] {\\n        transform: scale(1.1);\\n      }\\n\\n      :host([active]:not([checked])) [part=\\\"checkbox\\\"]::before {\\n        transition-duration: 0.01s, 0.01s;\\n        transform: scale(0);\\n        opacity: 0.4;\\n      }\\n    </style>\\n  </template>\\n</dom-module>\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html(_templateObject());\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 339,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid.js?babel-target=es5",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js';\nimport './vaadin-grid-styles.js';\nimport '../../src/vaadin-grid.js';"
    },
    {
     "id": 340,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-styles.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"<dom-module id=\\\"lumo-grid\\\" theme-for=\\\"vaadin-grid\\\">\\n  <template>\\n    <style>\\n      :host {\\n        font-family: var(--lumo-font-family);\\n        font-size: var(--lumo-font-size-m);\\n        line-height: var(--lumo-line-height-s);\\n        color: var(--lumo-body-text-color);\\n        background-color: var(--lumo-base-color);\\n        box-sizing: border-box;\\n        -webkit-text-size-adjust: 100%;\\n        -webkit-tap-highlight-color: transparent;\\n        -webkit-font-smoothing: antialiased;\\n        -moz-osx-font-smoothing: grayscale;\\n\\n        /* For internal use only */\\n        --_lumo-grid-border-color: var(--lumo-contrast-20pct);\\n        --_lumo-grid-secondary-border-color: var(--lumo-contrast-10pct);\\n        --_lumo-grid-border-width: 1px;\\n        --_lumo-grid-selected-row-color: var(--lumo-primary-color-10pct);\\n      }\\n\\n      /* No (outer) border */\\n\\n      :host(:not([theme~=\\\"no-border\\\"])) {\\n        border: var(--_lumo-grid-border-width) solid var(--_lumo-grid-border-color);\\n      }\\n\\n      /* Cell styles */\\n\\n      [part~=\\\"cell\\\"] {\\n        min-height: var(--lumo-size-m);\\n        background-color: var(--lumo-base-color);\\n      }\\n\\n      [part~=\\\"cell\\\"] ::slotted(vaadin-grid-cell-content) {\\n        cursor: default;\\n        padding: var(--lumo-space-xs) var(--lumo-space-m);\\n      }\\n\\n      /* Apply row borders by default and introduce the \\\"no-row-borders\\\" variant */\\n      :host(:not([theme~=\\\"no-row-borders\\\"])) [part~=\\\"cell\\\"]:not([part~=\\\"details-cell\\\"]) {\\n        border-top: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);\\n      }\\n\\n      /* Hide first body row top border */\\n      :host(:not([theme~=\\\"no-row-borders\\\"])) [part=\\\"row\\\"][first] [part~=\\\"cell\\\"]:not([part~=\\\"details-cell\\\"]) {\\n        border-top: 0;\\n        min-height: calc(var(--lumo-size-m) - var(--_lumo-grid-border-width));\\n      }\\n\\n      /* Focus-ring */\\n\\n      [part~=\\\"cell\\\"]:focus {\\n        outline: none;\\n      }\\n\\n      :host([navigating]) [part~=\\\"cell\\\"]:focus::before {\\n        content: \\\"\\\";\\n        position: absolute;\\n        top: 0;\\n        right: 0;\\n        bottom: 0;\\n        left: 0;\\n        pointer-events: none;\\n        box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);\\n      }\\n\\n      /* Drag and Drop styles */\\n      :host([dragover])::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        z-index: 100;\\n        top: 0;\\n        right: 0;\\n        bottom: 0;\\n        left: 0;\\n        pointer-events: none;\\n        box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);\\n      }\\n\\n      [part~=\\\"row\\\"][dragover] {\\n        z-index: 100 !important;\\n      }\\n\\n      [part~=\\\"row\\\"][dragover] [part~=\\\"cell\\\"] {\\n        overflow: visible;\\n      }\\n\\n      [part~=\\\"row\\\"][dragover] [part~=\\\"cell\\\"]::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        top: 0;\\n        right: 0;\\n        bottom: 0;\\n        left: 0;\\n        height: calc(var(--_lumo-grid-border-width) + 2px);\\n        pointer-events: none;\\n        background: var(--lumo-primary-color-50pct);\\n      }\\n\\n      :host([theme~=\\\"no-row-borders\\\"]) [dragover] [part~=\\\"cell\\\"]::after {\\n        height: 2px;\\n      }\\n\\n      [part~=\\\"row\\\"][dragover=\\\"below\\\"] [part~=\\\"cell\\\"]::after {\\n        top: 100%;\\n        bottom: auto;\\n        margin-top: -1px;\\n      }\\n\\n      [part~=\\\"row\\\"][dragover=\\\"above\\\"] [part~=\\\"cell\\\"]::after {\\n        top: auto;\\n        bottom: 100%;\\n        margin-bottom: -1px;\\n      }\\n\\n      [part~=\\\"row\\\"][details-opened][dragover=\\\"below\\\"] [part~=\\\"cell\\\"]:not([part~=\\\"details-cell\\\"])::after,\\n      [part~=\\\"row\\\"][details-opened][dragover=\\\"above\\\"] [part~=\\\"details-cell\\\"]::after {\\n        display: none;\\n      }\\n\\n      [part~=\\\"row\\\"][dragover][dragover=\\\"on-top\\\"] [part~=\\\"cell\\\"]::after {\\n        height: 100%;\\n      }\\n\\n      [part~=\\\"row\\\"][dragstart] {\\n        /* Add bottom-space to the row so the drag number doesn't get clipped. Needed for IE/Edge */\\n        border-bottom: 100px solid transparent;\\n        z-index: 100 !important;\\n        opacity: 0.9;\\n      }\\n\\n      [part~=\\\"row\\\"][dragstart] [part~=\\\"cell\\\"] {\\n        border: none !important;\\n        box-shadow: none !important;\\n      }\\n\\n      [part~=\\\"row\\\"][dragstart] [part~=\\\"cell\\\"][last-column] {\\n        border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;\\n      }\\n\\n      [part~=\\\"row\\\"][dragstart] [part~=\\\"cell\\\"][first-column] {\\n        border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);\\n      }\\n\\n      [ios] [part~=\\\"row\\\"][dragstart] [part~=\\\"cell\\\"] {\\n        background: var(--lumo-primary-color-50pct);\\n      }\\n\\n      #scroller:not([ios]) [part~=\\\"row\\\"][dragstart]:not([dragstart=\\\"\\\"])::after {\\n        display: block;\\n        position: absolute;\\n        left: var(--_grid-drag-start-x);\\n        top: var(--_grid-drag-start-y);\\n        z-index: 100;\\n        content: attr(dragstart);\\n        align-items: center;\\n        justify-content: center;\\n        box-sizing: border-box;\\n        padding: calc(var(--lumo-space-xs) * 0.8);\\n        color: var(--lumo-error-contrast-color);\\n        background-color: var(--lumo-error-color);\\n        border-radius: var(--lumo-border-radius-m);\\n        font-family: var(--lumo-font-family);\\n        font-size: var(--lumo-font-size-xxs);\\n        line-height: 1;\\n        font-weight: 500;\\n        text-transform: initial;\\n        letter-spacing: initial;\\n        min-width: calc(var(--lumo-size-s) * 0.7);\\n        text-align: center;\\n      }\\n\\n      /* Headers and footers */\\n\\n      [part~=\\\"header-cell\\\"] ::slotted(vaadin-grid-cell-content),\\n      [part~=\\\"footer-cell\\\"] ::slotted(vaadin-grid-cell-content),\\n      [part~=\\\"reorder-ghost\\\"] {\\n        font-size: var(--lumo-font-size-s);\\n        font-weight: 500;\\n      }\\n\\n      [part~=\\\"footer-cell\\\"] ::slotted(vaadin-grid-cell-content) {\\n        font-weight: 400;\\n      }\\n\\n      [part=\\\"row\\\"]:only-child [part~=\\\"header-cell\\\"] {\\n        min-height: var(--lumo-size-xl);\\n      }\\n\\n      /* Header borders */\\n\\n      /* Hide first header row top border */\\n      :host(:not([theme~=\\\"no-row-borders\\\"])) [part=\\\"row\\\"]:first-child [part~=\\\"header-cell\\\"] {\\n        border-top: 0;\\n      }\\n\\n      [part=\\\"row\\\"]:last-child [part~=\\\"header-cell\\\"] {\\n        border-bottom: var(--_lumo-grid-border-width) solid transparent;\\n      }\\n\\n      :host(:not([theme~=\\\"no-row-borders\\\"])) [part=\\\"row\\\"]:last-child [part~=\\\"header-cell\\\"] {\\n        border-bottom-color: var(--_lumo-grid-secondary-border-color);\\n      }\\n\\n      /* Overflow uses a stronger border color */\\n      :host([overflow~=\\\"top\\\"]) [part=\\\"row\\\"]:last-child [part~=\\\"header-cell\\\"] {\\n        border-bottom-color: var(--_lumo-grid-border-color);\\n      }\\n\\n      /* Footer borders */\\n\\n      [part=\\\"row\\\"]:first-child [part~=\\\"footer-cell\\\"] {\\n        border-top: var(--_lumo-grid-border-width) solid transparent;\\n      }\\n\\n      :host(:not([theme~=\\\"no-row-borders\\\"])) [part=\\\"row\\\"]:first-child [part~=\\\"footer-cell\\\"] {\\n        border-top-color: var(--_lumo-grid-secondary-border-color);\\n      }\\n\\n      /* Overflow uses a stronger border color */\\n      :host([overflow~=\\\"bottom\\\"]) [part=\\\"row\\\"]:first-child [part~=\\\"footer-cell\\\"] {\\n        border-top-color: var(--_lumo-grid-border-color);\\n      }\\n\\n      /* Column reordering */\\n\\n      :host([reordering]) [part~=\\\"cell\\\"] {\\n        background: linear-gradient(var(--lumo-shade-20pct), var(--lumo-shade-20pct)) var(--lumo-base-color);\\n      }\\n\\n      :host([reordering]) [part~=\\\"cell\\\"][reorder-status=\\\"allowed\\\"] {\\n        background: var(--lumo-base-color);\\n      }\\n\\n      :host([reordering]) [part~=\\\"cell\\\"][reorder-status=\\\"dragging\\\"] {\\n        background: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct)) var(--lumo-base-color);\\n      }\\n\\n      [part~=\\\"reorder-ghost\\\"] {\\n        opacity: 0.85;\\n        box-shadow: var(--lumo-box-shadow-s);\\n        /* TODO Use the same styles as for the cell element (reorder-ghost copies styles from the cell element) */\\n        padding: var(--lumo-space-s) var(--lumo-space-m) !important;\\n      }\\n\\n      /* Column resizing */\\n\\n      [part=\\\"resize-handle\\\"] {\\n        width: 3px;\\n        background-color: var(--lumo-primary-color-50pct);\\n        opacity: 0;\\n        transition: opacity 0.2s;\\n      }\\n\\n      :host(:not([reordering])) *:not([column-resizing]) [part~=\\\"cell\\\"]:hover [part=\\\"resize-handle\\\"],\\n      [part=\\\"resize-handle\\\"]:active {\\n        opacity: 1;\\n        transition-delay: 0.15s;\\n      }\\n\\n      /* Column borders */\\n\\n      :host([theme~=\\\"column-borders\\\"]) [part~=\\\"cell\\\"]:not([last-column]):not([part~=\\\"details-cell\\\"]) {\\n        border-right: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);\\n      }\\n\\n      /* Frozen columns */\\n\\n      [last-frozen] {\\n        border-right: var(--_lumo-grid-border-width) solid transparent;\\n        overflow: hidden;\\n      }\\n\\n      :host([overflow~=\\\"left\\\"]) [part~=\\\"cell\\\"][last-frozen]:not([part~=\\\"details-cell\\\"]) {\\n        border-right-color: var(--_lumo-grid-border-color);\\n      }\\n\\n      /* Row stripes */\\n\\n      :host([theme~=\\\"row-stripes\\\"]) [part~=\\\"row\\\"]:not([odd]) [part~=\\\"body-cell\\\"],\\n      :host([theme~=\\\"row-stripes\\\"]) [part~=\\\"row\\\"]:not([odd]) [part~=\\\"details-cell\\\"] {\\n        background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));\\n        background-repeat: repeat-x;\\n      }\\n\\n      /* Selected row */\\n\\n      /* Raise the selected rows above unselected rows (so that box-shadow can cover unselected rows) */\\n      :host(:not([reordering])) [part~=\\\"row\\\"][selected] {\\n        z-index: 1;\\n      }\\n\\n      :host(:not([reordering])) [part~=\\\"row\\\"][selected] [part~=\\\"body-cell\\\"]:not([part~=\\\"details-cell\\\"]) {\\n        background-image: linear-gradient(var(--_lumo-grid-selected-row-color), var(--_lumo-grid-selected-row-color));\\n        background-repeat: repeat;\\n      }\\n\\n      /* Cover the border of an unselected row */\\n      :host(:not([theme~=\\\"no-row-borders\\\"])) [part~=\\\"row\\\"][selected] [part~=\\\"cell\\\"]:not([part~=\\\"details-cell\\\"]) {\\n        box-shadow: 0 var(--_lumo-grid-border-width) 0 0 var(--_lumo-grid-selected-row-color);\\n      }\\n\\n      /* Compact */\\n\\n      :host([theme~=\\\"compact\\\"]) [part=\\\"row\\\"]:only-child [part~=\\\"header-cell\\\"] {\\n        min-height: var(--lumo-size-m);\\n      }\\n\\n      :host([theme~=\\\"compact\\\"]) [part~=\\\"cell\\\"] {\\n        min-height: var(--lumo-size-s);\\n      }\\n\\n      :host([theme~=\\\"compact\\\"]) [part=\\\"row\\\"][first] [part~=\\\"cell\\\"]:not([part~=\\\"details-cell\\\"]) {\\n        min-height: calc(var(--lumo-size-s) - var(--_lumo-grid-border-width));\\n      }\\n\\n      :host([theme~=\\\"compact\\\"]) [part~=\\\"cell\\\"] ::slotted(vaadin-grid-cell-content) {\\n        padding: var(--lumo-space-xs) var(--lumo-space-s);\\n      }\\n\\n      /* Wrap cell contents */\\n\\n      :host([theme~=\\\"wrap-cell-content\\\"]) [part~=\\\"cell\\\"] ::slotted(vaadin-grid-cell-content) {\\n        white-space: normal;\\n      }\\n\\n      /* RTL specific styles */\\n\\n      :host([dir=\\\"rtl\\\"]) [part~=\\\"row\\\"][dragstart] [part~=\\\"cell\\\"][last-column] {\\n        border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part~=\\\"row\\\"][dragstart] [part~=\\\"cell\\\"][first-column] {\\n        border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"][theme~=\\\"column-borders\\\"]) [part~=\\\"cell\\\"]:not([last-column]):not([part~=\\\"details-cell\\\"]) {\\n        border-right: none;\\n        border-left: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [last-frozen] {\\n        border-right: none;\\n        border-left: var(--_lumo-grid-border-width) solid transparent;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"][overflow~=\\\"right\\\"]) [part~=\\\"cell\\\"][last-frozen]:not([part~=\\\"details-cell\\\"]) {\\n        border-left-color: var(--_lumo-grid-border-color);\\n      }\\n    </style>\\n  </template>\\n</dom-module><dom-module theme-for=\\\"vaadin-checkbox\\\" id=\\\"vaadin-grid-select-all-checkbox-lumo\\\">\\n  <template>\\n    <style>\\n      :host(.vaadin-grid-select-all-checkbox) {\\n        font-size: var(--lumo-font-size-m);\\n      }\\n   </style>\\n  </template>\\n</dom-module>\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html(_templateObject());\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 341,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-sorter.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: inline-flex;\\n        cursor: pointer;\\n        max-width: 100%;\\n      }\\n\\n      [part=\\\"content\\\"] {\\n        flex: 1 1 auto;\\n      }\\n\\n      [part=\\\"indicators\\\"] {\\n        position: relative;\\n        align-self: center;\\n        flex: none;\\n      }\\n\\n      [part=\\\"order\\\"] {\\n        display: inline;\\n        vertical-align: super;\\n      }\\n\\n      [part=\\\"indicators\\\"]::before {\\n        font-family: 'vaadin-grid-sorter-icons';\\n        display: inline-block;\\n      }\\n\\n      :host(:not([direction])) [part=\\\"indicators\\\"]::before {\\n        content: \\\"\\\\e901\\\";\\n      }\\n\\n      :host([direction=asc]) [part=\\\"indicators\\\"]::before {\\n        content: \\\"\\\\e900\\\";\\n      }\\n\\n      :host([direction=desc]) [part=\\\"indicators\\\"]::before {\\n        content: \\\"\\\\e902\\\";\\n      }\\n    </style>\\n\\n    <div part=\\\"content\\\">\\n      <slot></slot>\\n    </div>\\n    <div part=\\\"indicators\\\">\\n      <span part=\\\"order\\\">[[_getDisplayOrder(_order)]]</span>\\n    </div>\\n\"], [\"\\n    <style>\\n      :host {\\n        display: inline-flex;\\n        cursor: pointer;\\n        max-width: 100%;\\n      }\\n\\n      [part=\\\"content\\\"] {\\n        flex: 1 1 auto;\\n      }\\n\\n      [part=\\\"indicators\\\"] {\\n        position: relative;\\n        align-self: center;\\n        flex: none;\\n      }\\n\\n      [part=\\\"order\\\"] {\\n        display: inline;\\n        vertical-align: super;\\n      }\\n\\n      [part=\\\"indicators\\\"]::before {\\n        font-family: 'vaadin-grid-sorter-icons';\\n        display: inline-block;\\n      }\\n\\n      :host(:not([direction])) [part=\\\"indicators\\\"]::before {\\n        content: \\\"\\\\\\\\e901\\\";\\n      }\\n\\n      :host([direction=asc]) [part=\\\"indicators\\\"]::before {\\n        content: \\\"\\\\\\\\e900\\\";\\n      }\\n\\n      :host([direction=desc]) [part=\\\"indicators\\\"]::before {\\n        content: \\\"\\\\\\\\e902\\\";\\n      }\\n    </style>\\n\\n    <div part=\\\"content\\\">\\n      <slot></slot>\\n    </div>\\n    <div part=\\\"indicators\\\">\\n      <span part=\\\"order\\\">[[_getDisplayOrder(_order)]]</span>\\n    </div>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { DirMixin } from '@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = \"<custom-style>\\n  <style>\\n    @font-face {\\n      font-family: 'vaadin-grid-sorter-icons';\\n      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQwAA0AAAAABuwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEFAAAABkAAAAcfep+mUdERUYAAAP4AAAAHAAAAB4AJwAOT1MvMgAAAZgAAAA/AAAAYA8TBPpjbWFwAAAB7AAAAFUAAAFeF1fZ4mdhc3AAAAPwAAAACAAAAAgAAAAQZ2x5ZgAAAlgAAABcAAAAnMvguMloZWFkAAABMAAAAC8AAAA2C5Ap72hoZWEAAAFgAAAAHQAAACQGbQPHaG10eAAAAdgAAAAUAAAAHAoAAABsb2NhAAACRAAAABIAAAASAIwAYG1heHAAAAGAAAAAFgAAACAACwAKbmFtZQAAArQAAAECAAACZxWCgKhwb3N0AAADuAAAADUAAABZCrApUXicY2BkYGAA4rDECVrx/DZfGbhZGEDgyqNPOxH0/wNMq5kPALkcDEwgUQBWRA0dAHicY2BkYGA+8P8AAwMLAwgwrWZgZEAFbABY4QM8AAAAeJxjYGRgYOAAQiYGEICQSAAAAi8AFgAAeJxjYGY6yziBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKoAkwODAwvmRiPvD/AIMDMxCD1CDJKjAwAgBktQsXAHicY2GAAMZQCM0EwqshbAALxAEKeJxjYGBgZoBgGQZGBhCIAPIYwXwWBhsgzcXAwcAEhIwMCi+Z/v/9/x+sSuElA4T9/4k4K1gHFwMMMILMY2QDYmaoABOQYGJABUA7WBiGNwAAJd4NIQAAAAAAAAAACAAIABAAGAAmAEAATgAAeJyNjLENgDAMBP9tIURJwQCMQccSZgk2i5fIYBDAidJjycXr7x5EPwE2wY8si7jmyBNXGo/bNBerxJNrpxhbO3/fEFpx8ZICpV+ghxJ74fAMe+h7Ox14AbrsHB14nK2QQWrDMBRER4mTkhQK3ZRQKOgCNk7oGQqhhEIX2WSlWEI1BAlkJ5CDdNsj5Ey9Rncdi38ES+jzNJo/HwTgATcoDEthhY3wBHc4CE+pfwsX5F/hGe7Vo/AcK/UhvMSz+mGXKhZU6pww8ISz3oWn1BvhgnwTnuEJf8Jz1OpFeIlX9YULDLdFi4ASHolkSR0iuYdjLak1vAequBhj21D61Nqyi6l3qWybGPjySbPHGScGJl6dP58MYcQRI0bts7mjebBqrFENH7t3qWtj0OuqHnXcW7b0HOTZFnKryRGW2hFX1m0O2vEM3opNMfTau+CS6Z3Vx6veNnEXY6jwDxhsc2gAAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSrpYEBlIbxjQDrzgsuAAAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKyoz1cD0o087YTQATOcIewAAAA==) format('woff');\\n      font-weight: normal;\\n      font-style: normal;\\n    }\\n  </style>\\n</custom-style>\";\ndocument.head.appendChild($_documentContainer.content);\n/**\n * `<vaadin-grid-sorter>` is a helper element for the `<vaadin-grid>` that provides out-of-the-box UI controls,\n * visual feedback, and handlers for sorting the grid data.\n *\n * #### Example:\n * ```html\n * <vaadin-grid-column>\n *   <template class=\"header\">\n *     <vaadin-grid-sorter path=\"name.first\">First name</vaadin-grid-sorter>\n *   </template>\n *   <template>[[item.name.first]]</template>\n * </vaadin-grid-column>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ----------------|----------------\n * `content` | The slotted content wrapper\n * `indicators` | The internal sorter indicators.\n * `order` | The internal sorter order\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `direction` | Sort direction of a sorter | :host\n *\n * @extends PolymerElement\n */\n\nvar GridSorterElement = /*#__PURE__*/function (_ThemableMixin) {\n  _inherits(GridSorterElement, _ThemableMixin);\n\n  var _super = _createSuper(GridSorterElement);\n\n  function GridSorterElement() {\n    _classCallCheck(this, GridSorterElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GridSorterElement, [{\n    key: \"ready\",\n\n    /** @protected */\n    value: function ready() {\n      _get(_getPrototypeOf(GridSorterElement.prototype), \"ready\", this).call(this);\n\n      this.addEventListener('click', this._onClick.bind(this));\n    }\n    /** @protected */\n\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(GridSorterElement.prototype), \"connectedCallback\", this).call(this);\n\n      this._isConnected = true;\n    }\n    /** @protected */\n\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(GridSorterElement.prototype), \"disconnectedCallback\", this).call(this);\n\n      this._isConnected = false;\n    }\n    /** @private */\n\n  }, {\n    key: \"_pathOrDirectionChanged\",\n    value: function _pathOrDirectionChanged(path, direction, isConnected) {\n      if (path === undefined || direction === undefined || isConnected === undefined) {\n        return;\n      }\n\n      if (isConnected) {\n        this.dispatchEvent(new CustomEvent('sorter-changed', {\n          bubbles: true,\n          composed: true\n        }));\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_getDisplayOrder\",\n    value: function _getDisplayOrder(order) {\n      return order === null ? '' : order + 1;\n    }\n    /** @private */\n\n  }, {\n    key: \"_onClick\",\n    value: function _onClick(e) {\n      var activeElement = this.getRootNode().activeElement;\n\n      if (this !== activeElement && this.contains(activeElement)) {\n        // Some focusable content inside the sorter was clicked, do nothing.\n        return;\n      }\n\n      e.preventDefault();\n\n      if (this.direction === 'asc') {\n        this.direction = 'desc';\n      } else if (this.direction === 'desc') {\n        this.direction = null;\n      } else {\n        this.direction = 'asc';\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_directionOrOrderChanged\",\n    value: function _directionOrOrderChanged(direction, order) {\n      if (direction === undefined || order === undefined) {\n        return;\n      } // Safari has an issue with repainting shadow root element styles when a host attribute changes.\n      // Need this workaround (toggle any inline css property on and off) until the issue gets fixed.\n\n\n      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n      if (isSafari && this.root) {\n        this.root.querySelectorAll('*').forEach(function (el) {\n          el.style['-webkit-backface-visibility'] = 'visible';\n          el.style['-webkit-backface-visibility'] = '';\n        });\n      }\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-grid-sorter';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * JS Path of the property in the item used for sorting the data.\n         */\n        path: String,\n\n        /**\n         * How to sort the data.\n         * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in\n         * descending direction, or `null` for not sorting the data.\n         * @type {GridSorterDirection | undefined}\n         */\n        direction: {\n          type: String,\n          reflectToAttribute: true,\n          notify: true,\n          value: null\n        },\n\n        /**\n         * @type {number | null}\n         * @protected\n         */\n        _order: {\n          type: Number,\n          value: null\n        },\n\n        /** @private */\n        _isConnected: {\n          type: Boolean,\n          value: false\n        }\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['_pathOrDirectionChanged(path, direction, _isConnected)', '_directionOrOrderChanged(direction, _order)'];\n    }\n  }]);\n\n  return GridSorterElement;\n}(ThemableMixin(DirMixin(PolymerElement)));\n\ncustomElements.define(GridSorterElement.is, GridSorterElement);\nexport { GridSorterElement };"
    },
    {
     "id": 342,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-column-group.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { microTask } from '@polymer/polymer/lib/utils/async.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { ColumnBaseMixin } from './vaadin-grid-column.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\n/**\n * A `<vaadin-grid-column-group>` is used to make groups of columns in `<vaadin-grid>` and\n * to configure additional headers and footers.\n *\n * Groups can be nested to create complex header and footer configurations.\n *\n * The `class` attribute is used to differentiate header and footer templates.\n *\n * #### Example:\n * ```html\n * <vaadin-grid-column-group resizable>\n *  <template class=\"header\">Name</template>\n *\n *  <vaadin-grid-column>\n *    <template class=\"header\">First</template>\n *    <template>[[item.name.first]]</template>\n *  </vaadin-grid-column>\n *  <vaadin-grid-column>\n *    <template class=\"header\">Last</template>\n *    <template>[[item.name.last]]</template>\n *  </vaadin-grid-column>\n * </vaadin-grid-column-group>\n * ```\n *\n * @extends PolymerElement\n * @mixes ColumnBaseMixin\n */\n\nvar GridColumnGroupElement = /*#__PURE__*/function (_ColumnBaseMixin) {\n  _inherits(GridColumnGroupElement, _ColumnBaseMixin);\n\n  var _super = _createSuper(GridColumnGroupElement);\n\n  function GridColumnGroupElement() {\n    _classCallCheck(this, GridColumnGroupElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GridColumnGroupElement, [{\n    key: \"connectedCallback\",\n\n    /** @protected */\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(GridColumnGroupElement.prototype), \"connectedCallback\", this).call(this);\n\n      this._addNodeObserver();\n\n      this._updateFlexAndWidth();\n    }\n    /** @protected */\n\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(GridColumnGroupElement.prototype), \"disconnectedCallback\", this).call(this);\n\n      this._observer && this._observer.disconnect();\n    }\n    /**\n     * @param {string} path\n     * @param {unknown=} value\n     * @protected\n     */\n\n  }, {\n    key: \"_columnPropChanged\",\n    value: function _columnPropChanged(path, value) {\n      if (path === 'hidden') {\n        this._preventHiddenCascade = true;\n\n        this._updateVisibleChildColumns(this._childColumns);\n\n        this._preventHiddenCascade = false;\n      }\n\n      if (/flexGrow|width|hidden|_childColumns/.test(path)) {\n        this._updateFlexAndWidth();\n      }\n\n      if (path === 'frozen') {\n        // Dont unfreeze the frozen group because of a non-frozen child\n        this.frozen = this.frozen || value;\n      }\n\n      if (path === 'lastFrozen') {\n        // Dont unfreeze the frozen group because of a non-frozen child\n        this._lastFrozen = this._lastFrozen || value;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_groupOrderChanged\",\n    value: function _groupOrderChanged(order, rootColumns) {\n      if (rootColumns) {\n        var _rootColumns = rootColumns.slice(0);\n\n        if (!order) {\n          _rootColumns.forEach(function (column) {\n            return column._order = 0;\n          });\n\n          return;\n        } // The parent column order number cascades downwards to it's children\n        // so that the resulting order numbering constructs as follows:\n        // [             1000              ]\n        // [     1100    ] | [     1200    ]\n        // [1110] | [1120] | [1210] | [1220]\n        // Trailing zeros are counted so we know the level on which we're working on.\n\n\n        var trailingZeros = /(0+)$/.exec(order).pop().length; // In an unlikely situation where a group has more than 9 child columns,\n        // the child scope must have 1 digit less...\n\n        var childCountDigits = ~~(Math.log(rootColumns.length) / Math.log(Math.LN10)) + 1; // Final scope for the child columns needs to mind both factors.\n\n        var scope = Math.pow(10, trailingZeros - childCountDigits);\n\n        if (_rootColumns[0] && _rootColumns[0]._order) {\n          _rootColumns.sort(function (a, b) {\n            return a._order - b._order;\n          });\n        }\n\n        _rootColumns.forEach(function (column, index) {\n          return column._order = order + (index + 1) * scope;\n        });\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_groupReorderStatusChanged\",\n    value: function _groupReorderStatusChanged(reorderStatus, rootColumns) {\n      if (reorderStatus === undefined || rootColumns === undefined) {\n        return;\n      }\n\n      rootColumns.forEach(function (column) {\n        return column._reorderStatus = reorderStatus;\n      });\n    }\n    /** @private */\n\n  }, {\n    key: \"_groupResizableChanged\",\n    value: function _groupResizableChanged(resizable, rootColumns) {\n      if (resizable === undefined || rootColumns === undefined) {\n        return;\n      }\n\n      rootColumns.forEach(function (column) {\n        return column.resizable = resizable;\n      });\n    }\n    /** @private */\n\n  }, {\n    key: \"_updateVisibleChildColumns\",\n    value: function _updateVisibleChildColumns(childColumns) {\n      this._visibleChildColumns = Array.prototype.filter.call(childColumns, function (col) {\n        return !col.hidden;\n      });\n    }\n    /** @private */\n\n  }, {\n    key: \"_childColumnsChanged\",\n    value: function _childColumnsChanged(childColumns) {\n      if (!this._autoHidden && this.hidden) {\n        Array.prototype.forEach.call(childColumns, function (column) {\n          return column.hidden = true;\n        });\n\n        this._updateVisibleChildColumns(childColumns);\n      }\n    }\n    /** @protected */\n\n  }, {\n    key: \"_updateFlexAndWidth\",\n    value: function _updateFlexAndWidth() {\n      if (!this._visibleChildColumns) {\n        return;\n      }\n\n      if (this._visibleChildColumns.length) {\n        this._setWidth('calc(' + Array.prototype.reduce.call(this._visibleChildColumns, function (prev, curr) {\n          return prev += ' + ' + (curr.width || '0px').replace('calc', '');\n        }, '').substring(3) + ')');\n      } else {\n        this._setWidth('0px');\n      }\n\n      this._setFlexGrow(Array.prototype.reduce.call(this._visibleChildColumns, function (prev, curr) {\n        return prev + curr.flexGrow;\n      }, 0));\n    }\n    /** @private */\n\n  }, {\n    key: \"_groupFrozenChanged\",\n    value: function _groupFrozenChanged(frozen, rootColumns) {\n      if (rootColumns === undefined || frozen === undefined) {\n        return;\n      } // Dont propagate the default `false` value.\n\n\n      if (frozen !== false) {\n        Array.from(rootColumns).forEach(function (col) {\n          return col.frozen = frozen;\n        });\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_groupHiddenChanged\",\n    value: function _groupHiddenChanged(hidden, rootColumns) {\n      if (rootColumns && !this._preventHiddenCascade) {\n        this._ignoreVisibleChildColumns = true;\n        rootColumns.forEach(function (column) {\n          return column.hidden = hidden;\n        });\n        this._ignoreVisibleChildColumns = false;\n      }\n\n      this._columnPropChanged('hidden');\n    }\n    /** @private */\n\n  }, {\n    key: \"_visibleChildColumnsChanged\",\n    value: function _visibleChildColumnsChanged(visibleChildColumns) {\n      this._colSpan = visibleChildColumns.length;\n\n      if (!this._ignoreVisibleChildColumns) {\n        if (visibleChildColumns.length === 0) {\n          this._autoHidden = this.hidden = true;\n        } else if (this.hidden && this._autoHidden) {\n          this._autoHidden = this.hidden = false;\n        }\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_colSpanChanged\",\n    value: function _colSpanChanged(colSpan, headerCell, footerCell) {\n      if (headerCell) {\n        headerCell.setAttribute('colspan', colSpan);\n        this._grid && this._grid._a11yUpdateCellColspan(headerCell, colSpan);\n      }\n\n      if (footerCell) {\n        footerCell.setAttribute('colspan', colSpan);\n        this._grid && this._grid._a11yUpdateCellColspan(footerCell, colSpan);\n      }\n    }\n    /**\n     * @param {!GridColumnGroupElement} el\n     * @return {!Array<!GridColumnElement>}\n     * @protected\n     */\n\n  }, {\n    key: \"_getChildColumns\",\n    value: function _getChildColumns(el) {\n      return FlattenedNodesObserver.getFlattenedNodes(el).filter(this._isColumnElement);\n    }\n    /** @private */\n\n  }, {\n    key: \"_addNodeObserver\",\n    value: function _addNodeObserver() {\n      var _this = this;\n\n      this._observer = new FlattenedNodesObserver(this, function (info) {\n        if (info.addedNodes.filter(_this._isColumnElement).length > 0 || info.removedNodes.filter(_this._isColumnElement).length > 0) {\n          _this._preventHiddenCascade = true;\n          _this._rootColumns = _this._getChildColumns(_this);\n          _this._childColumns = _this._rootColumns;\n          _this._preventHiddenCascade = false; // Update the column tree with microtask timing to avoid shady style scope issues\n\n          microTask.run(function () {\n            _this._grid && _this._grid._updateColumnTree && _this._grid._updateColumnTree();\n          });\n        }\n      });\n\n      this._observer.flush();\n    }\n    /**\n     * @param {!Node} node\n     * @return {boolean}\n     * @protected\n     */\n\n  }, {\n    key: \"_isColumnElement\",\n    value: function _isColumnElement(node) {\n      return node.nodeType === Node.ELEMENT_NODE && /\\bcolumn\\b/.test(node.localName);\n    }\n  }], [{\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-grid-column-group';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /** @private */\n        _childColumns: {\n          value: function value() {\n            return this._getChildColumns(this);\n          }\n        },\n\n        /**\n         * Flex grow ratio for the column group as the sum of the ratios of its child columns.\n         * @attr {number} flex-grow\n         */\n        flexGrow: {\n          type: Number,\n          readOnly: true\n        },\n\n        /**\n         * Width of the column group as the sum of the widths of its child columns.\n         */\n        width: {\n          type: String,\n          readOnly: true\n        },\n\n        /** @private */\n        _visibleChildColumns: Array,\n\n        /** @private */\n        _colSpan: Number,\n\n        /** @private */\n        _rootColumns: Array\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['_updateVisibleChildColumns(_childColumns)', '_childColumnsChanged(_childColumns)', '_groupFrozenChanged(frozen, _rootColumns)', '_groupHiddenChanged(hidden, _rootColumns)', '_visibleChildColumnsChanged(_visibleChildColumns)', '_colSpanChanged(_colSpan, _headerCell, _footerCell)', '_groupOrderChanged(_order, _rootColumns)', '_groupReorderStatusChanged(_reorderStatus, _rootColumns)', '_groupResizableChanged(resizable, _rootColumns)'];\n    }\n  }]);\n\n  return GridColumnGroupElement;\n}(ColumnBaseMixin(PolymerElement));\n\ncustomElements.define(GridColumnGroupElement.is, GridColumnGroupElement);\nexport { GridColumnGroupElement };"
    },
    {
     "id": 343,
     "name": "../node_modules/@vaadin/vaadin-combo-box/src/vaadin-combo-box-light.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host([opened]) {\\n        pointer-events: auto;\\n      }\\n    </style>\\n\\n    <slot></slot>\\n\\n    <vaadin-combo-box-dropdown-wrapper id=\\\"overlay\\\" opened=\\\"[[opened]]\\\" position-target=\\\"[[inputElement]]\\\" renderer=\\\"[[renderer]]\\\" _focused-index=\\\"[[_focusedIndex]]\\\" _item-id-path=\\\"[[itemIdPath]]\\\" _item-label-path=\\\"[[itemLabelPath]]\\\" loading=\\\"[[loading]]\\\" theme=\\\"[[theme]]\\\">\\n    </vaadin-combo-box-dropdown-wrapper>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ComboBoxMixin } from './vaadin-combo-box-mixin.js';\nimport { ComboBoxDataProviderMixin } from './vaadin-combo-box-data-provider-mixin.js';\nimport './vaadin-combo-box-dropdown-wrapper.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { dashToCamelCase } from '@polymer/polymer/lib/utils/case-map.js';\n/**\n * `<vaadin-combo-box-light>` is a customizable version of the `<vaadin-combo-box>` providing\n * only the dropdown functionality and leaving the input field definition to the user.\n *\n * The element has the same API as `<vaadin-combo-box>`.\n *\n * To create a custom input field, you need to add a child element which has a two-way\n * data-bindable property representing the input value. The property name is expected\n * to be `value` by default. See the example below for a simplest possible example\n * using a `<vaadin-text-field>` element.\n *\n * ```html\n * <vaadin-combo-box-light>\n *   <vaadin-text-field>\n *   </vaadin-text-field>\n * </vaadin-combo-box-light>\n * ```\n *\n * If you are using other custom input fields like `<iron-input>`, you\n * need to define the name of the bindable property with the `attrForValue` attribute.\n *\n * ```html\n * <vaadin-combo-box-light attr-for-value=\"bind-value\">\n *   <iron-input>\n *     <input>\n *   </iron-input>\n * </vaadin-combo-box-light>\n * ```\n *\n * In the next example you can see how to create a custom input field based\n * on a `<paper-input>` decorated with a custom `<iron-icon>` and\n * two `<paper-button>`s to act as the clear and toggle controls.\n *\n * ```html\n * <vaadin-combo-box-light>\n *   <paper-input label=\"Elements\" class=\"input\">\n *     <iron-icon icon=\"toll\" slot=\"prefix\"></iron-icon>\n *     <paper-button slot=\"suffix\" class=\"clear-button\">Clear</paper-button>\n *     <paper-button slot=\"suffix\" class=\"toggle-button\">Toggle</paper-button>\n *   </paper-input>\n * </vaadin-combo-box-light>\n * ```\n * @extends PolymerElement\n * @mixes ComboBoxDataProviderMixin\n * @mixes ComboBoxMixin\n * @mixes ThemableMixin\n */\n\nvar ComboBoxLightElement = /*#__PURE__*/function (_ThemableMixin) {\n  _inherits(ComboBoxLightElement, _ThemableMixin);\n\n  var _super = _createSuper(ComboBoxLightElement);\n\n  _createClass(ComboBoxLightElement, null, [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-combo-box-light';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * Name of the two-way data-bindable property representing the\n         * value of the custom input field.\n         * @attr {string} attr-for-value\n         * @type {string}\n         */\n        attrForValue: {\n          type: String,\n          value: 'value'\n        },\n\n        /**\n         * @type {!Element | undefined}\n         */\n        inputElement: {\n          type: Element,\n          readOnly: true\n        }\n      };\n    }\n  }]);\n\n  function ComboBoxLightElement() {\n    var _this;\n\n    _classCallCheck(this, ComboBoxLightElement);\n\n    _this = _super.call(this);\n    _this._boundInputValueChanged = _this._inputValueChanged.bind(_assertThisInitialized(_this));\n    _this.__boundInputValueCommitted = _this.__inputValueCommitted.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /** @protected */\n\n\n  _createClass(ComboBoxLightElement, [{\n    key: \"ready\",\n    value: function ready() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(ComboBoxLightElement.prototype), \"ready\", this).call(this);\n\n      this._toggleElement = this.querySelector('.toggle-button');\n      this._clearElement = this.querySelector('.clear-button');\n\n      if (this._clearElement) {\n        this._clearElement.addEventListener('mousedown', function (e) {\n          e.preventDefault(); // Prevent native focus changes\n          // _focusableElement is needed for paper-input\n\n          (_this2.inputElement._focusableElement || _this2.inputElement).focus();\n        });\n      }\n    }\n    /**\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"connectedCallback\",\n\n    /** @protected */\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(ComboBoxLightElement.prototype), \"connectedCallback\", this).call(this);\n\n      var cssSelector = 'vaadin-text-field,iron-input,paper-input,.paper-input-input,.input';\n\n      this._setInputElement(this.querySelector(cssSelector));\n\n      this._revertInputValue();\n\n      this.inputElement.addEventListener('input', this._boundInputValueChanged);\n      this.inputElement.addEventListener('change', this.__boundInputValueCommitted);\n\n      this._preventInputBlur();\n    }\n    /** @protected */\n\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(ComboBoxLightElement.prototype), \"disconnectedCallback\", this).call(this);\n\n      this.inputElement.removeEventListener('input', this._boundInputValueChanged);\n      this.inputElement.removeEventListener('change', this.__boundInputValueCommitted);\n\n      this._restoreInputBlur();\n    }\n    /** @private */\n\n  }, {\n    key: \"__inputValueCommitted\",\n    value: function __inputValueCommitted(e) {\n      // Detect if the input was cleared (by clicking the clear button on a vaadin-text-field)\n      // and propagate the value change to combo box value immediately.\n      if (e.__fromClearButton) {\n        this._clear();\n      }\n    }\n    /**\n     * @return {string}\n     * @protected\n     */\n\n  }, {\n    key: \"focused\",\n    get: function get() {\n      return this.getRootNode().activeElement === this.inputElement;\n    }\n  }, {\n    key: \"_propertyForValue\",\n    get: function get() {\n      return dashToCamelCase(this.attrForValue);\n    }\n    /**\n     * @return {string}\n     * @protected\n     */\n\n  }, {\n    key: \"_inputElementValue\",\n    get: function get() {\n      return this.inputElement && this.inputElement[this._propertyForValue];\n    }\n    /**\n     * @param {string} value\n     * @protected\n     */\n    ,\n    set: function set(value) {\n      if (this.inputElement) {\n        this.inputElement[this._propertyForValue] = value;\n      }\n    }\n  }]);\n\n  return ComboBoxLightElement;\n}(ThemableMixin(ComboBoxDataProviderMixin(ComboBoxMixin(PolymerElement))));\n\ncustomElements.define(ComboBoxLightElement.is, ComboBoxLightElement);\nexport { ComboBoxLightElement };"
    },
    {
     "id": 344,
     "name": "../node_modules/@babel/runtime/helpers/slicedToArray.js?babel-target=es5",
     "source": "var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;"
    },
    {
     "id": 345,
     "name": "../node_modules/@vaadin/vaadin-text-field/src/vaadin-password-field.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"<custom-style>\\n  <style>\\n    @font-face {\\n      font-family: 'vaadin-password-field-icons';\\n      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAYMAAsAAAAABcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIFgGNtYXAAAAFoAAAAVAAAAFQXVtKIZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAfwAAAH8yBLEP2hlYWQAAAPAAAAANgAAADYN+RfTaGhlYQAAA/gAAAAkAAAAJAfCA8dobXR4AAAEHAAAABgAAAAYDgAAAGxvY2EAAAQ0AAAADgAAAA4BJgCSbWF4cAAABEQAAAAgAAAAIAAMAFpuYW1lAAAEZAAAAYYAAAGGmUoJ+3Bvc3QAAAXsAAAAIAAAACAAAwAAAAMDVQGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QEDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkB//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAwAAAHoEAALGABQAJABFAAABIg4CMTAeAjMyPgIxMC4CIwc+ATEwBhUUFjEHMCY1NDYTIi4CJz4BNw4BFRQeAjMyPgI1NCYnHgEXDgMjAgChyHAnN3rAiYjFfjsncMihrRg7IA1GExmnY5ZqQg8PWGAFCChGXTU1XUYoCAVgWA8RRW2ZZALGZnpmUmJSUGBQaHxoYA8FRSIhJQ0rIiYz/lQvQkYVInswEygYNV1GKChGXTUYKBMrgCIVRkIvAAAABQAA/8AEAAPAABoAJgA6AEcAVwAAAQceARcOAyMiJicHHgEzMj4CMTAuAicHNCYnATIWMzI+AhMBLgEjIg4CMTAeAhcHFTMBNQEuASc+ATcOARUUFhc3BzAmNTQ2MT4BMTAGFQYWAzo0UlMPEUVtmWQiNR0zJ1QsiMV+OxEsTTw6AgT+zA8dDjVdRijT/ucnXjWhyHAnGTNQN9MtA9P9AE1ZFA9YYAUILSY6QBMZGDsgBAsCczMrcyIWQ0AtCAQzDgtQYFAzS1ckeQ4bCv7TBihGXQH7/uYKEGZ6Zic5RBzNLQPTLf0tIVoYInswEygYNWMihgwrISc5DwVHJiIlAAEAAAAAAADkyo21Xw889QALBAAAAAAA1W1pqwAAAADVbWmrAAD/wAQAA8AAAAAIAAIAAAAAAAAAAQAAA8D/wAAABAAAAAAABAAAAQAAAAAAAAAAAAAAAAAAAAYEAAAAAAAAAAAAAAACAAAABAAAAAQAAAAAAAAAAAoAFAAeAH4A/gAAAAEAAAAGAFgABQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAHAAAAAQAAAAAAAgAHAGAAAQAAAAAAAwAHADYAAQAAAAAABAAHAHUAAQAAAAAABQALABUAAQAAAAAABgAHAEsAAQAAAAAACgAaAIoAAwABBAkAAQAOAAcAAwABBAkAAgAOAGcAAwABBAkAAwAOAD0AAwABBAkABAAOAHwAAwABBAkABQAWACAAAwABBAkABgAOAFIAAwABBAkACgA0AKRpY29tb29uAGkAYwBvAG0AbwBvAG5WZXJzaW9uIDEuMABWAGUAcgBzAGkAbwBuACAAMQAuADBpY29tb29uAGkAYwBvAG0AbwBvAG5pY29tb29uAGkAYwBvAG0AbwBvAG5SZWd1bGFyAFIAZQBnAHUAbABhAHJpY29tb29uAGkAYwBvAG0AbwBvAG5Gb250IGdlbmVyYXRlZCBieSBJY29Nb29uLgBGAG8AbgB0ACAAZwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAC4AAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) format('woff');\\n      font-weight: normal;\\n      font-style: normal;\\n    }\\n  </style>\\n</custom-style><dom-module id=\\\"vaadin-password-field-template\\\">\\n  <template>\\n    <style>\\n      /* Hide the native eye icon for IE/Edge */\\n      ::-ms-reveal {\\n        display: none;\\n      }\\n\\n      [part=\\\"reveal-button\\\"][hidden] {\\n        display: none !important;\\n      }\\n    </style>\\n\\n    <div part=\\\"reveal-button\\\" on-mousedown=\\\"_revealButtonMouseDown\\\" on-touchend=\\\"_togglePasswordVisibilityTouchend\\\" on-click=\\\"_togglePasswordVisibility\\\" hidden$=\\\"[[revealButtonHidden]]\\\">\\n    </div>\\n  </template>\\n  \\n</dom-module>\"], [\"<custom-style>\\n  <style>\\n    @font-face {\\n      font-family: 'vaadin-password-field-icons';\\n      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAYMAAsAAAAABcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIFgGNtYXAAAAFoAAAAVAAAAFQXVtKIZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAfwAAAH8yBLEP2hlYWQAAAPAAAAANgAAADYN+RfTaGhlYQAAA/gAAAAkAAAAJAfCA8dobXR4AAAEHAAAABgAAAAYDgAAAGxvY2EAAAQ0AAAADgAAAA4BJgCSbWF4cAAABEQAAAAgAAAAIAAMAFpuYW1lAAAEZAAAAYYAAAGGmUoJ+3Bvc3QAAAXsAAAAIAAAACAAAwAAAAMDVQGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QEDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkB//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAwAAAHoEAALGABQAJABFAAABIg4CMTAeAjMyPgIxMC4CIwc+ATEwBhUUFjEHMCY1NDYTIi4CJz4BNw4BFRQeAjMyPgI1NCYnHgEXDgMjAgChyHAnN3rAiYjFfjsncMihrRg7IA1GExmnY5ZqQg8PWGAFCChGXTU1XUYoCAVgWA8RRW2ZZALGZnpmUmJSUGBQaHxoYA8FRSIhJQ0rIiYz/lQvQkYVInswEygYNV1GKChGXTUYKBMrgCIVRkIvAAAABQAA/8AEAAPAABoAJgA6AEcAVwAAAQceARcOAyMiJicHHgEzMj4CMTAuAicHNCYnATIWMzI+AhMBLgEjIg4CMTAeAhcHFTMBNQEuASc+ATcOARUUFhc3BzAmNTQ2MT4BMTAGFQYWAzo0UlMPEUVtmWQiNR0zJ1QsiMV+OxEsTTw6AgT+zA8dDjVdRijT/ucnXjWhyHAnGTNQN9MtA9P9AE1ZFA9YYAUILSY6QBMZGDsgBAsCczMrcyIWQ0AtCAQzDgtQYFAzS1ckeQ4bCv7TBihGXQH7/uYKEGZ6Zic5RBzNLQPTLf0tIVoYInswEygYNWMihgwrISc5DwVHJiIlAAEAAAAAAADkyo21Xw889QALBAAAAAAA1W1pqwAAAADVbWmrAAD/wAQAA8AAAAAIAAIAAAAAAAAAAQAAA8D/wAAABAAAAAAABAAAAQAAAAAAAAAAAAAAAAAAAAYEAAAAAAAAAAAAAAACAAAABAAAAAQAAAAAAAAAAAoAFAAeAH4A/gAAAAEAAAAGAFgABQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAHAAAAAQAAAAAAAgAHAGAAAQAAAAAAAwAHADYAAQAAAAAABAAHAHUAAQAAAAAABQALABUAAQAAAAAABgAHAEsAAQAAAAAACgAaAIoAAwABBAkAAQAOAAcAAwABBAkAAgAOAGcAAwABBAkAAwAOAD0AAwABBAkABAAOAHwAAwABBAkABQAWACAAAwABBAkABgAOAFIAAwABBAkACgA0AKRpY29tb29uAGkAYwBvAG0AbwBvAG5WZXJzaW9uIDEuMABWAGUAcgBzAGkAbwBuACAAMQAuADBpY29tb29uAGkAYwBvAG0AbwBvAG5pY29tb29uAGkAYwBvAG0AbwBvAG5SZWd1bGFyAFIAZQBnAHUAbABhAHJpY29tb29uAGkAYwBvAG0AbwBvAG5Gb250IGdlbmVyYXRlZCBieSBJY29Nb29uLgBGAG8AbgB0ACAAZwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAC4AAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) format('woff');\\n      font-weight: normal;\\n      font-style: normal;\\n    }\\n  </style>\\n</custom-style><dom-module id=\\\"vaadin-password-field-template\\\">\\n  <template>\\n    <style>\\n      /* Hide the native eye icon for IE/Edge */\\n      ::-ms-reveal {\\n        display: none;\\n      }\\n\\n      [part=\\\"reveal-button\\\"][hidden] {\\n        display: none !important;\\n      }\\n    </style>\\n\\n    <div part=\\\"reveal-button\\\" on-mousedown=\\\"_revealButtonMouseDown\\\" on-touchend=\\\"_togglePasswordVisibilityTouchend\\\" on-click=\\\"_togglePasswordVisibility\\\" hidden\\\\$=\\\"[[revealButtonHidden]]\\\">\\n    </div>\\n  </template>\\n  \\n</dom-module>\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport '@polymer/polymer/polymer-element.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nimport { TextFieldElement } from './vaadin-text-field.js';\nimport { DomModule } from '@polymer/polymer/lib/elements/dom-module.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html(_templateObject());\ndocument.head.appendChild($_documentContainer.content);\nvar memoizedTemplate;\n/**\n * `<vaadin-password-field>` is a Web Component for password field control in forms.\n *\n * ```html\n * <vaadin-password-field label=\"Password\">\n * </vaadin-password-field>\n * ```\n *\n * ### Styling\n *\n * See vaadin-text-field.html for the styling documentation\n *\n * In addition to vaadin-text-field parts, here's the list of vaadin-password-field specific parts\n *\n * Part name       | Description\n * ----------------|----------------------------------------------------\n * `reveal-button` | The eye icon which toggles the password visibility\n *\n * In addition to vaadin-text-field state attributes, here's the list of vaadin-password-field specific attributes\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `password-visible` | Set when the password is visible | :host\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends TextFieldElement\n * @demo demo/index.html\n */\n\nvar PasswordFieldElement = /*#__PURE__*/function (_TextFieldElement) {\n  _inherits(PasswordFieldElement, _TextFieldElement);\n\n  var _super = _createSuper(PasswordFieldElement);\n\n  function PasswordFieldElement() {\n    _classCallCheck(this, PasswordFieldElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PasswordFieldElement, [{\n    key: \"ready\",\n\n    /** @protected */\n    value: function ready() {\n      var _this = this;\n\n      _get(_getPrototypeOf(PasswordFieldElement.prototype), \"ready\", this).call(this);\n\n      this.inputElement.type = 'password';\n      this.inputElement.autocapitalize = 'off';\n      this.addEventListener('focusout', function () {\n        if (!_this._passwordVisibilityChanging) {\n          _this._setPasswordVisible(false);\n\n          if (_this._cachedChangeEvent) {\n            _this._onChange(_this._cachedChangeEvent);\n          }\n        }\n      });\n    }\n    /**\n     * @param {!Event} e\n     * @protected\n     */\n\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(e) {\n      var slotted = this.querySelector(\"\".concat(this._slottedTagName, \"[slot=\\\"\").concat(this._slottedTagName, \"\\\"]\"));\n\n      if (slotted) {\n        e.stopPropagation();\n      }\n\n      if (this._passwordVisibilityChanging) {\n        this._cachedChangeEvent = e;\n      } else {\n        this._cachedChangeEvent = null;\n\n        _get(_getPrototypeOf(PasswordFieldElement.prototype), \"_onChange\", this).call(this, e);\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_revealButtonMouseDown\",\n    value: function _revealButtonMouseDown(e) {\n      if (this.hasAttribute('focused')) {\n        e.preventDefault();\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_togglePasswordVisibilityTouchend\",\n    value: function _togglePasswordVisibilityTouchend(e) {\n      // Cancel the following click event\n      e.preventDefault();\n\n      this._togglePasswordVisibility();\n\n      this.inputElement.focus();\n    }\n    /** @private */\n\n  }, {\n    key: \"_togglePasswordVisibility\",\n    value: function _togglePasswordVisibility() {\n      this._passwordVisibilityChanging = true;\n      this.inputElement.blur();\n\n      this._setPasswordVisible(!this.passwordVisible);\n\n      this.inputElement.focus();\n      this._passwordVisibilityChanging = false;\n    }\n    /** @private */\n\n  }, {\n    key: \"_passwordVisibleChange\",\n    value: function _passwordVisibleChange(passwordVisible) {\n      this.inputElement.type = passwordVisible ? 'text' : 'password';\n    }\n  }], [{\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-password-field';\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return '2.8.2';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * Set to true to hide the eye icon which toggles the password visibility.\n         * @attr {boolean} reveal-button-hidden\n         * @type {boolean}\n         */\n        revealButtonHidden: {\n          type: Boolean,\n          value: false\n        },\n\n        /**\n         * True if the password is visible ([type=text]).\n         * @attr {boolean} password-visible\n         * @type {boolean}\n         */\n        passwordVisible: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true,\n          observer: '_passwordVisibleChange',\n          readOnly: true\n        }\n      };\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      if (!memoizedTemplate) {\n        // Clone the superclass template\n        memoizedTemplate = _get(_getPrototypeOf(PasswordFieldElement), \"template\", this).cloneNode(true); // Retrieve this element's dom-module template\n\n        var thisTemplate = DomModule.import(this.is + '-template', 'template');\n        var revealButton = thisTemplate.content.querySelector('[part=\"reveal-button\"]');\n        var styles = thisTemplate.content.querySelector('style'); // Append reveal-button and styles to the text-field template\n\n        var inputField = memoizedTemplate.content.querySelector('[part=\"input-field\"]');\n        inputField.appendChild(revealButton);\n        memoizedTemplate.content.appendChild(styles);\n      }\n\n      return memoizedTemplate;\n    }\n  }]);\n\n  return PasswordFieldElement;\n}(TextFieldElement);\n\ncustomElements.define(PasswordFieldElement.is, PasswordFieldElement);\nexport { PasswordFieldElement };"
    },
    {
     "id": 346,
     "name": "../node_modules/@vaadin/vaadin-login/theme/lumo/vaadin-login-form-wrapper-styles.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"<dom-module id=\\\"lumo-login-form-wrapper\\\" theme-for=\\\"vaadin-login-form-wrapper\\\">\\n  <template>\\n    <style include=\\\"lumo-color lumo-typography\\\">\\n      :host {\\n        max-width: calc(var(--lumo-size-m) * 10);\\n        background: var(--lumo-base-color) linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));\\n      }\\n\\n      [part=\\\"form\\\"] {\\n        padding: var(--lumo-space-l);\\n      }\\n\\n      [part=\\\"form-title\\\"] {\\n        margin-top: calc(var(--lumo-font-size-xxxl) - var(--lumo-font-size-xxl));\\n      }\\n\\n      #forgotPasswordButton {\\n        margin: var(--lumo-space-s) auto;\\n      }\\n\\n      [part=\\\"error-message\\\"] {\\n        background-color: var(--lumo-error-color-10pct);\\n        padding: var(--lumo-space-m);\\n        border-radius: var(--lumo-border-radius);\\n        margin-top: var(--lumo-space-m);\\n        margin-bottom: var(--lumo-space-s);\\n        color: var(--lumo-error-text-color);\\n      }\\n\\n      :host(:not([dir=\\\"rtl\\\"])) [part=\\\"error-message\\\"] {\\n        padding-left: var(--lumo-size-m);\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"error-message\\\"] {\\n        padding-right: var(--lumo-size-m);\\n      }\\n\\n      [part=\\\"error-message\\\"]::before {\\n        content: var(--lumo-icons-error);\\n        font-family: lumo-icons;\\n        font-size: var(--lumo-icon-size-m);\\n        position: absolute;\\n        width: var(--lumo-size-m);\\n        height: 1em;\\n        line-height: 1;\\n        text-align: center;\\n      }\\n\\n      :host(:not([dir=\\\"rtl\\\"])) [part=\\\"error-message\\\"]::before {\\n        /* Visual centering */\\n        margin-left: calc(var(--lumo-size-m) * -0.95);\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"error-message\\\"]::before {\\n        /* Visual centering */\\n        margin-right: calc(var(--lumo-size-m) * -0.95);\\n      }\\n\\n      [part=\\\"error-message-title\\\"] {\\n        margin: 0 0 0.25em;\\n        color: inherit;\\n      }\\n\\n      [part=\\\"error-message-description\\\"] {\\n        font-size: var(--lumo-font-size-s);\\n        line-height: var(--lumo-line-height-s);\\n        margin: 0;\\n        opacity: 0.9;\\n      }\\n\\n      [part=\\\"footer\\\"] {\\n        font-size: var(--lumo-font-size-xs);\\n        line-height: var(--lumo-line-height-s);\\n        color: var(--lumo-secondary-text-color);\\n      }\\n    </style>\\n  </template>\\n</dom-module>\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html(_templateObject());\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 347,
     "name": "../node_modules/@vaadin/vaadin-login/src/vaadin-login-form-wrapper.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        overflow: hidden;\\n        display: inline-block;\\n      }\\n\\n      :host([hidden]) {\\n        display: none !important;\\n      }\\n\\n      [part=\\\"form\\\"] {\\n        flex: 1;\\n        display: flex;\\n        flex-direction: column;\\n        box-sizing: border-box;\\n      }\\n\\n      [part=\\\"form-title\\\"] {\\n        margin: 0;\\n      }\\n\\n      [part=\\\"error-message\\\"] {\\n        position: relative;\\n      }\\n    </style>\\n      <section part=\\\"form\\\">\\n        <h2 part=\\\"form-title\\\">[[i18n.form.title]]</h2>\\n        <div part=\\\"error-message\\\" hidden$=\\\"[[!error]]\\\">\\n          <h5 part=\\\"error-message-title\\\">[[i18n.errorMessage.title]]</h5>\\n          <p part=\\\"error-message-description\\\">[[i18n.errorMessage.message]]</p>\\n        </div>\\n\\n        <slot name=\\\"form\\\">\\n        </slot>\\n\\n        <vaadin-button id=\\\"forgotPasswordButton\\\" theme=\\\"tertiary small forgot-password\\\" on-click=\\\"_forgotPassword\\\" hidden$=\\\"[[noForgotPassword]]\\\">[[i18n.form.forgotPassword]]</vaadin-button>\\n\\n        <div part=\\\"footer\\\">\\n          <p>[[i18n.additionalInformation]]</p>\\n        </div>\\n      </section>\\n\"], [\"\\n    <style>\\n      :host {\\n        overflow: hidden;\\n        display: inline-block;\\n      }\\n\\n      :host([hidden]) {\\n        display: none !important;\\n      }\\n\\n      [part=\\\"form\\\"] {\\n        flex: 1;\\n        display: flex;\\n        flex-direction: column;\\n        box-sizing: border-box;\\n      }\\n\\n      [part=\\\"form-title\\\"] {\\n        margin: 0;\\n      }\\n\\n      [part=\\\"error-message\\\"] {\\n        position: relative;\\n      }\\n    </style>\\n      <section part=\\\"form\\\">\\n        <h2 part=\\\"form-title\\\">[[i18n.form.title]]</h2>\\n        <div part=\\\"error-message\\\" hidden\\\\$=\\\"[[!error]]\\\">\\n          <h5 part=\\\"error-message-title\\\">[[i18n.errorMessage.title]]</h5>\\n          <p part=\\\"error-message-description\\\">[[i18n.errorMessage.message]]</p>\\n        </div>\\n\\n        <slot name=\\\"form\\\">\\n        </slot>\\n\\n        <vaadin-button id=\\\"forgotPasswordButton\\\" theme=\\\"tertiary small forgot-password\\\" on-click=\\\"_forgotPassword\\\" hidden\\\\$=\\\"[[noForgotPassword]]\\\">[[i18n.form.forgotPassword]]</vaadin-button>\\n\\n        <div part=\\\"footer\\\">\\n          <p>[[i18n.additionalInformation]]</p>\\n        </div>\\n      </section>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nVaadin Login\nCopyright (C) 2018 Vaadin Ltd\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { LoginMixin } from './vaadin-login-mixin.js';\nimport '@vaadin/vaadin-button/src/vaadin-button.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-login-form-wrapper>` is a helper component providing a wrapper for the login form.\n *\n * See the usage in `<vaadin-login-form>`.\n *\n * ### Styling\n *\n * The following Shadow DOM parts of the `<vaadin-login-form-wrapper>` are available for styling:\n *\n * Part name      | Description\n * ---------------|---------------------------------------------------------|\n * `form`         | Container for the entire component's content\n * `form-title`   | Title of the login form\n * `error-message`| Container for error message, contains error-message-title and error-message-description parts. Hidden by default.\n * `error-message-title`       | Container for error message title\n * `error-message-description` | Container for error message description\n * `error-message-description` | Container for error message description\n * `footer`  | Container additional information text from `i18n` object\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * ### Component's slots\n *\n * The following slots are available for being set\n *\n * Slot name | Description\n * ----------|---------------------------------------------------|\n * `form`    | Html form placeholder. See the usage in `<vaadin-login-form>`.\n *\n * See examples of setting the content into slots in the live demos.\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @mixes Login.LoginMixin\n * @demo demo/index.html\n */\n\nvar LoginFormWrapperElement = /*#__PURE__*/function (_LoginMixin) {\n  _inherits(LoginFormWrapperElement, _LoginMixin);\n\n  var _super = _createSuper(LoginFormWrapperElement);\n\n  function LoginFormWrapperElement() {\n    _classCallCheck(this, LoginFormWrapperElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(LoginFormWrapperElement, [{\n    key: \"_forgotPassword\",\n    value: function _forgotPassword() {\n      this.dispatchEvent(new CustomEvent('forgot-password'));\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-login-form-wrapper';\n    }\n  }]);\n\n  return LoginFormWrapperElement;\n}(LoginMixin(ElementMixin(ThemableMixin(PolymerElement))));\n\ncustomElements.define(LoginFormWrapperElement.is, LoginFormWrapperElement);\nexport { LoginFormWrapperElement };"
    },
    {
     "id": 348,
     "name": "../node_modules/@vaadin/vaadin-login/src/vaadin-login-form.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      [part=\\\"vaadin-login-native-form\\\"] * {\\n        width: 100%;\\n      }\\n    </style>\\n    <vaadin-login-form-wrapper theme$=\\\"[[theme]]\\\" part=\\\"vaadin-login-native-form-wrapper\\\" action=\\\"{{action}}\\\" disabled=\\\"{{disabled}}\\\" error=\\\"{{error}}\\\" no-forgot-password=\\\"{{noForgotPassword}}\\\" i18n=\\\"{{i18n}}\\\" on-login=\\\"_retargetEvent\\\" on-forgot-password=\\\"_retargetEvent\\\">\\n\\n      <form part=\\\"vaadin-login-native-form\\\" method=\\\"POST\\\" action$=\\\"[[action]]\\\" slot=\\\"form\\\">\\n        <vaadin-text-field name=\\\"username\\\" label=\\\"[[i18n.form.username]]\\\" id=\\\"vaadinLoginUsername\\\" required=\\\"\\\" on-keydown=\\\"_handleInputKeydown\\\" autocapitalize=\\\"none\\\" autocorrect=\\\"off\\\" spellcheck=\\\"false\\\">\\n          <input type=\\\"text\\\" slot=\\\"input\\\" on-keyup=\\\"_handleInputKeyup\\\">\\n        </vaadin-text-field>\\n\\n        <vaadin-password-field name=\\\"password\\\" label=\\\"[[i18n.form.password]]\\\" id=\\\"vaadinLoginPassword\\\" required=\\\"\\\" on-keydown=\\\"_handleInputKeydown\\\" spellcheck=\\\"false\\\">\\n          <input type=\\\"password\\\" slot=\\\"input\\\" on-keyup=\\\"_handleInputKeyup\\\">\\n        </vaadin-password-field>\\n\\n        <vaadin-button part=\\\"vaadin-login-submit\\\" theme=\\\"primary contained\\\" on-click=\\\"submit\\\" disabled$=\\\"[[disabled]]\\\">[[i18n.form.submit]]</vaadin-button>\\n      </form>\\n    </vaadin-login-form-wrapper>\\n\"], [\"\\n    <style>\\n      [part=\\\"vaadin-login-native-form\\\"] * {\\n        width: 100%;\\n      }\\n    </style>\\n    <vaadin-login-form-wrapper theme\\\\$=\\\"[[theme]]\\\" part=\\\"vaadin-login-native-form-wrapper\\\" action=\\\"{{action}}\\\" disabled=\\\"{{disabled}}\\\" error=\\\"{{error}}\\\" no-forgot-password=\\\"{{noForgotPassword}}\\\" i18n=\\\"{{i18n}}\\\" on-login=\\\"_retargetEvent\\\" on-forgot-password=\\\"_retargetEvent\\\">\\n\\n      <form part=\\\"vaadin-login-native-form\\\" method=\\\"POST\\\" action\\\\$=\\\"[[action]]\\\" slot=\\\"form\\\">\\n        <vaadin-text-field name=\\\"username\\\" label=\\\"[[i18n.form.username]]\\\" id=\\\"vaadinLoginUsername\\\" required=\\\"\\\" on-keydown=\\\"_handleInputKeydown\\\" autocapitalize=\\\"none\\\" autocorrect=\\\"off\\\" spellcheck=\\\"false\\\">\\n          <input type=\\\"text\\\" slot=\\\"input\\\" on-keyup=\\\"_handleInputKeyup\\\">\\n        </vaadin-text-field>\\n\\n        <vaadin-password-field name=\\\"password\\\" label=\\\"[[i18n.form.password]]\\\" id=\\\"vaadinLoginPassword\\\" required=\\\"\\\" on-keydown=\\\"_handleInputKeydown\\\" spellcheck=\\\"false\\\">\\n          <input type=\\\"password\\\" slot=\\\"input\\\" on-keyup=\\\"_handleInputKeyup\\\">\\n        </vaadin-password-field>\\n\\n        <vaadin-button part=\\\"vaadin-login-submit\\\" theme=\\\"primary contained\\\" on-click=\\\"submit\\\" disabled\\\\$=\\\"[[disabled]]\\\">[[i18n.form.submit]]</vaadin-button>\\n      </form>\\n    </vaadin-login-form-wrapper>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport './vaadin-login-form-wrapper.js';\nimport '@vaadin/vaadin-text-field/src/vaadin-text-field.js';\nimport '@vaadin/vaadin-text-field/src/vaadin-password-field.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { LoginMixin } from './vaadin-login-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\n/**\n * `<vaadin-login-form>` is a Web Component providing an easy way to require users\n * to log in into an application. Note that component has no shadowRoot.\n *\n * ```\n * <vaadin-login-form></vaadin-login-form>\n * ```\n *\n * Component has to be accessible from the `document` layer in order to allow password managers to work properly with form values.\n * Using `<vaadin-login-overlay>` allows to always attach the component to the document body.\n *\n * ### Styling\n *\n * The component doesn't have a shadowRoot, so the html form and input fields can be styled in an upper layer. To style\n * `vaadin-login-form-wrapper` check its documentation.\n *\n * See examples of setting the content into slots in the live demos.\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @mixes LoginMixin\n * @demo demo/index.html\n */\n\nvar LoginFormElement = /*#__PURE__*/function (_LoginMixin) {\n  _inherits(LoginFormElement, _LoginMixin);\n\n  var _super = _createSuper(LoginFormElement);\n\n  function LoginFormElement() {\n    _classCallCheck(this, LoginFormElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(LoginFormElement, [{\n    key: \"connectedCallback\",\n\n    /** @protected */\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(LoginFormElement.prototype), \"connectedCallback\", this).call(this);\n\n      this._handleInputKeydown = this._handleInputKeydown.bind(this);\n    }\n    /**\n     * @param {StampedTemplate} dom\n     * @return {null}\n     * @protected\n     */\n\n  }, {\n    key: \"_attachDom\",\n    value: function _attachDom(dom) {\n      this.appendChild(dom);\n    }\n  }, {\n    key: \"_errorChanged\",\n\n    /** @private */\n    value: function _errorChanged() {\n      if (this.error && !this._preventAutoEnable) {\n        this.disabled = false;\n      }\n    }\n  }, {\n    key: \"submit\",\n    value: function submit() {\n      if (this.disabled || !(this.__isValid(this.$.vaadinLoginUsername) && this.__isValid(this.$.vaadinLoginPassword))) {\n        return;\n      }\n\n      this.error = false;\n      this.disabled = true;\n      var loginEventDetails = {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          username: this.$.vaadinLoginUsername.value,\n          password: this.$.vaadinLoginPassword.value\n        }\n      };\n      var firedEvent = this.dispatchEvent(new CustomEvent('login', loginEventDetails));\n\n      if (this.action && firedEvent) {\n        this.querySelector('[part=\"vaadin-login-native-form\"]').submit();\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"__isValid\",\n    value: function __isValid(input) {\n      return input.validate && input.validate() || input.checkValidity && input.checkValidity();\n    }\n    /** @private */\n\n  }, {\n    key: \"_isEnterKey\",\n    value: function _isEnterKey(e) {\n      return e.key === 'Enter' || e.keyCode === 13;\n    }\n    /** @private */\n\n  }, {\n    key: \"_handleInputKeydown\",\n    value: function _handleInputKeydown(e) {\n      if (this._isEnterKey(e)) {\n        var inputActive = e.currentTarget;\n        var nextInput = inputActive.id === 'vaadinLoginUsername' ? this.$.vaadinLoginPassword : this.$.vaadinLoginUsername;\n\n        if (this.__isValid(inputActive)) {\n          if (this.__isValid(nextInput)) {\n            this.submit();\n          } else {\n            nextInput.focus();\n          }\n        }\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_handleInputKeyup\",\n    value: function _handleInputKeyup(e) {\n      var isTab = e.key === 'Tab' || e.keyCode === 9;\n      var input = e.currentTarget;\n\n      if (isTab && input && input.select) {\n        input.select(); // iOS 9 workaround: https://stackoverflow.com/a/7436574\n\n        setTimeout(function () {\n          return input.setSelectionRange(0, 9999);\n        });\n      }\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-login-form';\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return '1.2.0';\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['_errorChanged(error)'];\n    }\n  }]);\n\n  return LoginFormElement;\n}(LoginMixin(ElementMixin(ThemableMixin(PolymerElement))));\n\ncustomElements.define(LoginFormElement.is, LoginFormElement);\nexport { LoginFormElement };"
    },
    {
     "id": 349,
     "name": "../node_modules/@vaadin/vaadin-radio-button/src/vaadin-radio-button.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: inline-block;\\n      }\\n\\n      label {\\n        display: inline-flex;\\n        align-items: baseline;\\n        outline: none;\\n      }\\n\\n      [part=\\\"radio\\\"] {\\n        position: relative;\\n        display: inline-block;\\n        flex: none;\\n      }\\n\\n      input[type=\\\"radio\\\"] {\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        width: 100%;\\n        height: 100%;\\n        opacity: 0;\\n        cursor: inherit;\\n        margin: 0;\\n      }\\n\\n      :host([disabled]) {\\n        -webkit-tap-highlight-color: transparent;\\n      }\\n    </style>\\n\\n    <label>\\n      <span part=\\\"radio\\\">\\n        <input type=\\\"radio\\\" checked=\\\"[[checked]]\\\" disabled$=\\\"[[disabled]]\\\" role=\\\"presentation\\\" on-change=\\\"_onChange\\\" tabindex=\\\"-1\\\">\\n      </span>\\n\\n      <span part=\\\"label\\\">\\n        <slot></slot>\\n      </span>\\n    </label>\\n\"], [\"\\n    <style>\\n      :host {\\n        display: inline-block;\\n      }\\n\\n      label {\\n        display: inline-flex;\\n        align-items: baseline;\\n        outline: none;\\n      }\\n\\n      [part=\\\"radio\\\"] {\\n        position: relative;\\n        display: inline-block;\\n        flex: none;\\n      }\\n\\n      input[type=\\\"radio\\\"] {\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        width: 100%;\\n        height: 100%;\\n        opacity: 0;\\n        cursor: inherit;\\n        margin: 0;\\n      }\\n\\n      :host([disabled]) {\\n        -webkit-tap-highlight-color: transparent;\\n      }\\n    </style>\\n\\n    <label>\\n      <span part=\\\"radio\\\">\\n        <input type=\\\"radio\\\" checked=\\\"[[checked]]\\\" disabled\\\\$=\\\"[[disabled]]\\\" role=\\\"presentation\\\" on-change=\\\"_onChange\\\" tabindex=\\\"-1\\\">\\n      </span>\\n\\n      <span part=\\\"label\\\">\\n        <slot></slot>\\n      </span>\\n    </label>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-radio-button>` is a Web Component for radio buttons.\n *\n * ```html\n * <vaadin-radio-button value=\"foo\">Foo</vaadin-radio-button>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name         | Description\n * ------------------|----------------\n * `radio`           | The radio button element\n * `label`           | The label content element\n *\n * The following state attributes are available for styling:\n *\n * Attribute  | Description | Part name\n * -----------|-------------|------------\n * `disabled`   | Set when the radio button is disabled. | :host\n * `focus-ring` | Set when the radio button is focused using the keyboard. | :host\n * `focused`    | Set when the radio button is focused. | :host\n * `checked`    | Set when the radio button is checked. | :host\n * `empty`      | Set when there is no label provided. | label\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ControlStateMixin\n * @mixes ThemableMixin\n * @mixes GestureEventListeners\n * @element vaadin-radio-button\n * @demo demo/index.html\n */\n\nvar RadioButtonElement = /*#__PURE__*/function (_ElementMixin) {\n  _inherits(RadioButtonElement, _ElementMixin);\n\n  var _super = _createSuper(RadioButtonElement);\n\n  function RadioButtonElement() {\n    _classCallCheck(this, RadioButtonElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(RadioButtonElement, [{\n    key: \"attributeChangedCallback\",\n\n    /**\n     * @param {string} prop\n     * @param {?string} oldVal\n     * @param {?string} newVal\n     * @protected\n     */\n    value: function attributeChangedCallback(prop, oldVal, newVal) {\n      _get(_getPrototypeOf(RadioButtonElement.prototype), \"attributeChangedCallback\", this).call(this, prop, oldVal, newVal); // Needed until Edge has CSS Custom Properties (present in Edge Preview)\n\n      /* istanbul ignore if */\n\n\n      if (/^(disabled|checked)$/.test(prop)) {\n        // iOS 10.3 Safari has an issue with repainting shadow root element styles when a host attribute changes.\n        // Need this workaround (toggle any inline css property on and off) until we drop iOS 10.\n        var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n        /* istanbul ignore if */\n\n        if (isIOS && this.shadowRoot && parseInt(navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/)[1], 10)) {\n          var WEBKIT_PROPERTY = '-webkit-backface-visibility';\n          this.shadowRoot.querySelectorAll('*').forEach(function (el) {\n            el.style[WEBKIT_PROPERTY] = 'visible';\n            el.style[WEBKIT_PROPERTY] = '';\n          });\n        }\n      }\n    }\n    /** @protected */\n\n  }, {\n    key: \"ready\",\n    value: function ready() {\n      _get(_getPrototypeOf(RadioButtonElement.prototype), \"ready\", this).call(this);\n\n      this.setAttribute('role', 'radio');\n\n      this._addListeners();\n\n      var attrName = this.getAttribute('name');\n\n      if (attrName) {\n        this.name = attrName;\n      }\n\n      this.shadowRoot.querySelector('[part~=\"label\"]').querySelector('slot').addEventListener('slotchange', this._updateLabelAttribute.bind(this));\n\n      this._updateLabelAttribute();\n    }\n    /** @private */\n\n  }, {\n    key: \"_updateLabelAttribute\",\n    value: function _updateLabelAttribute() {\n      var label = this.shadowRoot.querySelector('[part~=\"label\"]');\n      var assignedNodes = label.firstElementChild.assignedNodes();\n\n      if (this._isAssignedNodesEmpty(assignedNodes)) {\n        label.setAttribute('empty', '');\n      } else {\n        label.removeAttribute('empty');\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_isAssignedNodesEmpty\",\n    value: function _isAssignedNodesEmpty(nodes) {\n      // The assigned nodes considered to be empty if there is no slotted content or only one empty text node\n      return nodes.length === 0 || nodes.length == 1 && nodes[0].nodeType == Node.TEXT_NODE && nodes[0].textContent.trim() === '';\n    }\n    /** @private */\n\n  }, {\n    key: \"_checkedChanged\",\n    value: function _checkedChanged(checked) {\n      this.setAttribute('aria-checked', checked);\n    }\n    /** @private */\n\n  }, {\n    key: \"_addListeners\",\n    value: function _addListeners() {\n      var _this = this;\n\n      this._addEventListenerToNode(this, 'down', function (e) {\n        if (!_this.disabled) {\n          _this.setAttribute('active', '');\n        }\n      });\n\n      this._addEventListenerToNode(this, 'up', function (e) {\n        _this.removeAttribute('active');\n\n        if (!_this.checked && !_this.disabled) {\n          // If you change this block, please test manually that radio-button and\n          // radio-group still works ok on iOS 12/13 and up as it may cause\n          // an issue that is not possible to test programmatically.\n          // See: https://github.com/vaadin/vaadin-radio-button/issues/140\n          _this.click();\n        }\n      });\n\n      this.addEventListener('keydown', function (e) {\n        if (!_this.disabled && e.keyCode === 32) {\n          e.preventDefault();\n\n          _this.setAttribute('active', '');\n        }\n      });\n      this.addEventListener('keyup', function (e) {\n        if (!_this.disabled && e.keyCode === 32) {\n          e.preventDefault();\n\n          _this.click();\n\n          _this.removeAttribute('active');\n        }\n      });\n    }\n    /**\n     * Toggles the radio button, so that the native `change` event\n     * is dispatched. Overrides the standard `HTMLElement.prototype.click`.\n     * @protected\n     */\n\n  }, {\n    key: \"click\",\n    value: function click() {\n      // If you change this block, please test manually that radio-button and\n      // radio-group still works ok on iOS 12/13 and up as it may cause\n      // an issue that is not possible to test programmatically.\n      // See: https://github.com/vaadin/vaadin-radio-button/issues/140\n      if (!this.disabled) {\n        this.shadowRoot.querySelector('input').dispatchEvent(new MouseEvent('click'));\n      }\n    }\n    /**\n     * @return {!HTMLInputElement}\n     * @protected\n     */\n\n  }, {\n    key: \"_onChange\",\n\n    /** @private */\n    value: function _onChange(e) {\n      this.checked = e.target.checked; // In the Shadow DOM, the `change` event is not leaked into the\n      // ancestor tree, so we must do this manually.\n\n      var changeEvent = new CustomEvent('change', {\n        detail: {\n          sourceEvent: e\n        },\n        bubbles: e.bubbles,\n        cancelable: e.cancelable\n      });\n      this.dispatchEvent(changeEvent);\n    }\n    /**\n     * Fired when the user toggles the radio button.\n     *\n     * @event change\n     */\n\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.checked ? this._storedName : '';\n    },\n    set: function set(name) {\n      this._storedName = name;\n    }\n  }, {\n    key: \"focusElement\",\n    get: function get() {\n      return this.shadowRoot.querySelector('input');\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-radio-button';\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return '1.5.1';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * True if the radio button is checked.\n         * @type {boolean}\n         */\n        checked: {\n          type: Boolean,\n          value: false,\n          notify: true,\n          observer: '_checkedChanged',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Name of the element.\n         */\n        name: String,\n\n        /**\n         * The value for this element.\n         * @type {string}\n         */\n        value: {\n          type: String,\n          value: 'on'\n        }\n      };\n    }\n  }]);\n\n  return RadioButtonElement;\n}(ElementMixin(ControlStateMixin(ThemableMixin(GestureEventListeners(PolymerElement)))));\n\ncustomElements.define(RadioButtonElement.is, RadioButtonElement);\nexport { RadioButtonElement };"
    },
    {
     "id": 350,
     "name": "../node_modules/@vaadin/vaadin-text-field/src/vaadin-number-field.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"<dom-module id=\\\"vaadin-number-field-template\\\">\\n  <template>\\n    <style>\\n      :host([readonly]) [part$=\\\"button\\\"] {\\n        pointer-events: none;\\n      }\\n\\n      [part=\\\"decrease-button\\\"]::before {\\n        content: \\\"\\u2212\\\";\\n      }\\n\\n      [part=\\\"increase-button\\\"]::before {\\n        content: \\\"+\\\";\\n      }\\n\\n      [part=\\\"decrease-button\\\"],\\n      [part=\\\"increase-button\\\"] {\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n      }\\n\\n      /* Hide the native arrow icons */\\n      [part=\\\"value\\\"]::-webkit-outer-spin-button,\\n      [part=\\\"value\\\"]::-webkit-inner-spin-button {\\n        -webkit-appearance: none;\\n        margin: 0;\\n      }\\n\\n      [part=\\\"value\\\"] {\\n        /* Older Firefox versions (v47.0) requires !important */\\n        -moz-appearance: textfield !important;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] {\\n        direction: ltr;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"value\\\"]::placeholder {\\n        direction: rtl;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] ::slotted(input)::placeholder {\\n        direction: rtl;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"value\\\"]:-ms-input-placeholder,\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] ::slotted(input):-ms-input-placeholder {\\n        direction: rtl;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"value\\\"]::placeholder {\\n        text-align: left;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"input-field\\\"] ::slotted(input)::placeholder {\\n        text-align: left;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"value\\\"]:-ms-input-placeholder,\\n      :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"input-field\\\"] ::slotted(input):-ms-input-placeholder {\\n        text-align: left;\\n      }\\n    </style>\\n\\n    <div disabled$=\\\"[[!_allowed(-1, value, min, max, step)]]\\\" part=\\\"decrease-button\\\" on-click=\\\"_decreaseValue\\\" on-touchend=\\\"_decreaseButtonTouchend\\\" hidden$=\\\"[[!hasControls]]\\\">\\n    </div>\\n\\n    <div disabled$=\\\"[[!_allowed(1, value, min, max, step)]]\\\" part=\\\"increase-button\\\" on-click=\\\"_increaseValue\\\" on-touchend=\\\"_increaseButtonTouchend\\\" hidden$=\\\"[[!hasControls]]\\\">\\n    </div>\\n  </template>\\n\\n  \\n</dom-module>\"], [\"<dom-module id=\\\"vaadin-number-field-template\\\">\\n  <template>\\n    <style>\\n      :host([readonly]) [part\\\\$=\\\"button\\\"] {\\n        pointer-events: none;\\n      }\\n\\n      [part=\\\"decrease-button\\\"]::before {\\n        content: \\\"\\u2212\\\";\\n      }\\n\\n      [part=\\\"increase-button\\\"]::before {\\n        content: \\\"+\\\";\\n      }\\n\\n      [part=\\\"decrease-button\\\"],\\n      [part=\\\"increase-button\\\"] {\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n      }\\n\\n      /* Hide the native arrow icons */\\n      [part=\\\"value\\\"]::-webkit-outer-spin-button,\\n      [part=\\\"value\\\"]::-webkit-inner-spin-button {\\n        -webkit-appearance: none;\\n        margin: 0;\\n      }\\n\\n      [part=\\\"value\\\"] {\\n        /* Older Firefox versions (v47.0) requires !important */\\n        -moz-appearance: textfield !important;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] {\\n        direction: ltr;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"value\\\"]::placeholder {\\n        direction: rtl;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] ::slotted(input)::placeholder {\\n        direction: rtl;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"value\\\"]:-ms-input-placeholder,\\n      :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] ::slotted(input):-ms-input-placeholder {\\n        direction: rtl;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"value\\\"]::placeholder {\\n        text-align: left;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"input-field\\\"] ::slotted(input)::placeholder {\\n        text-align: left;\\n      }\\n\\n      :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"value\\\"]:-ms-input-placeholder,\\n      :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"input-field\\\"] ::slotted(input):-ms-input-placeholder {\\n        text-align: left;\\n      }\\n    </style>\\n\\n    <div disabled\\\\$=\\\"[[!_allowed(-1, value, min, max, step)]]\\\" part=\\\"decrease-button\\\" on-click=\\\"_decreaseValue\\\" on-touchend=\\\"_decreaseButtonTouchend\\\" hidden\\\\$=\\\"[[!hasControls]]\\\">\\n    </div>\\n\\n    <div disabled\\\\$=\\\"[[!_allowed(1, value, min, max, step)]]\\\" part=\\\"increase-button\\\" on-click=\\\"_increaseValue\\\" on-touchend=\\\"_increaseButtonTouchend\\\" hidden\\\\$=\\\"[[!hasControls]]\\\">\\n    </div>\\n  </template>\\n\\n  \\n</dom-module>\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport '@polymer/polymer/polymer-element.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nimport { TextFieldElement } from './vaadin-text-field.js';\nimport { DomModule } from '@polymer/polymer/lib/elements/dom-module.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html(_templateObject());\ndocument.head.appendChild($_documentContainer.content);\nvar memoizedTemplate;\n/**\n * `<vaadin-number-field>` is a Web Component for number field control in forms.\n *\n * ```html\n * <vaadin-number-field label=\"Number\">\n * </vaadin-number-field>\n * ```\n * @extends TextFieldElement\n * @demo demo/index.html\n */\n\nvar NumberFieldElement = /*#__PURE__*/function (_TextFieldElement) {\n  _inherits(NumberFieldElement, _TextFieldElement);\n\n  var _super = _createSuper(NumberFieldElement);\n\n  function NumberFieldElement() {\n    _classCallCheck(this, NumberFieldElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(NumberFieldElement, [{\n    key: \"ready\",\n\n    /** @protected */\n    value: function ready() {\n      _get(_getPrototypeOf(NumberFieldElement.prototype), \"ready\", this).call(this);\n\n      this.__previousValidInput = this.value || '';\n      this.inputElement.type = 'number';\n      this.inputElement.addEventListener('change', this.__onInputChange.bind(this));\n    }\n    /** @private */\n\n  }, {\n    key: \"_decreaseButtonTouchend\",\n    value: function _decreaseButtonTouchend(e) {\n      // Cancel the following click and focus events\n      e.preventDefault();\n\n      this._decreaseValue();\n    }\n    /** @private */\n\n  }, {\n    key: \"_increaseButtonTouchend\",\n    value: function _increaseButtonTouchend(e) {\n      // Cancel the following click and focus events\n      e.preventDefault();\n\n      this._increaseValue();\n    }\n  }, {\n    key: \"_createConstraintsObserver\",\n\n    /** @protected */\n    value: function _createConstraintsObserver() {\n      // NOTE: do not call \"super\" but instead override the method to add extra arguments\n      this._createMethodObserver('_constraintsChanged(required, minlength, maxlength, pattern, min, max, step)');\n    }\n    /** @private */\n\n  }, {\n    key: \"_constraintsChanged\",\n    value: function _constraintsChanged(required, minlength, maxlength, pattern, min, max, step) {\n      if (!this.invalid) {\n        return;\n      }\n\n      var isNumUnset = function isNumUnset(n) {\n        return !n && n !== 0;\n      };\n\n      if (!isNumUnset(min) || !isNumUnset(max)) {\n        this.validate();\n      } else {\n        _get(_getPrototypeOf(NumberFieldElement.prototype), \"_constraintsChanged\", this).call(this, required, minlength, maxlength, pattern);\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_decreaseValue\",\n    value: function _decreaseValue() {\n      this._incrementValue(-1);\n    }\n    /** @private */\n\n  }, {\n    key: \"_increaseValue\",\n    value: function _increaseValue() {\n      this._incrementValue(1);\n    }\n    /** @private */\n\n  }, {\n    key: \"_incrementValue\",\n    value: function _incrementValue(incr) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      var value = parseFloat(this.value);\n\n      if (!this.value) {\n        if (this.min == 0 && incr < 0 || this.max == 0 && incr > 0 || this.max == 0 && this.min == 0) {\n          incr = 0;\n          value = 0;\n        } else if ((this.max == null || this.max >= 0) && (this.min == null || this.min <= 0)) {\n          value = 0;\n        } else if (this.min > 0) {\n          value = this.min;\n\n          if (this.max < 0 && incr < 0) {\n            value = this.max;\n          }\n\n          incr = 0;\n        } else if (this.max < 0) {\n          value = this.max;\n\n          if (incr < 0) {\n            incr = 0;\n          } else {\n            // FIXME(yuriy): find a proper solution to make correct step back\n            if (this._getIncrement(1, value - this.step) > this.max) {\n              value -= 2 * this.step;\n            } else {\n              value -= this.step;\n            }\n          }\n        }\n      } else if (value < this.min) {\n        incr = 0;\n        value = this.min;\n      } else if (value > this.max) {\n        incr = 0;\n        value = this.max;\n      }\n\n      var newValue = this._getIncrement(incr, value);\n\n      if (!this.value || incr == 0 || this._incrementIsInsideTheLimits(incr, value)) {\n        this._setValue(newValue);\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_setValue\",\n    value: function _setValue(value) {\n      this.value = this.inputElement.value = String(parseFloat(value));\n      this.dispatchEvent(new CustomEvent('change', {\n        bubbles: true\n      }));\n    }\n    /** @private */\n\n  }, {\n    key: \"_getIncrement\",\n    value: function _getIncrement(incr, currentValue) {\n      var step = this.step || 1,\n          min = this.min || 0; // To avoid problems with decimal math, multiplying to operate with integers.\n\n      var multiplier = Math.max(this._getMultiplier(currentValue), this._getMultiplier(step), this._getMultiplier(min));\n      step *= multiplier;\n      currentValue = Math.round(currentValue * multiplier);\n      min *= multiplier;\n      var margin = (currentValue - min) % step;\n\n      if (incr > 0) {\n        return (currentValue - margin + step) / multiplier;\n      } else if (incr < 0) {\n        return (currentValue - (margin || step)) / multiplier;\n      } else {\n        return currentValue / multiplier;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_getDecimalCount\",\n    value: function _getDecimalCount(number) {\n      var s = String(number);\n      var i = s.indexOf('.');\n      return i === -1 ? 1 : s.length - i - 1;\n    }\n    /** @private */\n\n  }, {\n    key: \"_getMultiplier\",\n    value: function _getMultiplier(number) {\n      if (!isNaN(number)) {\n        return Math.pow(10, this._getDecimalCount(number));\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_incrementIsInsideTheLimits\",\n    value: function _incrementIsInsideTheLimits(incr, value) {\n      if (incr < 0) {\n        return this.min == null || this._getIncrement(incr, value) >= this.min;\n      } else if (incr > 0) {\n        return this.max == null || this._getIncrement(incr, value) <= this.max;\n      } else {\n        return this._getIncrement(incr, value) <= this.max && this._getIncrement(incr, value) >= this.min;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"_allowed\",\n    value: function _allowed(sign) {\n      var incr = sign * (this.step || 1);\n      var value = parseFloat(this.value);\n      return !this.value || !this.disabled && this._incrementIsInsideTheLimits(incr, value);\n    }\n    /**\n     * @param {number} newVal\n     * @param {number | undefined} oldVal\n     * @protected\n     */\n\n  }, {\n    key: \"_stepChanged\",\n    value: function _stepChanged(newVal, oldVal) {\n      // Avoid using initial value in validation\n      this.__validateByStep = this.__stepChangedCalled || this.getAttribute('step') !== null;\n      this.inputElement.step = this.__validateByStep ? newVal : 'any';\n      this.__stepChangedCalled = true;\n      this.setAttribute('step', newVal);\n    }\n    /** @private */\n\n  }, {\n    key: \"_minChanged\",\n    value: function _minChanged(min) {\n      this.inputElement.min = min;\n    }\n    /** @private */\n\n  }, {\n    key: \"_maxChanged\",\n    value: function _maxChanged(max) {\n      this.inputElement.max = max;\n    }\n    /**\n     * @param {unknown} newVal\n     * @param {unknown} oldVal\n     * @protected\n     */\n\n  }, {\n    key: \"_valueChanged\",\n    value: function _valueChanged(newVal, oldVal) {\n      // Validate value to be numeric\n      if (newVal && isNaN(parseFloat(newVal))) {\n        this.value = '';\n      } else if (typeof this.value !== 'string') {\n        this.value = String(this.value);\n      }\n\n      _get(_getPrototypeOf(NumberFieldElement.prototype), \"_valueChanged\", this).call(this, this.value, oldVal);\n    }\n    /**\n     * @param {!KeyboardEvent} e\n     * @protected\n     */\n\n  }, {\n    key: \"_onKeyDown\",\n    value: function _onKeyDown(e) {\n      if (e.keyCode == 38) {\n        e.preventDefault();\n\n        this._increaseValue();\n      } else if (e.keyCode == 40) {\n        e.preventDefault();\n\n        this._decreaseValue();\n      }\n\n      _get(_getPrototypeOf(NumberFieldElement.prototype), \"_onKeyDown\", this).call(this, e);\n    }\n    /** @private */\n\n  }, {\n    key: \"__onInputChange\",\n    value: function __onInputChange() {\n      this.validate();\n    }\n    /**\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"checkValidity\",\n    value: function checkValidity() {\n      // text-field mixin does not check against `min`, `max` and `step`\n      if (this.min !== undefined || this.max !== undefined || this.__validateByStep) {\n        return this.inputElement.checkValidity();\n      }\n\n      return _get(_getPrototypeOf(NumberFieldElement.prototype), \"checkValidity\", this).call(this);\n    }\n  }], [{\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-number-field';\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return '2.8.2';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * Set to true to display value increase/decrease controls.\n         * @attr {boolean} has-controls\n         * @type {boolean}\n         */\n        hasControls: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true\n        },\n\n        /**\n         * The minimum value of the field.\n         */\n        min: {\n          type: Number,\n          reflectToAttribute: true,\n          observer: '_minChanged'\n        },\n\n        /**\n         * The maximum value of the field.\n         */\n        max: {\n          type: Number,\n          reflectToAttribute: true,\n          observer: '_maxChanged'\n        },\n\n        /**\n         * Specifies the allowed number intervals of the field.\n         * @type {number}\n         */\n        step: {\n          type: Number,\n          value: 1,\n          observer: '_stepChanged'\n        }\n      };\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      if (!memoizedTemplate) {\n        // Clone the superclass template\n        memoizedTemplate = _get(_getPrototypeOf(NumberFieldElement), \"template\", this).cloneNode(true); // Retrieve this element's dom-module template\n\n        var thisTemplate = DomModule.import(this.is + '-template', 'template');\n        var decreaseButton = thisTemplate.content.querySelector('[part=\"decrease-button\"]');\n        var increaseButton = thisTemplate.content.querySelector('[part=\"increase-button\"]');\n        var styles = thisTemplate.content.querySelector('style'); // Add the buttons and styles to the text-field template\n\n        var inputField = memoizedTemplate.content.querySelector('[part=\"input-field\"]');\n        var prefixSlot = memoizedTemplate.content.querySelector('[name=\"prefix\"]');\n        inputField.insertBefore(decreaseButton, prefixSlot);\n        inputField.appendChild(increaseButton);\n        memoizedTemplate.content.appendChild(styles);\n      }\n\n      return memoizedTemplate;\n    }\n  }]);\n\n  return NumberFieldElement;\n}(TextFieldElement);\n\nwindow.customElements.define(NumberFieldElement.is, NumberFieldElement);\nexport { NumberFieldElement };"
    },
    {
     "id": 352,
     "name": "../node_modules/@vaadin/vaadin-context-menu/src/vaadin-context-menu.js?babel-target=es5 + 4 modules"
    },
    {
     "id": 354,
     "name": "../node_modules/@vaadin/vaadin-time-picker/theme/lumo/vaadin-time-picker.js?babel-target=es5 + 3 modules"
    },
    {
     "id": 356,
     "name": "../node_modules/@vaadin/vaadin-login/theme/lumo/vaadin-login-form.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 358,
     "name": "../node_modules/@vaadin/vaadin-select/src/vaadin-select.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 365,
     "name": "../node_modules/@vaadin/vaadin-context-menu/theme/lumo/vaadin-context-menu.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 366,
     "name": "../node_modules/@vaadin/vaadin-crud/src/vaadin-crud-edit-column.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 367,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-sorter.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 368,
     "name": "../node_modules/@vaadin/vaadin-select/theme/lumo/vaadin-select.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 369,
     "name": "../node_modules/@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-button.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 370,
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-number-field.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 372,
     "name": "../node_modules/@vaadin/vaadin-time-picker/src/vaadin-time-picker.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 397,
     "name": "../node_modules/@vaadin/flow-frontend/comboBoxConnector-es6.js?babel-target=es5",
     "source": "import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nimport './comboBoxConnector.js';\nimport { ComboBoxPlaceholder } from '@vaadin/vaadin-combo-box/src/vaadin-combo-box-placeholder.js';\nwindow.Vaadin.Flow.Legacy.Debouncer = Debouncer;\nwindow.Vaadin.Flow.Legacy.timeOut = timeOut;\nwindow.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;"
    },
    {
     "id": 398,
     "name": "../node_modules/@vaadin/flow-frontend/contextMenuConnector-es6.js?babel-target=es5",
     "source": "import { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport * as Gestures from '@polymer/polymer/lib/utils/gestures.js';\nimport './contextMenuConnector.js';\nwindow.Vaadin.Flow.Legacy.GestureEventListeners = GestureEventListeners;\nwindow.Vaadin.Flow.Legacy.Gestures = Gestures;"
    },
    {
     "id": 399,
     "name": "../node_modules/@vaadin/flow-frontend/datepickerConnector.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\n(function () {\n  var tryCatchWrapper = function tryCatchWrapper(callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Date Picker', 'vaadin-date-picker-flow');\n  };\n  /* helper class for parsing regex from formatted date string */\n\n\n  var FlowDatePickerPart = /*#__PURE__*/function () {\n    function FlowDatePickerPart(initial) {\n      _classCallCheck(this, FlowDatePickerPart);\n\n      this.initial = initial;\n      this.index = 0;\n      this.value = 0;\n    }\n\n    _createClass(FlowDatePickerPart, null, [{\n      key: \"compare\",\n      value: function compare(part1, part2) {\n        if (part1.index < part2.index) {\n          return -1;\n        }\n\n        if (part1.index > part2.index) {\n          return 1;\n        }\n\n        return 0;\n      }\n    }]);\n\n    return FlowDatePickerPart;\n  }();\n\n  window.Vaadin.Flow.datepickerConnector = {\n    initLazy: function initLazy(datepicker) {\n      return tryCatchWrapper(function (datepicker) {\n        // Check whether the connector was already initialized for the datepicker\n        if (datepicker.$connector) {\n          return;\n        }\n\n        datepicker.$connector = {};\n        /* init helper parts for reverse-engineering date-regex */\n\n        datepicker.$connector.dayPart = new FlowDatePickerPart(\"22\");\n        datepicker.$connector.monthPart = new FlowDatePickerPart(\"11\");\n        datepicker.$connector.yearPart = new FlowDatePickerPart(\"1987\");\n        datepicker.$connector.parts = [datepicker.$connector.dayPart, datepicker.$connector.monthPart, datepicker.$connector.yearPart]; // Old locale should always be the default vaadin-date-picker component\n        // locale {English/US} as we init lazily and the date-picker formats\n        // the date using the default i18n settings and we need to use the input\n        // value as we may need to parse user input so we can't use the _selectedDate value.\n\n        var oldLocale = \"en-us\";\n        datepicker.addEventListener('blur', tryCatchWrapper(function (e) {\n          if (!e.target.value && e.target.invalid) {\n            console.warn(\"Invalid value in the DatePicker.\");\n          }\n        }));\n        var cleanString = tryCatchWrapper(function (string) {\n          // Clear any non ascii characters from the date string,\n          // mainly the LEFT-TO-RIGHT MARK.\n          // This is a problem for many Microsoft browsers where `toLocaleDateString`\n          // adds the LEFT-TO-RIGHT MARK see https://en.wikipedia.org/wiki/Left-to-right_mark\n          return string.replace(/[^\\x00-\\x7F]/g, \"\");\n        });\n        var getInputValue = tryCatchWrapper(function () {\n          var inputValue = '';\n\n          try {\n            inputValue = datepicker._inputValue;\n          } catch (err) {\n            /* component not ready: falling back to stored value */\n            inputValue = datepicker.value || '';\n          }\n\n          return inputValue;\n        });\n        datepicker.$connector.setLocale = tryCatchWrapper(function (locale) {\n          try {\n            // Check whether the locale is supported or not\n            new Date().toLocaleDateString(locale);\n          } catch (e) {\n            locale = \"en-US\";\n            console.warn(\"The locale is not supported, using default locale setting(en-US).\");\n          }\n\n          var currentDate = false;\n          var inputValue = getInputValue();\n\n          if (datepicker.i18n.parseDate !== 'undefined' && inputValue) {\n            /* get current date with old parsing */\n            currentDate = datepicker.i18n.parseDate(inputValue);\n          }\n          /* create test-string where to extract parsing regex */\n\n\n          var testDate = new Date(Date.UTC(datepicker.$connector.yearPart.initial, datepicker.$connector.monthPart.initial - 1, datepicker.$connector.dayPart.initial));\n          var testString = cleanString(testDate.toLocaleDateString(locale, {\n            timeZone: 'UTC'\n          }));\n          datepicker.$connector.parts.forEach(function (part) {\n            part.index = testString.indexOf(part.initial);\n          });\n          /* sort items to match correct places in regex groups */\n\n          datepicker.$connector.parts.sort(FlowDatePickerPart.compare);\n          /* create regex\n          * regex will be the date, so that:\n          * - day-part is '(\\d{1,2})' (1 or 2 digits),\n          * - month-part is '(\\d{1,2})' (1 or 2 digits),\n          * - year-part is '(\\d{4})' (4 digits)\n          *\n          * and everything else is left as is.\n          * For example, us date \"10/20/2010\" => \"(\\d{1,2})/(\\d{1,2})/(\\d{4})\".\n          *\n          * The sorting part solves that which part is which (for example,\n          * here the first part is month, second day and third year)\n          *  */\n\n          datepicker.$connector.regex = testString.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&').replace(datepicker.$connector.dayPart.initial, \"(\\\\d{1,2})\").replace(datepicker.$connector.monthPart.initial, \"(\\\\d{1,2})\").replace(datepicker.$connector.yearPart.initial, \"(\\\\d{4})\");\n          datepicker.i18n.formatDate = tryCatchWrapper(function (date) {\n            var rawDate = new Date(Date.UTC(date.year, date.month, date.day));\n            return cleanString(rawDate.toLocaleDateString(locale, {\n              timeZone: 'UTC'\n            }));\n          });\n          datepicker.i18n.parseDate = tryCatchWrapper(function (dateString) {\n            dateString = cleanString(dateString);\n\n            if (dateString.length == 0) {\n              return;\n            }\n\n            var match = dateString.match(datepicker.$connector.regex);\n\n            if (match && match.length == 4) {\n              for (var i = 1; i < 4; i++) {\n                datepicker.$connector.parts[i - 1].value = parseInt(match[i]);\n              }\n\n              return {\n                day: datepicker.$connector.dayPart.value,\n                month: datepicker.$connector.monthPart.value - 1,\n                year: datepicker.$connector.yearPart.value\n              };\n            } else {\n              return false;\n            }\n          });\n\n          if (inputValue === \"\") {\n            oldLocale = locale;\n          } else if (currentDate) {\n            /* set current date to invoke use of new locale */\n            datepicker._selectedDate = new Date(currentDate.year, currentDate.month, currentDate.day);\n          }\n        });\n      })(datepicker);\n    }\n  };\n})();"
    },
    {
     "id": 400,
     "name": "../node_modules/@vaadin/flow-frontend/dndConnector-es6.js?babel-target=es5",
     "source": "import './dndConnector.js';"
    },
    {
     "id": 401,
     "name": "../node_modules/@vaadin/flow-frontend/flow-component-renderer.js?babel-target=es5",
     "source": "import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <slot></slot>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport '@polymer/polymer/polymer-legacy.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { animationFrame, idlePeriod } from '@polymer/polymer/lib/utils/async.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\n\nvar FlowComponentRenderer = /*#__PURE__*/function (_PolymerElement) {\n  _inherits(FlowComponentRenderer, _PolymerElement);\n\n  var _super = _createSuper(FlowComponentRenderer);\n\n  function FlowComponentRenderer() {\n    _classCallCheck(this, FlowComponentRenderer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(FlowComponentRenderer, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(FlowComponentRenderer.prototype), \"connectedCallback\", this).call(this);\n\n      this._runChrome72ShadowDomBugWorkaround();\n    }\n    /* workaround for issue vaadin/flow#5025 */\n\n  }, {\n    key: \"_runChrome72ShadowDomBugWorkaround\",\n    value: function _runChrome72ShadowDomBugWorkaround() {\n      var _this = this;\n\n      var userAgent = navigator.userAgent;\n\n      if (userAgent && userAgent.match('Chrome\\/')) {\n        // example: ... Chrome/72.0.3626.96 ...\n        var majorVersionString = userAgent.split('Chrome\\/')[1].split('.')[0];\n\n        if (majorVersionString && parseInt(majorVersionString) > 71) {\n          var debouncedNotifyResize = this._getDebouncedNotifyResizeFunction(); // if there is no notifyResize function, then just skip\n\n\n          if (debouncedNotifyResize) {\n            this.style.visibility = 'hidden'; // need to use animation frame instead of timeout or focusing won't work\n\n            requestAnimationFrame(function () {\n              _this.style.visibility = '';\n              debouncedNotifyResize();\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_getDebouncedNotifyResizeFunction\",\n    value: function _getDebouncedNotifyResizeFunction() {\n      // 1. dig out the web component that might have the notifyResize function\n      var component = this.parentElement;\n\n      while (true) {\n        if (!component) {\n          return;\n        }\n\n        if (component.notifyResize) {\n          break;\n        } else {\n          component = component.parentElement;\n        }\n      } // 2. assign a debounced proxy to notifyResize, if not yet there\n\n\n      if (!component._debouncedNotifyResize) {\n        component._debouncedNotifyResize = function () {\n          component.__debouncedNotifyResize = Debouncer.debounce(component.__debouncedNotifyResize, // initially undefined\n          animationFrame, component.notifyResize);\n        };\n      }\n\n      return component._debouncedNotifyResize;\n    }\n  }, {\n    key: \"ready\",\n    value: function ready() {\n      _get(_getPrototypeOf(FlowComponentRenderer.prototype), \"ready\", this).call(this);\n\n      this.addEventListener(\"click\", function (event) {\n        if (this.firstChild && typeof this.firstChild.click === \"function\" && event.target === this) {\n          this.firstChild.click();\n        }\n      });\n    }\n  }, {\n    key: \"_asyncAttachRenderedComponentIfAble\",\n    value: function _asyncAttachRenderedComponentIfAble() {\n      var _this2 = this;\n\n      this._debouncer = Debouncer.debounce(this._debouncer, idlePeriod, function () {\n        return _this2._attachRenderedComponentIfAble();\n      });\n    }\n  }, {\n    key: \"_attachRenderedComponentIfAble\",\n    value: function _attachRenderedComponentIfAble() {\n      if (!this.nodeid || !this.appid) {\n        return;\n      }\n\n      var renderedComponent = this._getRenderedComponent();\n\n      if (this.firstChild) {\n        if (!renderedComponent) {\n          this._clear();\n\n          this._asyncAttachRenderedComponentIfAble();\n        } else if (this.firstChild !== renderedComponent) {\n          this.replaceChild(renderedComponent, this.firstChild);\n\n          this._defineFocusTarget();\n\n          this.onComponentRendered();\n        } else {\n          this._defineFocusTarget();\n\n          this.onComponentRendered();\n        }\n      } else {\n        if (renderedComponent) {\n          this.appendChild(renderedComponent);\n\n          this._defineFocusTarget();\n\n          this.onComponentRendered();\n        } else {\n          this._asyncAttachRenderedComponentIfAble();\n        }\n      }\n    }\n  }, {\n    key: \"_getRenderedComponent\",\n    value: function _getRenderedComponent() {\n      try {\n        return window.Vaadin.Flow.clients[this.appid].getByNodeId(this.nodeid);\n      } catch (error) {\n        console.error(\"Could not get node %s from app %s\", this.nodeid, this.appid);\n        console.error(error);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      while (this.firstChild) {\n        this.removeChild(this.firstChild);\n      }\n    }\n  }, {\n    key: \"onComponentRendered\",\n    value: function onComponentRendered() {// subclasses can override this method to execute custom logic on resize\n    }\n    /* Setting the `focus-target` attribute to the first focusable descendant\n    starting from the firstChild necessary for the focus to be delegated\n    within the flow-component-renderer when used inside a vaadin-grid cell  */\n\n  }, {\n    key: \"_defineFocusTarget\",\n    value: function _defineFocusTarget() {\n      var focusable = this._getFirstFocusableDescendant(this.firstChild);\n\n      if (focusable !== null) {\n        focusable.setAttribute('focus-target', 'true');\n      }\n    }\n  }, {\n    key: \"_getFirstFocusableDescendant\",\n    value: function _getFirstFocusableDescendant(node) {\n      if (this._isFocusable(node)) {\n        return node;\n      }\n\n      if (!node.children) {\n        return null;\n      }\n\n      for (var i = 0; i < node.children.length; i++) {\n        var focusable = this._getFirstFocusableDescendant(node.children[i]);\n\n        if (focusable !== null) {\n          return focusable;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_isFocusable\",\n    value: function _isFocusable(node) {\n      if (node.hasAttribute && typeof node.hasAttribute === 'function' && (node.hasAttribute(\"disabled\") || node.hasAttribute(\"hidden\"))) {\n        return false;\n      }\n\n      return node.tabIndex === 0;\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'flow-component-renderer';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        nodeid: Number,\n        appid: String\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['_attachRenderedComponentIfAble(appid, nodeid)'];\n    }\n  }]);\n\n  return FlowComponentRenderer;\n}(PolymerElement);\n\nwindow.customElements.define(FlowComponentRenderer.is, FlowComponentRenderer);"
    },
    {
     "id": 402,
     "name": "../node_modules/@vaadin/flow-frontend/gridConnector-es6.js?babel-target=es5",
     "source": "import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut, animationFrame } from '@polymer/polymer/lib/utils/async.js';\nimport { GridElement } from '@vaadin/vaadin-grid/src/vaadin-grid.js';\nimport { ItemCache } from '@vaadin/vaadin-grid/src/vaadin-grid-data-provider-mixin.js';\nimport './gridConnector.js';\nwindow.Vaadin.Flow.Legacy.Debouncer = Debouncer;\nwindow.Vaadin.Flow.Legacy.timeOut = timeOut;\nwindow.Vaadin.Flow.Legacy.animationFrame = animationFrame;\nwindow.Vaadin.Flow.Legacy.GridElement = GridElement;\nwindow.Vaadin.Flow.Legacy.ItemCache = ItemCache;"
    },
    {
     "id": 403,
     "name": "../node_modules/@babel/runtime/helpers/set.js?babel-target=es5",
     "source": "var superPropBase = require(\"./superPropBase\");\n\nvar defineProperty = require(\"./defineProperty\");\n\nfunction set(target, property, value, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.set) {\n    set = Reflect.set;\n  } else {\n    set = function set(target, property, value, receiver) {\n      var base = superPropBase(target, property);\n      var desc;\n\n      if (base) {\n        desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.set) {\n          desc.set.call(receiver, value);\n          return true;\n        } else if (!desc.writable) {\n          return false;\n        }\n      }\n\n      desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n      if (desc) {\n        if (!desc.writable) {\n          return false;\n        }\n\n        desc.value = value;\n        Object.defineProperty(receiver, property, desc);\n      } else {\n        defineProperty(receiver, property, value);\n      }\n\n      return true;\n    };\n  }\n\n  return set(target, property, value, receiver);\n}\n\nfunction _set(target, property, value, receiver, isStrict) {\n  var s = set(target, property, value, receiver || target);\n\n  if (!s && isStrict) {\n    throw new Error('failed to set property');\n  }\n\n  return value;\n}\n\nmodule.exports = _set;"
    },
    {
     "id": 404,
     "name": "../node_modules/@vaadin/flow-frontend/gridProConnector.js?babel-target=es5",
     "source": "(function () {\n  var tryCatchWrapper = function tryCatchWrapper(callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Grid Pro', 'vaadin-grid-pro-flow');\n  };\n\n  window.Vaadin.Flow.gridProConnector = {\n    setEditModeRenderer: function setEditModeRenderer(column, component) {\n      return tryCatchWrapper(function (column, component) {\n        column.editModeRenderer = tryCatchWrapper(function (root) {\n          root.appendChild(component);\n\n          this._grid._cancelStopEdit();\n\n          component.focus();\n        }); // Not needed in case of custom editor as value is set on server-side.\n        // Overridden in order to avoid blinking of the cell content.\n\n        column._setEditorValue = function (editor, value) {};\n\n        column._getEditorValue = function (editor) {\n          return;\n        };\n      })(column, component);\n    },\n    patchEditModeRenderer: function patchEditModeRenderer(column) {\n      return tryCatchWrapper(function (column) {\n        column.__editModeRenderer = tryCatchWrapper(function (root, column, rowData) {\n          var cell = root.assignedSlot.parentNode;\n          var grid = column._grid;\n\n          if (grid.__edited && grid.__edited.model.item.key !== rowData.item.key) {\n            grid._stopEdit();\n\n            return;\n          }\n\n          var tagName = column._getEditorTagName(cell);\n\n          if (!root.firstElementChild || root.firstElementChild.localName.toLowerCase() !== tagName) {\n            root.innerHTML = \"<\".concat(tagName, \"></\").concat(tagName, \">\");\n          }\n        });\n      })(column);\n    }\n  };\n})();"
    },
    {
     "id": 405,
     "name": "../node_modules/@vaadin/flow-frontend/ironListConnector-es6.js?babel-target=es5",
     "source": "import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nimport './ironListConnector.js';\nwindow.Vaadin.Flow.Legacy.Debouncer = Debouncer;\nwindow.Vaadin.Flow.Legacy.timeOut = timeOut;"
    },
    {
     "id": 406,
     "name": "../node_modules/@vaadin/flow-frontend/ironListStyles.js?babel-target=es5",
     "source": "import '@polymer/polymer/lib/elements/custom-style.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = \"<style>\\n/* Fixes zero width in flex layouts */\\niron-list {\\n  flex: auto;\\n  align-self: stretch;\\n}\\n</style>\";\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 407,
     "name": "../node_modules/@vaadin/flow-frontend/menubarConnector.js?babel-target=es5",
     "source": "/*\n * Copyright 2000-2019 Vaadin Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n(function () {\n  var tryCatchWrapper = function tryCatchWrapper(callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Menu Bar', 'vaadin-menu-bar-flow');\n  };\n\n  window.Vaadin.Flow.menubarConnector = {\n    initLazy: function initLazy(menubar) {\n      if (menubar.$connector) {\n        return;\n      }\n\n      menubar.$connector = {\n        updateButtons: tryCatchWrapper(function () {\n          if (!menubar.shadowRoot) {\n            // workaround for https://github.com/vaadin/flow/issues/5722\n            setTimeout(function () {\n              return menubar.$connector.updateButtons();\n            });\n            return;\n          } // Propagate disabled state from items to parent buttons\n\n\n          menubar.items.forEach(function (item) {\n            return item.disabled = item.component.disabled;\n          }); // Remove hidden items entirely from the array. Just hiding them\n          // could cause the overflow button to be rendered without items.\n          // resetContent needs to be called to make buttons visible again.\n          //\n          // The items-prop needs to be set even when all items are visible\n          // to update the disabled state and re-render buttons.\n\n          menubar.items = menubar.items.filter(function (item) {\n            return !item.component.hidden;\n          }); // Propagate click events from the menu buttons to the item components\n\n          menubar._buttons.forEach(function (button) {\n            if (button.item && button.item.component) {\n              button.addEventListener('click', function (e) {\n                if (e.composedPath().indexOf(button.item.component) === -1) {\n                  button.item.component.click();\n                }\n              });\n            }\n          });\n        })\n      };\n    }\n  };\n})();"
    },
    {
     "id": 408,
     "name": "../node_modules/@vaadin/flow-frontend/timepickerConnector.js?babel-target=es5",
     "source": "(function () {\n  var tryCatchWrapper = function tryCatchWrapper(callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Time Picker', 'vaadin-time-picker-flow');\n  };\n\n  window.Vaadin.Flow.timepickerConnector = {\n    initLazy: function initLazy(timepicker) {\n      return tryCatchWrapper(function (timepicker) {\n        // Check whether the connector was already initialized for the timepicker\n        if (timepicker.$connector) {\n          return;\n        }\n\n        timepicker.$connector = {};\n\n        var getAmPmString = function getAmPmString(locale, testTime) {\n          var testTimeString = testTime.toLocaleTimeString(locale); // AM/PM string is anything from one letter in eastern arabic to standard two letters,\n          // to having space in between, dots ...\n          // cannot disqualify whitespace since some locales use a. m. / p. m.\n          // TODO when more scripts support is added (than Arabic), need to exclude those numbers too\n\n          var endWithAmPmRegex = /[^\\d\\u0660-\\u0669]+$/g;\n          var amPmString = testTimeString.match(endWithAmPmRegex);\n\n          if (!amPmString) {\n            // eg. chinese (and some else too) starts with am/pm\n            amPmString = testTimeString.match(/^[^\\d\\u0660-\\u0669]+/g);\n          }\n\n          if (amPmString) {\n            amPmString = amPmString[0].trim();\n          }\n\n          return amPmString;\n        };\n\n        var testPmTime = new Date('August 19, 1975 23:15:30');\n        var testAmTime = new Date('August 19, 1975 05:15:30');\n\n        var getPmString = function getPmString(locale) {\n          return getAmPmString(locale, testPmTime);\n        };\n\n        var getAmString = function getAmString(locale) {\n          return getAmPmString(locale, testAmTime);\n        }; // map from unicode eastern arabic number characters to arabic numbers\n\n\n        var arabicDigitMap = {\n          \"\\\\u0660\": '0',\n          \"\\\\u0661\": '1',\n          \"\\\\u0662\": '2',\n          \"\\\\u0663\": '3',\n          \"\\\\u0664\": '4',\n          \"\\\\u0665\": '5',\n          \"\\\\u0666\": '6',\n          \"\\\\u0667\": '7',\n          \"\\\\u0668\": '8',\n          \"\\\\u0669\": '9'\n        }; // parses eastern arabic number characters to arabic numbers (0-9)\n\n        var anyNumberCharToArabicNumberReplacer = function anyNumberCharToArabicNumberReplacer(charsToReplace) {\n          return charsToReplace.replace(/[\\u0660-\\u0669]/g, function (char) {\n            var unicode = \"\\\\u0\" + char.charCodeAt(0).toString(16);\n            return arabicDigitMap[unicode];\n          });\n        };\n\n        var parseAnyCharsToInt = function parseAnyCharsToInt(anyNumberChars) {\n          return parseInt(anyNumberCharToArabicNumberReplacer(anyNumberChars));\n        };\n\n        var parseMillisecondCharsToInt = function parseMillisecondCharsToInt(millisecondChars) {\n          millisecondChars = anyNumberCharToArabicNumberReplacer(millisecondChars); // digits are either .1 .01 or .001 so need to \"shift\"\n\n          if (millisecondChars.length === 1) {\n            millisecondChars += \"00\";\n          } else if (millisecondChars.length === 2) {\n            millisecondChars += \"0\";\n          }\n\n          return parseInt(millisecondChars);\n        }; // detecting milliseconds from input, expects am/pm removed from end, eg. .0 or .00 or .000\n\n\n        var millisecondRegExp = /[[\\.][\\d\\u0660-\\u0669]{1,3}$/;\n        timepicker.$connector.setLocale = tryCatchWrapper(function (locale) {\n          // capture previous value if any\n          var previousValueObject;\n\n          if (timepicker.value && timepicker.value !== '') {\n            previousValueObject = timepicker.i18n.parseTime(timepicker.value);\n          }\n\n          try {\n            // Check whether the locale is supported by the browser or not\n            testPmTime.toLocaleTimeString(locale);\n          } catch (e) {\n            locale = \"en-US\"; // FIXME should do a callback for server to throw an exception ?\n\n            throw new Error(\"vaadin-time-picker: The locale \" + locale + \" is not supported, falling back to default locale setting(en-US).\");\n          } // 1. 24 or 12 hour clock, if latter then what are the am/pm strings ?\n\n\n          var pmString = getPmString(locale);\n          var amString = getAmString(locale); // 2. What is the separator ?\n\n          var localeTimeString = testPmTime.toLocaleTimeString(locale); // since the next regex picks first non-number-whitespace, need to discard possible PM from beginning (eg. chinese locale)\n\n          if (pmString && localeTimeString.startsWith(pmString)) {\n            localeTimeString = localeTimeString.replace(pmString, '');\n          }\n\n          var separator = localeTimeString.match(/[^\\u0660-\\u0669\\s\\d]/); // 3. regexp that allows to find the numbers with optional separator and continuing searching after it\n\n          var numbersRegExp = new RegExp(\"([\\\\d\\\\u0660-\\\\u0669]){1,2}(?:\" + separator + ')?', 'g');\n\n          var includeSeconds = function includeSeconds() {\n            return timepicker.step && timepicker.step < 60;\n          };\n\n          var includeMilliSeconds = function includeMilliSeconds() {\n            return timepicker.step && timepicker.step < 1;\n          }; // the web component expects the correct granularity used for the time string,\n          // thus need to format the time object in correct granularity by passing the format options\n\n\n          var cachedStep;\n          var cachedOptions;\n\n          var getTimeFormatOptions = function getTimeFormatOptions() {\n            // calculate the format options if none done cached or step has changed\n            if (!cachedOptions || cachedStep !== timepicker.step) {\n              cachedOptions = {\n                hour: \"numeric\",\n                minute: \"numeric\",\n                second: includeSeconds() ? \"numeric\" : undefined\n              };\n              cachedStep = timepicker.step;\n            }\n\n            return cachedOptions;\n          };\n\n          var formatMilliseconds = function formatMilliseconds(localeTimeString, milliseconds) {\n            if (includeMilliSeconds()) {\n              // might need to inject milliseconds between seconds and AM/PM\n              var cleanedTimeString = localeTimeString;\n\n              if (localeTimeString.endsWith(amString)) {\n                cleanedTimeString = localeTimeString.replace(\" \" + amString, '');\n              } else if (localeTimeString.endsWith(pmString)) {\n                cleanedTimeString = localeTimeString.replace(\" \" + pmString, '');\n              }\n\n              if (milliseconds) {\n                var millisecondsString = milliseconds < 10 ? \"0\" : \"\";\n                millisecondsString += milliseconds < 100 ? \"0\" : \"\";\n                millisecondsString += milliseconds;\n                cleanedTimeString += \".\" + millisecondsString;\n              } else {\n                cleanedTimeString += \".000\";\n              }\n\n              if (localeTimeString.endsWith(amString)) {\n                cleanedTimeString = cleanedTimeString + \" \" + amString;\n              } else if (localeTimeString.endsWith(pmString)) {\n                cleanedTimeString = cleanedTimeString + \" \" + pmString;\n              }\n\n              return cleanedTimeString;\n            }\n\n            return localeTimeString;\n          };\n\n          var cachedTimeString;\n          var cachedTimeObject;\n          timepicker.i18n = {\n            formatTime: tryCatchWrapper(function (timeObject) {\n              if (timeObject) {\n                var timeToBeFormatted = new Date();\n                timeToBeFormatted.setHours(timeObject.hours);\n                timeToBeFormatted.setMinutes(timeObject.minutes);\n                timeToBeFormatted.setSeconds(timeObject.seconds !== undefined ? timeObject.seconds : 0);\n\n                var _localeTimeString = timeToBeFormatted.toLocaleTimeString(locale, getTimeFormatOptions()); // milliseconds not part of the time format API\n\n\n                _localeTimeString = formatMilliseconds(_localeTimeString, timeObject.milliseconds);\n                return _localeTimeString;\n              }\n            }),\n            parseTime: tryCatchWrapper(function (timeString) {\n              if (timeString && timeString === cachedTimeString && cachedTimeObject) {\n                return cachedTimeObject;\n              }\n\n              if (timeString) {\n                var pm = timeString.search(pmString);\n                var am = timeString.search(amString);\n                var numbersOnlyTimeString = timeString.replace(amString, '').replace(pmString, '').trim(); // reset regex to beginning or things can explode when the length of the input changes\n\n                numbersRegExp.lastIndex = 0;\n                var hours = numbersRegExp.exec(numbersOnlyTimeString);\n\n                if (hours) {\n                  hours = parseAnyCharsToInt(hours[0].replace(separator, '')); // handle 12 am -> 0\n                  // do not do anything if am & pm are not used or if those are the same,\n                  // as with locale bg-BG there is always . at the end of the time\n\n                  if (pm !== am) {\n                    if (hours === 12 && am !== -1) {\n                      hours = 0;\n                    } else {\n                      hours += pm !== -1 && hours !== 12 ? 12 : 0;\n                    }\n                  }\n\n                  var minutes = numbersRegExp.exec(numbersOnlyTimeString);\n                  var seconds = minutes && numbersRegExp.exec(numbersOnlyTimeString); // reset to end or things can explode\n\n                  var milliseconds = seconds && includeMilliSeconds() && millisecondRegExp.exec(numbersOnlyTimeString); // handle case where last numbers are seconds and . is the separator (invalid regexp match)\n\n                  if (milliseconds && milliseconds['index'] <= seconds['index']) {\n                    milliseconds = undefined;\n                  } // hours is a number at this point, others are either arrays or null\n                  // the string in [0] from the arrays includes the separator too\n\n\n                  cachedTimeObject = hours !== undefined && {\n                    hours: hours,\n                    minutes: minutes ? parseAnyCharsToInt(minutes[0].replace(separator, '')) : 0,\n                    seconds: seconds ? parseAnyCharsToInt(seconds[0].replace(separator, '')) : 0,\n                    milliseconds: minutes && seconds && milliseconds ? parseMillisecondCharsToInt(milliseconds[0].replace('.', '')) : 0\n                  };\n                  cachedTimeString = timeString;\n                  return cachedTimeObject;\n                } // when nothing is returned, the component shows the invalid state for the input\n\n              }\n            })\n          };\n\n          if (previousValueObject) {\n            var newValue = timepicker.i18n.formatTime(previousValueObject); // FIXME works but uses private API, needs fixes in web component\n\n            if (timepicker.__inputElement.value !== newValue) {\n              timepicker.__inputElement.value = newValue;\n              timepicker.__dropdownElement.value = newValue;\n\n              timepicker.__onInputChange();\n            }\n          }\n        });\n      })(timepicker);\n    }\n  };\n})();"
    },
    {
     "id": 409,
     "name": "../node_modules/@vaadin/flow-frontend/vaadin-big-decimal-field.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*\n * Copyright 2000-2019 Vaadin Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n(function () {\n  var memoizedTemplate;\n  customElements.whenDefined('vaadin-text-field').then(function () {\n    var BigDecimalFieldElement = /*#__PURE__*/function (_customElements$get) {\n      _inherits(BigDecimalFieldElement, _customElements$get);\n\n      var _super = _createSuper(BigDecimalFieldElement);\n\n      function BigDecimalFieldElement() {\n        _classCallCheck(this, BigDecimalFieldElement);\n\n        return _super.apply(this, arguments);\n      }\n\n      _createClass(BigDecimalFieldElement, [{\n        key: \"ready\",\n        value: function ready() {\n          _get(_getPrototypeOf(BigDecimalFieldElement.prototype), \"ready\", this).call(this);\n\n          this.inputElement.setAttribute('inputmode', 'decimal');\n        }\n      }, {\n        key: \"__decimalSeparatorChanged\",\n        value: function __decimalSeparatorChanged(separator, oldSeparator) {\n          this._enabledCharPattern = '[\\\\d-+' + separator + ']';\n\n          if (this.value && oldSeparator) {\n            this.value = this.value.split(oldSeparator).join(separator);\n          }\n        }\n      }], [{\n        key: \"template\",\n        get: function get() {\n          if (!memoizedTemplate) {\n            memoizedTemplate = _get(_getPrototypeOf(BigDecimalFieldElement), \"template\", this).cloneNode(true);\n            memoizedTemplate.innerHTML += \"<style>\\n                  :host {\\n                    width: 8em;\\n                  }\\n\\n                  :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] {\\n                    direction: ltr;\\n                  }\\n\\n                  :host([dir=\\\"rtl\\\"]) [part=\\\"value\\\"]::placeholder {\\n                    direction: rtl;\\n                  }\\n\\n                  :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] ::slotted(input)::placeholder {\\n                    direction: rtl;\\n                  }\\n\\n                  :host([dir=\\\"rtl\\\"]) [part=\\\"value\\\"]:-ms-input-placeholder,\\n                  :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] ::slotted(input):-ms-input-placeholder {\\n                    direction: rtl;\\n                  }\\n\\n                  :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"value\\\"]::placeholder {\\n                    text-align: left;\\n                  }\\n\\n                  :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"input-field\\\"] ::slotted(input)::placeholder {\\n                    text-align: left;\\n                  }\\n\\n                  :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"value\\\"]:-ms-input-placeholder,\\n                  :host([dir=\\\"rtl\\\"]:not([has-controls])) [part=\\\"input-field\\\"] ::slotted(input):-ms-input-placeholder {\\n                    text-align: left;\\n                  }\\n\\n                  :host([dir=\\\"rtl\\\"]) [part=\\\"value\\\"],\\n                  :host([dir=\\\"rtl\\\"]) [part=\\\"input-field\\\"] ::slotted(input) {\\n                    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em) !important;\\n                  }\\n            </style>\";\n          }\n\n          return memoizedTemplate;\n        }\n      }, {\n        key: \"is\",\n        get: function get() {\n          return 'vaadin-big-decimal-field';\n        }\n      }, {\n        key: \"properties\",\n        get: function get() {\n          return {\n            _decimalSeparator: {\n              type: String,\n              value: '.',\n              observer: '__decimalSeparatorChanged'\n            }\n          };\n        }\n      }]);\n\n      return BigDecimalFieldElement;\n    }(customElements.get('vaadin-text-field'));\n\n    customElements.define(BigDecimalFieldElement.is, BigDecimalFieldElement);\n  });\n})();"
    },
    {
     "id": 410,
     "name": "../node_modules/@vaadin/vaadin-board/vaadin-board-row.js?babel-target=es5",
     "source": "import './theme/lumo/vaadin-board-row.js';\nexport * from './src/vaadin-board-row.js';"
    },
    {
     "id": 411,
     "name": "../node_modules/@vaadin/vaadin-charts/src/vaadin-chart-series.js?babel-target=es5",
     "source": "import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n@license\nVaadin Charts\nCopyright (C) 2015 Vaadin Ltd\nThis program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).\nSee the file LICENSE.md distributed with this software for more information about licensing.\nSee <a href=\"https://vaadin.com/license/cval-3\">the website</a> for the complete license.\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ChartDeepMerger, ChartElement } from './vaadin-chart.js';\n/**\n * `<vaadin-chart-series>` is a custom element for creating series for Vaadin Charts.\n *\n * ### Basic use\n *\n * To use `<vaadin-chart-series>`, simply add it inside a `<vaadin-chart>` element:\n *\n * ```html\n *  <vaadin-chart>\n *    <vaadin-chart-series></vaadin-chart-series>\n *  </vaadin-chart>\n * ```\n *\n * `<vaadin-chart-series>` accepts `values` as an array attribute, so you can add it to your element definition:\n *\n * ```html\n *  <vaadin-chart-series values=\"[10,20,30,40,50]\"></vaadin-chart-series>\n * ```\n *\n * which will add a new line series, where each value will be a data point.\n * Look for the Properties session to see all available attributes.\n *\n * ### Dynamically adding and removing series\n *\n * You are also able to add and remove series by using DOM API.\n *\n * To create a new series, simply call `document.createElement('vaadin-chart-series')` and append it to your `<vaadin-chart>`:\n *\n * ```js\n *  const chart = \\* a <vaadin-chart> reference *\\\n *  const newSeries = document.createElement('vaadin-chart-series');\n *  newSeries.values = [10,20,30,40,50];\n *  chart.appendChild(newSeries);\n * ```\n *\n * In order to remove it, you should use the series to be removed as a reference for the `#removeChild()` call:\n *\n * ```js\n *  const chart = \\* a <vaadin-chart> reference *\\\n *  const seriesToBeRemoved = \\* a <vaadin-chart-series> reference to remove*\\\n *  chart.removeChild(seriesToBeRemoved);\n * ```\n *\n * (There's an issue with `#remove()` method on Firefox, so we advice to remove the element from its parent)\n *\n *\n * @polymer\n * @customElement\n * @extends {Polymer.Element}\n * @extends PolymerElement\n * @demo demo/index.html\n */\n\nvar ChartSeriesElement = /*#__PURE__*/function (_PolymerElement) {\n  _inherits(ChartSeriesElement, _PolymerElement);\n\n  var _super = _createSuper(ChartSeriesElement);\n\n  function ChartSeriesElement() {\n    _classCallCheck(this, ChartSeriesElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ChartSeriesElement, [{\n    key: \"setSeries\",\n\n    /**\n     * Method to attach a series object of type `Highcharts.Series`.\n     * @param series Object of type `Highcharts.Series`\n     */\n    value: function setSeries(series) {\n      this._series = series;\n    }\n  }, {\n    key: \"__valuesObserver\",\n    value: function __valuesObserver() {\n      if (this.__hasSeriesConfig()) {\n        this._series.setData(this.values);\n      }\n    }\n  }, {\n    key: \"__additionalOptionsObserver\",\n    value: function __additionalOptionsObserver() {\n      if (this.__hasSeriesConfig()) {\n        this._series.update(this.additionalOptions);\n      }\n    }\n  }, {\n    key: \"__valueMinObserver\",\n    value: function __valueMinObserver() {\n      if (!this.__hasSeriesConfig()) {\n        return;\n      }\n\n      if (!isFinite(this.valueMin)) {\n        this.__showWarn('value-min', 'Numbers or null');\n\n        return;\n      }\n\n      if (this._series.yAxis) {\n        this._series.yAxis.update({\n          min: this.valueMin\n        });\n      }\n    }\n  }, {\n    key: \"__valueMaxObserver\",\n    value: function __valueMaxObserver() {\n      if (!this.__hasSeriesConfig()) {\n        return;\n      }\n\n      if (!isFinite(this.valueMax)) {\n        this.__showWarn('value-max', 'Numbers or null');\n\n        return;\n      }\n\n      if (this._series.yAxis) {\n        this._series.yAxis.update({\n          max: this.valueMax\n        });\n      }\n    }\n  }, {\n    key: \"__typeObserver\",\n    value: function __typeObserver() {\n      if (this.__hasSeriesConfig()) {\n        this._series.update({\n          type: this.type\n        });\n      }\n    }\n  }, {\n    key: \"__titleObserver\",\n    value: function __titleObserver() {\n      if (this.__hasSeriesConfig()) {\n        this._series.update({\n          name: this.title\n        });\n      }\n    }\n  }, {\n    key: \"__stackObserver\",\n    value: function __stackObserver() {\n      if (!this.__hasSeriesConfig()) {\n        return;\n      }\n\n      this._series.update({\n        stack: this.stack\n      });\n    }\n  }, {\n    key: \"__neckPositionOberserver\",\n    value: function __neckPositionOberserver() {\n      if (!this.__hasSeriesConfig()) {\n        return;\n      }\n\n      this._series.update({\n        neckHeight: this.neckPosition\n      });\n    }\n  }, {\n    key: \"__neckWidthOberserver\",\n    value: function __neckWidthOberserver() {\n      if (!this.__hasSeriesConfig()) {\n        return;\n      }\n\n      this._series.update({\n        neckWidth: this.neckWidth\n      });\n    }\n  }, {\n    key: \"__unitObserver\",\n    value: function __unitObserver() {\n      if (this.__hasSeriesConfig()) {\n        var parent = this.parentNode instanceof ChartElement && this.parentNode;\n\n        if (parent && parent instanceof ChartElement) {\n          if (this.unit && !parent.__getAxis(this.unit)) {\n            var title = {\n              title: {\n                text: this.unit\n              }\n            };\n\n            parent.__addAxis(Object.assign({\n              id: this.unit,\n              axisGenerated: true\n            }, title));\n          }\n\n          this._series.update({\n            yAxis: this.unit || 0\n          });\n\n          this.__valueMinObserver();\n\n          this.__valueMaxObserver();\n\n          parent.__removeAxisIfEmpty();\n        }\n      }\n    }\n  }, {\n    key: \"__hasSeriesConfig\",\n    value: function __hasSeriesConfig() {\n      return !!this._series;\n    }\n  }, {\n    key: \"__isMarkersValid\",\n    value: function __isMarkersValid() {\n      if (['shown', 'hidden', 'auto'].indexOf(this.markers) === -1) {\n        this.__showWarn('markers', '\"shown\", \"hidden\" or \"auto\"');\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"__markersObserver\",\n    value: function __markersObserver() {\n      if (!this.__isMarkersValid()) {\n        this.markers = 'auto';\n        return;\n      }\n\n      if (this.__hasSeriesConfig()) {\n        this._series.update({\n          marker: this.__markersConfiguration\n        });\n      }\n    }\n  }, {\n    key: \"__showWarn\",\n    value: function __showWarn(propertyName, acceptedValues) {\n      console.warn('<vaadin-chart-series> Acceptable values for \"' + propertyName + '\" are ' + acceptedValues);\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      var options = ChartDeepMerger.__deepMerge({}, this.additionalOptions);\n\n      if (this.type) {\n        options.type = this.type;\n      }\n\n      if (this.title) {\n        options.name = this.title;\n      }\n\n      if (this.values) {\n        options.data = this.values;\n      }\n\n      if (this.markers) {\n        if (!this.__isMarkersValid()) {\n          this.markers = 'auto';\n        }\n\n        options.marker = this.__markersConfiguration;\n      }\n\n      if (this.unit) {\n        options.yAxis = this.unit;\n      }\n\n      if (this.stack) {\n        options.stack = this.stack;\n      }\n\n      if (isFinite(this.valueMin)) {\n        options.yAxisValueMin = this.valueMin;\n      }\n\n      if (isFinite(this.valueMax)) {\n        options.yAxisValueMax = this.valueMax;\n      }\n\n      if (this.neckWidth) {\n        options.neckWidth = this.neckWidth;\n      }\n\n      if (this.neckPosition) {\n        options.neckHeight = this.neckPosition;\n      }\n\n      return options;\n    }\n  }, {\n    key: \"__markersConfiguration\",\n    get: function get() {\n      var config = {};\n\n      switch (this.markers) {\n        case 'shown':\n          config.enabled = true;\n          break;\n\n        case 'hidden':\n          config.enabled = false;\n          break;\n\n        case 'auto':\n        default:\n          config.enabled = null;\n          break;\n      }\n\n      return config;\n    }\n  }], [{\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-chart-series';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * An array of data used by the series.\n         * Format depends on the chart type and can be:\n         *   - An array of numerical values `[y0, y1, y2, y3,...]`\n         *   - An array of arrays with 2 values (`x`, `y`) `[ [x0, y0], [x1, y1], [x2, y2], ... ]`\n         *   - An array of objects, each one describing one point `[ {x: x0, y: y0, name: 'Point0', color: '#FF0000'}, {...}, ...]`\n         *\n         *  See more in [API Site](https://api.highcharts.com/highcharts/series)\n         *\n         * Note that you should always use [Polymer API](https://www.polymer-project.org/2.0/docs/devguide/model-data#array-mutation)\n         * to mutate the values array in order to make the component aware of the\n         * change and be able to synchronize it.\n         */\n        values: {\n          type: Array,\n          value: function value() {\n            return [];\n          }\n        },\n\n        /**\n         *  Value-axis minimum-value.\n         *  Sets the value to a series bound by 'unit' property.\n         *  Otherwise sets the value to the first series.\n         *  Undefined by default (determined from data).\n         */\n        valueMin: {\n          type: Number,\n          observer: '__valueMinObserver',\n          reflectToAttribute: true\n        },\n\n        /**\n         *  Value-axis maximum-value.\n         *  See the 'valueMin'\n         */\n        valueMax: {\n          type: Number,\n          observer: '__valueMaxObserver',\n          reflectToAttribute: true\n        },\n\n        /**\n         *  A string with the type of the series.\n         *  Defaults to `'line'` in case no type is set for the chart.\n         * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type on `<vaadin-chart>`.\n         */\n        type: {\n          type: String,\n          observer: '__typeObserver',\n          reflectToAttribute: true\n        },\n\n        /**\n         * The name of the series as shown in the legend, tooltip etc.\n         */\n        title: {\n          type: String,\n          observer: '__titleObserver',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Shows/hides data-point markers for line-like series.\n         * Acceptable input are:\n         *  - `shown`: markers are always visible\n         *  - `hidden`: markers are always hidden\n         *  - `auto`: markers are visible for widespread data and hidden, when data is dense *(default)*\n         */\n        markers: {\n          type: String,\n          observer: '__markersObserver',\n          reflectToAttribute: true\n        },\n\n        /** Used to connect the series to an axis; if multiple series have the same unit, they will share axis.\n         * Displayed as a title for the axis.\n         * If no unit is defined, then series will be connected to the first axis.\n         */\n        unit: {\n          type: String,\n          observer: '__unitObserver',\n          reflectToAttribute: true\n        },\n\n        /** Used to group series in a different stacks.\n         * \"stacking\" property should be specified either for each series or in plotOptions.\n         * It is recommended to place series in a single stack, when they belong to the same yAxis.\n         */\n        stack: {\n          type: String,\n          observer: '__stackObserver',\n          reflectToAttribute: true\n        },\n\n        /** The height of the neck, the lower part of the funnel.\n         * A number defines pixel width, a percentage string defines a percentage of the plot area height. Defaults to 30%.\n         * Note that this property only applies for \"funnel\" charts.\n         */\n        neckPosition: {\n          type: String,\n          observer: '__neckPositionOberserver',\n          reflectToAttribute: true\n        },\n\n        /** The width of the neck, the lower part of the funnel.\n         * A number defines pixel width, a percentage string defines a percentage of the plot area width. Defaults to 30%.\n         * Note that this property only applies for \"funnel\" charts.\n         */\n        neckWidth: {\n          type: String,\n          observer: '__neckWidthOberserver',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Object with the configured options defined and used to create a series.\n         *\n         * @readonly\n         */\n        options: {\n          type: Object\n        },\n\n        /**\n         * Represents additional JSON configuration.\n         */\n        additionalOptions: {\n          type: Object,\n          reflectToAttribute: true\n        }\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['__valuesObserver(values.splices)', '__additionalOptionsObserver(additionalOptions.*)'];\n    }\n  }]);\n\n  return ChartSeriesElement;\n}(PolymerElement);\n\ncustomElements.define(ChartSeriesElement.is, ChartSeriesElement);\nexport { ChartSeriesElement };"
    },
    {
     "id": 412,
     "name": "../node_modules/@babel/runtime/helpers/arrayWithHoles.js?babel-target=es5",
     "source": "function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;"
    },
    {
     "id": 413,
     "name": "../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js?babel-target=es5",
     "source": "function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;"
    },
    {
     "id": 414,
     "name": "../node_modules/@babel/runtime/helpers/nonIterableRest.js?babel-target=es5",
     "source": "function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;"
    },
    {
     "id": 415,
     "name": "../node_modules/@vaadin/vaadin-details/theme/lumo/vaadin-details.js?babel-target=es5",
     "source": "import './vaadin-details-styles.js';\nimport '../../src/vaadin-details.js';"
    },
    {
     "id": 416,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column-group.js?babel-target=es5",
     "source": "import '../../src/vaadin-grid-column-group.js';"
    },
    {
     "id": 417,
     "name": "../node_modules/@vaadin/vaadin-rich-text-editor/vendor/vaadin-quill.js?babel-target=es5",
     "source": "import _typeof from \"@babel/runtime/helpers/typeof\";\n\n/*!\n * Quill Editor v1.3.6\n * https://quilljs.com/\n * Copyright (c) 2014, Jason Chen\n * Copyright (c) 2013, salesforce.com\n */\n!function (t, e) {\n  t.Quill = e();\n}(window, function () {\n  return function (t) {\n    function e(r) {\n      if (n[r]) return n[r].exports;\n      var o = n[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return t[r].call(o.exports, o, o.exports, e), o.l = !0, o.exports;\n    }\n\n    var n = {};\n    return e.m = t, e.c = n, e.d = function (t, n, r) {\n      e.o(t, n) || Object.defineProperty(t, n, {\n        configurable: !1,\n        enumerable: !0,\n        get: r\n      });\n    }, e.n = function (t) {\n      var n = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return e.d(n, \"a\", n), n;\n    }, e.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, e.p = \"\", e(e.s = 110);\n  }([function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var r = n(16),\n        o = n(17),\n        i = n(18),\n        a = n(42),\n        l = n(43),\n        u = n(44),\n        s = n(45),\n        c = n(46),\n        f = n(10),\n        d = n(25),\n        p = n(26),\n        h = n(24),\n        y = n(1),\n        v = {\n      Scope: y.Scope,\n      create: y.create,\n      find: y.find,\n      query: y.query,\n      register: y.register,\n      Container: r.default,\n      Format: o.default,\n      Leaf: i.default,\n      Embed: s.default,\n      Scroll: a.default,\n      Block: u.default,\n      Inline: l.default,\n      Text: c.default,\n      Attributor: {\n        Attribute: f.default,\n        Class: d.default,\n        Style: p.default,\n        Store: h.default\n      }\n    };\n    e.default = v;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      var n = i(t);\n      if (null == n) throw new u(\"Unable to create \" + t + \" blot\");\n      var r = n;\n      return new r(t instanceof Node || t.nodeType === Node.TEXT_NODE ? t : r.create(e), e);\n    }\n\n    function o(t, n) {\n      return void 0 === n && (n = !1), null == t ? null : null != t[e.DATA_KEY] ? t[e.DATA_KEY].blot : n ? o(t.parentNode, n) : null;\n    }\n\n    function i(t, e) {\n      void 0 === e && (e = p.ANY);\n      var n;\n      if (\"string\" == typeof t) n = d[t] || s[t];else if (t instanceof Text || t.nodeType === Node.TEXT_NODE) n = d.text;else if (\"number\" == typeof t) t & p.LEVEL & p.BLOCK ? n = d.block : t & p.LEVEL & p.INLINE && (n = d.inline);else if (t instanceof HTMLElement) {\n        var r = (t.getAttribute(\"class\") || \"\").split(/\\s+/);\n\n        for (var o in r) {\n          if (n = c[r[o]]) break;\n        }\n\n        n = n || f[t.tagName];\n      }\n      return null == n ? null : e & p.LEVEL & n.scope && e & p.TYPE & n.scope ? n : null;\n    }\n\n    function a() {\n      for (var t = [], e = 0; e < arguments.length; e++) {\n        t[e] = arguments[e];\n      }\n\n      if (t.length > 1) return t.map(function (t) {\n        return a(t);\n      });\n      var n = t[0];\n      if (\"string\" != typeof n.blotName && \"string\" != typeof n.attrName) throw new u(\"Invalid definition\");\n      if (\"abstract\" === n.blotName) throw new u(\"Cannot register abstract class\");\n      if (d[n.blotName || n.attrName] = n, \"string\" == typeof n.keyName) s[n.keyName] = n;else if (null != n.className && (c[n.className] = n), null != n.tagName) {\n        Array.isArray(n.tagName) ? n.tagName = n.tagName.map(function (t) {\n          return t.toUpperCase();\n        }) : n.tagName = n.tagName.toUpperCase();\n        var r = Array.isArray(n.tagName) ? n.tagName : [n.tagName];\n        r.forEach(function (t) {\n          null != f[t] && null != n.className || (f[t] = n);\n        });\n      }\n      return n;\n    }\n\n    var l = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var u = function (t) {\n      function e(e) {\n        var n = this;\n        return e = \"[Parchment] \" + e, n = t.call(this, e) || this, n.message = e, n.name = n.constructor.name, n;\n      }\n\n      return l(e, t), e;\n    }(Error);\n\n    e.ParchmentError = u;\n    var s = {},\n        c = {},\n        f = {},\n        d = {};\n    e.DATA_KEY = \"__blot\";\n    var p;\n    !function (t) {\n      t[t.TYPE = 3] = \"TYPE\", t[t.LEVEL = 12] = \"LEVEL\", t[t.ATTRIBUTE = 13] = \"ATTRIBUTE\", t[t.BLOT = 14] = \"BLOT\", t[t.INLINE = 7] = \"INLINE\", t[t.BLOCK = 11] = \"BLOCK\", t[t.BLOCK_BLOT = 10] = \"BLOCK_BLOT\", t[t.INLINE_BLOT = 6] = \"INLINE_BLOT\", t[t.BLOCK_ATTRIBUTE = 9] = \"BLOCK_ATTRIBUTE\", t[t.INLINE_ATTRIBUTE = 5] = \"INLINE_ATTRIBUTE\", t[t.ANY = 15] = \"ANY\";\n    }(p = e.Scope || (e.Scope = {})), e.create = r, e.find = o, e.query = i, e.register = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function l(t) {\n      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      return null == t ? e : (\"function\" == typeof t.formats && (e = (0, f.default)(e, t.formats())), null == t.parent || \"scroll\" == t.parent.blotName || t.parent.statics.scope !== t.statics.scope ? e : l(t.parent, e));\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.BlockEmbed = e.bubbleFormats = void 0;\n\n    var u = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        s = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        c = n(3),\n        f = r(c),\n        d = n(5),\n        p = r(d),\n        h = n(0),\n        y = r(h),\n        v = n(14),\n        b = r(v),\n        m = n(4),\n        g = r(m),\n        _ = n(7),\n        O = r(_),\n        E = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), u(e, [{\n        key: \"attach\",\n        value: function value() {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"attach\", this).call(this), this.attributes = new y.default.Attributor.Store(this.domNode);\n        }\n      }, {\n        key: \"delta\",\n        value: function value() {\n          return new p.default().insert(this.value(), (0, f.default)(this.formats(), this.attributes.values()));\n        }\n      }, {\n        key: \"format\",\n        value: function value(t, e) {\n          var n = y.default.query(t, y.default.Scope.BLOCK_ATTRIBUTE);\n          null != n && this.attributes.attribute(n, e);\n        }\n      }, {\n        key: \"formatAt\",\n        value: function value(t, e, n, r) {\n          this.format(n, r);\n        }\n      }, {\n        key: \"insertAt\",\n        value: function value(t, n, r) {\n          if (\"string\" == typeof n && n.endsWith(\"\\n\")) {\n            var o = y.default.create(N.blotName);\n            this.parent.insertBefore(o, 0 === t ? this : this.next), o.insertAt(0, n.slice(0, -1));\n          } else s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertAt\", this).call(this, t, n, r);\n        }\n      }]), e;\n    }(y.default.Embed);\n\n    E.scope = y.default.Scope.BLOCK_BLOT;\n\n    var N = function (t) {\n      function e(t) {\n        o(this, e);\n        var n = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));\n        return n.cache = {}, n;\n      }\n\n      return a(e, t), u(e, [{\n        key: \"delta\",\n        value: function value() {\n          return null == this.cache.delta && (this.cache.delta = this.descendants(y.default.Leaf).reduce(function (t, e) {\n            return 0 === e.length() ? t : t.insert(e.value(), l(e));\n          }, new p.default()).insert(\"\\n\", l(this))), this.cache.delta;\n        }\n      }, {\n        key: \"deleteAt\",\n        value: function value(t, n) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"deleteAt\", this).call(this, t, n), this.cache = {};\n        }\n      }, {\n        key: \"formatAt\",\n        value: function value(t, n, r, o) {\n          n <= 0 || (y.default.query(r, y.default.Scope.BLOCK) ? t + n === this.length() && this.format(r, o) : s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"formatAt\", this).call(this, t, Math.min(n, this.length() - t - 1), r, o), this.cache = {});\n        }\n      }, {\n        key: \"insertAt\",\n        value: function value(t, n, r) {\n          if (null != r) return s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertAt\", this).call(this, t, n, r);\n\n          if (0 !== n.length) {\n            var o = n.split(\"\\n\"),\n                i = o.shift();\n            i.length > 0 && (t < this.length() - 1 || null == this.children.tail ? s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertAt\", this).call(this, Math.min(t, this.length() - 1), i) : this.children.tail.insertAt(this.children.tail.length(), i), this.cache = {});\n            var a = this;\n            o.reduce(function (t, e) {\n              return a = a.split(t, !0), a.insertAt(0, e), e.length;\n            }, t + i.length);\n          }\n        }\n      }, {\n        key: \"insertBefore\",\n        value: function value(t, n) {\n          var r = this.children.head;\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertBefore\", this).call(this, t, n), r instanceof b.default && r.remove(), this.cache = {};\n        }\n      }, {\n        key: \"length\",\n        value: function value() {\n          return null == this.cache.length && (this.cache.length = s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"length\", this).call(this) + 1), this.cache.length;\n        }\n      }, {\n        key: \"moveChildren\",\n        value: function value(t, n) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"moveChildren\", this).call(this, t, n), this.cache = {};\n        }\n      }, {\n        key: \"optimize\",\n        value: function value(t) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t), this.cache = {};\n        }\n      }, {\n        key: \"path\",\n        value: function value(t) {\n          return s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"path\", this).call(this, t, !0);\n        }\n      }, {\n        key: \"removeChild\",\n        value: function value(t) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"removeChild\", this).call(this, t), this.cache = {};\n        }\n      }, {\n        key: \"split\",\n        value: function value(t) {\n          var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n\n          if (n && (0 === t || t >= this.length() - 1)) {\n            var r = this.clone();\n            return 0 === t ? (this.parent.insertBefore(r, this), this) : (this.parent.insertBefore(r, this.next), r);\n          }\n\n          var o = s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"split\", this).call(this, t, n);\n          return this.cache = {}, o;\n        }\n      }]), e;\n    }(y.default.Block);\n\n    N.blotName = \"block\", N.tagName = \"P\", N.defaultChild = \"break\", N.allowedChildren = [g.default, y.default.Embed, O.default], e.bubbleFormats = l, e.BlockEmbed = E, e.default = N;\n  }, function (t, e) {\n    \"use strict\";\n\n    var n = Object.prototype.hasOwnProperty,\n        r = Object.prototype.toString,\n        o = Object.defineProperty,\n        i = Object.getOwnPropertyDescriptor,\n        a = function a(t) {\n      return \"function\" == typeof Array.isArray ? Array.isArray(t) : \"[object Array]\" === r.call(t);\n    },\n        l = function l(t) {\n      if (!t || \"[object Object]\" !== r.call(t)) return !1;\n      var e = n.call(t, \"constructor\"),\n          o = t.constructor && t.constructor.prototype && n.call(t.constructor.prototype, \"isPrototypeOf\");\n      if (t.constructor && !e && !o) return !1;\n      var i;\n\n      for (i in t) {\n        ;\n      }\n\n      return void 0 === i || n.call(t, i);\n    },\n        u = function u(t, e) {\n      o && \"__proto__\" === e.name ? o(t, e.name, {\n        enumerable: !0,\n        configurable: !0,\n        value: e.newValue,\n        writable: !0\n      }) : t[e.name] = e.newValue;\n    },\n        s = function s(t, e) {\n      if (\"__proto__\" === e) {\n        if (!n.call(t, e)) return;\n        if (i) return i(t, e).value;\n      }\n\n      return t[e];\n    };\n\n    t.exports = function t() {\n      var e,\n          n,\n          r,\n          o,\n          i,\n          c,\n          f = arguments[0],\n          d = 1,\n          p = arguments.length,\n          h = !1;\n\n      for (\"boolean\" == typeof f && (h = f, f = arguments[1] || {}, d = 2), (null == f || \"object\" != _typeof(f) && \"function\" != typeof f) && (f = {}); d < p; ++d) {\n        if (null != (e = arguments[d])) for (n in e) {\n          r = s(f, n), o = s(e, n), f !== o && (h && o && (l(o) || (i = a(o))) ? (i ? (i = !1, c = r && a(r) ? r : []) : c = r && l(r) ? r : {}, u(f, {\n            name: n,\n            newValue: t(h, c, o)\n          })) : void 0 !== o && u(f, {\n            name: n,\n            newValue: o\n          }));\n        }\n      }\n\n      return f;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = n(7),\n        c = r(s),\n        f = n(0),\n        d = r(f),\n        p = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), l(e, [{\n        key: \"formatAt\",\n        value: function value(t, n, r, o) {\n          if (e.compare(this.statics.blotName, r) < 0 && d.default.query(r, d.default.Scope.BLOT)) {\n            var i = this.isolate(t, n);\n            o && i.wrap(r, o);\n          } else u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"formatAt\", this).call(this, t, n, r, o);\n        }\n      }, {\n        key: \"optimize\",\n        value: function value(t) {\n          if (u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t), this.parent instanceof e && e.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {\n            var n = this.parent.isolate(this.offset(), this.length());\n            this.moveChildren(n), n.wrap(this);\n          }\n        }\n      }], [{\n        key: \"compare\",\n        value: function value(t, n) {\n          var r = e.order.indexOf(t),\n              o = e.order.indexOf(n);\n          return r >= 0 || o >= 0 ? r - o : t === n ? 0 : t < n ? -1 : 1;\n        }\n      }]), e;\n    }(d.default.Inline);\n\n    p.allowedChildren = [p, d.default.Embed, c.default], p.order = [\"cursor\", \"inline\", \"underline\", \"strike\", \"italic\", \"bold\", \"script\", \"link\", \"code\"], e.default = p;\n  }, function (t, e, n) {\n    var r = n(48),\n        o = n(11),\n        i = n(3),\n        a = n(19),\n        l = String.fromCharCode(0),\n        u = function u(t) {\n      Array.isArray(t) ? this.ops = t : null != t && Array.isArray(t.ops) ? this.ops = t.ops : this.ops = [];\n    };\n\n    u.prototype.insert = function (t, e) {\n      var n = {};\n      return 0 === t.length ? this : (n.insert = t, null != e && \"object\" == _typeof(e) && Object.keys(e).length > 0 && (n.attributes = e), this.push(n));\n    }, u.prototype.delete = function (t) {\n      return t <= 0 ? this : this.push({\n        delete: t\n      });\n    }, u.prototype.retain = function (t, e) {\n      if (t <= 0) return this;\n      var n = {\n        retain: t\n      };\n      return null != e && \"object\" == _typeof(e) && Object.keys(e).length > 0 && (n.attributes = e), this.push(n);\n    }, u.prototype.push = function (t) {\n      var e = this.ops.length,\n          n = this.ops[e - 1];\n\n      if (t = i(!0, {}, t), \"object\" == _typeof(n)) {\n        if (\"number\" == typeof t.delete && \"number\" == typeof n.delete) return this.ops[e - 1] = {\n          delete: n.delete + t.delete\n        }, this;\n        if (\"number\" == typeof n.delete && null != t.insert && (e -= 1, \"object\" != _typeof(n = this.ops[e - 1]))) return this.ops.unshift(t), this;\n\n        if (o(t.attributes, n.attributes)) {\n          if (\"string\" == typeof t.insert && \"string\" == typeof n.insert) return this.ops[e - 1] = {\n            insert: n.insert + t.insert\n          }, \"object\" == _typeof(t.attributes) && (this.ops[e - 1].attributes = t.attributes), this;\n          if (\"number\" == typeof t.retain && \"number\" == typeof n.retain) return this.ops[e - 1] = {\n            retain: n.retain + t.retain\n          }, \"object\" == _typeof(t.attributes) && (this.ops[e - 1].attributes = t.attributes), this;\n        }\n      }\n\n      return e === this.ops.length ? this.ops.push(t) : this.ops.splice(e, 0, t), this;\n    }, u.prototype.chop = function () {\n      var t = this.ops[this.ops.length - 1];\n      return t && t.retain && !t.attributes && this.ops.pop(), this;\n    }, u.prototype.filter = function (t) {\n      return this.ops.filter(t);\n    }, u.prototype.forEach = function (t) {\n      this.ops.forEach(t);\n    }, u.prototype.map = function (t) {\n      return this.ops.map(t);\n    }, u.prototype.partition = function (t) {\n      var e = [],\n          n = [];\n      return this.forEach(function (r) {\n        (t(r) ? e : n).push(r);\n      }), [e, n];\n    }, u.prototype.reduce = function (t, e) {\n      return this.ops.reduce(t, e);\n    }, u.prototype.changeLength = function () {\n      return this.reduce(function (t, e) {\n        return e.insert ? t + a.length(e) : e.delete ? t - e.delete : t;\n      }, 0);\n    }, u.prototype.length = function () {\n      return this.reduce(function (t, e) {\n        return t + a.length(e);\n      }, 0);\n    }, u.prototype.slice = function (t, e) {\n      t = t || 0, \"number\" != typeof e && (e = 1 / 0);\n\n      for (var n = [], r = a.iterator(this.ops), o = 0; o < e && r.hasNext();) {\n        var i;\n        o < t ? i = r.next(t - o) : (i = r.next(e - o), n.push(i)), o += a.length(i);\n      }\n\n      return new u(n);\n    }, u.prototype.compose = function (t) {\n      var e = a.iterator(this.ops),\n          n = a.iterator(t.ops),\n          r = [],\n          i = n.peek();\n\n      if (null != i && \"number\" == typeof i.retain && null == i.attributes) {\n        for (var l = i.retain; \"insert\" === e.peekType() && e.peekLength() <= l;) {\n          l -= e.peekLength(), r.push(e.next());\n        }\n\n        i.retain - l > 0 && n.next(i.retain - l);\n      }\n\n      for (var s = new u(r); e.hasNext() || n.hasNext();) {\n        if (\"insert\" === n.peekType()) s.push(n.next());else if (\"delete\" === e.peekType()) s.push(e.next());else {\n          var c = Math.min(e.peekLength(), n.peekLength()),\n              f = e.next(c),\n              d = n.next(c);\n\n          if (\"number\" == typeof d.retain) {\n            var p = {};\n            \"number\" == typeof f.retain ? p.retain = c : p.insert = f.insert;\n            var h = a.attributes.compose(f.attributes, d.attributes, \"number\" == typeof f.retain);\n\n            if (h && (p.attributes = h), s.push(p), !n.hasNext() && o(s.ops[s.ops.length - 1], p)) {\n              var y = new u(e.rest());\n              return s.concat(y).chop();\n            }\n          } else \"number\" == typeof d.delete && \"number\" == typeof f.retain && s.push(d);\n        }\n      }\n\n      return s.chop();\n    }, u.prototype.concat = function (t) {\n      var e = new u(this.ops.slice());\n      return t.ops.length > 0 && (e.push(t.ops[0]), e.ops = e.ops.concat(t.ops.slice(1))), e;\n    }, u.prototype.diff = function (t, e) {\n      if (this.ops === t.ops) return new u();\n      var n = [this, t].map(function (e) {\n        return e.map(function (n) {\n          if (null != n.insert) return \"string\" == typeof n.insert ? n.insert : l;\n          var r = e === t ? \"on\" : \"with\";\n          throw new Error(\"diff() called \" + r + \" non-document\");\n        }).join(\"\");\n      }),\n          i = new u(),\n          s = r(n[0], n[1], e),\n          c = a.iterator(this.ops),\n          f = a.iterator(t.ops);\n      return s.forEach(function (t) {\n        for (var e = t[1].length; e > 0;) {\n          var n = 0;\n\n          switch (t[0]) {\n            case r.INSERT:\n              n = Math.min(f.peekLength(), e), i.push(f.next(n));\n              break;\n\n            case r.DELETE:\n              n = Math.min(e, c.peekLength()), c.next(n), i.delete(n);\n              break;\n\n            case r.EQUAL:\n              n = Math.min(c.peekLength(), f.peekLength(), e);\n              var l = c.next(n),\n                  u = f.next(n);\n              o(l.insert, u.insert) ? i.retain(n, a.attributes.diff(l.attributes, u.attributes)) : i.push(u).delete(n);\n          }\n\n          e -= n;\n        }\n      }), i.chop();\n    }, u.prototype.eachLine = function (t, e) {\n      e = e || \"\\n\";\n\n      for (var n = a.iterator(this.ops), r = new u(), o = 0; n.hasNext();) {\n        if (\"insert\" !== n.peekType()) return;\n        var i = n.peek(),\n            l = a.length(i) - n.peekLength(),\n            s = \"string\" == typeof i.insert ? i.insert.indexOf(e, l) - l : -1;\n        if (s < 0) r.push(n.next());else if (s > 0) r.push(n.next(s));else {\n          if (!1 === t(r, n.next(1).attributes || {}, o)) return;\n          o += 1, r = new u();\n        }\n      }\n\n      r.length() > 0 && t(r, {}, o);\n    }, u.prototype.transform = function (t, e) {\n      if (e = !!e, \"number\" == typeof t) return this.transformPosition(t, e);\n\n      for (var n = a.iterator(this.ops), r = a.iterator(t.ops), o = new u(); n.hasNext() || r.hasNext();) {\n        if (\"insert\" !== n.peekType() || !e && \"insert\" === r.peekType()) {\n          if (\"insert\" === r.peekType()) o.push(r.next());else {\n            var i = Math.min(n.peekLength(), r.peekLength()),\n                l = n.next(i),\n                s = r.next(i);\n            if (l.delete) continue;\n            s.delete ? o.push(s) : o.retain(i, a.attributes.transform(l.attributes, s.attributes, e));\n          }\n        } else o.retain(a.length(n.next()));\n      }\n\n      return o.chop();\n    }, u.prototype.transformPosition = function (t, e) {\n      e = !!e;\n\n      for (var n = a.iterator(this.ops), r = 0; n.hasNext() && r <= t;) {\n        var o = n.peekLength(),\n            i = n.peekType();\n        n.next(), \"delete\" !== i ? (\"insert\" === i && (r < t || !e) && (t += o), r += o) : t -= Math.min(o, t - r);\n      }\n\n      return t;\n    }, t.exports = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (e = (0, j.default)(!0, {\n        container: t,\n        modules: {\n          clipboard: !0,\n          keyboard: !0,\n          history: !0\n        }\n      }, e), e.theme && e.theme !== C.DEFAULTS.theme) {\n        if (e.theme = C.import(\"themes/\" + e.theme), null == e.theme) throw new Error(\"Invalid theme \" + e.theme + \". Did you register it?\");\n      } else e.theme = S.default;\n\n      var n = (0, j.default)(!0, {}, e.theme.DEFAULTS);\n      [n, e].forEach(function (t) {\n        t.modules = t.modules || {}, Object.keys(t.modules).forEach(function (e) {\n          !0 === t.modules[e] && (t.modules[e] = {});\n        });\n      });\n      var r = Object.keys(n.modules).concat(Object.keys(e.modules)),\n          o = r.reduce(function (t, e) {\n        var n = C.import(\"modules/\" + e);\n        return null == n ? P.error(\"Cannot load \" + e + \" module. Are you sure you registered it?\") : t[e] = n.DEFAULTS || {}, t;\n      }, {});\n      return null != e.modules && e.modules.toolbar && e.modules.toolbar.constructor !== Object && (e.modules.toolbar = {\n        container: e.modules.toolbar\n      }), e = (0, j.default)(!0, {}, C.DEFAULTS, {\n        modules: o\n      }, n, e), [\"bounds\", \"container\", \"scrollingContainer\"].forEach(function (t) {\n        \"string\" == typeof e[t] && (e[t] = document.querySelector(e[t]));\n      }), e.modules = Object.keys(e.modules).reduce(function (t, n) {\n        return e.modules[n] && (t[n] = e.modules[n]), t;\n      }, {}), e;\n    }\n\n    function l(t, e, n, r) {\n      if (this.options.strict && !this.isEnabled() && e === m.default.sources.USER) return new h.default();\n      var o = null == n ? null : this.getSelection(),\n          i = this.editor.delta,\n          a = t();\n\n      if (null != o && (!0 === n && (n = o.index), null == r ? o = s(o, a, e) : 0 !== r && (o = s(o, n, r, e)), this.setSelection(o, m.default.sources.SILENT)), a.length() > 0) {\n        var l,\n            u = [m.default.events.TEXT_CHANGE, a, i, e];\n\n        if ((l = this.emitter).emit.apply(l, [m.default.events.EDITOR_CHANGE].concat(u)), e !== m.default.sources.SILENT) {\n          var c;\n          (c = this.emitter).emit.apply(c, u);\n        }\n      }\n\n      return a;\n    }\n\n    function u(t, e, n, r, o) {\n      var i = {};\n      return \"number\" == typeof t.index && \"number\" == typeof t.length ? \"number\" != typeof e ? (o = r, r = n, n = e, e = t.length, t = t.index) : (e = t.length, t = t.index) : \"number\" != typeof e && (o = r, r = n, n = e, e = 0), \"object\" === (void 0 === n ? \"undefined\" : c(n)) ? (i = n, o = r) : \"string\" == typeof n && (null != r ? i[n] = r : o = n), o = o || m.default.sources.API, [t, e, i, o];\n    }\n\n    function s(t, e, n, r) {\n      if (null == t) return null;\n      var o = void 0,\n          i = void 0;\n\n      if (e instanceof h.default) {\n        var a = [t.index, t.index + t.length].map(function (t) {\n          return e.transformPosition(t, r !== m.default.sources.USER);\n        }),\n            l = f(a, 2);\n        o = l[0], i = l[1];\n      } else {\n        var u = [t.index, t.index + t.length].map(function (t) {\n          return t < e || t === e && r === m.default.sources.USER ? t : n >= 0 ? t + n : Math.max(e, t + n);\n        }),\n            s = f(u, 2);\n        o = s[0], i = s[1];\n      }\n\n      return new N.Range(o, i - o);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.overload = e.expandConfig = void 0;\n\n    var c = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (t) {\n      return _typeof(t);\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : _typeof(t);\n    },\n        f = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        d = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }();\n\n    n(47);\n\n    var p = n(5),\n        h = r(p),\n        y = n(51),\n        v = r(y),\n        b = n(13),\n        m = r(b),\n        g = n(9),\n        _ = r(g),\n        O = n(0),\n        E = r(O),\n        N = n(29),\n        w = r(N),\n        k = n(3),\n        j = r(k),\n        x = n(8),\n        A = r(x),\n        T = n(37),\n        S = r(T),\n        P = (0, A.default)(\"quill\"),\n        C = function () {\n      function t(e) {\n        var n = this,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        if (i(this, t), this.options = a(e, r), this.container = this.options.container, null == this.container) return P.error(\"Invalid Quill container\", e);\n        this.options.debug && t.debug(this.options.debug);\n        var o = this.container.innerHTML.trim();\n        this.container.classList.add(\"ql-container\"), this.container.innerHTML = \"\", this.container.__quill = this, this.root = this.addContainer(\"ql-editor\"), this.root.classList.add(\"ql-blank\"), this.root.setAttribute(\"data-gramm\", !1), this.scrollingContainer = this.options.scrollingContainer || this.root, this.emitter = new m.default(), this.scroll = E.default.create(this.root, {\n          emitter: this.emitter,\n          whitelist: this.options.formats\n        }), this.editor = new v.default(this.scroll), this.selection = new w.default(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule(\"keyboard\"), this.clipboard = this.theme.addModule(\"clipboard\"), this.history = this.theme.addModule(\"history\"), this.theme.init(), this.emitter.on(m.default.events.EDITOR_CHANGE, function (t) {\n          t === m.default.events.TEXT_CHANGE && n.root.classList.toggle(\"ql-blank\", n.editor.isBlank());\n        }), this.emitter.on(m.default.events.SCROLL_UPDATE, function (t, e) {\n          var r = n.selection.lastRange,\n              o = r && 0 === r.length ? r.index : void 0;\n          l.call(n, function () {\n            return n.editor.update(null, e, o);\n          }, t);\n        });\n        var u = this.clipboard.convert(\"<div class='ql-editor' style=\\\"white-space: normal;\\\">\" + o + \"<p><br></p></div>\");\n        this.setContents(u), this.history.clear(), this.options.placeholder && this.root.setAttribute(\"data-placeholder\", this.options.placeholder), this.options.readOnly && this.disable();\n      }\n\n      return d(t, null, [{\n        key: \"debug\",\n        value: function value(t) {\n          !0 === t && (t = \"log\"), A.default.level(t);\n        }\n      }, {\n        key: \"find\",\n        value: function value(t) {\n          return t.__quill || E.default.find(t);\n        }\n      }, {\n        key: \"import\",\n        value: function value(t) {\n          return null == this.imports[t] && P.error(\"Cannot import \" + t + \". Are you sure it was registered?\"), this.imports[t];\n        }\n      }, {\n        key: \"register\",\n        value: function value(t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n\n          if (\"string\" != typeof t) {\n            var o = t.attrName || t.blotName;\n            \"string\" == typeof o ? this.register(\"formats/\" + o, t, e) : Object.keys(t).forEach(function (r) {\n              n.register(r, t[r], e);\n            });\n          } else null == this.imports[t] || r || P.warn(\"Overwriting \" + t + \" with\", e), this.imports[t] = e, (t.startsWith(\"blots/\") || t.startsWith(\"formats/\")) && \"abstract\" !== e.blotName ? E.default.register(e) : t.startsWith(\"modules\") && \"function\" == typeof e.register && e.register();\n        }\n      }]), d(t, [{\n        key: \"addContainer\",\n        value: function value(t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n\n          if (\"string\" == typeof t) {\n            var n = t;\n            t = document.createElement(\"div\"), t.classList.add(n);\n          }\n\n          return this.container.insertBefore(t, e), t;\n        }\n      }, {\n        key: \"blur\",\n        value: function value() {\n          this.selection.setRange(null);\n        }\n      }, {\n        key: \"deleteText\",\n        value: function value(t, e, n) {\n          var r = this,\n              o = u(t, e, n),\n              i = f(o, 4);\n          return t = i[0], e = i[1], n = i[3], l.call(this, function () {\n            return r.editor.deleteText(t, e);\n          }, n, t, -1 * e);\n        }\n      }, {\n        key: \"disable\",\n        value: function value() {\n          this.enable(!1);\n        }\n      }, {\n        key: \"enable\",\n        value: function value() {\n          var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n          this.scroll.enable(t), this.container.classList.toggle(\"ql-disabled\", !t);\n        }\n      }, {\n        key: \"focus\",\n        value: function value() {\n          var t = this.scrollingContainer.scrollTop;\n          this.selection.focus(), this.scrollingContainer.scrollTop = t, this.scrollIntoView();\n        }\n      }, {\n        key: \"format\",\n        value: function value(t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : m.default.sources.API;\n          return l.call(this, function () {\n            var r = n.getSelection(!0),\n                i = new h.default();\n            if (null == r) return i;\n            if (E.default.query(t, E.default.Scope.BLOCK)) i = n.editor.formatLine(r.index, r.length, o({}, t, e));else {\n              if (0 === r.length) return n.selection.format(t, e), i;\n              i = n.editor.formatText(r.index, r.length, o({}, t, e));\n            }\n            return n.setSelection(r, m.default.sources.SILENT), i;\n          }, r);\n        }\n      }, {\n        key: \"formatLine\",\n        value: function value(t, e, n, r, o) {\n          var i = this,\n              a = void 0,\n              s = u(t, e, n, r, o),\n              c = f(s, 4);\n          return t = c[0], e = c[1], a = c[2], o = c[3], l.call(this, function () {\n            return i.editor.formatLine(t, e, a);\n          }, o, t, 0);\n        }\n      }, {\n        key: \"formatText\",\n        value: function value(t, e, n, r, o) {\n          var i = this,\n              a = void 0,\n              s = u(t, e, n, r, o),\n              c = f(s, 4);\n          return t = c[0], e = c[1], a = c[2], o = c[3], l.call(this, function () {\n            return i.editor.formatText(t, e, a);\n          }, o, t, 0);\n        }\n      }, {\n        key: \"getBounds\",\n        value: function value(t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n              n = void 0;\n          n = \"number\" == typeof t ? this.selection.getBounds(t, e) : this.selection.getBounds(t.index, t.length);\n          var r = this.container.getBoundingClientRect();\n          return {\n            bottom: n.bottom - r.top,\n            height: n.height,\n            left: n.left - r.left,\n            right: n.right - r.left,\n            top: n.top - r.top,\n            width: n.width\n          };\n        }\n      }, {\n        key: \"getContents\",\n        value: function value() {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t,\n              n = u(t, e),\n              r = f(n, 2);\n          return t = r[0], e = r[1], this.editor.getContents(t, e);\n        }\n      }, {\n        key: \"getFormat\",\n        value: function value() {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getSelection(!0),\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n          return \"number\" == typeof t ? this.editor.getFormat(t, e) : this.editor.getFormat(t.index, t.length);\n        }\n      }, {\n        key: \"getIndex\",\n        value: function value(t) {\n          return t.offset(this.scroll);\n        }\n      }, {\n        key: \"getLength\",\n        value: function value() {\n          return this.scroll.length();\n        }\n      }, {\n        key: \"getLeaf\",\n        value: function value(t) {\n          return this.scroll.leaf(t);\n        }\n      }, {\n        key: \"getLine\",\n        value: function value(t) {\n          return this.scroll.line(t);\n        }\n      }, {\n        key: \"getLines\",\n        value: function value() {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;\n          return \"number\" != typeof t ? this.scroll.lines(t.index, t.length) : this.scroll.lines(t, e);\n        }\n      }, {\n        key: \"getModule\",\n        value: function value(t) {\n          return this.theme.modules[t];\n        }\n      }, {\n        key: \"getSelection\",\n        value: function value() {\n          return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0];\n        }\n      }, {\n        key: \"getText\",\n        value: function value() {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t,\n              n = u(t, e),\n              r = f(n, 2);\n          return t = r[0], e = r[1], this.editor.getText(t, e);\n        }\n      }, {\n        key: \"hasFocus\",\n        value: function value() {\n          return this.selection.hasFocus();\n        }\n      }, {\n        key: \"insertEmbed\",\n        value: function value(e, n, r) {\n          var o = this,\n              i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.sources.API;\n          return l.call(this, function () {\n            return o.editor.insertEmbed(e, n, r);\n          }, i, e);\n        }\n      }, {\n        key: \"insertText\",\n        value: function value(t, e, n, r, o) {\n          var i = this,\n              a = void 0,\n              s = u(t, 0, n, r, o),\n              c = f(s, 4);\n          return t = c[0], a = c[2], o = c[3], l.call(this, function () {\n            return i.editor.insertText(t, e, a);\n          }, o, t, e.length);\n        }\n      }, {\n        key: \"isEnabled\",\n        value: function value() {\n          return !this.container.classList.contains(\"ql-disabled\");\n        }\n      }, {\n        key: \"off\",\n        value: function value() {\n          return this.emitter.off.apply(this.emitter, arguments);\n        }\n      }, {\n        key: \"on\",\n        value: function value() {\n          return this.emitter.on.apply(this.emitter, arguments);\n        }\n      }, {\n        key: \"once\",\n        value: function value() {\n          return this.emitter.once.apply(this.emitter, arguments);\n        }\n      }, {\n        key: \"pasteHTML\",\n        value: function value(t, e, n) {\n          this.clipboard.dangerouslyPasteHTML(t, e, n);\n        }\n      }, {\n        key: \"removeFormat\",\n        value: function value(t, e, n) {\n          var r = this,\n              o = u(t, e, n),\n              i = f(o, 4);\n          return t = i[0], e = i[1], n = i[3], l.call(this, function () {\n            return r.editor.removeFormat(t, e);\n          }, n, t);\n        }\n      }, {\n        key: \"scrollIntoView\",\n        value: function value() {\n          this.selection.scrollIntoView(this.scrollingContainer);\n        }\n      }, {\n        key: \"setContents\",\n        value: function value(t) {\n          var e = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.default.sources.API;\n          return l.call(this, function () {\n            t = new h.default(t);\n            var n = e.getLength(),\n                r = e.editor.deleteText(0, n),\n                o = e.editor.applyDelta(t),\n                i = o.ops[o.ops.length - 1];\n            return null != i && \"string\" == typeof i.insert && \"\\n\" === i.insert[i.insert.length - 1] && (e.editor.deleteText(e.getLength() - 1, 1), o.delete(1)), r.compose(o);\n          }, n);\n        }\n      }, {\n        key: \"setSelection\",\n        value: function value(e, n, r) {\n          if (null == e) this.selection.setRange(null, n || t.sources.API);else {\n            var o = u(e, n, r),\n                i = f(o, 4);\n            e = i[0], n = i[1], r = i[3], this.selection.setRange(new N.Range(e, n), r), r !== m.default.sources.SILENT && this.selection.scrollIntoView(this.scrollingContainer);\n          }\n        }\n      }, {\n        key: \"setText\",\n        value: function value(t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.default.sources.API,\n              n = new h.default().insert(t);\n          return this.setContents(n, e);\n        }\n      }, {\n        key: \"update\",\n        value: function value() {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m.default.sources.USER,\n              e = this.scroll.update(t);\n          return this.selection.update(t), e;\n        }\n      }, {\n        key: \"updateContents\",\n        value: function value(t) {\n          var e = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.default.sources.API;\n          return l.call(this, function () {\n            return t = new h.default(t), e.editor.applyDelta(t, n);\n          }, n, !0);\n        }\n      }]), t;\n    }();\n\n    C.DEFAULTS = {\n      bounds: null,\n      formats: null,\n      modules: {},\n      placeholder: \"\",\n      readOnly: !1,\n      scrollingContainer: null,\n      strict: !0,\n      theme: \"default\"\n    }, C.events = m.default.events, C.sources = m.default.sources, C.version = \"1.3.6\", C.imports = {\n      delta: h.default,\n      parchment: E.default,\n      \"core/module\": _.default,\n      \"core/theme\": S.default\n    }, e.expandConfig = a, e.overload = u, e.default = C;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(0),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default.Text);\n\n    e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      if (i.indexOf(t) <= i.indexOf(a)) {\n        for (var e, n = arguments.length, r = Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) {\n          r[o - 1] = arguments[o];\n        }\n\n        (e = console)[t].apply(e, r);\n      }\n    }\n\n    function o(t) {\n      return i.reduce(function (e, n) {\n        return e[n] = r.bind(console, n, t), e;\n      }, {});\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var i = [\"error\", \"warn\", \"log\", \"info\"],\n        a = \"warn\";\n    r.level = o.level = function (t) {\n      a = t;\n    }, e.default = o;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = function t(e) {\n      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      r(this, t), this.quill = e, this.options = n;\n    };\n\n    o.DEFAULTS = {}, e.default = o;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var r = n(1),\n        o = function () {\n      function t(t, e, n) {\n        void 0 === n && (n = {}), this.attrName = t, this.keyName = e;\n        var o = r.Scope.TYPE & r.Scope.ATTRIBUTE;\n        null != n.scope ? this.scope = n.scope & r.Scope.LEVEL | o : this.scope = r.Scope.ATTRIBUTE, null != n.whitelist && (this.whitelist = n.whitelist);\n      }\n\n      return t.keys = function (t) {\n        return [].map.call(t.attributes, function (t) {\n          return t.name;\n        });\n      }, t.prototype.add = function (t, e) {\n        return !!this.canAdd(t, e) && (t.setAttribute(this.keyName, e), !0);\n      }, t.prototype.canAdd = function (t, e) {\n        return null != r.query(t, r.Scope.BLOT & (this.scope | r.Scope.TYPE)) && (null == this.whitelist || (\"string\" == typeof e ? this.whitelist.indexOf(e.replace(/[\"']/g, \"\")) > -1 : this.whitelist.indexOf(e) > -1));\n      }, t.prototype.remove = function (t) {\n        t.removeAttribute(this.keyName);\n      }, t.prototype.value = function (t) {\n        var e = t.getAttribute(this.keyName);\n        return this.canAdd(t, e) && e ? e : \"\";\n      }, t;\n    }();\n\n    e.default = o;\n  }, function (t, e, n) {\n    function r(t) {\n      return null === t || void 0 === t;\n    }\n\n    function o(t) {\n      return !(!t || \"object\" != _typeof(t) || \"number\" != typeof t.length) && \"function\" == typeof t.copy && \"function\" == typeof t.slice && !(t.length > 0 && \"number\" != typeof t[0]);\n    }\n\n    function i(t, e, n) {\n      var i, c;\n      if (r(t) || r(e)) return !1;\n      if (t.prototype !== e.prototype) return !1;\n      if (u(t)) return !!u(e) && (t = a.call(t), e = a.call(e), s(t, e, n));\n\n      if (o(t)) {\n        if (!o(e)) return !1;\n        if (t.length !== e.length) return !1;\n\n        for (i = 0; i < t.length; i++) {\n          if (t[i] !== e[i]) return !1;\n        }\n\n        return !0;\n      }\n\n      try {\n        var f = l(t),\n            d = l(e);\n      } catch (t) {\n        return !1;\n      }\n\n      if (f.length != d.length) return !1;\n\n      for (f.sort(), d.sort(), i = f.length - 1; i >= 0; i--) {\n        if (f[i] != d[i]) return !1;\n      }\n\n      for (i = f.length - 1; i >= 0; i--) {\n        if (c = f[i], !s(t[c], e[c], n)) return !1;\n      }\n\n      return _typeof(t) == _typeof(e);\n    }\n\n    var a = Array.prototype.slice,\n        l = n(49),\n        u = n(50),\n        s = t.exports = function (t, e, n) {\n      return n || (n = {}), t === e || (t instanceof Date && e instanceof Date ? t.getTime() === e.getTime() : !t || !e || \"object\" != _typeof(t) && \"object\" != _typeof(e) ? n.strict ? t === e : t == e : i(t, e, n));\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.Code = void 0;\n\n    var l = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        u = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        s = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        c = n(5),\n        f = r(c),\n        d = n(0),\n        p = r(d),\n        h = n(2),\n        y = r(h),\n        v = n(4),\n        b = r(v),\n        m = n(7),\n        g = r(m),\n        _ = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), e;\n    }(b.default);\n\n    _.blotName = \"code\", _.tagName = \"CODE\";\n\n    var O = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), u(e, [{\n        key: \"delta\",\n        value: function value() {\n          var t = this,\n              e = this.domNode.textContent;\n          return e.endsWith(\"\\n\") && (e = e.slice(0, -1)), e.split(\"\\n\").reduce(function (e, n) {\n            return e.insert(n).insert(\"\\n\", t.formats());\n          }, new f.default());\n        }\n      }, {\n        key: \"format\",\n        value: function value(t, n) {\n          if (t !== this.statics.blotName || !n) {\n            var r = this.descendant(g.default, this.length() - 1),\n                o = l(r, 1),\n                i = o[0];\n            null != i && i.deleteAt(i.length() - 1, 1), s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n          }\n        }\n      }, {\n        key: \"formatAt\",\n        value: function value(t, n, r, o) {\n          if (0 !== n && null != p.default.query(r, p.default.Scope.BLOCK) && (r !== this.statics.blotName || o !== this.statics.formats(this.domNode))) {\n            var i = this.newlineIndex(t);\n\n            if (!(i < 0 || i >= t + n)) {\n              var a = this.newlineIndex(t, !0) + 1,\n                  l = i - a + 1,\n                  u = this.isolate(a, l),\n                  s = u.next;\n              u.format(r, o), s instanceof e && s.formatAt(0, t - a + n - l, r, o);\n            }\n          }\n        }\n      }, {\n        key: \"insertAt\",\n        value: function value(t, e, n) {\n          if (null == n) {\n            var r = this.descendant(g.default, t),\n                o = l(r, 2),\n                i = o[0],\n                a = o[1];\n            i.insertAt(a, e);\n          }\n        }\n      }, {\n        key: \"length\",\n        value: function value() {\n          var t = this.domNode.textContent.length;\n          return this.domNode.textContent.endsWith(\"\\n\") ? t : t + 1;\n        }\n      }, {\n        key: \"newlineIndex\",\n        value: function value(t) {\n          if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) return this.domNode.textContent.slice(0, t).lastIndexOf(\"\\n\");\n          var e = this.domNode.textContent.slice(t).indexOf(\"\\n\");\n          return e > -1 ? t + e : -1;\n        }\n      }, {\n        key: \"optimize\",\n        value: function value(t) {\n          this.domNode.textContent.endsWith(\"\\n\") || this.appendChild(p.default.create(\"text\", \"\\n\")), s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t);\n          var n = this.next;\n          null != n && n.prev === this && n.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === n.statics.formats(n.domNode) && (n.optimize(t), n.moveChildren(this), n.remove());\n        }\n      }, {\n        key: \"replace\",\n        value: function value(t) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"replace\", this).call(this, t), [].slice.call(this.domNode.querySelectorAll(\"*\")).forEach(function (t) {\n            var e = p.default.find(t);\n            null == e ? t.parentNode.removeChild(t) : e instanceof p.default.Embed ? e.remove() : e.unwrap();\n          });\n        }\n      }], [{\n        key: \"create\",\n        value: function value(t) {\n          var n = s(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n          return n.setAttribute(\"spellcheck\", !1), n;\n        }\n      }, {\n        key: \"formats\",\n        value: function value() {\n          return !0;\n        }\n      }]), e;\n    }(y.default);\n\n    O.blotName = \"code-block\", O.tagName = \"PRE\", O.TAB = \"  \", e.Code = _, e.default = O;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = n(52),\n        c = r(s),\n        f = n(8),\n        d = r(f),\n        p = n(28),\n        h = (0, d.default)(\"quill:events\"),\n        y = [p.SHADOW_SELECTIONCHANGE, \"mousedown\", \"mouseup\", \"click\"],\n        v = [],\n        b = (\"getRootNode\" in document);\n\n    y.forEach(function (t) {\n      document.addEventListener(t, function () {\n        for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) {\n          e[n] = arguments[n];\n        }\n\n        v.forEach(function (t) {\n          t.handleDOM.apply(t, e);\n        });\n      });\n    });\n\n    var m = function (t) {\n      function e() {\n        o(this, e);\n        var t = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));\n        return t.listeners = {}, v.push(t), t.on(\"error\", h.error), t;\n      }\n\n      return a(e, t), l(e, [{\n        key: \"emit\",\n        value: function value() {\n          h.log.apply(h, arguments), u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"emit\", this).apply(this, arguments);\n        }\n      }, {\n        key: \"handleDOM\",\n        value: function value(t) {\n          for (var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) {\n            n[r - 1] = arguments[r];\n          }\n\n          var o = t.composedPath ? t.composedPath()[0] : t.target,\n              i = function i(t, e) {\n            if (!b || e.getRootNode() === document) return t.contains(e);\n\n            for (; !t.contains(e);) {\n              var n = e.getRootNode();\n              if (!n || !n.host) return !1;\n              e = n.host;\n            }\n\n            return !0;\n          };\n\n          (this.listeners[t.type] || []).forEach(function (e) {\n            var r = e.node,\n                a = e.handler;\n            (o === r || i(r, o)) && a.apply(void 0, [t].concat(n));\n          });\n        }\n      }, {\n        key: \"listenDOM\",\n        value: function value(t, e, n) {\n          this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push({\n            node: e,\n            handler: n\n          });\n        }\n      }]), e;\n    }(c.default);\n\n    m.events = {\n      EDITOR_CHANGE: \"editor-change\",\n      SCROLL_BEFORE_UPDATE: \"scroll-before-update\",\n      SCROLL_OPTIMIZE: \"scroll-optimize\",\n      SCROLL_UPDATE: \"scroll-update\",\n      SELECTION_CHANGE: \"selection-change\",\n      TEXT_CHANGE: \"text-change\"\n    }, m.sources = {\n      API: \"api\",\n      SILENT: \"silent\",\n      USER: \"user\"\n    }, e.default = m;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"insertInto\",\n        value: function value(t, n) {\n          0 === t.children.length ? l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertInto\", this).call(this, t, n) : this.remove();\n        }\n      }, {\n        key: \"length\",\n        value: function value() {\n          return 0;\n        }\n      }, {\n        key: \"value\",\n        value: function value() {\n          return \"\";\n        }\n      }], [{\n        key: \"value\",\n        value: function value() {}\n      }]), e;\n    }(s.default.Embed);\n\n    c.blotName = \"break\", c.tagName = \"BR\", e.default = c;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function a(t, e) {\n      var n = document.createElement(\"a\");\n      n.href = t;\n      var r = n.href.slice(0, n.href.indexOf(\":\"));\n      return e.indexOf(r) > -1;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.sanitize = e.default = void 0;\n\n    var l = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = n(4),\n        c = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(s),\n        f = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), l(e, [{\n        key: \"format\",\n        value: function value(t, n) {\n          if (t !== this.statics.blotName || !n) return u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n          n = this.constructor.sanitize(n), this.domNode.setAttribute(\"href\", n);\n        }\n      }], [{\n        key: \"create\",\n        value: function value(t) {\n          var n = u(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n          return t = this.sanitize(t), n.setAttribute(\"href\", t), n.setAttribute(\"target\", \"_blank\"), n;\n        }\n      }, {\n        key: \"formats\",\n        value: function value(t) {\n          return t.getAttribute(\"href\");\n        }\n      }, {\n        key: \"sanitize\",\n        value: function value(t) {\n          return a(t, this.PROTOCOL_WHITELIST) ? t : this.SANITIZED_URL;\n        }\n      }]), e;\n    }(c.default);\n\n    f.blotName = \"link\", f.tagName = \"A\", f.SANITIZED_URL = \"about:blank\", f.PROTOCOL_WHITELIST = [\"http\", \"https\", \"mailto\", \"tel\"], e.default = f, e.sanitize = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      var e = l.find(t);\n      if (null == e) try {\n        e = l.create(t);\n      } catch (n) {\n        e = l.create(l.Scope.INLINE), [].slice.call(t.childNodes).forEach(function (t) {\n          e.domNode.appendChild(t);\n        }), t.parentNode && t.parentNode.replaceChild(e.domNode, t), e.attach();\n      }\n      return e;\n    }\n\n    var o = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var i = n(41),\n        a = n(23),\n        l = n(1),\n        u = function (t) {\n      function e(e) {\n        var n = t.call(this, e) || this;\n        return n.build(), n;\n      }\n\n      return o(e, t), e.prototype.appendChild = function (t) {\n        this.insertBefore(t);\n      }, e.prototype.attach = function () {\n        t.prototype.attach.call(this), this.children.forEach(function (t) {\n          t.attach();\n        });\n      }, e.prototype.build = function () {\n        var t = this;\n        this.children = new i.default(), [].slice.call(this.domNode.childNodes).reverse().forEach(function (e) {\n          try {\n            var n = r(e);\n            t.insertBefore(n, t.children.head || void 0);\n          } catch (t) {\n            if (t instanceof l.ParchmentError) return;\n            throw t;\n          }\n        });\n      }, e.prototype.deleteAt = function (t, e) {\n        if (0 === t && e === this.length()) return this.remove();\n        this.children.forEachAt(t, e, function (t, e, n) {\n          t.deleteAt(e, n);\n        });\n      }, e.prototype.descendant = function (t, n) {\n        var r = this.children.find(n),\n            o = r[0],\n            i = r[1];\n        return null == t.blotName && t(o) || null != t.blotName && o instanceof t ? [o, i] : o instanceof e ? o.descendant(t, i) : [null, -1];\n      }, e.prototype.descendants = function (t, n, r) {\n        void 0 === n && (n = 0), void 0 === r && (r = Number.MAX_VALUE);\n        var o = [],\n            i = r;\n        return this.children.forEachAt(n, r, function (n, r, a) {\n          (null == t.blotName && t(n) || null != t.blotName && n instanceof t) && o.push(n), n instanceof e && (o = o.concat(n.descendants(t, r, i))), i -= a;\n        }), o;\n      }, e.prototype.detach = function () {\n        this.children.forEach(function (t) {\n          t.detach();\n        }), t.prototype.detach.call(this);\n      }, e.prototype.formatAt = function (t, e, n, r) {\n        this.children.forEachAt(t, e, function (t, e, o) {\n          t.formatAt(e, o, n, r);\n        });\n      }, e.prototype.insertAt = function (t, e, n) {\n        var r = this.children.find(t),\n            o = r[0],\n            i = r[1];\n        if (o) o.insertAt(i, e, n);else {\n          var a = null == n ? l.create(\"text\", e) : l.create(e, n);\n          this.appendChild(a);\n        }\n      }, e.prototype.insertBefore = function (t, e) {\n        if (null != this.statics.allowedChildren && !this.statics.allowedChildren.some(function (e) {\n          return t instanceof e;\n        })) throw new l.ParchmentError(\"Cannot insert \" + t.statics.blotName + \" into \" + this.statics.blotName);\n        t.insertInto(this, e);\n      }, e.prototype.length = function () {\n        return this.children.reduce(function (t, e) {\n          return t + e.length();\n        }, 0);\n      }, e.prototype.moveChildren = function (t, e) {\n        this.children.forEach(function (n) {\n          t.insertBefore(n, e);\n        });\n      }, e.prototype.optimize = function (e) {\n        if (t.prototype.optimize.call(this, e), 0 === this.children.length) if (null != this.statics.defaultChild) {\n          var n = l.create(this.statics.defaultChild);\n          this.appendChild(n), n.optimize(e);\n        } else this.remove();\n      }, e.prototype.path = function (t, n) {\n        void 0 === n && (n = !1);\n        var r = this.children.find(t, n),\n            o = r[0],\n            i = r[1],\n            a = [[this, t]];\n        return o instanceof e ? a.concat(o.path(i, n)) : (null != o && a.push([o, i]), a);\n      }, e.prototype.removeChild = function (t) {\n        this.children.remove(t);\n      }, e.prototype.replace = function (n) {\n        n instanceof e && n.moveChildren(this), t.prototype.replace.call(this, n);\n      }, e.prototype.split = function (t, e) {\n        if (void 0 === e && (e = !1), !e) {\n          if (0 === t) return this;\n          if (t === this.length()) return this.next;\n        }\n\n        var n = this.clone();\n        return this.parent.insertBefore(n, this.next), this.children.forEachAt(t, this.length(), function (t, r, o) {\n          t = t.split(r, e), n.appendChild(t);\n        }), n;\n      }, e.prototype.unwrap = function () {\n        this.moveChildren(this.parent, this.next), this.remove();\n      }, e.prototype.update = function (t, e) {\n        var n = this,\n            o = [],\n            i = [];\n        t.forEach(function (t) {\n          t.target === n.domNode && \"childList\" === t.type && (o.push.apply(o, t.addedNodes), i.push.apply(i, t.removedNodes));\n        }), i.forEach(function (t) {\n          if (!(null != t.parentNode && \"IFRAME\" !== t.tagName && document.body.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {\n            var e = l.find(t);\n            null != e && (null != e.domNode.parentNode && e.domNode.parentNode !== n.domNode || e.detach());\n          }\n        }), o.filter(function (t) {\n          return t.parentNode == n.domNode;\n        }).sort(function (t, e) {\n          return t === e ? 0 : t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1;\n        }).forEach(function (t) {\n          var e = null;\n          null != t.nextSibling && (e = l.find(t.nextSibling));\n          var o = r(t);\n          o.next == e && null != o.next || (null != o.parent && o.parent.removeChild(n), n.insertBefore(o, e || void 0));\n        });\n      }, e;\n    }(a.default);\n\n    e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(10),\n        i = n(24),\n        a = n(16),\n        l = n(1),\n        u = function (t) {\n      function e(e) {\n        var n = t.call(this, e) || this;\n        return n.attributes = new i.default(n.domNode), n;\n      }\n\n      return r(e, t), e.formats = function (t) {\n        return \"string\" == typeof this.tagName || (Array.isArray(this.tagName) ? t.tagName.toLowerCase() : void 0);\n      }, e.prototype.format = function (t, e) {\n        var n = l.query(t);\n        n instanceof o.default ? this.attributes.attribute(n, e) : e && (null == n || t === this.statics.blotName && this.formats()[t] === e || this.replaceWith(t, e));\n      }, e.prototype.formats = function () {\n        var t = this.attributes.values(),\n            e = this.statics.formats(this.domNode);\n        return null != e && (t[this.statics.blotName] = e), t;\n      }, e.prototype.replaceWith = function (e, n) {\n        var r = t.prototype.replaceWith.call(this, e, n);\n        return this.attributes.copy(r), r;\n      }, e.prototype.update = function (e, n) {\n        var r = this;\n        t.prototype.update.call(this, e, n), e.some(function (t) {\n          return t.target === r.domNode && \"attributes\" === t.type;\n        }) && this.attributes.build();\n      }, e.prototype.wrap = function (n, r) {\n        var o = t.prototype.wrap.call(this, n, r);\n        return o instanceof e && o.statics.scope === this.statics.scope && this.attributes.move(o), o;\n      }, e;\n    }(a.default);\n\n    e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(23),\n        i = n(1),\n        a = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return r(e, t), e.value = function (t) {\n        return !0;\n      }, e.prototype.index = function (t, e) {\n        return this.domNode === t || this.domNode.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(e, 1) : -1;\n      }, e.prototype.position = function (t, e) {\n        var n = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);\n        return t > 0 && (n += 1), [this.parent.domNode, n];\n      }, e.prototype.value = function () {\n        var t;\n        return t = {}, t[this.statics.blotName] = this.statics.value(this.domNode) || !0, t;\n      }, e.scope = i.Scope.INLINE_BLOT, e;\n    }(o.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    function r(t) {\n      this.ops = t, this.index = 0, this.offset = 0;\n    }\n\n    var o = n(11),\n        i = n(3),\n        a = {\n      attributes: {\n        compose: function compose(t, e, n) {\n          \"object\" != _typeof(t) && (t = {}), \"object\" != _typeof(e) && (e = {});\n          var r = i(!0, {}, e);\n          n || (r = Object.keys(r).reduce(function (t, e) {\n            return null != r[e] && (t[e] = r[e]), t;\n          }, {}));\n\n          for (var o in t) {\n            void 0 !== t[o] && void 0 === e[o] && (r[o] = t[o]);\n          }\n\n          return Object.keys(r).length > 0 ? r : void 0;\n        },\n        diff: function diff(t, e) {\n          \"object\" != _typeof(t) && (t = {}), \"object\" != _typeof(e) && (e = {});\n          var n = Object.keys(t).concat(Object.keys(e)).reduce(function (n, r) {\n            return o(t[r], e[r]) || (n[r] = void 0 === e[r] ? null : e[r]), n;\n          }, {});\n          return Object.keys(n).length > 0 ? n : void 0;\n        },\n        transform: function transform(t, e, n) {\n          if (\"object\" != _typeof(t)) return e;\n\n          if (\"object\" == _typeof(e)) {\n            if (!n) return e;\n            var r = Object.keys(e).reduce(function (n, r) {\n              return void 0 === t[r] && (n[r] = e[r]), n;\n            }, {});\n            return Object.keys(r).length > 0 ? r : void 0;\n          }\n        }\n      },\n      iterator: function iterator(t) {\n        return new r(t);\n      },\n      length: function length(t) {\n        return \"number\" == typeof t.delete ? t.delete : \"number\" == typeof t.retain ? t.retain : \"string\" == typeof t.insert ? t.insert.length : 1;\n      }\n    };\n    r.prototype.hasNext = function () {\n      return this.peekLength() < 1 / 0;\n    }, r.prototype.next = function (t) {\n      t || (t = 1 / 0);\n      var e = this.ops[this.index];\n\n      if (e) {\n        var n = this.offset,\n            r = a.length(e);\n        if (t >= r - n ? (t = r - n, this.index += 1, this.offset = 0) : this.offset += t, \"number\" == typeof e.delete) return {\n          delete: t\n        };\n        var o = {};\n        return e.attributes && (o.attributes = e.attributes), \"number\" == typeof e.retain ? o.retain = t : \"string\" == typeof e.insert ? o.insert = e.insert.substr(n, t) : o.insert = e.insert, o;\n      }\n\n      return {\n        retain: 1 / 0\n      };\n    }, r.prototype.peek = function () {\n      return this.ops[this.index];\n    }, r.prototype.peekLength = function () {\n      return this.ops[this.index] ? a.length(this.ops[this.index]) - this.offset : 1 / 0;\n    }, r.prototype.peekType = function () {\n      return this.ops[this.index] ? \"number\" == typeof this.ops[this.index].delete ? \"delete\" : \"number\" == typeof this.ops[this.index].retain ? \"retain\" : \"insert\" : \"retain\";\n    }, r.prototype.rest = function () {\n      if (this.hasNext()) {\n        if (0 === this.offset) return this.ops.slice(this.index);\n        var t = this.offset,\n            e = this.index,\n            n = this.next(),\n            r = this.ops.slice(this.index);\n        return this.offset = t, this.index = e, [n].concat(r);\n      }\n\n      return [];\n    }, t.exports = a;\n  }, function (t, e) {\n    var n = function () {\n      \"use strict\";\n\n      function t(t, e) {\n        return null != e && t instanceof e;\n      }\n\n      function e(n, r, o, i, c) {\n        function f(n, o) {\n          if (null === n) return null;\n          if (0 === o) return n;\n          var y, v;\n          if (\"object\" != _typeof(n)) return n;\n          if (t(n, l)) y = new l();else if (t(n, u)) y = new u();else if (t(n, s)) y = new s(function (t, e) {\n            n.then(function (e) {\n              t(f(e, o - 1));\n            }, function (t) {\n              e(f(t, o - 1));\n            });\n          });else if (e.__isArray(n)) y = [];else if (e.__isRegExp(n)) y = new RegExp(n.source, a(n)), n.lastIndex && (y.lastIndex = n.lastIndex);else if (e.__isDate(n)) y = new Date(n.getTime());else {\n            if (h && Buffer.isBuffer(n)) return y = Buffer.allocUnsafe ? Buffer.allocUnsafe(n.length) : new Buffer(n.length), n.copy(y), y;\n            t(n, Error) ? y = Object.create(n) : void 0 === i ? (v = Object.getPrototypeOf(n), y = Object.create(v)) : (y = Object.create(i), v = i);\n          }\n\n          if (r) {\n            var b = d.indexOf(n);\n            if (-1 != b) return p[b];\n            d.push(n), p.push(y);\n          }\n\n          t(n, l) && n.forEach(function (t, e) {\n            var n = f(e, o - 1),\n                r = f(t, o - 1);\n            y.set(n, r);\n          }), t(n, u) && n.forEach(function (t) {\n            var e = f(t, o - 1);\n            y.add(e);\n          });\n\n          for (var m in n) {\n            var g;\n            v && (g = Object.getOwnPropertyDescriptor(v, m)), g && null == g.set || (y[m] = f(n[m], o - 1));\n          }\n\n          if (Object.getOwnPropertySymbols) for (var _ = Object.getOwnPropertySymbols(n), m = 0; m < _.length; m++) {\n            var O = _[m],\n                E = Object.getOwnPropertyDescriptor(n, O);\n            (!E || E.enumerable || c) && (y[O] = f(n[O], o - 1), E.enumerable || Object.defineProperty(y, O, {\n              enumerable: !1\n            }));\n          }\n          if (c) for (var N = Object.getOwnPropertyNames(n), m = 0; m < N.length; m++) {\n            var w = N[m],\n                E = Object.getOwnPropertyDescriptor(n, w);\n            E && E.enumerable || (y[w] = f(n[w], o - 1), Object.defineProperty(y, w, {\n              enumerable: !1\n            }));\n          }\n          return y;\n        }\n\n        \"object\" == _typeof(r) && (o = r.depth, i = r.prototype, c = r.includeNonEnumerable, r = r.circular);\n        var d = [],\n            p = [],\n            h = \"undefined\" != typeof Buffer;\n        return void 0 === r && (r = !0), void 0 === o && (o = 1 / 0), f(n, o);\n      }\n\n      function n(t) {\n        return Object.prototype.toString.call(t);\n      }\n\n      function r(t) {\n        return \"object\" == _typeof(t) && \"[object Date]\" === n(t);\n      }\n\n      function o(t) {\n        return \"object\" == _typeof(t) && \"[object Array]\" === n(t);\n      }\n\n      function i(t) {\n        return \"object\" == _typeof(t) && \"[object RegExp]\" === n(t);\n      }\n\n      function a(t) {\n        var e = \"\";\n        return t.global && (e += \"g\"), t.ignoreCase && (e += \"i\"), t.multiline && (e += \"m\"), e;\n      }\n\n      var l;\n\n      try {\n        l = Map;\n      } catch (t) {\n        l = function l() {};\n      }\n\n      var u;\n\n      try {\n        u = Set;\n      } catch (t) {\n        u = function u() {};\n      }\n\n      var s;\n\n      try {\n        s = Promise;\n      } catch (t) {\n        s = function s() {};\n      }\n\n      return e.clonePrototype = function (t) {\n        if (null === t) return null;\n\n        var e = function e() {};\n\n        return e.prototype = t, new e();\n      }, e.__objToStr = n, e.__isDate = r, e.__isArray = o, e.__isRegExp = i, e.__getRegExpFlags = a, e;\n    }();\n\n    \"object\" == _typeof(t) && t.exports && (t.exports = n);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = n(0),\n        u = r(l),\n        s = n(2),\n        c = r(s),\n        f = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), e;\n    }(u.default.Container);\n\n    f.allowedChildren = [c.default, s.BlockEmbed, f], e.default = f;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.ColorStyle = e.ColorClass = e.ColorAttributor = void 0;\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"value\",\n        value: function value(t) {\n          var n = l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"value\", this).call(this, t);\n          return n.startsWith(\"rgb(\") ? (n = n.replace(/^[^\\d]+/, \"\").replace(/[^\\d]+$/, \"\"), \"#\" + n.split(\",\").map(function (t) {\n            return (\"00\" + parseInt(t).toString(16)).slice(-2);\n          }).join(\"\")) : n;\n        }\n      }]), e;\n    }(s.default.Attributor.Style),\n        f = new s.default.Attributor.Class(\"color\", \"ql-color\", {\n      scope: s.default.Scope.INLINE\n    }),\n        d = new c(\"color\", \"color\", {\n      scope: s.default.Scope.INLINE\n    });\n\n    e.ColorAttributor = c, e.ColorClass = f, e.ColorStyle = d;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var r = n(1),\n        o = function () {\n      function t(t) {\n        this.domNode = t, this.domNode[r.DATA_KEY] = {\n          blot: this\n        };\n      }\n\n      return Object.defineProperty(t.prototype, \"statics\", {\n        get: function get() {\n          return this.constructor;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), t.create = function (t) {\n        if (null == this.tagName) throw new r.ParchmentError(\"Blot definition missing tagName\");\n        var e;\n        return Array.isArray(this.tagName) ? (\"string\" == typeof t && (t = t.toUpperCase(), parseInt(t).toString() === t && (t = parseInt(t))), e = \"number\" == typeof t ? document.createElement(this.tagName[t - 1]) : this.tagName.indexOf(t) > -1 ? document.createElement(t) : document.createElement(this.tagName[0])) : e = document.createElement(this.tagName), this.className && e.classList.add(this.className), e;\n      }, t.prototype.attach = function () {\n        null != this.parent && (this.scroll = this.parent.scroll);\n      }, t.prototype.clone = function () {\n        var t = this.domNode.cloneNode(!1);\n        return r.create(t);\n      }, t.prototype.detach = function () {\n        null != this.parent && this.parent.removeChild(this), delete this.domNode[r.DATA_KEY];\n      }, t.prototype.deleteAt = function (t, e) {\n        this.isolate(t, e).remove();\n      }, t.prototype.formatAt = function (t, e, n, o) {\n        var i = this.isolate(t, e);\n        if (null != r.query(n, r.Scope.BLOT) && o) i.wrap(n, o);else if (null != r.query(n, r.Scope.ATTRIBUTE)) {\n          var a = r.create(this.statics.scope);\n          i.wrap(a), a.format(n, o);\n        }\n      }, t.prototype.insertAt = function (t, e, n) {\n        var o = null == n ? r.create(\"text\", e) : r.create(e, n),\n            i = this.split(t);\n        this.parent.insertBefore(o, i);\n      }, t.prototype.insertInto = function (t, e) {\n        void 0 === e && (e = null), null != this.parent && this.parent.children.remove(this);\n        var n = null;\n        t.children.insertBefore(this, e), null != e && (n = e.domNode), this.domNode.parentNode == t.domNode && this.domNode.nextSibling == n || t.domNode.insertBefore(this.domNode, n), this.parent = t, this.attach();\n      }, t.prototype.isolate = function (t, e) {\n        var n = this.split(t);\n        return n.split(e), n;\n      }, t.prototype.length = function () {\n        return 1;\n      }, t.prototype.offset = function (t) {\n        return void 0 === t && (t = this.parent), null == this.parent || this == t ? 0 : this.parent.children.offset(this) + this.parent.offset(t);\n      }, t.prototype.optimize = function (t) {\n        null != this.domNode[r.DATA_KEY] && delete this.domNode[r.DATA_KEY].mutations;\n      }, t.prototype.remove = function () {\n        null != this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), this.detach();\n      }, t.prototype.replace = function (t) {\n        null != t.parent && (t.parent.insertBefore(this, t.next), t.remove());\n      }, t.prototype.replaceWith = function (t, e) {\n        var n = \"string\" == typeof t ? r.create(t, e) : t;\n        return n.replace(this), n;\n      }, t.prototype.split = function (t, e) {\n        return 0 === t ? this : this.next;\n      }, t.prototype.update = function (t, e) {}, t.prototype.wrap = function (t, e) {\n        var n = \"string\" == typeof t ? r.create(t, e) : t;\n        return null != this.parent && this.parent.insertBefore(n, this.next), n.appendChild(this), n;\n      }, t.blotName = \"abstract\", t;\n    }();\n\n    e.default = o;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var r = n(10),\n        o = n(25),\n        i = n(26),\n        a = n(1),\n        l = function () {\n      function t(t) {\n        this.attributes = {}, this.domNode = t, this.build();\n      }\n\n      return t.prototype.attribute = function (t, e) {\n        e ? t.add(this.domNode, e) && (null != t.value(this.domNode) ? this.attributes[t.attrName] = t : delete this.attributes[t.attrName]) : (t.remove(this.domNode), delete this.attributes[t.attrName]);\n      }, t.prototype.build = function () {\n        var t = this;\n        this.attributes = {};\n        var e = r.default.keys(this.domNode),\n            n = o.default.keys(this.domNode),\n            l = i.default.keys(this.domNode);\n        e.concat(n).concat(l).forEach(function (e) {\n          var n = a.query(e, a.Scope.ATTRIBUTE);\n          n instanceof r.default && (t.attributes[n.attrName] = n);\n        });\n      }, t.prototype.copy = function (t) {\n        var e = this;\n        Object.keys(this.attributes).forEach(function (n) {\n          var r = e.attributes[n].value(e.domNode);\n          t.format(n, r);\n        });\n      }, t.prototype.move = function (t) {\n        var e = this;\n        this.copy(t), Object.keys(this.attributes).forEach(function (t) {\n          e.attributes[t].remove(e.domNode);\n        }), this.attributes = {};\n      }, t.prototype.values = function () {\n        var t = this;\n        return Object.keys(this.attributes).reduce(function (e, n) {\n          return e[n] = t.attributes[n].value(t.domNode), e;\n        }, {});\n      }, t;\n    }();\n\n    e.default = l;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      return (t.getAttribute(\"class\") || \"\").split(/\\s+/).filter(function (t) {\n        return 0 === t.indexOf(e + \"-\");\n      });\n    }\n\n    var o = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var i = n(10),\n        a = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return o(e, t), e.keys = function (t) {\n        return (t.getAttribute(\"class\") || \"\").split(/\\s+/).map(function (t) {\n          return t.split(\"-\").slice(0, -1).join(\"-\");\n        });\n      }, e.prototype.add = function (t, e) {\n        return !!this.canAdd(t, e) && (this.remove(t), t.classList.add(this.keyName + \"-\" + e), !0);\n      }, e.prototype.remove = function (t) {\n        r(t, this.keyName).forEach(function (e) {\n          t.classList.remove(e);\n        }), 0 === t.classList.length && t.removeAttribute(\"class\");\n      }, e.prototype.value = function (t) {\n        var e = r(t, this.keyName)[0] || \"\",\n            n = e.slice(this.keyName.length + 1);\n        return this.canAdd(t, n) ? n : \"\";\n      }, e;\n    }(i.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      var e = t.split(\"-\"),\n          n = e.slice(1).map(function (t) {\n        return t[0].toUpperCase() + t.slice(1);\n      }).join(\"\");\n      return e[0] + n;\n    }\n\n    var o = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var i = n(10),\n        a = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return o(e, t), e.keys = function (t) {\n        return (t.getAttribute(\"style\") || \"\").split(\";\").map(function (t) {\n          return t.split(\":\")[0].trim();\n        });\n      }, e.prototype.add = function (t, e) {\n        return !!this.canAdd(t, e) && (t.style[r(this.keyName)] = e, !0);\n      }, e.prototype.remove = function (t) {\n        t.style[r(this.keyName)] = \"\", t.getAttribute(\"style\") || t.removeAttribute(\"style\");\n      }, e.prototype.value = function (t) {\n        var e = t.style[r(this.keyName)];\n        return this.canAdd(t, e) ? e : \"\";\n      }, e;\n    }(i.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        c = n(0),\n        f = r(c),\n        d = n(7),\n        p = r(d),\n        h = function (t) {\n      function e(t, n) {\n        o(this, e);\n        var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));\n        return r.selection = n, r.textNode = document.createTextNode(e.CONTENTS), r.domNode.appendChild(r.textNode), r._length = 0, r;\n      }\n\n      return a(e, t), s(e, null, [{\n        key: \"value\",\n        value: function value() {}\n      }]), s(e, [{\n        key: \"detach\",\n        value: function value() {\n          null != this.parent && this.parent.removeChild(this);\n        }\n      }, {\n        key: \"format\",\n        value: function value(t, n) {\n          if (0 !== this._length) return u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n\n          for (var r = this, o = 0; null != r && r.statics.scope !== f.default.Scope.BLOCK_BLOT;) {\n            o += r.offset(r.parent), r = r.parent;\n          }\n\n          null != r && (this._length = e.CONTENTS.length, r.optimize(), r.formatAt(o, e.CONTENTS.length, t, n), this._length = 0);\n        }\n      }, {\n        key: \"index\",\n        value: function value(t, n) {\n          return t === this.textNode ? 0 : u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"index\", this).call(this, t, n);\n        }\n      }, {\n        key: \"length\",\n        value: function value() {\n          return this._length;\n        }\n      }, {\n        key: \"position\",\n        value: function value() {\n          return [this.textNode, this.textNode.data.length];\n        }\n      }, {\n        key: \"remove\",\n        value: function value() {\n          u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"remove\", this).call(this), this.parent = null;\n        }\n      }, {\n        key: \"restore\",\n        value: function value() {\n          if (!this.selection.composing && null != this.parent) {\n            var t = this.textNode,\n                n = this.selection.getNativeRange(),\n                r = void 0,\n                o = void 0,\n                i = void 0;\n\n            if (null != n && n.start.node === t && n.end.node === t) {\n              var a = [t, n.start.offset, n.end.offset];\n              r = a[0], o = a[1], i = a[2];\n            }\n\n            for (; null != this.domNode.lastChild && this.domNode.lastChild !== this.textNode;) {\n              this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n            }\n\n            if (this.textNode.data !== e.CONTENTS) {\n              var u = this.textNode.data.split(e.CONTENTS).join(\"\");\n              this.next instanceof p.default ? (r = this.next.domNode, this.next.insertAt(0, u), this.textNode.data = e.CONTENTS) : (this.textNode.data = u, this.parent.insertBefore(f.default.create(this.textNode), this), this.textNode = document.createTextNode(e.CONTENTS), this.domNode.appendChild(this.textNode));\n            }\n\n            if (this.remove(), null != o) {\n              var s = [o, i].map(function (t) {\n                return Math.max(0, Math.min(r.data.length, t - 1));\n              }),\n                  c = l(s, 2);\n              return o = c[0], i = c[1], {\n                startNode: r,\n                startOffset: o,\n                endNode: r,\n                endOffset: i\n              };\n            }\n          }\n        }\n      }, {\n        key: \"update\",\n        value: function value(t, e) {\n          var n = this;\n\n          if (t.some(function (t) {\n            return \"characterData\" === t.type && t.target === n.textNode;\n          })) {\n            var r = this.restore();\n            r && (e.range = r);\n          }\n        }\n      }, {\n        key: \"value\",\n        value: function value() {\n          return \"\";\n        }\n      }]), e;\n    }(f.default.Embed);\n\n    h.blotName = \"cursor\", h.className = \"ql-cursor\", h.tagName = \"span\", h.CONTENTS = \"\\uFEFF\", e.default = h;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return _.includes(t.nodeType);\n    }\n\n    function o(t, e) {\n      var n = [],\n          r = function r(t) {\n        for (var e = 0; e < t.length; ++e) {\n          t[e].shadowRoot && n.push(t[e].shadowRoot);\n        }\n      };\n\n      for (e.shadowRoot && n.push(e.shadowRoot), r(e.childNodes); n.length;) {\n        for (var o = n.shift(), i = 0; i < o.childNodes.length; ++i) {\n          if (t.containsNode(o.childNodes[i], !0)) return o;\n        }\n\n        r(o.querySelectorAll(\"*\"));\n      }\n\n      return null;\n    }\n\n    function i(t, e, n) {\n      var o = e.childNodes || e.children;\n      if (!o) return e;\n\n      for (var a = 0; a < o.length; ++a) {\n        var l = n ? a : o.length - 1 - a,\n            u = o[l];\n\n        if (r(u) && t.containsNode(u, !0)) {\n          if (t.containsNode(u, !1)) return u;\n          if (!g.exec(u.localName || \"\")) return i(t, u, n);\n        }\n      }\n\n      return e;\n    }\n\n    function a(t, e, n) {\n      for (var r = e; (e = u(e, n)) && e.contains(r);) {\n        ;\n      }\n\n      return !!e && e instanceof Element && t.containsNode(e, !0);\n    }\n\n    function l(t, e, n) {\n      if (\"Range\" === t.type) {\n        var r = function r() {\n          return t.toString().length;\n        },\n            o = r(),\n            i = void 0;\n\n        return t.modify(\"extend\", \"forward\", \"character\"), (i = r()) > o || a(t, n, !0) ? (t.modify(\"extend\", \"backward\", \"character\"), !0) : i < o || !t.containsNode(e) ? (t.modify(\"extend\", \"backward\", \"character\"), !1) : (t.modify(\"extend\", \"backward\", \"character\"), i = r(), i > o || a(t, e, !1) ? (t.modify(\"extend\", \"forward\", \"character\"), !1) : i < o || !t.containsNode(n) ? (t.modify(\"extend\", \"forward\", \"character\"), !0) : void 0);\n      }\n    }\n\n    function u(t, e) {\n      if (!e) return t.previousSibling || t.parentNode || null;\n\n      for (; t;) {\n        if (t.nextSibling) return t.nextSibling;\n        t = t.parentNode;\n      }\n\n      return null;\n    }\n\n    function s(t, e, n) {\n      E.has(t) && (E.delete(t), E.set(t, n)), e.removeAllRanges(), e.addRange(n);\n    }\n\n    function c(t) {\n      if (y) {\n        var e = document.getSelection();\n        return e.rangeCount ? e.getRangeAt(0) : null;\n      }\n\n      if (b) {\n        var n = document.getSelection();\n        return n.containsNode(t, !0) ? n.getRangeAt(0) : null;\n      }\n\n      if (h) {\n        var r = t.getSelection();\n        return r.rangeCount ? r.getRangeAt(0) : null;\n      }\n\n      var o = E.get(t);\n      if (o) return o;\n      var i = f(t);\n      return E.set(t, i.range), window.setTimeout(function () {\n        E.delete(t);\n      }, 0), i.range;\n    }\n\n    function f(t) {\n      var e = window.getSelection();\n      if (\"None\" === e.type) return {\n        range: null,\n        type: \"none\"\n      };\n      if (\"Caret\" !== e.type && \"Range\" !== e.type) throw new TypeError(\"unexpected type: \" + e.type);\n      var n = i(e, t, !0);\n      if (n === t) return {\n        range: null,\n        mode: \"none\"\n      };\n      var r = document.createRange(),\n          o = null,\n          a = void 0;\n      if (\"Range\" === e.type && (o = i(e, t, !1), void 0 === (a = l(e, n, o)))) return r.setStart(n, 0), r.setEnd(o, o.length), {\n        range: r,\n        mode: \"all\"\n      };\n      var u = e.toString().length,\n          s = 0,\n          c = 0;\n      if (null === o) ;else if (o.nodeType === Node.TEXT_NODE) {\n        for (var f = o.textContent, d = o.nextSibling, p = f.length - 1; p >= 0; --p) {\n          o.splitText(p);\n          var h = e.toString().length;\n\n          if (h !== u) {\n            c = p + 1;\n            break;\n          }\n        }\n\n        for (o.insertData(o.length, f.substr(o.length)); o.nextSibling !== d;) {\n          o.nextSibling.remove();\n        }\n      }\n\n      if (n.nodeType === Node.TEXT_NODE) {\n        n !== o && (n.appendData(\"?\"), e.collapseToStart(), e.modify(\"extend\", \"right\", \"character\"));\n\n        for (var y = n.textContent, v = n.nextSibling, b = n === o ? c : y.length - 1, m = b; m >= 0; --m) {\n          if (n.splitText(m), \"\" === e.toString()) {\n            s = m;\n            break;\n          }\n        }\n\n        for (n.insertData(n.length, y.substr(n.length)); n.nextSibling !== v;) {\n          n.nextSibling.remove();\n        }\n\n        n !== o && n.deleteData(n.length - 1, 1), null === o && (o = n, c = s);\n      } else null === o && (o = n);\n\n      return 1 === u && O && O.node === n && O.offset > s && a && (a = !1), !0 === a ? (e.collapse(n, s), e.extend(o, c)) : !1 === a ? (e.collapse(o, c), e.extend(n, s)) : e.setPosition(n, s), r.setStart(n, s), r.setEnd(o, c), {\n        range: r,\n        mode: \"normal\"\n      };\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.findCaretFocus = o, e.addRange = s, e.getRange = c;\n    var d = e.SHADOW_SELECTIONCHANGE = \"-shadow-selectionchange\",\n        p = \"attachShadow\" in Element.prototype && \"getRootNode\" in Element.prototype,\n        h = !(!p || !document.createElement(\"div\").attachShadow({\n      mode: \"open\"\n    }).getSelection),\n        y = window.ShadyDOM && window.ShadyDOM.inUse,\n        v = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,\n        b = !p || y || !h && !v,\n        m = e.usePolyfill = !(h || b),\n        g = /^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|script|source|style|template|track|wbr)$/,\n        _ = [Node.ELEMENT_NODE, Node.TEXT_NODE, Node.DOCUMENT_FRAGMENT_NODE],\n        O = {\n      node: null,\n      offset: -1\n    };\n    !function () {\n      if (!m) return document.addEventListener(\"selectionchange\", function () {\n        document.dispatchEvent(new CustomEvent(d));\n      }), function () {};\n      var t = !1;\n      document.addEventListener(\"selectionchange\", function () {\n        if (!t) {\n          t = !0;\n          var e = window.getSelection();\n\n          if (\"Caret\" === e.type) {\n            var n = o(e, e.anchorNode);\n\n            if (n instanceof window.ShadowRoot) {\n              var r = c(n);\n\n              if (r) {\n                var i = r.startContainer,\n                    a = r.startOffset;\n                O = {\n                  node: i,\n                  offset: a\n                };\n              }\n            }\n          }\n\n          document.dispatchEvent(new CustomEvent(\"-shadow-selectionchange\")), window.requestAnimationFrame(function () {\n            t = !1;\n          });\n        }\n      });\n    }();\n    var E = new Map();\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t) {\n      if (Array.isArray(t)) {\n        for (var e = 0, n = Array(t.length); e < t.length; e++) {\n          n[e] = t[e];\n        }\n\n        return n;\n      }\n\n      return Array.from(t);\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      try {\n        e.parentNode;\n      } catch (t) {\n        return !1;\n      }\n\n      return e instanceof Text && (e = e.parentNode), t.contains(e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.Range = void 0;\n\n    var l = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        u = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        s = n(0),\n        c = r(s),\n        f = n(20),\n        d = r(f),\n        p = n(11),\n        h = r(p),\n        y = n(13),\n        v = r(y),\n        b = n(8),\n        m = r(b),\n        g = n(28),\n        _ = (0, m.default)(\"quill:selection\"),\n        O = function t(e) {\n      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n      i(this, t), this.index = e, this.length = n;\n    },\n        E = function () {\n      function t(e, n) {\n        var r = this;\n        i(this, t), this.emitter = n, this.scroll = e, this.composing = !1, this.mouseDown = !1, this.root = this.scroll.domNode, this.rootDocument = this.root.getRootNode ? this.root.getRootNode() : document, this.cursor = c.default.create(\"cursor\", this), this.lastRange = this.savedRange = new O(0, 0), this.handleComposition(), this.handleDragging(), g.usePolyfill || this.emitter.listenDOM(g.SHADOW_SELECTIONCHANGE, document, function () {\n          r.mouseDown || setTimeout(r.update.bind(r, v.default.sources.USER), 1);\n        }), this.emitter.on(v.default.events.EDITOR_CHANGE, function (t, e) {\n          t === v.default.events.TEXT_CHANGE && e.length() > 0 && r.update(v.default.sources.SILENT);\n        }), this.emitter.on(v.default.events.SCROLL_BEFORE_UPDATE, function () {\n          if (r.hasFocus()) {\n            var t = r.getNativeRange();\n            null != t && t.start.node !== r.cursor.textNode && r.emitter.once(v.default.events.SCROLL_UPDATE, function () {\n              try {\n                r.setNativeRange(t.start.node, t.start.offset, t.end.node, t.end.offset);\n              } catch (t) {}\n            });\n          }\n        }), this.emitter.on(v.default.events.SCROLL_OPTIMIZE, function (t, e) {\n          if (e.range) {\n            var n = e.range,\n                o = n.startNode,\n                i = n.startOffset,\n                a = n.endNode,\n                l = n.endOffset;\n            r.setNativeRange(o, i, a, l);\n          }\n        }), this.update(v.default.sources.SILENT);\n      }\n\n      return u(t, [{\n        key: \"handleComposition\",\n        value: function value() {\n          var t = this;\n          this.root.addEventListener(\"compositionstart\", function () {\n            t.composing = !0;\n          }), this.root.addEventListener(\"compositionend\", function () {\n            if (t.composing = !1, t.cursor.parent) {\n              var e = t.cursor.restore();\n              if (!e) return;\n              setTimeout(function () {\n                t.setNativeRange(e.startNode, e.startOffset, e.endNode, e.endOffset);\n              }, 1);\n            }\n          });\n        }\n      }, {\n        key: \"handleDragging\",\n        value: function value() {\n          var t = this;\n          this.emitter.listenDOM(\"mousedown\", document.body, function () {\n            t.mouseDown = !0;\n          }), this.emitter.listenDOM(\"mouseup\", document.body, function () {\n            t.mouseDown = !1, t.update(v.default.sources.USER);\n          });\n        }\n      }, {\n        key: \"focus\",\n        value: function value() {\n          this.hasFocus() || (this.root.focus(), this.setRange(this.savedRange));\n        }\n      }, {\n        key: \"format\",\n        value: function value(t, e) {\n          if (null == this.scroll.whitelist || this.scroll.whitelist[t]) {\n            this.scroll.update();\n            var n = this.getNativeRange();\n\n            if (null != n && n.native.collapsed && !c.default.query(t, c.default.Scope.BLOCK)) {\n              if (n.start.node !== this.cursor.textNode) {\n                var r = c.default.find(n.start.node, !1);\n                if (null == r) return;\n\n                if (r instanceof c.default.Leaf) {\n                  var o = r.split(n.start.offset);\n                  r.parent.insertBefore(this.cursor, o);\n                } else r.insertBefore(this.cursor, n.start.node);\n\n                this.cursor.attach();\n              }\n\n              this.cursor.format(t, e), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();\n            }\n          }\n        }\n      }, {\n        key: \"getBounds\",\n        value: function value(t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n              n = this.scroll.length();\n          t = Math.min(t, n - 1), e = Math.min(t + e, n - 1) - t;\n          var r = void 0,\n              o = this.scroll.leaf(t),\n              i = l(o, 2),\n              a = i[0],\n              u = i[1];\n          if (null == a) return null;\n          var s = a.position(u, !0),\n              c = l(s, 2);\n          r = c[0], u = c[1];\n          var f = document.createRange();\n\n          if (e > 0) {\n            f.setStart(r, u);\n            var d = this.scroll.leaf(t + e),\n                p = l(d, 2);\n            if (a = p[0], u = p[1], null == a) return null;\n            var h = a.position(u, !0),\n                y = l(h, 2);\n            return r = y[0], u = y[1], f.setEnd(r, u), f.getBoundingClientRect();\n          }\n\n          var v = \"left\",\n              b = void 0;\n          return r instanceof Text ? (u < r.data.length ? (f.setStart(r, u), f.setEnd(r, u + 1)) : (f.setStart(r, u - 1), f.setEnd(r, u), v = \"right\"), b = f.getBoundingClientRect()) : (b = a.domNode.getBoundingClientRect(), u > 0 && (v = \"right\")), {\n            bottom: b.top + b.height,\n            height: b.height,\n            left: b[v],\n            right: b[v],\n            top: b.top,\n            width: 0\n          };\n        }\n      }, {\n        key: \"getNativeRange\",\n        value: function value() {\n          var t = (0, g.getRange)(this.rootDocument);\n          if (null == t) return null;\n          var e = this.normalizeNative(t);\n          return _.info(\"getNativeRange\", e), e;\n        }\n      }, {\n        key: \"getRange\",\n        value: function value() {\n          var t = this.getNativeRange();\n          return null == t ? [null, null] : [this.normalizedToRange(t), t];\n        }\n      }, {\n        key: \"hasFocus\",\n        value: function value() {\n          return this.rootDocument.activeElement === this.root;\n        }\n      }, {\n        key: \"normalizedToRange\",\n        value: function value(t) {\n          var e = this,\n              n = [[t.start.node, t.start.offset]];\n          t.native.collapsed || n.push([t.end.node, t.end.offset]);\n          var r = n.map(function (t) {\n            var n = l(t, 2),\n                r = n[0],\n                o = n[1],\n                i = c.default.find(r, !0),\n                a = i.offset(e.scroll);\n            return 0 === o ? a : i instanceof c.default.Container ? a + i.length() : a + i.index(r, o);\n          }),\n              i = Math.min(Math.max.apply(Math, o(r)), this.scroll.length() - 1),\n              a = Math.min.apply(Math, [i].concat(o(r)));\n          return new O(a, i - a);\n        }\n      }, {\n        key: \"normalizeNative\",\n        value: function value(t) {\n          if (!a(this.root, t.startContainer) || !t.collapsed && !a(this.root, t.endContainer)) return null;\n          var e = {\n            start: {\n              node: t.startContainer,\n              offset: t.startOffset\n            },\n            end: {\n              node: t.endContainer,\n              offset: t.endOffset\n            },\n            native: t\n          };\n          return [e.start, e.end].forEach(function (t) {\n            for (var e = t.node, n = t.offset; !(e instanceof Text) && e.childNodes.length > 0;) {\n              if (e.childNodes.length > n) e = e.childNodes[n], n = 0;else {\n                if (e.childNodes.length !== n) break;\n                e = e.lastChild, n = e instanceof Text ? e.data.length : e.childNodes.length + 1;\n              }\n            }\n\n            t.node = e, t.offset = n;\n          }), e;\n        }\n      }, {\n        key: \"rangeToNative\",\n        value: function value(t) {\n          var e = this,\n              n = t.collapsed ? [t.index] : [t.index, t.index + t.length],\n              r = [],\n              o = this.scroll.length();\n          return n.forEach(function (t, n) {\n            t = Math.min(o - 1, t);\n            var i = void 0,\n                a = e.scroll.leaf(t),\n                u = l(a, 2),\n                s = u[0],\n                c = u[1],\n                f = s.position(c, 0 !== n),\n                d = l(f, 2);\n            i = d[0], c = d[1], r.push(i, c);\n          }), r.length < 2 && (r = r.concat(r)), r;\n        }\n      }, {\n        key: \"scrollIntoView\",\n        value: function value(t) {\n          var e = this.lastRange;\n\n          if (null != e) {\n            var n = this.getBounds(e.index, e.length);\n\n            if (null != n) {\n              var r = this.scroll.length() - 1,\n                  o = this.scroll.line(Math.min(e.index, r)),\n                  i = l(o, 1),\n                  a = i[0],\n                  u = a;\n\n              if (e.length > 0) {\n                var s = this.scroll.line(Math.min(e.index + e.length, r));\n                u = l(s, 1)[0];\n              }\n\n              if (null != a && null != u) {\n                var c = t.getBoundingClientRect();\n                n.top < c.top ? t.scrollTop -= c.top - n.top : n.bottom > c.bottom && (t.scrollTop += n.bottom - c.bottom);\n              }\n            }\n          }\n        }\n      }, {\n        key: \"setNativeRange\",\n        value: function value(t, e) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t,\n              r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e,\n              o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];\n\n          if (_.info(\"setNativeRange\", t, e, n, r), null == t || null != this.root.parentNode && null != t.parentNode && null != n.parentNode) {\n            var i = \"function\" == typeof this.rootDocument.getSelection ? this.rootDocument.getSelection() : document.getSelection();\n            if (null != i) if (null != t) {\n              this.hasFocus() || this.root.focus();\n              var a = (this.getNativeRange() || {}).native;\n\n              if (null == a || o || t !== a.startContainer || e !== a.startOffset || n !== a.endContainer || r !== a.endOffset) {\n                \"BR\" == t.tagName && (e = [].indexOf.call(t.parentNode.childNodes, t), t = t.parentNode), \"BR\" == n.tagName && (r = [].indexOf.call(n.parentNode.childNodes, n), n = n.parentNode);\n                var l = document.createRange();\n                l.setStart(t, e), l.setEnd(n, r), (0, g.addRange)(this.rootDocument, i, l);\n              }\n            } else i.removeAllRanges(), this.root.blur(), document.body.focus();\n          }\n        }\n      }, {\n        key: \"setRange\",\n        value: function value(t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : v.default.sources.API;\n\n          if (\"string\" == typeof e && (n = e, e = !1), _.info(\"setRange\", t), null != t) {\n            var r = this.rangeToNative(t);\n            this.setNativeRange.apply(this, o(r).concat([e]));\n          } else this.setNativeRange(null);\n\n          this.update(n);\n        }\n      }, {\n        key: \"update\",\n        value: function value() {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v.default.sources.USER,\n              e = this.lastRange,\n              n = this.getRange(),\n              r = l(n, 2),\n              o = r[0],\n              i = r[1];\n\n          if (this.lastRange = o, null != this.lastRange && (this.savedRange = this.lastRange), !(0, h.default)(e, this.lastRange)) {\n            var a;\n            !this.composing && null != i && i.native.collapsed && i.start.node !== this.cursor.textNode && this.cursor.restore();\n            var u = [v.default.events.SELECTION_CHANGE, (0, d.default)(this.lastRange), (0, d.default)(e), t];\n\n            if ((a = this.emitter).emit.apply(a, [v.default.events.EDITOR_CHANGE].concat(u)), t !== v.default.sources.SILENT) {\n              var s;\n              (s = this.emitter).emit.apply(s, u);\n            }\n          }\n        }\n      }]), t;\n    }();\n\n    e.Range = O, e.default = E;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.AlignStyle = e.AlignClass = e.AlignAttribute = void 0;\n\n    var r = n(0),\n        o = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(r),\n        i = {\n      scope: o.default.Scope.BLOCK,\n      whitelist: [\"right\", \"center\", \"justify\"]\n    },\n        a = new o.default.Attributor.Attribute(\"align\", \"align\", i),\n        l = new o.default.Attributor.Class(\"align\", \"ql-align\", i),\n        u = new o.default.Attributor.Style(\"align\", \"text-align\", i);\n\n    e.AlignAttribute = a, e.AlignClass = l, e.AlignStyle = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.BackgroundStyle = e.BackgroundClass = void 0;\n\n    var r = n(0),\n        o = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(r),\n        i = n(22),\n        a = new o.default.Attributor.Class(\"background\", \"ql-bg\", {\n      scope: o.default.Scope.INLINE\n    }),\n        l = new i.ColorAttributor(\"background\", \"background-color\", {\n      scope: o.default.Scope.INLINE\n    });\n\n    e.BackgroundClass = a, e.BackgroundStyle = l;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.DirectionStyle = e.DirectionClass = e.DirectionAttribute = void 0;\n\n    var r = n(0),\n        o = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(r),\n        i = {\n      scope: o.default.Scope.BLOCK,\n      whitelist: [\"rtl\"]\n    },\n        a = new o.default.Attributor.Attribute(\"direction\", \"dir\", i),\n        l = new o.default.Attributor.Class(\"direction\", \"ql-direction\", i),\n        u = new o.default.Attributor.Style(\"direction\", \"direction\", i);\n\n    e.DirectionAttribute = a, e.DirectionClass = l, e.DirectionStyle = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.FontClass = e.FontStyle = void 0;\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = {\n      scope: s.default.Scope.INLINE,\n      whitelist: [\"serif\", \"monospace\"]\n    },\n        f = new s.default.Attributor.Class(\"font\", \"ql-font\", c),\n        d = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"value\",\n        value: function value(t) {\n          return l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"value\", this).call(this, t).replace(/[\"']/g, \"\");\n        }\n      }]), e;\n    }(s.default.Attributor.Style),\n        p = new d(\"font\", \"font-family\", c);\n\n    e.FontStyle = p, e.FontClass = f;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.SizeStyle = e.SizeClass = void 0;\n\n    var r = n(0),\n        o = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(r),\n        i = new o.default.Attributor.Class(\"size\", \"ql-size\", {\n      scope: o.default.Scope.INLINE,\n      whitelist: [\"small\", \"large\", \"huge\"]\n    }),\n        a = new o.default.Attributor.Style(\"size\", \"font-size\", {\n      scope: o.default.Scope.INLINE,\n      whitelist: [\"10px\", \"18px\", \"32px\"]\n    });\n\n    e.SizeClass = i, e.SizeStyle = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function l(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function u(t, e) {\n      var n,\n          r = t === D.keys.LEFT ? \"prefix\" : \"suffix\";\n      return n = {\n        key: t,\n        shiftKey: e,\n        altKey: null\n      }, o(n, r, /^$/), o(n, \"handler\", function (n) {\n        var r = n.index;\n        t === D.keys.RIGHT && (r += n.length + 1);\n        var o = this.quill.getLeaf(r);\n        return !(b(o, 1)[0] instanceof S.default.Embed) || (t === D.keys.LEFT ? e ? this.quill.setSelection(n.index - 1, n.length + 1, C.default.sources.USER) : this.quill.setSelection(n.index - 1, C.default.sources.USER) : e ? this.quill.setSelection(n.index, n.length + 1, C.default.sources.USER) : this.quill.setSelection(n.index + n.length + 1, C.default.sources.USER), !1);\n      }), n;\n    }\n\n    function s(t, e) {\n      if (!(0 === t.index || this.quill.getLength() <= 1)) {\n        var n = this.quill.getLine(t.index),\n            r = b(n, 1),\n            o = r[0],\n            i = {};\n\n        if (0 === e.offset) {\n          var a = this.quill.getLine(t.index - 1),\n              l = b(a, 1),\n              u = l[0];\n\n          if (null != u && u.length() > 1) {\n            var s = o.formats(),\n                c = this.quill.getFormat(t.index - 1, 1);\n            i = A.default.attributes.diff(s, c) || {};\n          }\n        }\n\n        var f = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(e.prefix) ? 2 : 1;\n        this.quill.deleteText(t.index - f, f, C.default.sources.USER), Object.keys(i).length > 0 && this.quill.formatLine(t.index - f, f, i, C.default.sources.USER), this.quill.focus();\n      }\n    }\n\n    function c(t, e) {\n      var n = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(e.suffix) ? 2 : 1;\n\n      if (!(t.index >= this.quill.getLength() - n)) {\n        var r = {},\n            o = 0,\n            i = this.quill.getLine(t.index),\n            a = b(i, 1),\n            l = a[0];\n\n        if (e.offset >= l.length() - 1) {\n          var u = this.quill.getLine(t.index + 1),\n              s = b(u, 1),\n              c = s[0];\n\n          if (c) {\n            var f = l.formats(),\n                d = this.quill.getFormat(t.index, 1);\n            r = A.default.attributes.diff(f, d) || {}, o = c.length();\n          }\n        }\n\n        this.quill.deleteText(t.index, n, C.default.sources.USER), Object.keys(r).length > 0 && this.quill.formatLine(t.index + o - 1, n, r, C.default.sources.USER);\n      }\n    }\n\n    function f(t) {\n      var e = this.quill.getLines(t),\n          n = {};\n\n      if (e.length > 1) {\n        var r = e[0].formats(),\n            o = e[e.length - 1].formats();\n        n = A.default.attributes.diff(o, r) || {};\n      }\n\n      this.quill.deleteText(t, C.default.sources.USER), Object.keys(n).length > 0 && this.quill.formatLine(t.index, 1, n, C.default.sources.USER), this.quill.setSelection(t.index, C.default.sources.SILENT), this.quill.focus();\n    }\n\n    function d(t, e) {\n      var n = this;\n      t.length > 0 && this.quill.scroll.deleteAt(t.index, t.length);\n      var r = Object.keys(e.format).reduce(function (t, n) {\n        return S.default.query(n, S.default.Scope.BLOCK) && !Array.isArray(e.format[n]) && (t[n] = e.format[n]), t;\n      }, {});\n      this.quill.insertText(t.index, \"\\n\", r, C.default.sources.USER), this.quill.setSelection(t.index + 1, C.default.sources.SILENT), this.quill.focus(), Object.keys(e.format).forEach(function (t) {\n        null == r[t] && (Array.isArray(e.format[t]) || \"link\" !== t && n.quill.format(t, e.format[t], C.default.sources.USER));\n      });\n    }\n\n    function p(t) {\n      return {\n        key: D.keys.TAB,\n        shiftKey: !t,\n        format: {\n          \"code-block\": !0\n        },\n        handler: function handler(e) {\n          var n = S.default.query(\"code-block\"),\n              r = e.index,\n              o = e.length,\n              i = this.quill.scroll.descendant(n, r),\n              a = b(i, 2),\n              l = a[0],\n              u = a[1];\n\n          if (null != l) {\n            var s = this.quill.getIndex(l),\n                c = l.newlineIndex(u, !0) + 1,\n                f = l.newlineIndex(s + u + o),\n                d = l.domNode.textContent.slice(c, f).split(\"\\n\");\n            u = 0, d.forEach(function (e, i) {\n              t ? (l.insertAt(c + u, n.TAB), u += n.TAB.length, 0 === i ? r += n.TAB.length : o += n.TAB.length) : e.startsWith(n.TAB) && (l.deleteAt(c + u, n.TAB.length), u -= n.TAB.length, 0 === i ? r -= n.TAB.length : o -= n.TAB.length), u += e.length + 1;\n            }), this.quill.update(C.default.sources.USER), this.quill.setSelection(r, o, C.default.sources.SILENT);\n          }\n        }\n      };\n    }\n\n    function h(t) {\n      return {\n        key: t[0].toUpperCase(),\n        shortKey: !0,\n        handler: function handler(e, n) {\n          this.quill.format(t, !n.format[t], C.default.sources.USER);\n        }\n      };\n    }\n\n    function y(t) {\n      if (\"string\" == typeof t || \"number\" == typeof t) return y({\n        key: t\n      });\n      if (\"object\" === (void 0 === t ? \"undefined\" : v(t)) && (t = (0, _.default)(t, !1)), \"string\" == typeof t.key) if (null != D.keys[t.key.toUpperCase()]) t.key = D.keys[t.key.toUpperCase()];else {\n        if (1 !== t.key.length) return null;\n        t.key = t.key.toUpperCase().charCodeAt(0);\n      }\n      return t.shortKey && (t[B] = t.shortKey, delete t.shortKey), t;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.SHORTKEY = e.default = void 0;\n\n    var v = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (t) {\n      return _typeof(t);\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : _typeof(t);\n    },\n        b = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        m = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        g = n(20),\n        _ = r(g),\n        O = n(11),\n        E = r(O),\n        N = n(3),\n        w = r(N),\n        k = n(5),\n        j = r(k),\n        x = n(19),\n        A = r(x),\n        T = n(0),\n        S = r(T),\n        P = n(6),\n        C = r(P),\n        L = n(8),\n        R = r(L),\n        q = n(9),\n        I = r(q),\n        M = (0, R.default)(\"quill:keyboard\"),\n        B = /Mac/i.test(navigator.platform) ? \"metaKey\" : \"ctrlKey\",\n        D = function (t) {\n      function e(t, n) {\n        i(this, e);\n        var r = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));\n        return r.bindings = {}, Object.keys(r.options.bindings).forEach(function (e) {\n          (\"list autofill\" !== e || null == t.scroll.whitelist || t.scroll.whitelist.list) && r.options.bindings[e] && r.addBinding(r.options.bindings[e]);\n        }), r.addBinding({\n          key: e.keys.ENTER,\n          shiftKey: null\n        }, d), r.addBinding({\n          key: e.keys.ENTER,\n          metaKey: null,\n          ctrlKey: null,\n          altKey: null\n        }, function () {}), /Firefox/i.test(navigator.userAgent) ? (r.addBinding({\n          key: e.keys.BACKSPACE\n        }, {\n          collapsed: !0\n        }, s), r.addBinding({\n          key: e.keys.DELETE\n        }, {\n          collapsed: !0\n        }, c)) : (r.addBinding({\n          key: e.keys.BACKSPACE\n        }, {\n          collapsed: !0,\n          prefix: /^.?$/\n        }, s), r.addBinding({\n          key: e.keys.DELETE\n        }, {\n          collapsed: !0,\n          suffix: /^.?$/\n        }, c)), r.addBinding({\n          key: e.keys.BACKSPACE\n        }, {\n          collapsed: !1\n        }, f), r.addBinding({\n          key: e.keys.DELETE\n        }, {\n          collapsed: !1\n        }, f), r.addBinding({\n          key: e.keys.BACKSPACE,\n          altKey: null,\n          ctrlKey: null,\n          metaKey: null,\n          shiftKey: null\n        }, {\n          collapsed: !0,\n          offset: 0\n        }, s), r.listen(), r;\n      }\n\n      return l(e, t), m(e, null, [{\n        key: \"match\",\n        value: function value(t, e) {\n          return e = y(e), ![\"altKey\", \"ctrlKey\", \"metaKey\", \"shiftKey\"].some(function (n) {\n            return !!e[n] !== t[n] && null !== e[n];\n          }) && e.key === (t.which || t.keyCode);\n        }\n      }]), m(e, [{\n        key: \"addBinding\",\n        value: function value(t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n              r = y(t);\n          if (null == r || null == r.key) return M.warn(\"Attempted to add invalid keyboard binding\", r);\n          \"function\" == typeof e && (e = {\n            handler: e\n          }), \"function\" == typeof n && (n = {\n            handler: n\n          }), r = (0, w.default)(r, e, n), this.bindings[r.key] = this.bindings[r.key] || [], this.bindings[r.key].push(r);\n        }\n      }, {\n        key: \"listen\",\n        value: function value() {\n          var t = this;\n          this.quill.root.addEventListener(\"keydown\", function (n) {\n            if (!n.defaultPrevented) {\n              var r = n.which || n.keyCode,\n                  o = (t.bindings[r] || []).filter(function (t) {\n                return e.match(n, t);\n              });\n\n              if (0 !== o.length) {\n                var i = t.quill.getSelection();\n\n                if (null != i && t.quill.hasFocus()) {\n                  var a = t.quill.getLine(i.index),\n                      l = b(a, 2),\n                      u = l[0],\n                      s = l[1],\n                      c = t.quill.getLeaf(i.index),\n                      f = b(c, 2),\n                      d = f[0],\n                      p = f[1],\n                      h = 0 === i.length ? [d, p] : t.quill.getLeaf(i.index + i.length),\n                      y = b(h, 2),\n                      m = y[0],\n                      g = y[1],\n                      _ = d instanceof S.default.Text ? d.value().slice(0, p) : \"\",\n                      O = m instanceof S.default.Text ? m.value().slice(g) : \"\",\n                      N = {\n                    collapsed: 0 === i.length,\n                    empty: 0 === i.length && u.length() <= 1,\n                    format: t.quill.getFormat(i),\n                    offset: s,\n                    prefix: _,\n                    suffix: O\n                  };\n\n                  o.some(function (e) {\n                    if (null != e.collapsed && e.collapsed !== N.collapsed) return !1;\n                    if (null != e.empty && e.empty !== N.empty) return !1;\n                    if (null != e.offset && e.offset !== N.offset) return !1;\n\n                    if (Array.isArray(e.format)) {\n                      if (e.format.every(function (t) {\n                        return null == N.format[t];\n                      })) return !1;\n                    } else if (\"object\" === v(e.format) && !Object.keys(e.format).every(function (t) {\n                      return !0 === e.format[t] ? null != N.format[t] : !1 === e.format[t] ? null == N.format[t] : (0, E.default)(e.format[t], N.format[t]);\n                    })) return !1;\n\n                    return !(null != e.prefix && !e.prefix.test(N.prefix)) && !(null != e.suffix && !e.suffix.test(N.suffix)) && !0 !== e.handler.call(t, i, N);\n                  }) && n.preventDefault();\n                }\n              }\n            }\n          });\n        }\n      }]), e;\n    }(I.default);\n\n    D.keys = {\n      BACKSPACE: 8,\n      TAB: 9,\n      ENTER: 13,\n      ESCAPE: 27,\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      DOWN: 40,\n      DELETE: 46\n    }, D.DEFAULTS = {\n      bindings: {\n        bold: h(\"bold\"),\n        italic: h(\"italic\"),\n        underline: h(\"underline\"),\n        indent: {\n          key: D.keys.TAB,\n          format: [\"blockquote\", \"indent\", \"list\"],\n          handler: function handler(t, e) {\n            if (e.collapsed && 0 !== e.offset) return !0;\n            this.quill.format(\"indent\", \"+1\", C.default.sources.USER);\n          }\n        },\n        outdent: {\n          key: D.keys.TAB,\n          shiftKey: !0,\n          format: [\"blockquote\", \"indent\", \"list\"],\n          handler: function handler(t, e) {\n            if (e.collapsed && 0 !== e.offset) return !0;\n            this.quill.format(\"indent\", \"-1\", C.default.sources.USER);\n          }\n        },\n        \"outdent backspace\": {\n          key: D.keys.BACKSPACE,\n          collapsed: !0,\n          shiftKey: null,\n          metaKey: null,\n          ctrlKey: null,\n          altKey: null,\n          format: [\"indent\", \"list\"],\n          offset: 0,\n          handler: function handler(t, e) {\n            null != e.format.indent ? this.quill.format(\"indent\", \"-1\", C.default.sources.USER) : null != e.format.list && this.quill.format(\"list\", !1, C.default.sources.USER);\n          }\n        },\n        \"indent code-block\": p(!0),\n        \"outdent code-block\": p(!1),\n        \"remove tab\": {\n          key: D.keys.TAB,\n          shiftKey: !0,\n          collapsed: !0,\n          prefix: /\\t$/,\n          handler: function handler(t) {\n            this.quill.deleteText(t.index - 1, 1, C.default.sources.USER);\n          }\n        },\n        tab: {\n          key: D.keys.TAB,\n          handler: function handler(t) {\n            this.quill.history.cutoff();\n            var e = new j.default().retain(t.index).delete(t.length).insert(\"\\t\");\n            this.quill.updateContents(e, C.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t.index + 1, C.default.sources.SILENT);\n          }\n        },\n        \"list empty enter\": {\n          key: D.keys.ENTER,\n          collapsed: !0,\n          format: [\"list\"],\n          empty: !0,\n          handler: function handler(t, e) {\n            this.quill.format(\"list\", !1, C.default.sources.USER), e.format.indent && this.quill.format(\"indent\", !1, C.default.sources.USER);\n          }\n        },\n        \"checklist enter\": {\n          key: D.keys.ENTER,\n          collapsed: !0,\n          format: {\n            list: \"checked\"\n          },\n          handler: function handler(t) {\n            var e = this.quill.getLine(t.index),\n                n = b(e, 2),\n                r = n[0],\n                o = n[1],\n                i = (0, w.default)({}, r.formats(), {\n              list: \"checked\"\n            }),\n                a = new j.default().retain(t.index).insert(\"\\n\", i).retain(r.length() - o - 1).retain(1, {\n              list: \"unchecked\"\n            });\n            this.quill.updateContents(a, C.default.sources.USER), this.quill.setSelection(t.index + 1, C.default.sources.SILENT), this.quill.scrollIntoView();\n          }\n        },\n        \"header enter\": {\n          key: D.keys.ENTER,\n          collapsed: !0,\n          format: [\"header\"],\n          suffix: /^$/,\n          handler: function handler(t, e) {\n            var n = this.quill.getLine(t.index),\n                r = b(n, 2),\n                o = r[0],\n                i = r[1],\n                a = new j.default().retain(t.index).insert(\"\\n\", e.format).retain(o.length() - i - 1).retain(1, {\n              header: null\n            });\n            this.quill.updateContents(a, C.default.sources.USER), this.quill.setSelection(t.index + 1, C.default.sources.SILENT), this.quill.scrollIntoView();\n          }\n        },\n        \"list autofill\": {\n          key: \" \",\n          collapsed: !0,\n          format: {\n            list: !1\n          },\n          prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n          handler: function handler(t, e) {\n            var n = e.prefix.length,\n                r = this.quill.getLine(t.index),\n                o = b(r, 2),\n                i = o[0],\n                a = o[1];\n            if (a > n) return !0;\n            var l = void 0;\n\n            switch (e.prefix.trim()) {\n              case \"[]\":\n              case \"[ ]\":\n                l = \"unchecked\";\n                break;\n\n              case \"[x]\":\n                l = \"checked\";\n                break;\n\n              case \"-\":\n              case \"*\":\n                l = \"bullet\";\n                break;\n\n              default:\n                l = \"ordered\";\n            }\n\n            this.quill.insertText(t.index, \" \", C.default.sources.USER), this.quill.history.cutoff();\n            var u = new j.default().retain(t.index - a).delete(n + 1).retain(i.length() - 2 - a).retain(1, {\n              list: l\n            });\n            this.quill.updateContents(u, C.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t.index - n, C.default.sources.SILENT);\n          }\n        },\n        \"code exit\": {\n          key: D.keys.ENTER,\n          collapsed: !0,\n          format: [\"code-block\"],\n          prefix: /\\n\\n$/,\n          suffix: /^\\s+$/,\n          handler: function handler(t) {\n            var e = this.quill.getLine(t.index),\n                n = b(e, 2),\n                r = n[0],\n                o = n[1],\n                i = new j.default().retain(t.index + r.length() - o - 2).retain(1, {\n              \"code-block\": null\n            }).delete(1);\n            this.quill.updateContents(i, C.default.sources.USER);\n          }\n        },\n        \"embed left\": u(D.keys.LEFT, !1),\n        \"embed left shift\": u(D.keys.LEFT, !0),\n        \"embed right\": u(D.keys.RIGHT, !1),\n        \"embed right shift\": u(D.keys.RIGHT, !0)\n      }\n    }, e.default = D, e.SHORTKEY = B;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(4),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"optimize\",\n        value: function value(t) {\n          l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);\n        }\n      }], [{\n        key: \"create\",\n        value: function value() {\n          return l(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this);\n        }\n      }, {\n        key: \"formats\",\n        value: function value() {\n          return !0;\n        }\n      }]), e;\n    }(s.default);\n\n    c.blotName = \"bold\", c.tagName = [\"STRONG\", \"B\"], e.default = c;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        i = function () {\n      function t(e, n) {\n        r(this, t), this.quill = e, this.options = n, this.modules = {};\n      }\n\n      return o(t, [{\n        key: \"init\",\n        value: function value() {\n          var t = this;\n          Object.keys(this.options.modules).forEach(function (e) {\n            null == t.modules[e] && t.addModule(e);\n          });\n        }\n      }, {\n        key: \"addModule\",\n        value: function value(t) {\n          var e = this.quill.constructor.import(\"modules/\" + t);\n          return this.modules[t] = new e(this.quill, this.options.modules[t] || {}), this.modules[t];\n        }\n      }]), t;\n    }();\n\n    i.DEFAULTS = {\n      modules: {}\n    }, i.themes = {\n      default: i\n    }, e.default = i;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = n(0),\n        c = r(s),\n        f = n(7),\n        d = r(f),\n        p = \"\\uFEFF\",\n        h = function (t) {\n      function e(t) {\n        o(this, e);\n        var n = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));\n        return n.contentNode = document.createElement(\"span\"), n.contentNode.setAttribute(\"contenteditable\", !1), [].slice.call(n.domNode.childNodes).forEach(function (t) {\n          n.contentNode.appendChild(t);\n        }), n.leftGuard = document.createTextNode(p), n.rightGuard = document.createTextNode(p), n.domNode.appendChild(n.leftGuard), n.domNode.appendChild(n.contentNode), n.domNode.appendChild(n.rightGuard), n;\n      }\n\n      return a(e, t), l(e, [{\n        key: \"index\",\n        value: function value(t, n) {\n          return t === this.leftGuard ? 0 : t === this.rightGuard ? 1 : u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"index\", this).call(this, t, n);\n        }\n      }, {\n        key: \"restore\",\n        value: function value(t) {\n          var e = void 0,\n              n = void 0,\n              r = t.data.split(p).join(\"\");\n          if (t === this.leftGuard) {\n            if (this.prev instanceof d.default) {\n              var o = this.prev.length();\n              this.prev.insertAt(o, r), e = {\n                startNode: this.prev.domNode,\n                startOffset: o + r.length\n              };\n            } else n = document.createTextNode(r), this.parent.insertBefore(c.default.create(n), this), e = {\n              startNode: n,\n              startOffset: r.length\n            };\n          } else t === this.rightGuard && (this.next instanceof d.default ? (this.next.insertAt(0, r), e = {\n            startNode: this.next.domNode,\n            startOffset: r.length\n          }) : (n = document.createTextNode(r), this.parent.insertBefore(c.default.create(n), this.next), e = {\n            startNode: n,\n            startOffset: r.length\n          }));\n          return t.data = p, e;\n        }\n      }, {\n        key: \"update\",\n        value: function value(t, e) {\n          var n = this;\n          t.forEach(function (t) {\n            if (\"characterData\" === t.type && (t.target === n.leftGuard || t.target === n.rightGuard)) {\n              var r = n.restore(t.target);\n              r && (e.range = r);\n            }\n          });\n        }\n      }]), e;\n    }(c.default.Embed);\n\n    e.default = h;\n  },, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(0),\n        i = r(o),\n        a = n(6),\n        l = r(a),\n        u = n(2),\n        s = r(u),\n        c = n(14),\n        f = r(c),\n        d = n(21),\n        p = r(d),\n        h = n(27),\n        y = r(h),\n        v = n(38),\n        b = r(v),\n        m = n(4),\n        g = r(m),\n        _ = n(53),\n        O = r(_),\n        E = n(7),\n        N = r(E),\n        w = n(54),\n        k = r(w),\n        j = n(55),\n        x = r(j),\n        A = n(35),\n        T = r(A);\n\n    l.default.register({\n      \"blots/block\": s.default,\n      \"blots/block/embed\": u.BlockEmbed,\n      \"blots/break\": f.default,\n      \"blots/container\": p.default,\n      \"blots/cursor\": y.default,\n      \"blots/embed\": b.default,\n      \"blots/inline\": g.default,\n      \"blots/scroll\": O.default,\n      \"blots/text\": N.default,\n      \"modules/clipboard\": k.default,\n      \"modules/history\": x.default,\n      \"modules/keyboard\": T.default\n    }), i.default.register(s.default, f.default, y.default, g.default, O.default, N.default), e.default = l.default;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var r = function () {\n      function t() {\n        this.head = this.tail = null, this.length = 0;\n      }\n\n      return t.prototype.append = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) {\n          t[e] = arguments[e];\n        }\n\n        this.insertBefore(t[0], null), t.length > 1 && this.append.apply(this, t.slice(1));\n      }, t.prototype.contains = function (t) {\n        for (var e, n = this.iterator(); e = n();) {\n          if (e === t) return !0;\n        }\n\n        return !1;\n      }, t.prototype.insertBefore = function (t, e) {\n        t && (t.next = e, null != e ? (t.prev = e.prev, null != e.prev && (e.prev.next = t), e.prev = t, e === this.head && (this.head = t)) : null != this.tail ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : (t.prev = null, this.head = this.tail = t), this.length += 1);\n      }, t.prototype.offset = function (t) {\n        for (var e = 0, n = this.head; null != n;) {\n          if (n === t) return e;\n          e += n.length(), n = n.next;\n        }\n\n        return -1;\n      }, t.prototype.remove = function (t) {\n        this.contains(t) && (null != t.prev && (t.prev.next = t.next), null != t.next && (t.next.prev = t.prev), t === this.head && (this.head = t.next), t === this.tail && (this.tail = t.prev), this.length -= 1);\n      }, t.prototype.iterator = function (t) {\n        return void 0 === t && (t = this.head), function () {\n          var e = t;\n          return null != t && (t = t.next), e;\n        };\n      }, t.prototype.find = function (t, e) {\n        void 0 === e && (e = !1);\n\n        for (var n, r = this.iterator(); n = r();) {\n          var o = n.length();\n          if (t < o || e && t === o && (null == n.next || 0 !== n.next.length())) return [n, t];\n          t -= o;\n        }\n\n        return [null, 0];\n      }, t.prototype.forEach = function (t) {\n        for (var e, n = this.iterator(); e = n();) {\n          t(e);\n        }\n      }, t.prototype.forEachAt = function (t, e, n) {\n        if (!(e <= 0)) for (var r, o = this.find(t), i = o[0], a = o[1], l = t - a, u = this.iterator(i); (r = u()) && l < t + e;) {\n          var s = r.length();\n          t > l ? n(r, t - l, Math.min(e, l + s - t)) : n(r, 0, Math.min(s, t + e - l)), l += s;\n        }\n      }, t.prototype.map = function (t) {\n        return this.reduce(function (e, n) {\n          return e.push(t(n)), e;\n        }, []);\n      }, t.prototype.reduce = function (t, e) {\n        for (var n, r = this.iterator(); n = r();) {\n          e = t(e, n);\n        }\n\n        return e;\n      }, t;\n    }();\n\n    e.default = r;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(16),\n        i = n(1),\n        a = {\n      attributes: !0,\n      characterData: !0,\n      characterDataOldValue: !0,\n      childList: !0,\n      subtree: !0\n    },\n        l = function (t) {\n      function e(e) {\n        var n = t.call(this, e) || this;\n        return n.scroll = n, n.observer = new MutationObserver(function (t) {\n          n.update(t);\n        }), n.observer.observe(n.domNode, a), n.attach(), n;\n      }\n\n      return r(e, t), e.prototype.detach = function () {\n        t.prototype.detach.call(this), this.observer.disconnect();\n      }, e.prototype.deleteAt = function (e, n) {\n        this.update(), 0 === e && n === this.length() ? this.children.forEach(function (t) {\n          t.remove();\n        }) : t.prototype.deleteAt.call(this, e, n);\n      }, e.prototype.formatAt = function (e, n, r, o) {\n        this.update(), t.prototype.formatAt.call(this, e, n, r, o);\n      }, e.prototype.insertAt = function (e, n, r) {\n        this.update(), t.prototype.insertAt.call(this, e, n, r);\n      }, e.prototype.optimize = function (e, n) {\n        var r = this;\n        void 0 === e && (e = []), void 0 === n && (n = {}), t.prototype.optimize.call(this, n);\n\n        for (var a = [].slice.call(this.observer.takeRecords()); a.length > 0;) {\n          e.push(a.pop());\n        }\n\n        for (var l = function l(t, e) {\n          void 0 === e && (e = !0), null != t && t !== r && null != t.domNode.parentNode && (null == t.domNode[i.DATA_KEY].mutations && (t.domNode[i.DATA_KEY].mutations = []), e && l(t.parent));\n        }, u = function u(t) {\n          null != t.domNode[i.DATA_KEY] && null != t.domNode[i.DATA_KEY].mutations && (t instanceof o.default && t.children.forEach(u), t.optimize(n));\n        }, s = e, c = 0; s.length > 0; c += 1) {\n          if (c >= 100) throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n\n          for (s.forEach(function (t) {\n            var e = i.find(t.target, !0);\n            null != e && (e.domNode === t.target && (\"childList\" === t.type ? (l(i.find(t.previousSibling, !1)), [].forEach.call(t.addedNodes, function (t) {\n              var e = i.find(t, !1);\n              l(e, !1), e instanceof o.default && e.children.forEach(function (t) {\n                l(t, !1);\n              });\n            })) : \"attributes\" === t.type && l(e.prev)), l(e));\n          }), this.children.forEach(u), s = [].slice.call(this.observer.takeRecords()), a = s.slice(); a.length > 0;) {\n            e.push(a.pop());\n          }\n        }\n      }, e.prototype.update = function (e, n) {\n        var r = this;\n        void 0 === n && (n = {}), e = e || this.observer.takeRecords(), e.map(function (t) {\n          var e = i.find(t.target, !0);\n          return null == e ? null : null == e.domNode[i.DATA_KEY].mutations ? (e.domNode[i.DATA_KEY].mutations = [t], e) : (e.domNode[i.DATA_KEY].mutations.push(t), null);\n        }).forEach(function (t) {\n          null != t && t !== r && null != t.domNode[i.DATA_KEY] && t.update(t.domNode[i.DATA_KEY].mutations || [], n);\n        }), null != this.domNode[i.DATA_KEY].mutations && t.prototype.update.call(this, this.domNode[i.DATA_KEY].mutations, n), this.optimize(e, n);\n      }, e.blotName = \"scroll\", e.defaultChild = \"block\", e.scope = i.Scope.BLOCK_BLOT, e.tagName = \"DIV\", e;\n    }(o.default);\n\n    e.default = l;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (Object.keys(t).length !== Object.keys(e).length) return !1;\n\n      for (var n in t) {\n        if (t[n] !== e[n]) return !1;\n      }\n\n      return !0;\n    }\n\n    var o = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var i = n(17),\n        a = n(1),\n        l = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return o(e, t), e.formats = function (n) {\n        if (n.tagName !== e.tagName) return t.formats.call(this, n);\n      }, e.prototype.format = function (n, r) {\n        var o = this;\n        n !== this.statics.blotName || r ? t.prototype.format.call(this, n, r) : (this.children.forEach(function (t) {\n          t instanceof i.default || (t = t.wrap(e.blotName, !0)), o.attributes.copy(t);\n        }), this.unwrap());\n      }, e.prototype.formatAt = function (e, n, r, o) {\n        if (null != this.formats()[r] || a.query(r, a.Scope.ATTRIBUTE)) {\n          this.isolate(e, n).format(r, o);\n        } else t.prototype.formatAt.call(this, e, n, r, o);\n      }, e.prototype.optimize = function (n) {\n        t.prototype.optimize.call(this, n);\n        var o = this.formats();\n        if (0 === Object.keys(o).length) return this.unwrap();\n        var i = this.next;\n        i instanceof e && i.prev === this && r(o, i.formats()) && (i.moveChildren(this), i.remove());\n      }, e.blotName = \"inline\", e.scope = a.Scope.INLINE_BLOT, e.tagName = \"SPAN\", e;\n    }(i.default);\n\n    e.default = l;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(17),\n        i = n(1),\n        a = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return r(e, t), e.formats = function (n) {\n        var r = i.query(e.blotName).tagName;\n        if (n.tagName !== r) return t.formats.call(this, n);\n      }, e.prototype.format = function (n, r) {\n        null != i.query(n, i.Scope.BLOCK) && (n !== this.statics.blotName || r ? t.prototype.format.call(this, n, r) : this.replaceWith(e.blotName));\n      }, e.prototype.formatAt = function (e, n, r, o) {\n        null != i.query(r, i.Scope.BLOCK) ? this.format(r, o) : t.prototype.formatAt.call(this, e, n, r, o);\n      }, e.prototype.insertAt = function (e, n, r) {\n        if (null == r || null != i.query(n, i.Scope.INLINE)) t.prototype.insertAt.call(this, e, n, r);else {\n          var o = this.split(e),\n              a = i.create(n, r);\n          o.parent.insertBefore(a, o);\n        }\n      }, e.prototype.update = function (e, n) {\n        navigator.userAgent.match(/Trident/) ? this.build() : t.prototype.update.call(this, e, n);\n      }, e.blotName = \"block\", e.scope = i.Scope.BLOCK_BLOT, e.tagName = \"P\", e;\n    }(o.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(18),\n        i = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return r(e, t), e.formats = function (t) {}, e.prototype.format = function (e, n) {\n        t.prototype.formatAt.call(this, 0, this.length(), e, n);\n      }, e.prototype.formatAt = function (e, n, r, o) {\n        0 === e && n === this.length() ? this.format(r, o) : t.prototype.formatAt.call(this, e, n, r, o);\n      }, e.prototype.formats = function () {\n        return this.statics.formats(this.domNode);\n      }, e;\n    }(o.default);\n\n    e.default = i;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(18),\n        i = n(1),\n        a = function (t) {\n      function e(e) {\n        var n = t.call(this, e) || this;\n        return n.text = n.statics.value(n.domNode), n;\n      }\n\n      return r(e, t), e.create = function (t) {\n        return document.createTextNode(t);\n      }, e.value = function (t) {\n        var e = t.data;\n        return e.normalize && (e = e.normalize()), e;\n      }, e.prototype.deleteAt = function (t, e) {\n        this.domNode.data = this.text = this.text.slice(0, t) + this.text.slice(t + e);\n      }, e.prototype.index = function (t, e) {\n        return this.domNode === t ? e : -1;\n      }, e.prototype.insertAt = function (e, n, r) {\n        null == r ? (this.text = this.text.slice(0, e) + n + this.text.slice(e), this.domNode.data = this.text) : t.prototype.insertAt.call(this, e, n, r);\n      }, e.prototype.length = function () {\n        return this.text.length;\n      }, e.prototype.optimize = function (n) {\n        t.prototype.optimize.call(this, n), this.text = this.statics.value(this.domNode), 0 === this.text.length ? this.remove() : this.next instanceof e && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());\n      }, e.prototype.position = function (t, e) {\n        return void 0 === e && (e = !1), [this.domNode, t];\n      }, e.prototype.split = function (t, e) {\n        if (void 0 === e && (e = !1), !e) {\n          if (0 === t) return this;\n          if (t === this.length()) return this.next;\n        }\n\n        var n = i.create(this.domNode.splitText(t));\n        return this.parent.insertBefore(n, this.next), this.text = this.statics.value(this.domNode), n;\n      }, e.prototype.update = function (t, e) {\n        var n = this;\n        t.some(function (t) {\n          return \"characterData\" === t.type && t.target === n.domNode;\n        }) && (this.text = this.statics.value(this.domNode));\n      }, e.prototype.value = function () {\n        return this.text;\n      }, e.blotName = \"text\", e.scope = i.Scope.INLINE_BLOT, e;\n    }(o.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = document.createElement(\"div\");\n\n    if (r.classList.toggle(\"test-class\", !1), r.classList.contains(\"test-class\")) {\n      var o = DOMTokenList.prototype.toggle;\n\n      DOMTokenList.prototype.toggle = function (t, e) {\n        return arguments.length > 1 && !this.contains(t) == !e ? e : o.call(this, t);\n      };\n    }\n\n    String.prototype.startsWith || (String.prototype.startsWith = function (t, e) {\n      return e = e || 0, this.substr(e, t.length) === t;\n    }), String.prototype.endsWith || (String.prototype.endsWith = function (t, e) {\n      var n = this.toString();\n      (\"number\" != typeof e || !isFinite(e) || Math.floor(e) !== e || e > n.length) && (e = n.length), e -= t.length;\n      var r = n.indexOf(t, e);\n      return -1 !== r && r === e;\n    }), Array.prototype.find || Object.defineProperty(Array.prototype, \"find\", {\n      value: function value(t) {\n        if (null === this) throw new TypeError(\"Array.prototype.find called on null or undefined\");\n        if (\"function\" != typeof t) throw new TypeError(\"predicate must be a function\");\n\n        for (var e, n = Object(this), r = n.length >>> 0, o = arguments[1], i = 0; i < r; i++) {\n          if (e = n[i], t.call(o, e, i, n)) return e;\n        }\n      }\n    }), document.addEventListener(\"DOMContentLoaded\", function () {\n      document.execCommand(\"enableObjectResizing\", !1, !1), document.execCommand(\"autoUrlDetect\", !1, !1);\n    });\n  }, function (t, e) {\n    function n(t, e, n) {\n      if (t == e) return t ? [[v, t]] : [];\n      (n < 0 || t.length < n) && (n = null);\n      var o = a(t, e),\n          i = t.substring(0, o);\n      t = t.substring(o), e = e.substring(o), o = l(t, e);\n      var u = t.substring(t.length - o);\n      t = t.substring(0, t.length - o), e = e.substring(0, e.length - o);\n      var c = r(t, e);\n      return i && c.unshift([v, i]), u && c.push([v, u]), s(c), null != n && (c = f(c, n)), c = d(c);\n    }\n\n    function r(t, e) {\n      var r;\n      if (!t) return [[y, e]];\n      if (!e) return [[h, t]];\n      var i = t.length > e.length ? t : e,\n          a = t.length > e.length ? e : t,\n          l = i.indexOf(a);\n      if (-1 != l) return r = [[y, i.substring(0, l)], [v, a], [y, i.substring(l + a.length)]], t.length > e.length && (r[0][0] = r[2][0] = h), r;\n      if (1 == a.length) return [[h, t], [y, e]];\n      var s = u(t, e);\n\n      if (s) {\n        var c = s[0],\n            f = s[1],\n            d = s[2],\n            p = s[3],\n            b = s[4],\n            m = n(c, d),\n            g = n(f, p);\n        return m.concat([[v, b]], g);\n      }\n\n      return o(t, e);\n    }\n\n    function o(t, e) {\n      for (var n = t.length, r = e.length, o = Math.ceil((n + r) / 2), a = o, l = 2 * o, u = new Array(l), s = new Array(l), c = 0; c < l; c++) {\n        u[c] = -1, s[c] = -1;\n      }\n\n      u[a + 1] = 0, s[a + 1] = 0;\n\n      for (var f = n - r, d = f % 2 != 0, p = 0, v = 0, b = 0, m = 0, g = 0; g < o; g++) {\n        for (var _ = -g + p; _ <= g - v; _ += 2) {\n          var O,\n              E = a + _;\n          O = _ == -g || _ != g && u[E - 1] < u[E + 1] ? u[E + 1] : u[E - 1] + 1;\n\n          for (var N = O - _; O < n && N < r && t.charAt(O) == e.charAt(N);) {\n            O++, N++;\n          }\n\n          if (u[E] = O, O > n) v += 2;else if (N > r) p += 2;else if (d) {\n            var w = a + f - _;\n\n            if (w >= 0 && w < l && -1 != s[w]) {\n              var k = n - s[w];\n              if (O >= k) return i(t, e, O, N);\n            }\n          }\n        }\n\n        for (var j = -g + b; j <= g - m; j += 2) {\n          var k,\n              w = a + j;\n          k = j == -g || j != g && s[w - 1] < s[w + 1] ? s[w + 1] : s[w - 1] + 1;\n\n          for (var x = k - j; k < n && x < r && t.charAt(n - k - 1) == e.charAt(r - x - 1);) {\n            k++, x++;\n          }\n\n          if (s[w] = k, k > n) m += 2;else if (x > r) b += 2;else if (!d) {\n            var E = a + f - j;\n\n            if (E >= 0 && E < l && -1 != u[E]) {\n              var O = u[E],\n                  N = a + O - E;\n              if (k = n - k, O >= k) return i(t, e, O, N);\n            }\n          }\n        }\n      }\n\n      return [[h, t], [y, e]];\n    }\n\n    function i(t, e, r, o) {\n      var i = t.substring(0, r),\n          a = e.substring(0, o),\n          l = t.substring(r),\n          u = e.substring(o),\n          s = n(i, a),\n          c = n(l, u);\n      return s.concat(c);\n    }\n\n    function a(t, e) {\n      if (!t || !e || t.charAt(0) != e.charAt(0)) return 0;\n\n      for (var n = 0, r = Math.min(t.length, e.length), o = r, i = 0; n < o;) {\n        t.substring(i, o) == e.substring(i, o) ? (n = o, i = n) : r = o, o = Math.floor((r - n) / 2 + n);\n      }\n\n      return o;\n    }\n\n    function l(t, e) {\n      if (!t || !e || t.charAt(t.length - 1) != e.charAt(e.length - 1)) return 0;\n\n      for (var n = 0, r = Math.min(t.length, e.length), o = r, i = 0; n < o;) {\n        t.substring(t.length - o, t.length - i) == e.substring(e.length - o, e.length - i) ? (n = o, i = n) : r = o, o = Math.floor((r - n) / 2 + n);\n      }\n\n      return o;\n    }\n\n    function u(t, e) {\n      function n(t, e, n) {\n        for (var r, o, i, u, s = t.substring(n, n + Math.floor(t.length / 4)), c = -1, f = \"\"; -1 != (c = e.indexOf(s, c + 1));) {\n          var d = a(t.substring(n), e.substring(c)),\n              p = l(t.substring(0, n), e.substring(0, c));\n          f.length < p + d && (f = e.substring(c - p, c) + e.substring(c, c + d), r = t.substring(0, n - p), o = t.substring(n + d), i = e.substring(0, c - p), u = e.substring(c + d));\n        }\n\n        return 2 * f.length >= t.length ? [r, o, i, u, f] : null;\n      }\n\n      var r = t.length > e.length ? t : e,\n          o = t.length > e.length ? e : t;\n      if (r.length < 4 || 2 * o.length < r.length) return null;\n      var i,\n          u = n(r, o, Math.ceil(r.length / 4)),\n          s = n(r, o, Math.ceil(r.length / 2));\n      if (!u && !s) return null;\n      i = s ? u && u[4].length > s[4].length ? u : s : u;\n      var c, f, d, p;\n      return t.length > e.length ? (c = i[0], f = i[1], d = i[2], p = i[3]) : (d = i[0], p = i[1], c = i[2], f = i[3]), [c, f, d, p, i[4]];\n    }\n\n    function s(t) {\n      t.push([v, \"\"]);\n\n      for (var e, n = 0, r = 0, o = 0, i = \"\", u = \"\"; n < t.length;) {\n        switch (t[n][0]) {\n          case y:\n            o++, u += t[n][1], n++;\n            break;\n\n          case h:\n            r++, i += t[n][1], n++;\n            break;\n\n          case v:\n            r + o > 1 ? (0 !== r && 0 !== o && (e = a(u, i), 0 !== e && (n - r - o > 0 && t[n - r - o - 1][0] == v ? t[n - r - o - 1][1] += u.substring(0, e) : (t.splice(0, 0, [v, u.substring(0, e)]), n++), u = u.substring(e), i = i.substring(e)), 0 !== (e = l(u, i)) && (t[n][1] = u.substring(u.length - e) + t[n][1], u = u.substring(0, u.length - e), i = i.substring(0, i.length - e))), 0 === r ? t.splice(n - o, r + o, [y, u]) : 0 === o ? t.splice(n - r, r + o, [h, i]) : t.splice(n - r - o, r + o, [h, i], [y, u]), n = n - r - o + (r ? 1 : 0) + (o ? 1 : 0) + 1) : 0 !== n && t[n - 1][0] == v ? (t[n - 1][1] += t[n][1], t.splice(n, 1)) : n++, o = 0, r = 0, i = \"\", u = \"\";\n        }\n      }\n\n      \"\" === t[t.length - 1][1] && t.pop();\n      var c = !1;\n\n      for (n = 1; n < t.length - 1;) {\n        t[n - 1][0] == v && t[n + 1][0] == v && (t[n][1].substring(t[n][1].length - t[n - 1][1].length) == t[n - 1][1] ? (t[n][1] = t[n - 1][1] + t[n][1].substring(0, t[n][1].length - t[n - 1][1].length), t[n + 1][1] = t[n - 1][1] + t[n + 1][1], t.splice(n - 1, 1), c = !0) : t[n][1].substring(0, t[n + 1][1].length) == t[n + 1][1] && (t[n - 1][1] += t[n + 1][1], t[n][1] = t[n][1].substring(t[n + 1][1].length) + t[n + 1][1], t.splice(n + 1, 1), c = !0)), n++;\n      }\n\n      c && s(t);\n    }\n\n    function c(t, e) {\n      if (0 === e) return [v, t];\n\n      for (var n = 0, r = 0; r < t.length; r++) {\n        var o = t[r];\n\n        if (o[0] === h || o[0] === v) {\n          var i = n + o[1].length;\n          if (e === i) return [r + 1, t];\n\n          if (e < i) {\n            t = t.slice();\n            var a = e - n,\n                l = [o[0], o[1].slice(0, a)],\n                u = [o[0], o[1].slice(a)];\n            return t.splice(r, 1, l, u), [r + 1, t];\n          }\n\n          n = i;\n        }\n      }\n\n      throw new Error(\"cursor_pos is out of bounds!\");\n    }\n\n    function f(t, e) {\n      var n = c(t, e),\n          r = n[1],\n          o = n[0],\n          i = r[o],\n          a = r[o + 1];\n      if (null == i) return t;\n      if (i[0] !== v) return t;\n      if (null != a && i[1] + a[1] === a[1] + i[1]) return r.splice(o, 2, a, i), p(r, o, 2);\n\n      if (null != a && 0 === a[1].indexOf(i[1])) {\n        r.splice(o, 2, [a[0], i[1]], [0, i[1]]);\n        var l = a[1].slice(i[1].length);\n        return l.length > 0 && r.splice(o + 2, 0, [a[0], l]), p(r, o, 3);\n      }\n\n      return t;\n    }\n\n    function d(t) {\n      for (var e = !1, n = function n(t) {\n        return t.charCodeAt(0) >= 56320 && t.charCodeAt(0) <= 57343;\n      }, r = 2; r < t.length; r += 1) {\n        t[r - 2][0] === v && function (t) {\n          return t.charCodeAt(t.length - 1) >= 55296 && t.charCodeAt(t.length - 1) <= 56319;\n        }(t[r - 2][1]) && t[r - 1][0] === h && n(t[r - 1][1]) && t[r][0] === y && n(t[r][1]) && (e = !0, t[r - 1][1] = t[r - 2][1].slice(-1) + t[r - 1][1], t[r][1] = t[r - 2][1].slice(-1) + t[r][1], t[r - 2][1] = t[r - 2][1].slice(0, -1));\n      }\n\n      if (!e) return t;\n\n      for (var o = [], r = 0; r < t.length; r += 1) {\n        t[r][1].length > 0 && o.push(t[r]);\n      }\n\n      return o;\n    }\n\n    function p(t, e, n) {\n      for (var r = e + n - 1; r >= 0 && r >= e - 1; r--) {\n        if (r + 1 < t.length) {\n          var o = t[r],\n              i = t[r + 1];\n          o[0] === i[1] && t.splice(r, 2, [o[0], o[1] + i[1]]);\n        }\n      }\n\n      return t;\n    }\n\n    var h = -1,\n        y = 1,\n        v = 0,\n        b = n;\n    b.INSERT = y, b.DELETE = h, b.EQUAL = v, t.exports = b;\n  }, function (t, e) {\n    function n(t) {\n      var e = [];\n\n      for (var n in t) {\n        e.push(n);\n      }\n\n      return e;\n    }\n\n    e = t.exports = \"function\" == typeof Object.keys ? Object.keys : n, e.shim = n;\n  }, function (t, e) {\n    function n(t) {\n      return \"[object Arguments]\" == Object.prototype.toString.call(t);\n    }\n\n    function r(t) {\n      return t && \"object\" == _typeof(t) && \"number\" == typeof t.length && Object.prototype.hasOwnProperty.call(t, \"callee\") && !Object.prototype.propertyIsEnumerable.call(t, \"callee\") || !1;\n    }\n\n    var o = \"[object Arguments]\" == function () {\n      return Object.prototype.toString.call(arguments);\n    }();\n\n    e = t.exports = o ? n : r, e.supported = n, e.unsupported = r;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      return Object.keys(e).reduce(function (n, r) {\n        return null == t[r] ? n : (e[r] === t[r] ? n[r] = e[r] : Array.isArray(e[r]) ? e[r].indexOf(t[r]) < 0 && (n[r] = e[r].concat([t[r]])) : n[r] = [e[r], t[r]], n);\n      }, {});\n    }\n\n    function l(t) {\n      return t.reduce(function (t, e) {\n        if (1 === e.insert) {\n          var n = (0, j.default)(e.attributes);\n          return delete n.image, t.insert({\n            image: e.attributes.image\n          }, n);\n        }\n\n        if (null == e.attributes || !0 !== e.attributes.list && !0 !== e.attributes.bullet || (e = (0, j.default)(e), e.attributes.list ? e.attributes.list = \"ordered\" : (e.attributes.list = \"bullet\", delete e.attributes.bullet)), \"string\" == typeof e.insert) {\n          var r = e.insert.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n          return t.insert(r, e.attributes);\n        }\n\n        return t.push(e);\n      }, new d.default());\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var u = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (t) {\n      return _typeof(t);\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : _typeof(t);\n    },\n        s = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        c = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        f = n(5),\n        d = r(f),\n        p = n(19),\n        h = r(p),\n        y = n(0),\n        v = r(y),\n        b = n(12),\n        m = r(b),\n        g = n(27),\n        _ = r(g),\n        O = n(2),\n        E = r(O),\n        N = n(14),\n        w = r(N),\n        k = n(20),\n        j = r(k),\n        x = n(11),\n        A = r(x),\n        T = n(3),\n        S = r(T),\n        P = /^[ -~]*$/,\n        C = function () {\n      function t(e) {\n        i(this, t), this.scroll = e, this.delta = this.getDelta();\n      }\n\n      return c(t, [{\n        key: \"applyDelta\",\n        value: function value(t) {\n          var e = this,\n              n = !1;\n          this.scroll.update();\n          var r = this.scroll.length();\n          return this.scroll.batchStart(), t = l(t), t.reduce(function (t, o) {\n            var i = o.retain || o.delete || o.insert.length || 1,\n                a = o.attributes || {};\n\n            if (null != o.insert) {\n              if (\"string\" == typeof o.insert) {\n                var l = o.insert;\n                l.endsWith(\"\\n\") && n && (n = !1, l = l.slice(0, -1)), t >= r && !l.endsWith(\"\\n\") && (n = !0), e.scroll.insertAt(t, l);\n                var c = e.scroll.line(t),\n                    f = s(c, 2),\n                    d = f[0],\n                    p = f[1],\n                    y = (0, S.default)({}, (0, O.bubbleFormats)(d));\n\n                if (d instanceof E.default) {\n                  var b = d.descendant(v.default.Leaf, p),\n                      m = s(b, 1),\n                      g = m[0];\n                  y = (0, S.default)(y, (0, O.bubbleFormats)(g));\n                }\n\n                a = h.default.attributes.diff(y, a) || {};\n              } else if (\"object\" === u(o.insert)) {\n                var _ = Object.keys(o.insert)[0];\n                if (null == _) return t;\n                e.scroll.insertAt(t, _, o.insert[_]);\n              }\n\n              r += i;\n            }\n\n            return Object.keys(a).forEach(function (n) {\n              e.scroll.formatAt(t, i, n, a[n]);\n            }), t + i;\n          }, 0), t.reduce(function (t, n) {\n            return \"number\" == typeof n.delete ? (e.scroll.deleteAt(t, n.delete), t) : t + (n.retain || n.insert.length || 1);\n          }, 0), this.scroll.batchEnd(), this.update(t);\n        }\n      }, {\n        key: \"deleteText\",\n        value: function value(t, e) {\n          return this.scroll.deleteAt(t, e), this.update(new d.default().retain(t).delete(e));\n        }\n      }, {\n        key: \"formatLine\",\n        value: function value(t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n          return this.scroll.update(), Object.keys(r).forEach(function (o) {\n            if (null == n.scroll.whitelist || n.scroll.whitelist[o]) {\n              var i = n.scroll.lines(t, Math.max(e, 1)),\n                  a = e;\n              i.forEach(function (e) {\n                var i = e.length();\n\n                if (e instanceof m.default) {\n                  var l = t - e.offset(n.scroll),\n                      u = e.newlineIndex(l + a) - l + 1;\n                  e.formatAt(l, u, o, r[o]);\n                } else e.format(o, r[o]);\n\n                a -= i;\n              });\n            }\n          }), this.scroll.optimize(), this.update(new d.default().retain(t).retain(e, (0, j.default)(r)));\n        }\n      }, {\n        key: \"formatText\",\n        value: function value(t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n          return Object.keys(r).forEach(function (o) {\n            n.scroll.formatAt(t, e, o, r[o]);\n          }), this.update(new d.default().retain(t).retain(e, (0, j.default)(r)));\n        }\n      }, {\n        key: \"getContents\",\n        value: function value(t, e) {\n          return this.delta.slice(t, t + e);\n        }\n      }, {\n        key: \"getDelta\",\n        value: function value() {\n          return this.scroll.lines().reduce(function (t, e) {\n            return t.concat(e.delta());\n          }, new d.default());\n        }\n      }, {\n        key: \"getFormat\",\n        value: function value(t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n              n = [],\n              r = [];\n          0 === e ? this.scroll.path(t).forEach(function (t) {\n            var e = s(t, 1),\n                o = e[0];\n            o instanceof E.default ? n.push(o) : o instanceof v.default.Leaf && r.push(o);\n          }) : (n = this.scroll.lines(t, e), r = this.scroll.descendants(v.default.Leaf, t, e));\n          var o = [n, r].map(function (t) {\n            if (0 === t.length) return {};\n\n            for (var e = (0, O.bubbleFormats)(t.shift()); Object.keys(e).length > 0;) {\n              var n = t.shift();\n              if (null == n) return e;\n              e = a((0, O.bubbleFormats)(n), e);\n            }\n\n            return e;\n          });\n          return S.default.apply(S.default, o);\n        }\n      }, {\n        key: \"getText\",\n        value: function value(t, e) {\n          return this.getContents(t, e).filter(function (t) {\n            return \"string\" == typeof t.insert;\n          }).map(function (t) {\n            return t.insert;\n          }).join(\"\");\n        }\n      }, {\n        key: \"insertEmbed\",\n        value: function value(t, e, n) {\n          return this.scroll.insertAt(t, e, n), this.update(new d.default().retain(t).insert(o({}, e, n)));\n        }\n      }, {\n        key: \"insertText\",\n        value: function value(t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n          return e = e.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\"), this.scroll.insertAt(t, e), Object.keys(r).forEach(function (o) {\n            n.scroll.formatAt(t, e.length, o, r[o]);\n          }), this.update(new d.default().retain(t).insert(e, (0, j.default)(r)));\n        }\n      }, {\n        key: \"isBlank\",\n        value: function value() {\n          if (0 == this.scroll.children.length) return !0;\n          if (this.scroll.children.length > 1) return !1;\n          var t = this.scroll.children.head;\n          return t.statics.blotName === E.default.blotName && !(t.children.length > 1) && t.children.head instanceof w.default;\n        }\n      }, {\n        key: \"removeFormat\",\n        value: function value(t, e) {\n          var n = this.getText(t, e),\n              r = this.scroll.line(t + e),\n              o = s(r, 2),\n              i = o[0],\n              a = o[1],\n              l = 0,\n              u = new d.default();\n          null != i && (l = i instanceof m.default ? i.newlineIndex(a) - a + 1 : i.length() - a, u = i.delta().slice(a, a + l - 1).insert(\"\\n\"));\n          var c = this.getContents(t, e + l),\n              f = c.diff(new d.default().insert(n).concat(u)),\n              p = new d.default().retain(t).concat(f);\n          return this.applyDelta(p);\n        }\n      }, {\n        key: \"update\",\n        value: function value(t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,\n              r = this.delta;\n\n          if (1 === e.length && \"characterData\" === e[0].type && e[0].target.data.match(P) && v.default.find(e[0].target)) {\n            var o = v.default.find(e[0].target),\n                i = (0, O.bubbleFormats)(o),\n                a = o.offset(this.scroll),\n                l = e[0].oldValue.replace(_.default.CONTENTS, \"\"),\n                u = new d.default().insert(l),\n                s = new d.default().insert(o.value());\n            t = new d.default().retain(a).concat(u.diff(s, n)).reduce(function (t, e) {\n              return e.insert ? t.insert(e.insert, i) : t.push(e);\n            }, new d.default()), this.delta = r.compose(t);\n          } else this.delta = this.getDelta(), t && (0, A.default)(r.compose(t), this.delta) || (t = r.diff(this.delta, n));\n\n          return t;\n        }\n      }]), t;\n    }();\n\n    e.default = C;\n  }, function (t, e) {\n    \"use strict\";\n\n    function n() {}\n\n    function r(t, e, n) {\n      this.fn = t, this.context = e, this.once = n || !1;\n    }\n\n    function o() {\n      this._events = new n(), this._eventsCount = 0;\n    }\n\n    var i = Object.prototype.hasOwnProperty,\n        a = \"~\";\n    Object.create && (n.prototype = Object.create(null), new n().__proto__ || (a = !1)), o.prototype.eventNames = function () {\n      var t,\n          e,\n          n = [];\n      if (0 === this._eventsCount) return n;\n\n      for (e in t = this._events) {\n        i.call(t, e) && n.push(a ? e.slice(1) : e);\n      }\n\n      return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n;\n    }, o.prototype.listeners = function (t, e) {\n      var n = a ? a + t : t,\n          r = this._events[n];\n      if (e) return !!r;\n      if (!r) return [];\n      if (r.fn) return [r.fn];\n\n      for (var o = 0, i = r.length, l = new Array(i); o < i; o++) {\n        l[o] = r[o].fn;\n      }\n\n      return l;\n    }, o.prototype.emit = function (t, e, n, r, o, i) {\n      var l = a ? a + t : t;\n      if (!this._events[l]) return !1;\n      var u,\n          s,\n          c = this._events[l],\n          f = arguments.length;\n\n      if (c.fn) {\n        switch (c.once && this.removeListener(t, c.fn, void 0, !0), f) {\n          case 1:\n            return c.fn.call(c.context), !0;\n\n          case 2:\n            return c.fn.call(c.context, e), !0;\n\n          case 3:\n            return c.fn.call(c.context, e, n), !0;\n\n          case 4:\n            return c.fn.call(c.context, e, n, r), !0;\n\n          case 5:\n            return c.fn.call(c.context, e, n, r, o), !0;\n\n          case 6:\n            return c.fn.call(c.context, e, n, r, o, i), !0;\n        }\n\n        for (s = 1, u = new Array(f - 1); s < f; s++) {\n          u[s - 1] = arguments[s];\n        }\n\n        c.fn.apply(c.context, u);\n      } else {\n        var d,\n            p = c.length;\n\n        for (s = 0; s < p; s++) {\n          switch (c[s].once && this.removeListener(t, c[s].fn, void 0, !0), f) {\n            case 1:\n              c[s].fn.call(c[s].context);\n              break;\n\n            case 2:\n              c[s].fn.call(c[s].context, e);\n              break;\n\n            case 3:\n              c[s].fn.call(c[s].context, e, n);\n              break;\n\n            case 4:\n              c[s].fn.call(c[s].context, e, n, r);\n              break;\n\n            default:\n              if (!u) for (d = 1, u = new Array(f - 1); d < f; d++) {\n                u[d - 1] = arguments[d];\n              }\n              c[s].fn.apply(c[s].context, u);\n          }\n        }\n      }\n\n      return !0;\n    }, o.prototype.on = function (t, e, n) {\n      var o = new r(e, n || this),\n          i = a ? a + t : t;\n      return this._events[i] ? this._events[i].fn ? this._events[i] = [this._events[i], o] : this._events[i].push(o) : (this._events[i] = o, this._eventsCount++), this;\n    }, o.prototype.once = function (t, e, n) {\n      var o = new r(e, n || this, !0),\n          i = a ? a + t : t;\n      return this._events[i] ? this._events[i].fn ? this._events[i] = [this._events[i], o] : this._events[i].push(o) : (this._events[i] = o, this._eventsCount++), this;\n    }, o.prototype.removeListener = function (t, e, r, o) {\n      var i = a ? a + t : t;\n      if (!this._events[i]) return this;\n      if (!e) return 0 == --this._eventsCount ? this._events = new n() : delete this._events[i], this;\n      var l = this._events[i];\n      if (l.fn) l.fn !== e || o && !l.once || r && l.context !== r || (0 == --this._eventsCount ? this._events = new n() : delete this._events[i]);else {\n        for (var u = 0, s = [], c = l.length; u < c; u++) {\n          (l[u].fn !== e || o && !l[u].once || r && l[u].context !== r) && s.push(l[u]);\n        }\n\n        s.length ? this._events[i] = 1 === s.length ? s[0] : s : 0 == --this._eventsCount ? this._events = new n() : delete this._events[i];\n      }\n      return this;\n    }, o.prototype.removeAllListeners = function (t) {\n      var e;\n      return t ? (e = a ? a + t : t, this._events[e] && (0 == --this._eventsCount ? this._events = new n() : delete this._events[e])) : (this._events = new n(), this._eventsCount = 0), this;\n    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prototype.setMaxListeners = function () {\n      return this;\n    }, o.prefixed = a, o.EventEmitter = o, void 0 !== t && (t.exports = o);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function l(t) {\n      return t instanceof v.default || t instanceof y.BlockEmbed;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var u = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        s = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        c = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        f = n(0),\n        d = r(f),\n        p = n(13),\n        h = r(p),\n        y = n(2),\n        v = r(y),\n        b = n(14),\n        m = r(b),\n        g = n(12),\n        _ = r(g),\n        O = n(21),\n        E = r(O),\n        N = function (t) {\n      function e(t, n) {\n        o(this, e);\n        var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));\n        return r.emitter = n.emitter, Array.isArray(n.whitelist) && (r.whitelist = n.whitelist.reduce(function (t, e) {\n          return t[e] = !0, t;\n        }, {})), r.optimize(), r.enable(), r;\n      }\n\n      return a(e, t), s(e, [{\n        key: \"batchStart\",\n        value: function value() {\n          this.batch = !0;\n        }\n      }, {\n        key: \"batchEnd\",\n        value: function value() {\n          this.batch = !1, this.optimize();\n        }\n      }, {\n        key: \"deleteAt\",\n        value: function value(t, n) {\n          var r = this.line(t),\n              o = u(r, 2),\n              i = o[0],\n              a = o[1],\n              l = this.line(t + n),\n              s = u(l, 1),\n              f = s[0];\n\n          if (c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"deleteAt\", this).call(this, t, n), null != f && i !== f && a > 0) {\n            if (i instanceof y.BlockEmbed || f instanceof y.BlockEmbed) return void this.optimize();\n\n            if (i instanceof _.default) {\n              var d = i.newlineIndex(i.length(), !0);\n              if (d > -1 && (i = i.split(d + 1)) === f) return void this.optimize();\n            } else if (f instanceof _.default) {\n              var p = f.newlineIndex(0);\n              p > -1 && f.split(p + 1);\n            }\n\n            var h = f.children.head instanceof m.default ? null : f.children.head;\n            i.moveChildren(f, h), i.remove();\n          }\n\n          this.optimize();\n        }\n      }, {\n        key: \"enable\",\n        value: function value() {\n          var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n          this.domNode.setAttribute(\"contenteditable\", t);\n        }\n      }, {\n        key: \"formatAt\",\n        value: function value(t, n, r, o) {\n          (null == this.whitelist || this.whitelist[r]) && (c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"formatAt\", this).call(this, t, n, r, o), this.optimize());\n        }\n      }, {\n        key: \"insertAt\",\n        value: function value(t, n, r) {\n          if (null == r || null == this.whitelist || this.whitelist[n]) {\n            if (t >= this.length()) {\n              if (null == r || null == d.default.query(n, d.default.Scope.BLOCK)) {\n                var o = d.default.create(this.statics.defaultChild);\n                this.appendChild(o), null == r && n.endsWith(\"\\n\") && (n = n.slice(0, -1)), o.insertAt(0, n, r);\n              } else {\n                var i = d.default.create(n, r);\n                this.appendChild(i);\n              }\n            } else c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertAt\", this).call(this, t, n, r);\n            this.optimize();\n          }\n        }\n      }, {\n        key: \"insertBefore\",\n        value: function value(t, n) {\n          if (t.statics.scope === d.default.Scope.INLINE_BLOT) {\n            var r = d.default.create(this.statics.defaultChild);\n            r.appendChild(t), t = r;\n          }\n\n          c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertBefore\", this).call(this, t, n);\n        }\n      }, {\n        key: \"leaf\",\n        value: function value(t) {\n          return this.path(t).pop() || [null, -1];\n        }\n      }, {\n        key: \"line\",\n        value: function value(t) {\n          return t === this.length() ? this.line(t - 1) : this.descendant(l, t);\n        }\n      }, {\n        key: \"lines\",\n        value: function value() {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;\n          return function t(e, n, r) {\n            var o = [],\n                i = r;\n            return e.children.forEachAt(n, r, function (e, n, r) {\n              l(e) ? o.push(e) : e instanceof d.default.Container && (o = o.concat(t(e, n, i))), i -= r;\n            }), o;\n          }(this, t, e);\n        }\n      }, {\n        key: \"optimize\",\n        value: function value() {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n          !0 !== this.batch && (c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t, n), t.length > 0 && this.emitter.emit(h.default.events.SCROLL_OPTIMIZE, t, n));\n        }\n      }, {\n        key: \"path\",\n        value: function value(t) {\n          return c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"path\", this).call(this, t).slice(1);\n        }\n      }, {\n        key: \"update\",\n        value: function value(t) {\n          if (!0 !== this.batch) {\n            var n = h.default.sources.USER;\n            \"string\" == typeof t && (n = t), Array.isArray(t) || (t = this.observer.takeRecords()), t.length > 0 && this.emitter.emit(h.default.events.SCROLL_BEFORE_UPDATE, n, t), c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"update\", this).call(this, t.concat([])), t.length > 0 && this.emitter.emit(h.default.events.SCROLL_UPDATE, n, t);\n          }\n        }\n      }]), e;\n    }(d.default.Scroll);\n\n    N.blotName = \"scroll\", N.className = \"ql-editor\", N.tagName = \"DIV\", N.defaultChild = \"block\", N.allowedChildren = [v.default, y.BlockEmbed, E.default], e.default = N;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function l(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function u(t, e, n) {\n      return \"object\" === (void 0 === e ? \"undefined\" : E(e)) ? Object.keys(e).reduce(function (t, n) {\n        return u(t, n, e[n]);\n      }, t) : t.reduce(function (t, r) {\n        return r.attributes && r.attributes[e] ? t.push(r) : t.insert(r.insert, (0, j.default)({}, o({}, e, n), r.attributes));\n      }, new A.default());\n    }\n\n    function s(t) {\n      if (t.nodeType !== Node.ELEMENT_NODE) return {};\n      return t[\"__ql-computed-style\"] || (t[\"__ql-computed-style\"] = window.getComputedStyle(t));\n    }\n\n    function c(t, e) {\n      for (var n = \"\", r = t.ops.length - 1; r >= 0 && n.length < e.length; --r) {\n        var o = t.ops[r];\n        if (\"string\" != typeof o.insert) break;\n        n = o.insert + n;\n      }\n\n      return n.slice(-1 * e.length) === e;\n    }\n\n    function f(t) {\n      return 0 !== t.childNodes.length && [\"block\", \"list-item\"].indexOf(s(t).display) > -1;\n    }\n\n    function d(t, e, n) {\n      return t.nodeType === t.TEXT_NODE ? n.reduce(function (e, n) {\n        return n(t, e);\n      }, new A.default()) : t.nodeType === t.ELEMENT_NODE ? [].reduce.call(t.childNodes || [], function (r, o) {\n        var i = d(o, e, n);\n        return o.nodeType === t.ELEMENT_NODE && (i = e.reduce(function (t, e) {\n          return e(o, t);\n        }, i), i = (o[G] || []).reduce(function (t, e) {\n          return e(o, t);\n        }, i)), r.concat(i);\n      }, new A.default()) : new A.default();\n    }\n\n    function p(t, e, n) {\n      return u(n, t, !0);\n    }\n\n    function h(t, e) {\n      var n = S.default.Attributor.Attribute.keys(t),\n          r = S.default.Attributor.Class.keys(t),\n          o = S.default.Attributor.Style.keys(t),\n          i = {};\n      return n.concat(r).concat(o).forEach(function (e) {\n        var n = S.default.query(e, S.default.Scope.ATTRIBUTE);\n        null != n && (i[n.attrName] = n.value(t), i[n.attrName]) || (n = V[e], null == n || n.attrName !== e && n.keyName !== e || (i[n.attrName] = n.value(t) || void 0), null == (n = X[e]) || n.attrName !== e && n.keyName !== e || (n = X[e], i[n.attrName] = n.value(t) || void 0));\n      }), Object.keys(i).length > 0 && (e = u(e, i)), e;\n    }\n\n    function y(t, e) {\n      var n = S.default.query(t);\n      if (null == n) return e;\n\n      if (n.prototype instanceof S.default.Embed) {\n        var r = {},\n            o = n.value(t);\n        null != o && (r[n.blotName] = o, e = new A.default().insert(r, n.formats(t)));\n      } else \"function\" == typeof n.formats && (e = u(e, n.blotName, n.formats(t)));\n\n      return e;\n    }\n\n    function v(t, e) {\n      return c(e, \"\\n\") || e.insert(\"\\n\"), e;\n    }\n\n    function b() {\n      return new A.default();\n    }\n\n    function m(t, e) {\n      var n = S.default.query(t);\n      if (null == n || \"list-item\" !== n.blotName || !c(e, \"\\n\")) return e;\n\n      for (var r = -1, o = t.parentNode; !o.classList.contains(\"ql-clipboard\");) {\n        \"list\" === (S.default.query(o) || {}).blotName && (r += 1), o = o.parentNode;\n      }\n\n      return r <= 0 ? e : e.compose(new A.default().retain(e.length() - 1).retain(1, {\n        indent: r\n      }));\n    }\n\n    function g(t, e) {\n      return c(e, \"\\n\") || (f(t) || e.length() > 0 && t.nextSibling && f(t.nextSibling)) && e.insert(\"\\n\"), e;\n    }\n\n    function _(t, e) {\n      var n = {},\n          r = t.style || {};\n      return r.fontStyle && \"italic\" === s(t).fontStyle && (n.italic = !0), r.fontWeight && (s(t).fontWeight.startsWith(\"bold\") || parseInt(s(t).fontWeight) >= 700) && (n.bold = !0), Object.keys(n).length > 0 && (e = u(e, n)), parseFloat(r.textIndent || 0) > 0 && (e = new A.default().insert(\"\\t\").concat(e)), e;\n    }\n\n    function O(t, e) {\n      var n = t.data;\n      if (\"O:P\" === t.parentNode.tagName) return e.insert(n.trim());\n      if (0 === n.trim().length && t.parentNode.classList.contains(\"ql-clipboard\")) return e;\n\n      if (!s(t.parentNode).whiteSpace.startsWith(\"pre\")) {\n        var r = function r(t, e) {\n          return e = e.replace(/[^\\u00a0]/g, \"\"), e.length < 1 && t ? \" \" : e;\n        };\n\n        n = n.replace(/\\r\\n/g, \" \").replace(/\\n/g, \" \"), n = n.replace(/\\s\\s+/g, r.bind(r, !0)), (null == t.previousSibling && f(t.parentNode) || null != t.previousSibling && f(t.previousSibling)) && (n = n.replace(/^\\s+/, r.bind(r, !1))), (null == t.nextSibling && f(t.parentNode) || null != t.nextSibling && f(t.nextSibling)) && (n = n.replace(/\\s+$/, r.bind(r, !1)));\n      }\n\n      return e.insert(n);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.matchText = e.matchNewline = e.matchBlot = e.matchAttributor = e.default = void 0;\n\n    var E = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (t) {\n      return _typeof(t);\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : _typeof(t);\n    },\n        N = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        w = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        k = n(3),\n        j = r(k),\n        x = n(5),\n        A = r(x),\n        T = n(0),\n        S = r(T),\n        P = n(6),\n        C = r(P),\n        L = n(8),\n        R = r(L),\n        q = n(9),\n        I = r(q),\n        M = n(30),\n        B = n(31),\n        D = n(12),\n        U = r(D),\n        F = n(22),\n        K = n(32),\n        z = n(33),\n        H = n(34),\n        W = (0, R.default)(\"quill:clipboard\"),\n        G = \"__ql-matcher\",\n        Y = [[Node.TEXT_NODE, O], [Node.TEXT_NODE, g], [\"br\", v], [Node.ELEMENT_NODE, g], [Node.ELEMENT_NODE, y], [Node.ELEMENT_NODE, h], [Node.ELEMENT_NODE, _], [\"li\", m], [\"b\", p.bind(p, \"bold\")], [\"i\", p.bind(p, \"italic\")], [\"style\", b]],\n        V = [M.AlignAttribute, K.DirectionAttribute].reduce(function (t, e) {\n      return t[e.keyName] = e, t;\n    }, {}),\n        X = [M.AlignStyle, B.BackgroundStyle, F.ColorStyle, K.DirectionStyle, z.FontStyle, H.SizeStyle].reduce(function (t, e) {\n      return t[e.keyName] = e, t;\n    }, {}),\n        $ = function (t) {\n      function e(t, n) {\n        i(this, e);\n        var r = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));\n        return r.quill.root.addEventListener(\"paste\", r.onPaste.bind(r)), r.container = r.quill.addContainer(\"ql-clipboard\"), r.container.setAttribute(\"contenteditable\", !0), r.container.setAttribute(\"tabindex\", -1), r.matchers = [], Y.concat(r.options.matchers).forEach(function (t) {\n          var e = N(t, 2),\n              n = e[0],\n              o = e[1];\n          r.addMatcher(n, o);\n        }), r;\n      }\n\n      return l(e, t), w(e, [{\n        key: \"addMatcher\",\n        value: function value(t, e) {\n          this.matchers.push([t, e]);\n        }\n      }, {\n        key: \"convert\",\n        value: function value(t) {\n          if (\"string\" == typeof t) return this.container.innerHTML = t.replace(/\\>\\r?\\n +\\</g, \"><\"), this.convert();\n          var e = this.quill.getFormat(this.quill.selection.savedRange.index);\n\n          if (e[U.default.blotName]) {\n            var n = this.container.innerText;\n            return this.container.innerHTML = \"\", new A.default().insert(n, o({}, U.default.blotName, e[U.default.blotName]));\n          }\n\n          var r = this.prepareMatching(),\n              i = N(r, 2),\n              a = i[0],\n              l = i[1],\n              u = d(this.container, a, l);\n          return c(u, \"\\n\") && null == u.ops[u.ops.length - 1].attributes && (u = u.compose(new A.default().retain(u.length() - 1).delete(1))), W.log(\"convert\", this.container.innerHTML, u), this.container.innerHTML = \"\", u;\n        }\n      }, {\n        key: \"dangerouslyPasteHTML\",\n        value: function value(t, e) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : C.default.sources.API;\n          if (\"string\" == typeof t) this.quill.setContents(this.convert(t), e), this.quill.setSelection(0, C.default.sources.SILENT);else {\n            var r = this.convert(e);\n            this.quill.updateContents(new A.default().retain(t).concat(r), n), this.quill.setSelection(t + r.length(), C.default.sources.SILENT);\n          }\n        }\n      }, {\n        key: \"onPaste\",\n        value: function value(t) {\n          var e = this;\n\n          if (!t.defaultPrevented && this.quill.isEnabled()) {\n            var n = this.quill.getSelection(),\n                r = new A.default().retain(n.index),\n                o = this.quill.scrollingContainer.scrollTop;\n            this.container.focus(), this.quill.selection.update(C.default.sources.SILENT), setTimeout(function () {\n              r = r.concat(e.convert()).delete(n.length), e.quill.updateContents(r, C.default.sources.USER), e.quill.setSelection(r.length() - n.length, C.default.sources.SILENT), e.quill.scrollingContainer.scrollTop = o, e.quill.focus();\n            }, 1);\n          }\n        }\n      }, {\n        key: \"prepareMatching\",\n        value: function value() {\n          var t = this,\n              e = [],\n              n = [];\n          return this.matchers.forEach(function (r) {\n            var o = N(r, 2),\n                i = o[0],\n                a = o[1];\n\n            switch (i) {\n              case Node.TEXT_NODE:\n                n.push(a);\n                break;\n\n              case Node.ELEMENT_NODE:\n                e.push(a);\n                break;\n\n              default:\n                [].forEach.call(t.container.querySelectorAll(i), function (t) {\n                  t[G] = t[G] || [], t[G].push(a);\n                });\n            }\n          }), [e, n];\n        }\n      }]), e;\n    }(I.default);\n\n    $.DEFAULTS = {\n      matchers: [],\n      matchVisual: !1\n    }, e.default = $, e.matchAttributor = h, e.matchBlot = y, e.matchNewline = g, e.matchText = O;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function l(t) {\n      var e = t.ops[t.ops.length - 1];\n      return null != e && (null != e.insert ? \"string\" == typeof e.insert && e.insert.endsWith(\"\\n\") : null != e.attributes && Object.keys(e.attributes).some(function (t) {\n        return null != f.default.query(t, f.default.Scope.BLOCK);\n      }));\n    }\n\n    function u(t) {\n      var e = t.reduce(function (t, e) {\n        return t += e.delete || 0;\n      }, 0),\n          n = t.length() - e;\n      return l(t) && (n -= 1), n;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.getLastChangeIndex = e.default = void 0;\n\n    var s = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        c = n(0),\n        f = r(c),\n        d = n(6),\n        p = r(d),\n        h = n(9),\n        y = r(h),\n        v = function (t) {\n      function e(t, n) {\n        o(this, e);\n        var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));\n        return r.lastRecorded = 0, r.ignoreChange = !1, r.clear(), r.quill.on(p.default.events.EDITOR_CHANGE, function (t, e, n, o) {\n          t !== p.default.events.TEXT_CHANGE || r.ignoreChange || (r.options.userOnly && o !== p.default.sources.USER ? r.transform(e) : r.record(e, n));\n        }), r.quill.keyboard.addBinding({\n          key: \"Z\",\n          shortKey: !0\n        }, r.undo.bind(r)), r.quill.keyboard.addBinding({\n          key: \"Z\",\n          shortKey: !0,\n          shiftKey: !0\n        }, r.redo.bind(r)), /Win/i.test(navigator.platform) && r.quill.keyboard.addBinding({\n          key: \"Y\",\n          shortKey: !0\n        }, r.redo.bind(r)), r;\n      }\n\n      return a(e, t), s(e, [{\n        key: \"change\",\n        value: function value(t, e) {\n          if (0 !== this.stack[t].length) {\n            var n = this.stack[t].pop();\n            this.stack[e].push(n), this.lastRecorded = 0, this.ignoreChange = !0, this.quill.updateContents(n[t], p.default.sources.USER), this.ignoreChange = !1;\n            var r = u(n[t]);\n            this.quill.setSelection(r);\n          }\n        }\n      }, {\n        key: \"clear\",\n        value: function value() {\n          this.stack = {\n            undo: [],\n            redo: []\n          };\n        }\n      }, {\n        key: \"cutoff\",\n        value: function value() {\n          this.lastRecorded = 0;\n        }\n      }, {\n        key: \"record\",\n        value: function value(t, e) {\n          if (0 !== t.ops.length) {\n            this.stack.redo = [];\n            var n = this.quill.getContents().diff(e),\n                r = Date.now();\n\n            if (this.lastRecorded + this.options.delay > r && this.stack.undo.length > 0) {\n              var o = this.stack.undo.pop();\n              n = n.compose(o.undo), t = o.redo.compose(t);\n            } else this.lastRecorded = r;\n\n            this.stack.undo.push({\n              redo: t,\n              undo: n\n            }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift();\n          }\n        }\n      }, {\n        key: \"redo\",\n        value: function value() {\n          this.change(\"redo\", \"undo\");\n        }\n      }, {\n        key: \"transform\",\n        value: function value(t) {\n          this.stack.undo.forEach(function (e) {\n            e.undo = t.transform(e.undo, !0), e.redo = t.transform(e.redo, !0);\n          }), this.stack.redo.forEach(function (e) {\n            e.undo = t.transform(e.undo, !0), e.redo = t.transform(e.redo, !0);\n          });\n        }\n      }, {\n        key: \"undo\",\n        value: function value() {\n          this.change(\"undo\", \"redo\");\n        }\n      }]), e;\n    }(y.default);\n\n    v.DEFAULTS = {\n      delay: 1e3,\n      maxStack: 100,\n      userOnly: !1\n    }, e.default = v, e.getLastChangeIndex = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.IndentClass = void 0;\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"add\",\n        value: function value(t, n) {\n          if (\"+1\" === n || \"-1\" === n) {\n            var r = this.value(t) || 0;\n            n = \"+1\" === n ? r + 1 : r - 1;\n          }\n\n          return 0 === n ? (this.remove(t), !0) : l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"add\", this).call(this, t, n);\n        }\n      }, {\n        key: \"canAdd\",\n        value: function value(t, n) {\n          return l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"canAdd\", this).call(this, t, n) || l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"canAdd\", this).call(this, t, parseInt(n));\n        }\n      }, {\n        key: \"value\",\n        value: function value(t) {\n          return parseInt(l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"value\", this).call(this, t)) || void 0;\n        }\n      }]), e;\n    }(s.default.Attributor.Class),\n        f = new c(\"indent\", \"ql-indent\", {\n      scope: s.default.Scope.BLOCK,\n      whitelist: [1, 2, 3, 4, 5, 6, 7, 8]\n    });\n\n    e.IndentClass = f;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(2),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default);\n\n    u.blotName = \"blockquote\", u.tagName = \"blockquote\", e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = n(2),\n        u = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(l),\n        s = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, null, [{\n        key: \"formats\",\n        value: function value(t) {\n          return this.tagName.indexOf(t.tagName) + 1;\n        }\n      }]), e;\n    }(u.default);\n\n    s.blotName = \"header\", s.tagName = [\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\"], e.default = s;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function l(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.ListItem = void 0;\n\n    var u = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        s = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        c = n(0),\n        f = r(c),\n        d = n(2),\n        p = r(d),\n        h = n(21),\n        y = r(h),\n        v = function (t) {\n      function e() {\n        return i(this, e), a(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return l(e, t), u(e, [{\n        key: \"format\",\n        value: function value(t, n) {\n          t !== b.blotName || n ? s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n) : this.replaceWith(f.default.create(this.statics.scope));\n        }\n      }, {\n        key: \"remove\",\n        value: function value() {\n          null == this.prev && null == this.next ? this.parent.remove() : s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"remove\", this).call(this);\n        }\n      }, {\n        key: \"replaceWith\",\n        value: function value(t, n) {\n          return this.parent.isolate(this.offset(this.parent), this.length()), t === this.parent.statics.blotName ? (this.parent.replaceWith(t, n), this) : (this.parent.unwrap(), s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"replaceWith\", this).call(this, t, n));\n        }\n      }], [{\n        key: \"formats\",\n        value: function value(t) {\n          return t.tagName === this.tagName ? void 0 : s(e.__proto__ || Object.getPrototypeOf(e), \"formats\", this).call(this, t);\n        }\n      }]), e;\n    }(p.default);\n\n    v.blotName = \"list-item\", v.tagName = \"LI\";\n\n    var b = function (t) {\n      function e(t) {\n        i(this, e);\n\n        var n = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t)),\n            r = function r(e) {\n          if (e.target.parentNode === t) {\n            var r = n.statics.formats(t),\n                o = f.default.find(e.target);\n            \"checked\" === r ? o.format(\"list\", \"unchecked\") : \"unchecked\" === r && o.format(\"list\", \"checked\");\n          }\n        };\n\n        return t.addEventListener(\"touchstart\", r), t.addEventListener(\"mousedown\", r), n;\n      }\n\n      return l(e, t), u(e, null, [{\n        key: \"create\",\n        value: function value(t) {\n          var n = \"ordered\" === t ? \"OL\" : \"UL\",\n              r = s(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, n);\n          return \"checked\" !== t && \"unchecked\" !== t || r.setAttribute(\"data-checked\", \"checked\" === t), r;\n        }\n      }, {\n        key: \"formats\",\n        value: function value(t) {\n          return \"OL\" === t.tagName ? \"ordered\" : \"UL\" === t.tagName ? t.hasAttribute(\"data-checked\") ? \"true\" === t.getAttribute(\"data-checked\") ? \"checked\" : \"unchecked\" : \"bullet\" : void 0;\n        }\n      }]), u(e, [{\n        key: \"format\",\n        value: function value(t, e) {\n          this.children.length > 0 && this.children.tail.format(t, e);\n        }\n      }, {\n        key: \"formats\",\n        value: function value() {\n          return o({}, this.statics.blotName, this.statics.formats(this.domNode));\n        }\n      }, {\n        key: \"insertBefore\",\n        value: function value(t, n) {\n          if (t instanceof v) s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertBefore\", this).call(this, t, n);else {\n            var r = null == n ? this.length() : n.offset(this),\n                o = this.split(r);\n            o.parent.insertBefore(t, o);\n          }\n        }\n      }, {\n        key: \"optimize\",\n        value: function value(t) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t);\n          var n = this.next;\n          null != n && n.prev === this && n.statics.blotName === this.statics.blotName && n.domNode.tagName === this.domNode.tagName && n.domNode.getAttribute(\"data-checked\") === this.domNode.getAttribute(\"data-checked\") && (n.moveChildren(this), n.remove());\n        }\n      }, {\n        key: \"replace\",\n        value: function value(t) {\n          if (t.statics.blotName !== this.statics.blotName) {\n            var n = f.default.create(this.statics.defaultChild);\n            t.moveChildren(n), this.appendChild(n);\n          }\n\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"replace\", this).call(this, t);\n        }\n      }]), e;\n    }(y.default);\n\n    b.blotName = \"list\", b.scope = f.default.Scope.BLOCK_BLOT, b.tagName = [\"OL\", \"UL\"], b.defaultChild = \"list-item\", b.allowedChildren = [v], e.ListItem = v, e.default = b;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(36),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default);\n\n    u.blotName = \"italic\", u.tagName = [\"EM\", \"I\"], e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(4),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, null, [{\n        key: \"create\",\n        value: function value(t) {\n          return \"super\" === t ? document.createElement(\"sup\") : \"sub\" === t ? document.createElement(\"sub\") : l(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n        }\n      }, {\n        key: \"formats\",\n        value: function value(t) {\n          return \"SUB\" === t.tagName ? \"sub\" : \"SUP\" === t.tagName ? \"super\" : void 0;\n        }\n      }]), e;\n    }(s.default);\n\n    c.blotName = \"script\", c.tagName = [\"SUB\", \"SUP\"], e.default = c;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(4),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default);\n\n    u.blotName = \"strike\", u.tagName = \"S\", e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(4),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default);\n\n    u.blotName = \"underline\", u.tagName = \"U\", e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = n(15),\n        f = [\"alt\", \"height\", \"width\"],\n        d = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"format\",\n        value: function value(t, n) {\n          f.indexOf(t) > -1 ? n ? this.domNode.setAttribute(t, n) : this.domNode.removeAttribute(t) : l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n        }\n      }], [{\n        key: \"create\",\n        value: function value(t) {\n          var n = l(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n          return \"string\" == typeof t && n.setAttribute(\"src\", this.sanitize(t)), n;\n        }\n      }, {\n        key: \"formats\",\n        value: function value(t) {\n          return f.reduce(function (e, n) {\n            return t.hasAttribute(n) && (e[n] = t.getAttribute(n)), e;\n          }, {});\n        }\n      }, {\n        key: \"match\",\n        value: function value(t) {\n          return /\\.(jpe?g|gif|png)$/.test(t) || /^data:image\\/.+;base64/.test(t);\n        }\n      }, {\n        key: \"sanitize\",\n        value: function value(t) {\n          return (0, c.sanitize)(t, [\"http\", \"https\", \"data\"]) ? t : \"//:0\";\n        }\n      }, {\n        key: \"value\",\n        value: function value(t) {\n          return t.getAttribute(\"src\");\n        }\n      }]), e;\n    }(s.default.Embed);\n\n    d.blotName = \"image\", d.tagName = \"IMG\", e.default = d;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(2),\n        s = n(15),\n        c = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(s),\n        f = [\"height\", \"width\"],\n        d = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"format\",\n        value: function value(t, n) {\n          f.indexOf(t) > -1 ? n ? this.domNode.setAttribute(t, n) : this.domNode.removeAttribute(t) : l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n        }\n      }], [{\n        key: \"create\",\n        value: function value(t) {\n          var n = l(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n          return n.setAttribute(\"frameborder\", \"0\"), n.setAttribute(\"allowfullscreen\", !0), n.setAttribute(\"src\", this.sanitize(t)), n;\n        }\n      }, {\n        key: \"formats\",\n        value: function value(t) {\n          return f.reduce(function (e, n) {\n            return t.hasAttribute(n) && (e[n] = t.getAttribute(n)), e;\n          }, {});\n        }\n      }, {\n        key: \"sanitize\",\n        value: function value(t) {\n          return c.default.sanitize(t);\n        }\n      }, {\n        key: \"value\",\n        value: function value(t) {\n          return t.getAttribute(\"src\");\n        }\n      }]), e;\n    }(u.BlockEmbed);\n\n    d.blotName = \"video\", d.className = \"ql-video\", d.tagName = \"IFRAME\", e.default = d;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n    }\n\n    function l(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function u(t, e, n) {\n      var r = document.createElement(\"button\");\n      r.setAttribute(\"type\", \"button\"), r.classList.add(\"ql-\" + e), null != n && (r.value = n), t.appendChild(r);\n    }\n\n    function s(t, e) {\n      Array.isArray(e[0]) || (e = [e]), e.forEach(function (e) {\n        var n = document.createElement(\"span\");\n        n.classList.add(\"ql-formats\"), e.forEach(function (t) {\n          if (\"string\" == typeof t) u(n, t);else {\n            var e = Object.keys(t)[0],\n                r = t[e];\n            Array.isArray(r) ? c(n, e, r) : u(n, e, r);\n          }\n        }), t.appendChild(n);\n      });\n    }\n\n    function c(t, e, n) {\n      var r = document.createElement(\"select\");\n      r.classList.add(\"ql-\" + e), n.forEach(function (t) {\n        var e = document.createElement(\"option\");\n        !1 !== t ? e.setAttribute(\"value\", t) : e.setAttribute(\"selected\", \"selected\"), r.appendChild(e);\n      }), t.appendChild(r);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.addControls = e.default = void 0;\n\n    var f = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        d = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        p = n(5),\n        h = r(p),\n        y = n(0),\n        v = r(y),\n        b = n(6),\n        m = r(b),\n        g = n(8),\n        _ = r(g),\n        O = n(9),\n        E = r(O),\n        N = (\"getRootNode\" in document),\n        w = (0, _.default)(\"quill:toolbar\"),\n        k = function (t) {\n      function e(t, n) {\n        i(this, e);\n        var r = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));\n\n        if (Array.isArray(r.options.container)) {\n          var o = document.createElement(\"div\");\n          s(o, r.options.container), t.container.parentNode.insertBefore(o, t.container), r.container = o;\n        } else if (\"string\" == typeof r.options.container) {\n          var l = N ? t.container.getRootNode() : document;\n          r.container = l.querySelector(r.options.container);\n        } else r.container = r.options.container;\n\n        if (!(r.container instanceof HTMLElement)) {\n          var u;\n          return u = w.error(\"Container required for toolbar\", r.options), a(r, u);\n        }\n\n        return r.container.classList.add(\"ql-toolbar\"), r.controls = [], r.handlers = {}, Object.keys(r.options.handlers).forEach(function (t) {\n          r.addHandler(t, r.options.handlers[t]);\n        }), [].forEach.call(r.container.querySelectorAll(\"button, select\"), function (t) {\n          r.attach(t);\n        }), r.quill.on(m.default.events.EDITOR_CHANGE, function (t, e) {\n          t === m.default.events.SELECTION_CHANGE && r.update(e);\n        }), r.quill.on(m.default.events.SCROLL_OPTIMIZE, function () {\n          var t = r.quill.selection.getRange(),\n              e = f(t, 1),\n              n = e[0];\n          r.update(n);\n        }), r;\n      }\n\n      return l(e, t), d(e, [{\n        key: \"addHandler\",\n        value: function value(t, e) {\n          this.handlers[t] = e;\n        }\n      }, {\n        key: \"attach\",\n        value: function value(t) {\n          var e = this,\n              n = [].find.call(t.classList, function (t) {\n            return 0 === t.indexOf(\"ql-\");\n          });\n\n          if (n) {\n            if (n = n.slice(\"ql-\".length), \"BUTTON\" === t.tagName && t.setAttribute(\"type\", \"button\"), null == this.handlers[n]) {\n              if (null != this.quill.scroll.whitelist && null == this.quill.scroll.whitelist[n]) return void w.warn(\"ignoring attaching to disabled format\", n, t);\n              if (null == v.default.query(n)) return void w.warn(\"ignoring attaching to nonexistent format\", n, t);\n            }\n\n            var r = \"SELECT\" === t.tagName ? \"change\" : \"click\";\n            t.addEventListener(r, function (r) {\n              var i = void 0;\n\n              if (\"SELECT\" === t.tagName) {\n                if (t.selectedIndex < 0) return;\n                var a = t.options[t.selectedIndex];\n                i = !a.hasAttribute(\"selected\") && (a.value || !1);\n              } else i = !t.classList.contains(\"ql-active\") && (t.value || !t.hasAttribute(\"value\")), r.preventDefault();\n\n              e.quill.focus();\n              var l = e.quill.selection.getRange(),\n                  u = f(l, 1),\n                  s = u[0];\n              if (null != e.handlers[n]) e.handlers[n].call(e, i);else if (v.default.query(n).prototype instanceof v.default.Embed) {\n                if (!(i = prompt(\"Enter \" + n))) return;\n                e.quill.updateContents(new h.default().retain(s.index).delete(s.length).insert(o({}, n, i)), m.default.sources.USER);\n              } else e.quill.format(n, i, m.default.sources.USER);\n              e.update(s);\n            }), this.controls.push([n, t]);\n          }\n        }\n      }, {\n        key: \"update\",\n        value: function value(t) {\n          var e = null == t ? {} : this.quill.getFormat(t);\n          this.controls.forEach(function (n) {\n            var r = f(n, 2),\n                o = r[0],\n                i = r[1];\n\n            if (\"SELECT\" === i.tagName) {\n              var a = void 0;\n              if (null == t) a = null;else if (null == e[o]) a = i.querySelector(\"option[selected]\");else if (!Array.isArray(e[o])) {\n                var l = e[o];\n                \"string\" == typeof l && (l = l.replace(/\\\"/g, '\\\\\"')), a = i.querySelector('option[value=\"' + l + '\"]');\n              }\n              null == a ? (i.value = \"\", i.selectedIndex = -1) : a.selected = !0;\n            } else if (null == t) i.classList.remove(\"ql-active\");else if (i.hasAttribute(\"value\")) {\n              var u = e[o] === i.getAttribute(\"value\") || null != e[o] && e[o].toString() === i.getAttribute(\"value\") || null == e[o] && !i.getAttribute(\"value\");\n              i.classList.toggle(\"ql-active\", u);\n            } else i.classList.toggle(\"ql-active\", null != e[o]);\n          });\n        }\n      }]), e;\n    }(E.default);\n\n    k.DEFAULTS = {}, k.DEFAULTS = {\n      container: null,\n      handlers: {\n        clean: function clean() {\n          var t = this,\n              e = this.quill.getSelection();\n          if (null != e) if (0 == e.length) {\n            var n = this.quill.getFormat();\n            Object.keys(n).forEach(function (e) {\n              null != v.default.query(e, v.default.Scope.INLINE) && t.quill.format(e, !1);\n            });\n          } else this.quill.removeFormat(e, m.default.sources.USER);\n        },\n        direction: function direction(t) {\n          var e = this.quill.getFormat().align;\n          \"rtl\" === t && null == e ? this.quill.format(\"align\", \"right\", m.default.sources.USER) : t || \"right\" !== e || this.quill.format(\"align\", !1, m.default.sources.USER), this.quill.format(\"direction\", t, m.default.sources.USER);\n        },\n        indent: function indent(t) {\n          var e = this.quill.getSelection(),\n              n = this.quill.getFormat(e),\n              r = parseInt(n.indent || 0);\n\n          if (\"+1\" === t || \"-1\" === t) {\n            var o = \"+1\" === t ? 1 : -1;\n            \"rtl\" === n.direction && (o *= -1), this.quill.format(\"indent\", r + o, m.default.sources.USER);\n          }\n        },\n        link: function link(t) {\n          !0 === t && (t = prompt(\"Enter link URL:\")), this.quill.format(\"link\", t, m.default.sources.USER);\n        },\n        list: function list(t) {\n          var e = this.quill.getSelection(),\n              n = this.quill.getFormat(e);\n          \"check\" === t ? \"checked\" === n.list || \"unchecked\" === n.list ? this.quill.format(\"list\", !1, m.default.sources.USER) : this.quill.format(\"list\", \"unchecked\", m.default.sources.USER) : this.quill.format(\"list\", t, m.default.sources.USER);\n        }\n      }\n    }, e.default = k, e.addControls = s;\n  },,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(40),\n        i = r(o),\n        a = n(30),\n        l = n(32),\n        u = n(56),\n        s = n(57),\n        c = r(s),\n        f = n(58),\n        d = r(f),\n        p = n(59),\n        h = r(p),\n        y = n(31),\n        v = n(22),\n        b = n(33),\n        m = n(34),\n        g = n(36),\n        _ = r(g),\n        O = n(60),\n        E = r(O),\n        N = n(15),\n        w = r(N),\n        k = n(61),\n        j = r(k),\n        x = n(62),\n        A = r(x),\n        T = n(63),\n        S = r(T),\n        P = n(64),\n        C = r(P),\n        L = n(65),\n        R = r(L),\n        q = n(12),\n        I = r(q),\n        M = n(66),\n        B = r(M);\n\n    i.default.register({\n      \"attributors/attribute/direction\": l.DirectionAttribute,\n      \"attributors/class/align\": a.AlignClass,\n      \"attributors/class/background\": y.BackgroundClass,\n      \"attributors/class/color\": v.ColorClass,\n      \"attributors/class/direction\": l.DirectionClass,\n      \"attributors/class/font\": b.FontClass,\n      \"attributors/class/size\": m.SizeClass,\n      \"attributors/style/align\": a.AlignStyle,\n      \"attributors/style/background\": y.BackgroundStyle,\n      \"attributors/style/color\": v.ColorStyle,\n      \"attributors/style/direction\": l.DirectionStyle,\n      \"attributors/style/font\": b.FontStyle,\n      \"attributors/style/size\": m.SizeStyle\n    }, !0), i.default.register({\n      \"formats/align\": a.AlignClass,\n      \"formats/direction\": l.DirectionClass,\n      \"formats/indent\": u.IndentClass,\n      \"formats/background\": y.BackgroundStyle,\n      \"formats/color\": v.ColorStyle,\n      \"formats/font\": b.FontClass,\n      \"formats/size\": m.SizeClass,\n      \"formats/blockquote\": c.default,\n      \"formats/code-block\": I.default,\n      \"formats/header\": d.default,\n      \"formats/list\": h.default,\n      \"formats/bold\": _.default,\n      \"formats/code\": q.Code,\n      \"formats/italic\": E.default,\n      \"formats/link\": w.default,\n      \"formats/script\": j.default,\n      \"formats/strike\": A.default,\n      \"formats/underline\": S.default,\n      \"formats/image\": C.default,\n      \"formats/video\": R.default,\n      \"formats/list/item\": p.ListItem,\n      \"modules/toolbar\": B.default\n    }, !0), e.default = i.default;\n  }]).default;\n});"
    },
    {
     "id": 418,
     "name": "../node_modules/@vaadin/vaadin-rich-text-editor/src/vaadin-rich-text-editor-content-styles.js?babel-target=es5",
     "source": "var $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = \"<dom-module id=\\\"vaadin-rich-text-editor-content-styles\\\">\\n  <template>\\n    <style>\\n      [part=\\\"content\\\"] {\\n        box-sizing: border-box;\\n        position: relative;\\n        flex: auto;\\n        display: flex;\\n        flex-direction: column;\\n        overflow: hidden;\\n      }\\n\\n      /*\\n        Quill core styles.\\n        CSS selectors removed: margin & padding reset, check list, indentation, video, colors, ordered & unordered list, h1-6, anchor\\n      */\\n      .ql-clipboard {\\n        left: -100000px;\\n        height: 1px;\\n        overflow-y: hidden;\\n        position: absolute;\\n        top: 50%;\\n      }\\n\\n      .ql-clipboard p {\\n        margin: 0;\\n        padding: 0;\\n      }\\n\\n      .ql-editor {\\n        box-sizing: border-box;\\n        line-height: 1.42;\\n        height: 100%;\\n        outline: none;\\n        overflow-y: auto;\\n        padding: 0.75em 1em;\\n        tab-size: 4;\\n        -moz-tab-size: 4;\\n        text-align: left;\\n        white-space: pre-wrap;\\n        word-wrap: break-word;\\n        flex: 1;\\n      }\\n\\n      .ql-editor > * {\\n        cursor: text;\\n      }\\n\\n      .ql-align-left {\\n        text-align: left;\\n      }\\n\\n      .ql-direction-rtl {\\n        direction: rtl;\\n        text-align: inherit;\\n      }\\n\\n      .ql-align-center {\\n        text-align: center;\\n      }\\n\\n      .ql-align-justify {\\n        text-align: justify;\\n      }\\n\\n      .ql-align-right {\\n        text-align: right;\\n      }\\n      /* quill core end */\\n\\n      blockquote {\\n        border-left: 0.25em solid #ccc;\\n        margin-bottom: 0.3125em;\\n        margin-top: 0.3125em;\\n        padding-left: 1em;\\n      }\\n\\n      code,\\n      pre {\\n        background-color: #f0f0f0;\\n        border-radius: 0.1875em;\\n      }\\n\\n      pre {\\n        white-space: pre-wrap;\\n        margin-bottom: 0.3125em;\\n        margin-top: 0.3125em;\\n        padding: 0.3125em 0.625em;\\n      }\\n\\n      code {\\n        font-size: 85%;\\n        padding: 0.125em 0.25em;\\n      }\\n\\n      img {\\n        max-width: 100%;\\n      }\\n\\n      /* RTL specific styles */\\n\\n      :host([dir=\\\"rtl\\\"]) .ql-editor {\\n        direction: rtl;\\n        text-align: right;\\n      }\\n    </style>\\n  </template>\\n</dom-module>\";\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 419,
     "name": "../node_modules/@vaadin/flow-frontend/selectConnector.js?babel-target=es5",
     "source": "(function () {\n  var tryCatchWrapper = function tryCatchWrapper(callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Select', 'vaadin-select-flow');\n  };\n\n  window.Vaadin.Flow.selectConnector = {\n    initLazy: function initLazy(select) {\n      return tryCatchWrapper(function (select) {\n        var _findListBoxElement = tryCatchWrapper(function () {\n          for (var i = 0; i < select.childElementCount; i++) {\n            var child = select.children[i];\n\n            if (\"VAADIN-LIST-BOX\" === child.tagName.toUpperCase()) {\n              return child;\n            }\n          }\n        }); // do not init this connector twice for the given select\n\n\n        if (select.$connector) {\n          return;\n        }\n\n        select.$connector = {};\n        select.renderer = tryCatchWrapper(function (root) {\n          var listBox = _findListBoxElement();\n\n          if (listBox) {\n            if (root.firstChild) {\n              root.removeChild(root.firstChild);\n            }\n\n            root.appendChild(listBox);\n          }\n        });\n      })(select);\n    }\n  };\n})();"
    },
    {
     "id": 421,
     "name": "../node_modules/highcharts/js/es-modules/masters/highstock.src.js?babel-target=es5 + 31 modules"
    },
    {
     "id": 423,
     "name": "../node_modules/highcharts/js/es-modules/masters/highcharts-more.src.js?babel-target=es5 + 11 modules"
    },
    {
     "id": 425,
     "name": "../node_modules/@vaadin/vaadin-menu-bar/theme/lumo/vaadin-menu-bar.js?babel-target=es5 + 9 modules"
    },
    {
     "id": 427,
     "name": "../node_modules/highcharts/js/es-modules/masters/highcharts-3d.src.js?babel-target=es5 + 9 modules"
    },
    {
     "id": 429,
     "name": "../node_modules/@vaadin/vaadin-crud/theme/lumo/vaadin-crud.js?babel-target=es5 + 8 modules"
    },
    {
     "id": 432,
     "name": "../node_modules/@vaadin/vaadin-date-time-picker/theme/lumo/vaadin-date-time-picker.js?babel-target=es5 + 7 modules"
    },
    {
     "id": 433,
     "name": "../node_modules/@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro-edit-column.js?babel-target=es5 + 7 modules"
    },
    {
     "id": 435,
     "name": "../node_modules/@webcomponents/shadycss/src/scoping-shim.js?babel-target=es5 + 6 modules"
    },
    {
     "id": 437,
     "name": "../node_modules/@vaadin/vaadin-rich-text-editor/theme/lumo/vaadin-rich-text-editor.js?babel-target=es5 + 5 modules"
    },
    {
     "id": 440,
     "name": "../node_modules/@vaadin/vaadin-accordion/theme/lumo/vaadin-accordion.js?babel-target=es5 + 4 modules"
    },
    {
     "id": 441,
     "name": "../node_modules/@vaadin/vaadin-login/theme/lumo/vaadin-login-overlay.js?babel-target=es5 + 4 modules"
    },
    {
     "id": 443,
     "name": "../node_modules/@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro.js?babel-target=es5 + 3 modules"
    },
    {
     "id": 446,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/accessibility.src.js?babel-target=es5 + 3 modules"
    },
    {
     "id": 447,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/heatmap.src.js?babel-target=es5 + 3 modules"
    },
    {
     "id": 458,
     "name": "../node_modules/@vaadin/vaadin-app-layout/theme/lumo/vaadin-drawer-toggle.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 459,
     "name": "../node_modules/@vaadin/vaadin-board/vaadin-board.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 460,
     "name": "../node_modules/@vaadin/vaadin-charts/vaadin-chart.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 461,
     "name": "../node_modules/@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox-group.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 462,
     "name": "../node_modules/@vaadin/vaadin-cookie-consent/theme/lumo/vaadin-cookie-consent.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 463,
     "name": "../node_modules/@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-item.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 464,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-tree-toggle.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 465,
     "name": "../node_modules/@vaadin/vaadin-notification/theme/lumo/vaadin-notification.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 466,
     "name": "../node_modules/@vaadin/vaadin-ordered-layout/vaadin-scroller.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 467,
     "name": "../node_modules/@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-group.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 468,
     "name": "../node_modules/@vaadin/vaadin-split-layout/theme/lumo/vaadin-split-layout.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 471,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/data.src.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 472,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/treemap.src.js?babel-target=es5 + 2 modules"
    },
    {
     "id": 477,
     "name": "../node_modules/@vaadin/flow-frontend/vaadin-grid-flow-selection-column.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 478,
     "name": "../node_modules/@vaadin/vaadin-icons/vaadin-icons.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 479,
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-integer-field.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 485,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/drilldown.src.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 486,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/exporting.src.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 487,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/funnel.src.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 488,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/solid-gauge.src.js?babel-target=es5 + 1 modules"
    },
    {
     "id": 489,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/no-data-to-display.src.js?babel-target=es5 + 1 modules"
    }
   ]
  },
  {
   "id": 4,
   "names": [],
   "files": [
    "build/vaadin-4-124d711ad4051828a047.cache.js"
   ],
   "hash": "f4fa59915b465540cf70",
   "modules": [
    {
     "id": 234,
     "name": "../node_modules/highcharts/js/es-modules/parts/Globals.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n/* global win, window */\n// glob is a temporary fix to allow our es-modules to work.\n\nvar glob = typeof win === 'undefined' ? window : win,\n    doc = glob.document,\n    SVG_NS = 'http://www.w3.org/2000/svg',\n    userAgent = glob.navigator && glob.navigator.userAgent || '',\n    svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n    isMS = /(edge|msie|trident)/i.test(userAgent) && !glob.opera,\n    isFirefox = userAgent.indexOf('Firefox') !== -1,\n    isChrome = userAgent.indexOf('Chrome') !== -1,\n    hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4 // issue #38\n;\nvar Highcharts = glob.Highcharts ? glob.Highcharts.error(16, true) : {\n  product: '@product.name@',\n  version: '@product.version@',\n  deg2rad: Math.PI * 2 / 360,\n  doc: doc,\n  hasBidiBug: hasBidiBug,\n  hasTouch: doc && doc.documentElement.ontouchstart !== undefined,\n  isMS: isMS,\n  isWebKit: userAgent.indexOf('AppleWebKit') !== -1,\n  isFirefox: isFirefox,\n  isChrome: isChrome,\n  isSafari: !isChrome && userAgent.indexOf('Safari') !== -1,\n  isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),\n  SVG_NS: SVG_NS,\n  chartCount: 0,\n  seriesTypes: {},\n  symbolSizes: {},\n  svg: svg,\n  win: glob,\n  marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n  noop: function () {\n    return undefined;\n  },\n\n  /**\n   * An array containing the current chart objects in the page. A chart's\n   * position in the array is preserved throughout the page's lifetime. When\n   * a chart is destroyed, the array item becomes `undefined`.\n   *\n   * @name Highcharts.charts\n   * @type {Array<Highcharts.Chart>}\n   */\n  charts: []\n};\nexport default Highcharts;"
    },
    {
     "id": 236,
     "name": "../node_modules/highcharts/js/es-modules/parts/Utilities.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Reference to the global SVGElement class as a workaround for a name conflict\n * in the Highcharts namespace.\n *\n * @typedef {global.SVGElement} GlobalSVGElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n\n/**\n * An animation configuration. Animation configurations can also be defined as\n * booleans, where `false` turns off animation and `true` defaults to a duration\n * of 500ms.\n *\n * @typedef Highcharts.AnimationOptionsObject\n *\n * @property {number} duration\n *           The animation duration in milliseconds.\n *\n * @property {string} [easing]\n *           The name of an easing function as defined on the `Math` object.\n *\n * @property {Function} [complete]\n *           A callback function to exectute when the animation finishes.\n *\n * @property {Function} [step]\n *           A callback function to execute on each step of each attribute or\n *           CSS property that's being animated. The first argument contains\n *           information about the animation and progress.\n */\n\n/**\n * A style object with camel case property names to define visual appearance of\n * a SVG element or HTML element. The properties can be whatever styles are\n * supported on the given SVG or HTML element.\n *\n * @example\n * {\n *    fontFamily: 'monospace',\n *    fontSize: '1.2em'\n * }\n *\n * @typedef Highcharts.CSSObject\n *\n * @property {boolean|number|string|undefined} [key:string]\n *\n * @property {string} [background]\n *           Background style for the element.\n *\n * @property {Highcharts.ColorString} [backgroundColor]\n *           Background color of the element.\n *\n * @property {string} [border]\n *           Border style for the element.\n *\n * @property {number} [borderRadius]\n *           Radius of the element border.\n *\n * @property {\"contrast\"|Highcharts.ColorString} [color]\n *           Color used in the element. The \"contrast\" option is a Highcharts\n *           custom property that results in black or white, depending on the\n *           background of the element.\n *\n * @property {string} [cursor]\n *           Style of the mouse cursor when resting over the element.\n *\n * @property {string} [fontFamily]\n *           Font family of the element text. Multiple values have to be in\n *           decreasing preference order and separated by comma.\n *\n * @property {string} [fontSize]\n *           Font size of the element text.\n *\n * @property {string} [fontWeight]\n *           Font weight of the element text.\n *\n * @property {number} [height]\n *           Height of the element.\n *\n * @property {number} [lineWidth]\n *           Width of the element border.\n *\n * @property {number} [opacity]\n *           Opacity of the element.\n *\n * @property {string} [padding]\n *           Space around the element content.\n *\n * @property {string} [pointerEvents]\n *           Behaviour of the element when the mouse cursor rests over it.\n *\n * @property {string} [position]\n *           Positioning of the element.\n *\n * @property {string} [textAlign]\n *           Alignment of the element text.\n *\n * @property {string} [textOutline]\n *           Outline style of the element text.\n *\n * @property {string} [textDecoration]\n *           Additional decoration of the element text.\n *\n * @property {string} [textOverflow]\n *           Line break style of the element text. Highcharts SVG elements\n *           support `ellipsis` when a `width` is set.\n *\n * @property {string} [transition]\n *           Animated transition of selected element properties.\n *\n * @property {string} [top]\n *           Top spacing of the element relative to the parent element.\n *\n * @property {string} [whiteSpace]\n *           Line break style of the element text.\n *\n * @property {number} [width]\n *           Width of the element.\n */\n\n/**\n * Generic dictionary in TypeScript notation.\n *\n * @typedef Highcharts.Dictionary<T>\n *\n * @property {T} [key:string]\n */\n\n/**\n * An object of key-value pairs for HTML attributes.\n *\n * @typedef {Highcharts.Dictionary<boolean|number|string>} Highcharts.HTMLAttributes\n */\n\n/**\n * The iterator callback.\n *\n * @callback Highcharts.EachCallbackFunction<T>\n *\n * @param {T} item\n *        The array item.\n *\n * @param {number} index\n *        The item's index in the array.\n *\n * @param {Array<T>} arr\n *        The array that each is being applied to.\n */\n\n/**\n * The function callback to execute when the event is fired. The `this` context\n * contains the instance, that fired the event.\n *\n * @callback Highcharts.EventCallbackFunction\n *\n * @param {Highcharts.Dictionary<*>} [eventArguments]\n *        Event arguments.\n */\n\n/**\n * Formats data as a string. Usually the data is accessible throught the `this`\n * keyword.\n *\n * @callback Highcharts.FormatterCallbackFunction\n *\n * @return {string}\n */\n\n/**\n * An HTML DOM element. The type is a reference to the regular SVGElement in the\n * global scope.\n *\n * @typedef {global.HTMLElement} Highcharts.HTMLDOMElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n */\n\n/**\n * The iterator callback.\n *\n * @callback Highcharts.ObjectEachCallbackFunction\n *\n * @param {*} value\n *        The property value.\n *\n * @param {string} key\n *        The property key.\n *\n * @param {*} obj\n *        The object that objectEach is being applied to.\n */\n\n/**\n * An object containing `left` and `top` properties for the position in the\n * page.\n *\n * @typedef Highcharts.OffsetObject\n *\n * @property {number} left\n *           Left distance to the page border.\n *\n * @property {number} top\n *           Top distance to the page border.\n */\n\n/**\n * An object containing `x` and `y` properties for the position of an element.\n *\n * @typedef Highcharts.PositionObject\n *\n * @property {number} x\n *           X position of the element.\n *\n * @property {number} y\n *           Y position of the element.\n */\n\n/**\n * If a number is given, it defines the pixel length. If a percentage string is\n * given, like for example `'50%'`, the setting defines a length relative to a\n * base size, for example the size of a container.\n *\n * @typedef {number|string} Highcharts.RelativeSize\n */\n\n/**\n * An object of key-value pairs for SVG attributes. Attributes in Highcharts\n * elements for the most parts correspond to SVG, but some are specific to\n * Highcharts, like `zIndex`, `rotation`, `rotationOriginX`,\n * `rotationOriginY`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG\n * attributes containing a hyphen are _not_ camel-cased, they should be\n * quoted to preserve the hyphen.\n *\n * @example\n * {\n *     'stroke': '#ff0000', // basic\n *     'stroke-width': 2, // hyphenated\n *     'rotation': 45 // custom\n *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format\n * }\n *\n * @typedef Highcharts.SVGAttributes\n *\n * @property {boolean|number|string|Array<any>|undefined} [key:string]\n *\n * @property {string|Highcharts.SVGPathArray} [d]\n *\n * @property {boolean} [inverted]\n *\n * @property {Array<number>} [matrix]\n *\n * @property {Highcharts.ColorString} [stroke]\n *\n * @property {string} [rotation]\n *\n * @property {number} [rotationOriginX]\n *\n * @property {number} [rotationOriginY]\n *\n * @property {number} [scaleX]\n *\n * @property {number} [scaleY]\n *\n * @property {number} [translateX]\n *\n * @property {number} [translateY]\n *\n * @property {number} [zIndex]\n */\n\n/**\n * An SVG DOM element. The type is a reference to the regular SVGElement in the\n * global scope.\n *\n * @typedef {global.GlobalSVGElement} Highcharts.SVGDOMElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n\n/**\n * Array of path commands, that will go into the `d` attribute of an SVG\n * element.\n *\n * @typedef {Array<number|Highcharts.SVGPathCommand>} Highcharts.SVGPathArray\n */\n\n/**\n * Possible path commands in a SVG path array.\n *\n * @typedef {string} Highcharts.SVGPathCommand\n * @validvalue [\"a\",\"c\",\"h\",\"l\",\"m\",\"q\",\"s\",\"t\",\"v\",\"z\",\"A\",\"C\",\"H\",\"L\",\"M\",\"Q\",\"S\",\"T\",\"V\",\"Z\"]\n */\n'use strict';\n\nimport H from './Globals.js';\n/**\n * The Highcharts object is the placeholder for all other members, and various\n * utility functions. The most important member of the namespace would be the\n * chart constructor.\n *\n * @example\n * var chart = Highcharts.chart('container', { ... });\n *\n * @namespace Highcharts\n */\n\nH.timers = [];\nvar charts = H.charts,\n    doc = H.doc,\n    win = H.win;\n/**\n * Provide error messages for debugging, with links to online explanation. This\n * function can be overridden to provide custom error handling.\n *\n * @sample highcharts/chart/highcharts-error/\n *         Custom error handler\n *\n * @function Highcharts.error\n *\n * @param {number|string} code\n *        The error code. See\n *        [errors.xml]{@link https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}\n *        for available codes. If it is a string, the error message is printed\n *        directly in the console.\n *\n * @param {boolean} [stop=false]\n *        Whether to throw an error or just log a warning in the console.\n */\n\nH.error = function (code, stop) {\n  var msg = H.isNumber(code) ? 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code : code;\n\n  if (stop) {\n    throw new Error(msg);\n  } // else ...\n\n\n  if (win.console) {\n    console.log(msg); // eslint-disable-line no-console\n  }\n};\n/**\n * An animator object used internally. One instance applies to one property\n * (attribute or style prop) on one element. Animation is always initiated\n * through {@link SVGElement#animate}.\n *\n * @example\n * var rect = renderer.rect(0, 0, 10, 10).add();\n * rect.animate({ width: 100 });\n *\n * @private\n * @class Highcharts.Fx\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem\n *        The element to animate.\n *\n * @param {Highcharts.AnimationOptionsObject} options\n *        Animation options.\n *\n * @param {string} prop\n *        The single attribute or CSS property to animate.\n */\n\n\nH.Fx = function (elem, options, prop) {\n  this.options = options;\n  this.elem = elem;\n  this.prop = prop;\n};\n\nH.Fx.prototype = {\n  /**\n   * Set the current step of a path definition on SVGElement.\n   *\n   * @function Highcharts.Fx#dSetter\n   */\n  dSetter: function () {\n    var start = this.paths[0],\n        end = this.paths[1],\n        ret = [],\n        now = this.now,\n        i = start.length,\n        startVal; // Land on the final path without adjustment points appended in the ends\n\n    if (now === 1) {\n      ret = this.toD;\n    } else if (i === end.length && now < 1) {\n      while (i--) {\n        startVal = parseFloat(start[i]);\n        ret[i] = isNaN(startVal) ? // a letter instruction like M or L\n        end[i] : now * parseFloat(end[i] - startVal) + startVal;\n      } // If animation is finished or length not matching, land on right value\n\n    } else {\n      ret = end;\n    }\n\n    this.elem.attr('d', ret, null, true);\n  },\n\n  /**\n   * Update the element with the current animation step.\n   *\n   * @function Highcharts.Fx#update\n   */\n  update: function () {\n    var elem = this.elem,\n        prop = this.prop,\n        // if destroyed, it is null\n    now = this.now,\n        step = this.options.step; // Animation setter defined from outside\n\n    if (this[prop + 'Setter']) {\n      this[prop + 'Setter'](); // Other animations on SVGElement\n    } else if (elem.attr) {\n      if (elem.element) {\n        elem.attr(prop, now, null, true);\n      } // HTML styles, raw HTML content like container size\n\n    } else {\n      elem.style[prop] = now + this.unit;\n    }\n\n    if (step) {\n      step.call(elem, now, this);\n    }\n  },\n\n  /**\n   * Run an animation.\n   *\n   * @function Highcharts.Fx#run\n   *\n   * @param {number} from\n   *        The current value, value to start from.\n   *\n   * @param {number} to\n   *        The end value, value to land on.\n   *\n   * @param {string} [unit]\n   *        The property unit, for example `px`.\n   */\n  run: function (from, to, unit) {\n    var self = this,\n        options = self.options,\n        timer = function (gotoEnd) {\n      return timer.stopped ? false : self.step(gotoEnd);\n    },\n        requestAnimationFrame = win.requestAnimationFrame || function (step) {\n      setTimeout(step, 13);\n    },\n        step = function () {\n      for (var i = 0; i < H.timers.length; i++) {\n        if (!H.timers[i]()) {\n          H.timers.splice(i--, 1);\n        }\n      }\n\n      if (H.timers.length) {\n        requestAnimationFrame(step);\n      }\n    };\n\n    if (from === to && !this.elem['forceAnimate:' + this.prop]) {\n      delete options.curAnim[this.prop];\n\n      if (options.complete && H.keys(options.curAnim).length === 0) {\n        options.complete.call(this.elem);\n      }\n    } else {\n      // #7166\n      this.startTime = +new Date();\n      this.start = from;\n      this.end = to;\n      this.unit = unit;\n      this.now = this.start;\n      this.pos = 0;\n      timer.elem = this.elem;\n      timer.prop = this.prop;\n\n      if (timer() && H.timers.push(timer) === 1) {\n        requestAnimationFrame(step);\n      }\n    }\n  },\n\n  /**\n   * Run a single step in the animation.\n   *\n   * @function Highcharts.Fx#step\n   *\n   * @param {boolean} [gotoEnd]\n   *        Whether to go to the endpoint of the animation after abort.\n   *\n   * @return {boolean}\n   *         Returns `true` if animation continues.\n   */\n  step: function (gotoEnd) {\n    var t = +new Date(),\n        ret,\n        done,\n        options = this.options,\n        elem = this.elem,\n        complete = options.complete,\n        duration = options.duration,\n        curAnim = options.curAnim;\n\n    if (elem.attr && !elem.element) {\n      // #2616, element is destroyed\n      ret = false;\n    } else if (gotoEnd || t >= duration + this.startTime) {\n      this.now = this.end;\n      this.pos = 1;\n      this.update();\n      curAnim[this.prop] = true;\n      done = true;\n      H.objectEach(curAnim, function (val) {\n        if (val !== true) {\n          done = false;\n        }\n      });\n\n      if (done && complete) {\n        complete.call(elem);\n      }\n\n      ret = false;\n    } else {\n      this.pos = options.easing((t - this.startTime) / duration);\n      this.now = this.start + (this.end - this.start) * this.pos;\n      this.update();\n      ret = true;\n    }\n\n    return ret;\n  },\n\n  /**\n   * Prepare start and end values so that the path can be animated one to one.\n   *\n   * @function Highcharts.Fx#initPath\n   *\n   * @param {Highcharts.SVGElement} elem\n   *        The SVGElement item.\n   *\n   * @param {string} fromD\n   *        Starting path definition.\n   *\n   * @param {Highcharts.SVGPathArray} toD\n   *        Ending path definition.\n   *\n   * @return {Array<Highcharts.SVGPathArray>}\n   *         An array containing start and end paths in array form so that\n   *         they can be animated in parallel.\n   */\n  initPath: function (elem, fromD, toD) {\n    fromD = fromD || '';\n    var shift,\n        startX = elem.startX,\n        endX = elem.endX,\n        bezier = fromD.indexOf('C') > -1,\n        numParams = bezier ? 7 : 3,\n        fullLength,\n        slice,\n        i,\n        start = fromD.split(' '),\n        end = toD.slice(),\n        // copy\n    isArea = elem.isArea,\n        positionFactor = isArea ? 2 : 1,\n        reverse;\n    /**\n     * In splines make moveTo and lineTo points have six parameters like\n     * bezier curves, to allow animation one-to-one.\n     */\n\n    function sixify(arr) {\n      var isOperator, nextIsOperator;\n      i = arr.length;\n\n      while (i--) {\n        // Fill in dummy coordinates only if the next operator comes\n        // three places behind (#5788)\n        isOperator = arr[i] === 'M' || arr[i] === 'L';\n        nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);\n\n        if (isOperator && nextIsOperator) {\n          arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);\n        }\n      }\n    }\n    /**\n     * Insert an array at the given position of another array\n     */\n\n\n    function insertSlice(arr, subArr, index) {\n      [].splice.apply(arr, [index, 0].concat(subArr));\n    }\n    /**\n     * If shifting points, prepend a dummy point to the end path.\n     */\n\n\n    function prepend(arr, other) {\n      while (arr.length < fullLength) {\n        // Move to, line to or curve to?\n        arr[0] = other[fullLength - arr.length]; // Prepend a copy of the first point\n\n        insertSlice(arr, arr.slice(0, numParams), 0); // For areas, the bottom path goes back again to the left, so we\n        // need to append a copy of the last point.\n\n        if (isArea) {\n          insertSlice(arr, arr.slice(arr.length - numParams), arr.length);\n          i--;\n        }\n      }\n\n      arr[0] = 'M';\n    }\n    /**\n     * Copy and append last point until the length matches the end length.\n     */\n\n\n    function append(arr, other) {\n      var i = (fullLength - arr.length) / numParams;\n\n      while (i > 0 && i--) {\n        // Pull out the slice that is going to be appended or inserted.\n        // In a line graph, the positionFactor is 1, and the last point\n        // is sliced out. In an area graph, the positionFactor is 2,\n        // causing the middle two points to be sliced out, since an area\n        // path starts at left, follows the upper path then turns and\n        // follows the bottom back.\n        slice = arr.slice().splice(arr.length / positionFactor - numParams, numParams * positionFactor); // Move to, line to or curve to?\n\n        slice[0] = other[fullLength - numParams - i * numParams]; // Disable first control point\n\n        if (bezier) {\n          slice[numParams - 6] = slice[numParams - 2];\n          slice[numParams - 5] = slice[numParams - 1];\n        } // Now insert the slice, either in the middle (for areas) or at\n        // the end (for lines)\n\n\n        insertSlice(arr, slice, arr.length / positionFactor);\n\n        if (isArea) {\n          i--;\n        }\n      }\n    }\n\n    if (bezier) {\n      sixify(start);\n      sixify(end);\n    } // For sideways animation, find out how much we need to shift to get the\n    // start path Xs to match the end path Xs.\n\n\n    if (startX && endX) {\n      for (i = 0; i < startX.length; i++) {\n        // Moving left, new points coming in on right\n        if (startX[i] === endX[0]) {\n          shift = i;\n          break; // Moving right\n        } else if (startX[0] === endX[endX.length - startX.length + i]) {\n          shift = i;\n          reverse = true;\n          break;\n        }\n      }\n\n      if (shift === undefined) {\n        start = [];\n      }\n    }\n\n    if (start.length && H.isNumber(shift)) {\n      // The common target length for the start and end array, where both\n      // arrays are padded in opposite ends\n      fullLength = end.length + shift * positionFactor * numParams;\n\n      if (!reverse) {\n        prepend(end, start);\n        append(start, end);\n      } else {\n        prepend(start, end);\n        append(end, start);\n      }\n    }\n\n    return [start, end];\n  },\n\n  /**\n   * Handle animation of the color attributes directly.\n   *\n   * @function Highcharts.Fx#fillSetter\n   */\n  fillSetter: function () {\n    H.Fx.prototype.strokeSetter.apply(this, arguments);\n  },\n\n  /**\n   * Handle animation of the color attributes directly.\n   *\n   * @function Highcharts.Fx#strokeSetter\n   */\n  strokeSetter: function () {\n    this.elem.attr(this.prop, H.color(this.start).tweenTo(H.color(this.end), this.pos), null, true);\n  }\n}; // End of Fx prototype\n\n/**\n * Utility function to deep merge two or more objects and return a third object.\n * The merge function can also be used with a single object argument to create a\n * deep copy of an object.\n *\n * @function Highcharts.merge\n *\n * @param {*} a\n *        The first object to extend. When only this is given, the function\n *        returns a deep copy.\n *\n * @param {*} [n]\n *        An object to merge into the previous one.\n *\n * @return {*}\n *         The merged object. If the first argument is true, the return is the\n *         same as the second argument.\n */\n\n/**\n* Utility function to deep merge two or more objects and return a third object.\n* If the first argument is true, the contents of the second object is copied\n* into the first object. The merge function can also be used with a single\n* object argument to create a deep copy of an object.\n*\n* @function Highcharts.merge\n*\n* @param {boolean} extend\n*        Whether to extend the left-side object (a) or return a whole new\n*        object.\n*\n* @param {*} a\n*        The first object to extend. When only this is given, the function\n*        returns a deep copy.\n*\n* @param {*} [n]\n*        An object to merge into the previous one.\n*\n* @return {*}\n*         The merged object. If the first argument is true, the return is the\n*         same as the second argument.\n*/\n\nH.merge = function () {\n  var i,\n      args = arguments,\n      len,\n      ret = {},\n      doCopy = function (copy, original) {\n    // An object is replacing a primitive\n    if (typeof copy !== 'object') {\n      copy = {};\n    }\n\n    H.objectEach(original, function (value, key) {\n      // Copy the contents of objects, but not arrays or DOM nodes\n      if (H.isObject(value, true) && !H.isClass(value) && !H.isDOMElement(value)) {\n        copy[key] = doCopy(copy[key] || {}, value); // Primitives and arrays are copied over directly\n      } else {\n        copy[key] = original[key];\n      }\n    });\n    return copy;\n  }; // If first argument is true, copy into the existing object. Used in\n  // setOptions.\n\n\n  if (args[0] === true) {\n    ret = args[1];\n    args = Array.prototype.slice.call(args, 2);\n  } // For each argument, extend the return\n\n\n  len = args.length;\n\n  for (i = 0; i < len; i++) {\n    ret = doCopy(ret, args[i]);\n  }\n\n  return ret;\n};\n/**\n * Shortcut for parseInt\n *\n * @private\n * @function Highcharts.pInt\n *\n * @param {*} s\n *\n * @param {number} mag\n *        Magnitude\n *\n * @return {number}\n */\n\n\nH.pInt = function (s, mag) {\n  return parseInt(s, mag || 10);\n};\n/**\n * Utility function to check for string type.\n *\n * @function Highcharts.isString\n *\n * @param {*} s\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is a string.\n */\n\n\nH.isString = function (s) {\n  return typeof s === 'string';\n};\n/**\n * Utility function to check if an item is an array.\n *\n * @function Highcharts.isArray\n *\n * @param {*} obj\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is an array.\n */\n\n\nH.isArray = function (obj) {\n  var str = Object.prototype.toString.call(obj);\n  return str === '[object Array]' || str === '[object Array Iterator]';\n};\n/**\n * Utility function to check if an item is of type object.\n *\n * @function Highcharts.isObject\n *\n * @param {*} obj\n *        The item to check.\n *\n * @param {boolean} [strict=false]\n *        Also checks that the object is not an array.\n *\n * @return {boolean}\n *         True if the argument is an object.\n */\n\n\nH.isObject = function (obj, strict) {\n  return !!obj && typeof obj === 'object' && (!strict || !H.isArray(obj));\n};\n/**\n * Utility function to check if an Object is a HTML Element.\n *\n * @function Highcharts.isDOMElement\n *\n * @param {*} obj\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is a HTML Element.\n */\n\n\nH.isDOMElement = function (obj) {\n  return H.isObject(obj) && typeof obj.nodeType === 'number';\n};\n/**\n * Utility function to check if an Object is an class.\n *\n * @function Highcharts.isClass\n *\n * @param {*} obj\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is an class.\n */\n\n\nH.isClass = function (obj) {\n  var c = obj && obj.constructor;\n  return !!(H.isObject(obj, true) && !H.isDOMElement(obj) && c && c.name && c.name !== 'Object');\n};\n/**\n * Utility function to check if an item is a number and it is finite (not NaN,\n * Infinity or -Infinity).\n *\n * @function Highcharts.isNumber\n *\n * @param {*} n\n *        The item to check.\n *\n * @return {boolean}\n *         True if the item is a finite number\n */\n\n\nH.isNumber = function (n) {\n  return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity;\n};\n/**\n * Remove the last occurence of an item from an array.\n *\n * @function Highcharts.erase\n *\n * @param {Array} arr\n *        The array.\n *\n * @param {*} item\n *        The item to remove.\n */\n\n\nH.erase = function (arr, item) {\n  var i = arr.length;\n\n  while (i--) {\n    if (arr[i] === item) {\n      arr.splice(i, 1);\n      break;\n    }\n  }\n};\n/**\n * Check if an object is null or undefined.\n *\n * @function Highcharts.defined\n *\n * @param {*} obj\n *        The object to check.\n *\n * @return {boolean}\n *         False if the object is null or undefined, otherwise true.\n */\n\n\nH.defined = function (obj) {\n  return obj !== undefined && obj !== null;\n};\n/**\n * Set or get an attribute or an object of attributes. To use as a setter, pass\n * a key and a value, or let the second argument be a collection of keys and\n * values. To use as a getter, pass only a string as the second argument.\n *\n * @function Highcharts.attr\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} elem\n *        The DOM element to receive the attribute(s).\n *\n * @param {string|Highcharts.HTMLAttributes|Highcharts.SVGAttributes} [prop]\n *        The property or an object of key-value pairs.\n *\n * @param {string} [value]\n *        The value if a single property is set.\n *\n * @return {*}\n *         When used as a getter, return the value.\n */\n\n\nH.attr = function (elem, prop, value) {\n  var ret; // if the prop is a string\n\n  if (H.isString(prop)) {\n    // set the value\n    if (H.defined(value)) {\n      elem.setAttribute(prop, value); // get the value\n    } else if (elem && elem.getAttribute) {\n      ret = elem.getAttribute(prop); // IE7 and below cannot get class through getAttribute (#7850)\n\n      if (!ret && prop === 'class') {\n        ret = elem.getAttribute(prop + 'Name');\n      }\n    } // else if prop is defined, it is a hash of key/value pairs\n\n  } else if (H.defined(prop) && H.isObject(prop)) {\n    H.objectEach(prop, function (val, key) {\n      elem.setAttribute(key, val);\n    });\n  }\n\n  return ret;\n};\n/**\n * Check if an element is an array, and if not, make it into an array.\n *\n * @function Highcharts.splat\n *\n * @param {*} obj\n *        The object to splat.\n *\n * @return {Array}\n *         The produced or original array.\n */\n\n\nH.splat = function (obj) {\n  return H.isArray(obj) ? obj : [obj];\n};\n/**\n * Set a timeout if the delay is given, otherwise perform the function\n * synchronously.\n *\n * @function Highcharts.syncTimeout\n *\n * @param {Function} fn\n *        The function callback.\n *\n * @param {number} delay\n *        Delay in milliseconds.\n *\n * @param {*} [context]\n *        The context.\n *\n * @return {number}\n *         An identifier for the timeout that can later be cleared with\n *         Highcharts.clearTimeout.\n */\n\n\nH.syncTimeout = function (fn, delay, context) {\n  if (delay) {\n    return setTimeout(fn, delay, context);\n  }\n\n  fn.call(0, context);\n};\n/**\n * Internal clear timeout. The function checks that the `id` was not removed\n * (e.g. by `chart.destroy()`). For the details see\n * [issue #7901](https://github.com/highcharts/highcharts/issues/7901).\n *\n * @function Highcharts.clearTimeout\n *\n * @param {number} id\n *        Id of a timeout.\n */\n\n\nH.clearTimeout = function (id) {\n  if (H.defined(id)) {\n    clearTimeout(id);\n  }\n};\n/**\n * Utility function to extend an object with the members of another.\n *\n * @function Highcharts.extend\n *\n * @param {Highcharts.Dictionary<*>} a\n *        The object to be extended.\n *\n * @param {Highcharts.Dictionary<*>} b\n *        The object to add to the first one.\n *\n * @return {Highcharts.Dictionary<*>}\n *         Object a, the original object.\n */\n\n\nH.extend = function (a, b) {\n  var n;\n\n  if (!a) {\n    a = {};\n  }\n\n  for (n in b) {\n    a[n] = b[n];\n  }\n\n  return a;\n};\n/**\n * Return the first value that is not null or undefined.\n *\n * @function Highcharts.pick\n *\n * @param {...*} items\n *        Variable number of arguments to inspect.\n *\n * @return {*}\n *         The value of the first argument that is not null or undefined.\n */\n\n\nH.pick = function () {\n  var args = arguments,\n      i,\n      arg,\n      length = args.length;\n\n  for (i = 0; i < length; i++) {\n    arg = args[i];\n\n    if (arg !== undefined && arg !== null) {\n      return arg;\n    }\n  }\n};\n/**\n * Set CSS on a given element.\n *\n * @function Highcharts.css\n *\n * @param {Highcharts.HTMLDOMElement} el\n *        An HTML DOM element.\n *\n * @param {Highcharts.CSSObject} styles\n *        Style object with camel case property names.\n */\n\n\nH.css = function (el, styles) {\n  if (H.isMS && !H.svg) {\n    // #2686\n    if (styles && styles.opacity !== undefined) {\n      styles.filter = 'alpha(opacity=' + styles.opacity * 100 + ')';\n    }\n  }\n\n  H.extend(el.style, styles);\n};\n/**\n * Utility function to create an HTML element with attributes and styles.\n *\n * @function Highcharts.createElement\n *\n * @param {string} tag\n *        The HTML tag.\n *\n * @param {Highcharts.HTMLAttributes} [attribs]\n *        Attributes as an object of key-value pairs.\n *\n * @param {Highcharts.CSSObject} [styles]\n *        Styles as an object of key-value pairs.\n *\n * @param {Highcharts.HTMLDOMElement} [parent]\n *        The parent HTML object.\n *\n * @param {boolean} [nopad=false]\n *        If true, remove all padding, border and margin.\n *\n * @return {Highcharts.HTMLDOMElement}\n *         The created DOM element.\n */\n\n\nH.createElement = function (tag, attribs, styles, parent, nopad) {\n  var el = doc.createElement(tag),\n      css = H.css;\n\n  if (attribs) {\n    H.extend(el, attribs);\n  }\n\n  if (nopad) {\n    css(el, {\n      padding: 0,\n      border: 'none',\n      margin: 0\n    });\n  }\n\n  if (styles) {\n    css(el, styles);\n  }\n\n  if (parent) {\n    parent.appendChild(el);\n  }\n\n  return el;\n};\n/**\n * Extend a prototyped class by new members.\n *\n * @function Highcharts.extendClass\n *\n * @param {*} parent\n *        The parent prototype to inherit.\n *\n * @param {Highcharts.Dictionary<*>} members\n *        A collection of prototype members to add or override compared to the\n *        parent prototype.\n *\n * @return {*}\n *         A new prototype.\n */\n\n\nH.extendClass = function (parent, members) {\n  var object = function () {};\n\n  object.prototype = new parent(); // eslint-disable-line new-cap\n\n  H.extend(object.prototype, members);\n  return object;\n};\n/**\n * Left-pad a string to a given length by adding a character repetetively.\n *\n * @function Highcharts.pad\n *\n * @param {number} number\n *        The input string or number.\n *\n * @param {number} length\n *        The desired string length.\n *\n * @param {string} [padder=0]\n *        The character to pad with.\n *\n * @return {string}\n *         The padded string.\n */\n\n\nH.pad = function (number, length, padder) {\n  return new Array((length || 2) + 1 - String(number).replace('-', '').length).join(padder || 0) + number;\n};\n/**\n * Return a length based on either the integer value, or a percentage of a base.\n *\n * @function Highcharts.relativeLength\n *\n * @param {Highcharts.RelativeSize} value\n *        A percentage string or a number.\n *\n * @param {number} base\n *        The full length that represents 100%.\n *\n * @param {number} [offset=0]\n *        A pixel offset to apply for percentage values. Used internally in\n *        axis positioning.\n *\n * @return {number}\n *         The computed length.\n */\n\n\nH.relativeLength = function (value, base, offset) {\n  return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset || 0) : parseFloat(value);\n};\n/**\n * Wrap a method with extended functionality, preserving the original function.\n *\n * @function Highcharts.wrap\n *\n * @param {*} obj\n *        The context object that the method belongs to. In real cases, this is\n *        often a prototype.\n *\n * @param {string} method\n *        The name of the method to extend.\n *\n * @param {Function} func\n *        A wrapper function callback. This function is called with the same\n *        arguments as the original function, except that the original function\n *        is unshifted and passed as the first argument.\n */\n\n\nH.wrap = function (obj, method, func) {\n  var proceed = obj[method];\n\n  obj[method] = function () {\n    var args = Array.prototype.slice.call(arguments),\n        outerArgs = arguments,\n        ctx = this,\n        ret;\n\n    ctx.proceed = function () {\n      proceed.apply(ctx, arguments.length ? arguments : outerArgs);\n    };\n\n    args.unshift(proceed);\n    ret = func.apply(this, args);\n    ctx.proceed = null;\n    return ret;\n  };\n};\n/**\n * Format a single variable. Similar to sprintf, without the % prefix.\n *\n * @example\n * formatSingle('.2f', 5); // => '5.00'.\n *\n * @function Highcharts.formatSingle\n *\n * @param {string} format\n *        The format string.\n *\n * @param {*} val\n *        The value.\n *\n * @param {Highcharts.Time} [time]\n *        A `Time` instance that determines the date formatting, for example\n *        for applying time zone corrections to the formatted date.\n *\n * @return {string}\n *         The formatted representation of the value.\n */\n\n\nH.formatSingle = function (format, val, time) {\n  var floatRegex = /f$/,\n      decRegex = /\\.([0-9])/,\n      lang = H.defaultOptions.lang,\n      decimals;\n\n  if (floatRegex.test(format)) {\n    // float\n    decimals = format.match(decRegex);\n    decimals = decimals ? decimals[1] : -1;\n\n    if (val !== null) {\n      val = H.numberFormat(val, decimals, lang.decimalPoint, format.indexOf(',') > -1 ? lang.thousandsSep : '');\n    }\n  } else {\n    val = (time || H.time).dateFormat(format, val);\n  }\n\n  return val;\n};\n/**\n * Format a string according to a subset of the rules of Python's String.format\n * method.\n *\n * @example\n * var s = Highcharts.format(\n *     'The {color} fox was {len:.2f} feet long',\n *     { color: 'red', len: Math.PI }\n * );\n * // => The red fox was 3.14 feet long\n *\n * @function Highcharts.format\n *\n * @param {string} str\n *        The string to format.\n *\n * @param {*} ctx\n *        The context, a collection of key-value pairs where each key is\n *        replaced by its value.\n *\n * @param {Highcharts.Time} [time]\n *        A `Time` instance that determines the date formatting, for example\n *        for applying time zone corrections to the formatted date.\n *\n * @return {string}\n *         The formatted string.\n */\n\n\nH.format = function (str, ctx, time) {\n  var splitter = '{',\n      isInside = false,\n      segment,\n      valueAndFormat,\n      path,\n      i,\n      len,\n      ret = [],\n      val,\n      index;\n\n  while (str) {\n    index = str.indexOf(splitter);\n\n    if (index === -1) {\n      break;\n    }\n\n    segment = str.slice(0, index);\n\n    if (isInside) {\n      // we're on the closing bracket looking back\n      valueAndFormat = segment.split(':');\n      path = valueAndFormat.shift().split('.'); // get first and leave\n\n      len = path.length;\n      val = ctx; // Assign deeper paths\n\n      for (i = 0; i < len; i++) {\n        if (val) {\n          val = val[path[i]];\n        }\n      } // Format the replacement\n\n\n      if (valueAndFormat.length) {\n        val = H.formatSingle(valueAndFormat.join(':'), val, time);\n      } // Push the result and advance the cursor\n\n\n      ret.push(val);\n    } else {\n      ret.push(segment);\n    }\n\n    str = str.slice(index + 1); // the rest\n\n    isInside = !isInside; // toggle\n\n    splitter = isInside ? '}' : '{'; // now look for next matching bracket\n  }\n\n  ret.push(str);\n  return ret.join('');\n};\n/**\n * Get the magnitude of a number.\n *\n * @function Highcharts.getMagnitude\n *\n * @param {number} number\n *        The number.\n *\n * @return {number}\n *         The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2 etc.\n */\n\n\nH.getMagnitude = function (num) {\n  return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));\n};\n/**\n * Take an interval and normalize it to multiples of round numbers.\n *\n * @deprecated\n * @function Highcharts.normalizeTickInterval\n *\n * @param {number} interval\n *        The raw, un-rounded interval.\n *\n * @param {Array} [multiples]\n *        Allowed multiples.\n *\n * @param {number} [magnitude]\n *        The magnitude of the number.\n *\n * @param {boolean} [allowDecimals]\n *        Whether to allow decimals.\n *\n * @param {boolean} [hasTickAmount]\n *        If it has tickAmount, avoid landing on tick intervals lower than\n *        original.\n *\n * @return {number}\n *         The normalized interval.\n *\n * @todo\n * Move this function to the Axis prototype. It is here only for historical\n * reasons.\n */\n\n\nH.normalizeTickInterval = function (interval, multiples, magnitude, allowDecimals, hasTickAmount) {\n  var normalized,\n      i,\n      retInterval = interval; // round to a tenfold of 1, 2, 2.5 or 5\n\n  magnitude = H.pick(magnitude, 1);\n  normalized = interval / magnitude; // multiples for a linear scale\n\n  if (!multiples) {\n    multiples = hasTickAmount ? // Finer grained ticks when the tick amount is hard set, including\n    // when alignTicks is true on multiple axes (#4580).\n    [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : // Else, let ticks fall on rounder numbers\n    [1, 2, 2.5, 5, 10]; // the allowDecimals option\n\n    if (allowDecimals === false) {\n      if (magnitude === 1) {\n        multiples = H.grep(multiples, function (num) {\n          return num % 1 === 0;\n        });\n      } else if (magnitude <= 0.1) {\n        multiples = [1 / magnitude];\n      }\n    }\n  } // normalize the interval to the nearest multiple\n\n\n  for (i = 0; i < multiples.length; i++) {\n    retInterval = multiples[i]; // only allow tick amounts smaller than natural\n\n    if (hasTickAmount && retInterval * magnitude >= interval || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {\n      break;\n    }\n  } // Multiply back to the correct magnitude. Correct floats to appropriate\n  // precision (#6085).\n\n\n  retInterval = H.correctFloat(retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10));\n  return retInterval;\n};\n/**\n * Sort an object array and keep the order of equal items. The ECMAScript\n * standard does not specify the behaviour when items are equal.\n *\n * @function Highcharts.stableSort\n *\n * @param {Array} arr\n *        The array to sort.\n *\n * @param {Function} sortFunction\n *        The function to sort it with, like with regular Array.prototype.sort.\n */\n\n\nH.stableSort = function (arr, sortFunction) {\n  var length = arr.length,\n      sortValue,\n      i; // Add index to each item\n\n  for (i = 0; i < length; i++) {\n    arr[i].safeI = i; // stable sort index\n  }\n\n  arr.sort(function (a, b) {\n    sortValue = sortFunction(a, b);\n    return sortValue === 0 ? a.safeI - b.safeI : sortValue;\n  }); // Remove index from items\n\n  for (i = 0; i < length; i++) {\n    delete arr[i].safeI; // stable sort index\n  }\n};\n/**\n * Non-recursive method to find the lowest member of an array. `Math.min` raises\n * a maximum call stack size exceeded error in Chrome when trying to apply more\n * than 150.000 points. This method is slightly slower, but safe.\n *\n * @function Highcharts.arrayMin\n *\n * @param {Array} data\n *        An array of numbers.\n *\n * @return {number}\n *         The lowest number.\n */\n\n\nH.arrayMin = function (data) {\n  var i = data.length,\n      min = data[0];\n\n  while (i--) {\n    if (data[i] < min) {\n      min = data[i];\n    }\n  }\n\n  return min;\n};\n/**\n * Non-recursive method to find the lowest member of an array. `Math.max` raises\n * a maximum call stack size exceeded error in Chrome when trying to apply more\n * than 150.000 points. This method is slightly slower, but safe.\n *\n * @function Highcharts.arrayMax\n *\n * @param {Array} data\n *        An array of numbers.\n *\n * @return {number}\n *         The highest number.\n */\n\n\nH.arrayMax = function (data) {\n  var i = data.length,\n      max = data[0];\n\n  while (i--) {\n    if (data[i] > max) {\n      max = data[i];\n    }\n  }\n\n  return max;\n};\n/**\n * Utility method that destroys any SVGElement instances that are properties on\n * the given object. It loops all properties and invokes destroy if there is a\n * destroy method. The property is then delete.\n *\n * @function Highcharts.destroyObjectProperties\n *\n * @param {*} obj\n *        The object to destroy properties on.\n *\n * @param {*} [except]\n *        Exception, do not destroy this property, only delete it.\n */\n\n\nH.destroyObjectProperties = function (obj, except) {\n  H.objectEach(obj, function (val, n) {\n    // If the object is non-null and destroy is defined\n    if (val && val !== except && val.destroy) {\n      // Invoke the destroy\n      val.destroy();\n    } // Delete the property from the object.\n\n\n    delete obj[n];\n  });\n};\n/**\n * Discard a HTML element by moving it to the bin and delete.\n *\n * @function Highcharts.discardElement\n *\n * @param {Highcharts.HTMLDOMElement} element\n *        The HTML node to discard.\n */\n\n\nH.discardElement = function (element) {\n  var garbageBin = H.garbageBin; // create a garbage bin element, not part of the DOM\n\n  if (!garbageBin) {\n    garbageBin = H.createElement('div');\n  } // move the node and empty bin\n\n\n  if (element) {\n    garbageBin.appendChild(element);\n  }\n\n  garbageBin.innerHTML = '';\n};\n/**\n * Fix JS round off float errors.\n *\n * @function Highcharts.correctFloat\n *\n * @param {number} num\n *        A float number to fix.\n *\n * @param {number} [prec=14]\n *        The precision.\n *\n * @return {number}\n *         The corrected float number.\n */\n\n\nH.correctFloat = function (num, prec) {\n  return parseFloat(num.toPrecision(prec || 14));\n};\n/**\n * Set the global animation to either a given value, or fall back to the given\n * chart's animation option.\n *\n * @function Highcharts.setAnimation\n *\n * @param {boolean|Highcharts.AnimationOptionsObject} animation\n *        The animation object.\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @todo\n * This function always relates to a chart, and sets a property on the renderer,\n * so it should be moved to the SVGRenderer.\n */\n\n\nH.setAnimation = function (animation, chart) {\n  chart.renderer.globalAnimation = H.pick(animation, chart.options.chart.animation, true);\n};\n/**\n * Get the animation in object form, where a disabled animation is always\n * returned as `{ duration: 0 }`.\n *\n * @function Highcharts.animObject\n *\n * @param {boolean|Highcharts.AnimationOptionsObject} animation\n *        An animation setting. Can be an object with duration, complete and\n *        easing properties, or a boolean to enable or disable.\n *\n * @return {Highcharts.AnimationOptionsObject}\n *         An object with at least a duration property.\n */\n\n\nH.animObject = function (animation) {\n  return H.isObject(animation) ? H.merge(animation) : {\n    duration: animation ? 500 : 0\n  };\n};\n/**\n * The time unit lookup\n *\n * @ignore\n */\n\n\nH.timeUnits = {\n  millisecond: 1,\n  second: 1000,\n  minute: 60000,\n  hour: 3600000,\n  day: 24 * 3600000,\n  week: 7 * 24 * 3600000,\n  month: 28 * 24 * 3600000,\n  year: 364 * 24 * 3600000\n};\n/**\n * Format a number and return a string based on input settings.\n *\n * @sample highcharts/members/highcharts-numberformat/\n *         Custom number format\n *\n * @function Highcharts.numberFormat\n *\n * @param {number} number\n *        The input number to format.\n *\n * @param {number} decimals\n *        The amount of decimals. A value of -1 preserves the amount in the\n *        input number.\n *\n * @param {string} [decimalPoint]\n *        The decimal point, defaults to the one given in the lang options, or\n *        a dot.\n *\n * @param {string} [thousandsSep]\n *        The thousands separator, defaults to the one given in the lang\n *        options, or a space character.\n *\n * @return {string}\n *         The formatted number.\n */\n\nH.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {\n  number = +number || 0;\n  decimals = +decimals;\n  var lang = H.defaultOptions.lang,\n      origDec = (number.toString().split('.')[1] || '').split('e')[0].length,\n      strinteger,\n      thousands,\n      ret,\n      roundedNumber,\n      exponent = number.toString().split('e'),\n      fractionDigits;\n\n  if (decimals === -1) {\n    // Preserve decimals. Not huge numbers (#3793).\n    decimals = Math.min(origDec, 20);\n  } else if (!H.isNumber(decimals)) {\n    decimals = 2;\n  } else if (decimals && exponent[1] && exponent[1] < 0) {\n    // Expose decimals from exponential notation (#7042)\n    fractionDigits = decimals + +exponent[1];\n\n    if (fractionDigits >= 0) {\n      // remove too small part of the number while keeping the notation\n      exponent[0] = (+exponent[0]).toExponential(fractionDigits).split('e')[0];\n      decimals = fractionDigits;\n    } else {\n      // fractionDigits < 0\n      exponent[0] = exponent[0].split('.')[0] || 0;\n\n      if (decimals < 20) {\n        // use number instead of exponential notation (#7405)\n        number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals);\n      } else {\n        // or zero\n        number = 0;\n      }\n\n      exponent[1] = 0;\n    }\n  } // Add another decimal to avoid rounding errors of float numbers. (#4573)\n  // Then use toFixed to handle rounding.\n\n\n  roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals); // A string containing the positive integer component of the number\n\n  strinteger = String(H.pInt(roundedNumber)); // Leftover after grouping into thousands. Can be 0, 1 or 2.\n\n  thousands = strinteger.length > 3 ? strinteger.length % 3 : 0; // Language\n\n  decimalPoint = H.pick(decimalPoint, lang.decimalPoint);\n  thousandsSep = H.pick(thousandsSep, lang.thousandsSep); // Start building the return\n\n  ret = number < 0 ? '-' : ''; // Add the leftover after grouping into thousands. For example, in the\n  // number 42 000 000, this line adds 42.\n\n  ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : ''; // Add the remaining thousands groups, joined by the thousands separator\n\n  ret += strinteger.substr(thousands).replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep); // Add the decimal point and the decimal component\n\n  if (decimals) {\n    // Get the decimal component\n    ret += decimalPoint + roundedNumber.slice(-decimals);\n  }\n\n  if (exponent[1] && +ret !== 0) {\n    ret += 'e' + exponent[1];\n  }\n\n  return ret;\n};\n/**\n * Easing definition\n *\n * @private\n * @function Math.easeInOutSine\n *\n * @param {number} pos\n *        Current position, ranging from 0 to 1.\n *\n * @return {number}\n */\n\n\nMath.easeInOutSine = function (pos) {\n  return -0.5 * (Math.cos(Math.PI * pos) - 1);\n};\n/**\n * Get the computed CSS value for given element and property, only for numerical\n * properties. For width and height, the dimension of the inner box (excluding\n * padding) is returned. Used for fitting the chart within the container.\n *\n * @function Highcharts.getStyle\n *\n * @param {Highcharts.HTMLDOMElement} el\n *        An HTML element.\n *\n * @param {string} prop\n *        The property name.\n *\n * @param {boolean} [toInt=true]\n *        Parse to integer.\n *\n * @return {number}\n *         The numeric value.\n */\n\n\nH.getStyle = function (el, prop, toInt) {\n  var style; // For width and height, return the actual inner pixel size (#4913)\n\n  if (prop === 'width') {\n    return Math.max(0, // #8377\n    Math.min(el.offsetWidth, el.scrollWidth) - H.getStyle(el, 'padding-left') - H.getStyle(el, 'padding-right'));\n  } else if (prop === 'height') {\n    return Math.max(0, // #8377\n    Math.min(el.offsetHeight, el.scrollHeight) - H.getStyle(el, 'padding-top') - H.getStyle(el, 'padding-bottom'));\n  }\n\n  if (!win.getComputedStyle) {\n    // SVG not supported, forgot to load oldie.js?\n    H.error(27, true);\n  } // Otherwise, get the computed style\n\n\n  style = win.getComputedStyle(el, undefined);\n\n  if (style) {\n    style = style.getPropertyValue(prop);\n\n    if (H.pick(toInt, prop !== 'opacity')) {\n      style = H.pInt(style);\n    }\n  }\n\n  return style;\n};\n/**\n * Search for an item in an array.\n *\n * @function Highcharts.inArray\n *\n * @param {*} item\n *        The item to search for.\n *\n * @param {Array} arr\n *        The array or node collection to search in.\n *\n * @param {number} [fromIndex=0]\n *        The index to start searching from.\n *\n * @return {number}\n *         The index within the array, or -1 if not found.\n */\n\n\nH.inArray = function (item, arr, fromIndex) {\n  return (H.indexOfPolyfill || Array.prototype.indexOf).call(arr, item, fromIndex);\n};\n/**\n * Filter an array by a callback.\n *\n * @function Highcharts.grep\n *\n * @param {Array} arr\n *        The array to filter.\n *\n * @param {Function} callback\n *        The callback function. The function receives the item as the first\n *        argument. Return `true` if the item is to be preserved.\n *\n * @return {Array}\n *         A new, filtered array.\n */\n\n\nH.grep = function (arr, callback) {\n  return (H.filterPolyfill || Array.prototype.filter).call(arr, callback);\n};\n/**\n * Return the value of the first element in the array that satisfies the\n * provided testing function.\n *\n * @function Highcharts.find\n *\n * @param {Array} arr\n *        The array to test.\n *\n * @param {Function} callback\n *        The callback function. The function receives the item as the first\n *        argument. Return `true` if this item satisfies the condition.\n *\n * @return {*}\n *         The value of the element.\n */\n\n\nH.find = Array.prototype.find ? function (arr, callback) {\n  return arr.find(callback);\n} : // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.\nfunction (arr, fn) {\n  var i,\n      length = arr.length;\n\n  for (i = 0; i < length; i++) {\n    if (fn(arr[i], i)) {\n      return arr[i];\n    }\n  }\n};\n/**\n * Test whether at least one element in the array passes the test implemented by\n * the provided function.\n *\n * @function Highcharts.some\n *\n * @param {Array} arr\n *        The array to test\n *\n * @param {Function} fn\n *        The function to run on each item. Return truty to pass the test.\n *        Receives arguments `currentValue`, `index` and `array`.\n *\n * @param {*} ctx\n *        The context.\n *\n * @return {boolean}\n */\n\nH.some = function (arr, fn, ctx) {\n  return (H.somePolyfill || Array.prototype.some).call(arr, fn, ctx);\n};\n/**\n * Map an array by a callback.\n *\n * @function Highcharts.map\n *\n * @param {Array} arr\n *        The array to map.\n *\n * @param {Function} fn\n *        The callback function. Return the new value for the new array.\n *\n * @return {Array}\n *         A new array item with modified items.\n */\n\n\nH.map = function (arr, fn) {\n  var results = [],\n      i = 0,\n      len = arr.length;\n\n  for (; i < len; i++) {\n    results[i] = fn.call(arr[i], arr[i], i, arr);\n  }\n\n  return results;\n};\n/**\n * Returns an array of a given object's own properties.\n *\n * @function Highcharts.keys\n *\n * @param {*} obj\n *        The object of which the properties are to be returned.\n *\n * @return {Array<string>}\n *         An array of strings that represents all the properties.\n */\n\n\nH.keys = function (obj) {\n  return (H.keysPolyfill || Object.keys).call(undefined, obj);\n};\n/**\n * Reduce an array to a single value.\n *\n * @function Highcharts.reduce\n *\n * @param {Array<*>} arr\n *        The array to reduce.\n *\n * @param {Function} fn\n *        The callback function. Return the reduced value. Receives 4\n *        arguments: Accumulated/reduced value, current value, current array\n *        index, and the array.\n *\n * @param {*} initialValue\n *        The initial value of the accumulator.\n *\n * @return {*}\n *         The reduced value.\n */\n\n\nH.reduce = function (arr, func, initialValue) {\n  var fn = H.reducePolyfill || Array.prototype.reduce;\n  return fn.apply(arr, arguments.length > 2 ? [func, initialValue] : [func]);\n};\n/**\n * Get the element's offset position, corrected for `overflow: auto`.\n *\n * @function Highcharts.offset\n *\n * @param {Highcharts.HTMLDOMElement} el\n *        The HTML element.\n *\n * @return {Highcharts.OffsetObject}\n *         An object containing `left` and `top` properties for the position in\n *         the page.\n */\n\n\nH.offset = function (el) {\n  var docElem = doc.documentElement,\n      box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : {\n    top: 0,\n    left: 0\n  };\n  return {\n    top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n    left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n  };\n};\n/**\n * Stop running animation.\n *\n * @function Highcharts.stop\n *\n * @param {Highcharts.SVGElement} el\n *        The SVGElement to stop animation on.\n *\n * @param {string} [prop]\n *        The property to stop animating. If given, the stop method will stop a\n *        single property from animating, while others continue.\n *\n * @todo\n * A possible extension to this would be to stop a single property, when\n * we want to continue animating others. Then assign the prop to the timer\n * in the Fx.run method, and check for the prop here. This would be an\n * improvement in all cases where we stop the animation from .attr. Instead of\n * stopping everything, we can just stop the actual attributes we're setting.\n */\n\n\nH.stop = function (el, prop) {\n  var i = H.timers.length; // Remove timers related to this element (#4519)\n\n  while (i--) {\n    if (H.timers[i].elem === el && (!prop || prop === H.timers[i].prop)) {\n      H.timers[i].stopped = true; // #4667\n    }\n  }\n};\n/**\n * Iterate over an array.\n *\n * @function Highcharts.each<T>\n *\n * @param {Array<T>} arr\n *        The array to iterate over.\n *\n * @param {Highcharts.EachCallbackFunction<T>} fn\n *        The iterator callback. It passes three arguments:\n *        * item - The array item.\n *        * index - The item's index in the array.\n *        * arr - The array that each is being applied to.\n *\n * @param {*} [ctx]\n *        The context.\n */\n\n\nH.each = function (arr, fn, ctx) {\n  // modern browsers\n  return (H.forEachPolyfill || Array.prototype.forEach).call(arr, fn, ctx);\n};\n/**\n * Iterate over object key pairs in an object.\n *\n * @function Highcharts.objectEach\n *\n * @param {*} obj\n *        The object to iterate over.\n *\n * @param {Highcharts.ObjectEachCallbackFunction} fn\n *        The iterator callback. It passes three arguments:\n *        * value - The property value.\n *        * key - The property key.\n *        * obj - The object that objectEach is being applied to.\n *\n * @param {*} [ctx]\n *        The context.\n */\n\n\nH.objectEach = function (obj, fn, ctx) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn.call(ctx || obj[key], obj[key], key, obj);\n    }\n  }\n};\n/**\n * Add an event listener.\n *\n * @function Highcharts.addEvent\n *\n * @param {*} el\n *        The element or object to add a listener to. It can be a\n *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.\n *\n * @param {string} type\n *        The event type.\n *\n * @param {Highcharts.EventCallbackFunction} fn\n *        The function callback to execute when the event is fired.\n *\n * @param {Highcharts.Dictionary<*>} options\n *        Event options\n *\n * @param {number} options.order\n *        The order the event handler should be called. This opens for having\n *        one handler be called before another, independent of in which order\n *        they were added.\n *\n * @return {Function}\n *         A callback function to remove the added event.\n */\n\n\nH.addEvent = function (el, type, fn, options) {\n  var events,\n      addEventListener = el.addEventListener || H.addEventListenerPolyfill; // If we're setting events directly on the constructor, use a separate\n  // collection, `protoEvents` to distinguish it from the item events in\n  // `hcEvents`.\n\n  if (typeof el === 'function' && el.prototype) {\n    events = el.prototype.protoEvents = el.prototype.protoEvents || {};\n  } else {\n    events = el.hcEvents = el.hcEvents || {};\n  } // Allow click events added to points, otherwise they will be prevented by\n  // the TouchPointer.pinch function after a pinch zoom operation (#7091).\n\n\n  if (H.Point && el instanceof H.Point && el.series && el.series.chart) {\n    el.series.chart.runTrackerClick = true;\n  } // Handle DOM events\n\n\n  if (addEventListener) {\n    addEventListener.call(el, type, fn, false);\n  }\n\n  if (!events[type]) {\n    events[type] = [];\n  }\n\n  events[type].push(fn); // Order the calls\n\n  if (options && H.isNumber(options.order)) {\n    fn.order = options.order;\n    events[type].sort(function (a, b) {\n      return a.order - b.order;\n    });\n  } // Return a function that can be called to remove this event.\n\n\n  return function () {\n    H.removeEvent(el, type, fn);\n  };\n};\n/**\n * Remove an event that was added with {@link Highcharts#addEvent}.\n *\n * @function Highcharts.removeEvent\n *\n * @param {*} el\n *        The element to remove events on.\n *\n * @param {string} [type]\n *        The type of events to remove. If undefined, all events are removed\n *        from the element.\n *\n * @param {Function} [fn]\n *        The specific callback to remove. If undefined, all events that match\n *        the element and optionally the type are removed.\n */\n\n\nH.removeEvent = function (el, type, fn) {\n  var events, index;\n\n  function removeOneEvent(type, fn) {\n    var removeEventListener = el.removeEventListener || H.removeEventListenerPolyfill;\n\n    if (removeEventListener) {\n      removeEventListener.call(el, type, fn, false);\n    }\n  }\n\n  function removeAllEvents(eventCollection) {\n    var types, len;\n\n    if (!el.nodeName) {\n      return; // break on non-DOM events\n    }\n\n    if (type) {\n      types = {};\n      types[type] = true;\n    } else {\n      types = eventCollection;\n    }\n\n    H.objectEach(types, function (val, n) {\n      if (eventCollection[n]) {\n        len = eventCollection[n].length;\n\n        while (len--) {\n          removeOneEvent(n, eventCollection[n][len]);\n        }\n      }\n    });\n  }\n\n  H.each(['protoEvents', 'hcEvents'], function (coll) {\n    var eventCollection = el[coll];\n\n    if (eventCollection) {\n      if (type) {\n        events = eventCollection[type] || [];\n\n        if (fn) {\n          index = H.inArray(fn, events);\n\n          if (index > -1) {\n            events.splice(index, 1);\n            eventCollection[type] = events;\n          }\n\n          removeOneEvent(type, fn);\n        } else {\n          removeAllEvents(eventCollection);\n          eventCollection[type] = [];\n        }\n      } else {\n        removeAllEvents(eventCollection);\n        el[coll] = {};\n      }\n    }\n  });\n};\n/**\n * Fire an event that was registered with {@link Highcharts#addEvent}.\n *\n * @function Highcharts.fireEvent\n *\n * @param {*} el\n *        The object to fire the event on. It can be a {@link HTMLDOMElement},\n *        an {@link SVGElement} or any other object.\n *\n * @param {string} type\n *        The type of event.\n *\n * @param {Highcharts.Dictionary<*>} [eventArguments]\n *        Custom event arguments that are passed on as an argument to the event\n *        handler.\n *\n * @param {Function} [defaultFunction]\n *        The default function to execute if the other listeners haven't\n *        returned false.\n */\n\n\nH.fireEvent = function (el, type, eventArguments, defaultFunction) {\n  var e, events, len, i, fn;\n  eventArguments = eventArguments || {};\n\n  if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {\n    e = doc.createEvent('Events');\n    e.initEvent(type, true, true);\n    H.extend(e, eventArguments);\n\n    if (el.dispatchEvent) {\n      el.dispatchEvent(e);\n    } else {\n      el.fireEvent(type, e);\n    }\n  } else {\n    H.each(['protoEvents', 'hcEvents'], function (coll) {\n      if (el[coll]) {\n        events = el[coll][type] || [];\n        len = events.length;\n\n        if (!eventArguments.target) {\n          // We're running a custom event\n          H.extend(eventArguments, {\n            // Attach a simple preventDefault function to skip\n            // default handler if called. The built-in\n            // defaultPrevented property is not overwritable (#5112)\n            preventDefault: function () {\n              eventArguments.defaultPrevented = true;\n            },\n            // Setting target to native events fails with clicking\n            // the zoom-out button in Chrome.\n            target: el,\n            // If the type is not set, we're running a custom event\n            // (#2297). If it is set, we're running a browser event,\n            // and setting it will cause en error in IE8 (#2465).\n            type: type\n          });\n        }\n\n        for (i = 0; i < len; i++) {\n          fn = events[i]; // If the event handler return false, prevent the default\n          // handler from executing\n\n          if (fn && fn.call(el, eventArguments) === false) {\n            eventArguments.preventDefault();\n          }\n        }\n      }\n    });\n  } // Run the default if not prevented\n\n\n  if (defaultFunction && !eventArguments.defaultPrevented) {\n    defaultFunction.call(el, eventArguments);\n  }\n};\n/**\n * The global animate method, which uses Fx to create individual animators.\n *\n * @function Highcharts.animate\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} el\n *        The element to animate.\n *\n * @param {Highcharts.HTMLAttributes|Highcharts.SVGAttributes} params\n *        An object containing key-value pairs of the properties to animate.\n *        Supports numeric as pixel-based CSS properties for HTML objects and\n *        attributes for SVGElements.\n *\n * @param {Highcharts.AnimationOptionsObject} [opt]\n *        Animation options.\n */\n\n\nH.animate = function (el, params, opt) {\n  var start,\n      unit = '',\n      end,\n      fx,\n      args;\n\n  if (!H.isObject(opt)) {\n    // Number or undefined/null\n    args = arguments;\n    opt = {\n      duration: args[2],\n      easing: args[3],\n      complete: args[4]\n    };\n  }\n\n  if (!H.isNumber(opt.duration)) {\n    opt.duration = 400;\n  }\n\n  opt.easing = typeof opt.easing === 'function' ? opt.easing : Math[opt.easing] || Math.easeInOutSine;\n  opt.curAnim = H.merge(params);\n  H.objectEach(params, function (val, prop) {\n    // Stop current running animation of this property\n    H.stop(el, prop);\n    fx = new H.Fx(el, opt, prop);\n    end = null;\n\n    if (prop === 'd') {\n      fx.paths = fx.initPath(el, el.d, params.d);\n      fx.toD = params.d;\n      start = 0;\n      end = 1;\n    } else if (el.attr) {\n      start = el.attr(prop);\n    } else {\n      start = parseFloat(H.getStyle(el, prop)) || 0;\n\n      if (prop !== 'opacity') {\n        unit = 'px';\n      }\n    }\n\n    if (!end) {\n      end = val;\n    }\n\n    if (end && end.match && end.match('px')) {\n      end = end.replace(/px/g, ''); // #4351\n    }\n\n    fx.run(start, end, unit);\n  });\n};\n/**\n * Factory to create new series prototypes.\n *\n * @function Highcharts.seriesType\n *\n * @param {string} type\n *        The series type name.\n *\n * @param {string} parent\n *        The parent series type name. Use `line` to inherit from the basic\n *        {@link Series} object.\n *\n * @param {*} options\n *        The additional default options that is merged with the parent's\n *        options.\n *\n * @param {*} props\n *        The properties (functions and primitives) to set on the new\n *        prototype.\n *\n * @param {*} [pointProps]\n *        Members for a series-specific extension of the {@link Point}\n *        prototype if needed.\n *\n * @return {Highcharts.Series}\n *         The newly created prototype as extended from {@link Series} or its\n *         derivatives.\n */\n// docs: add to API + extending Highcharts\n\n\nH.seriesType = function (type, parent, options, props, pointProps) {\n  var defaultOptions = H.getOptions(),\n      seriesTypes = H.seriesTypes; // Merge the options\n\n  defaultOptions.plotOptions[type] = H.merge(defaultOptions.plotOptions[parent], options); // Create the class\n\n  seriesTypes[type] = H.extendClass(seriesTypes[parent] || function () {}, props);\n  seriesTypes[type].prototype.type = type; // Create the point class if needed\n\n  if (pointProps) {\n    seriesTypes[type].prototype.pointClass = H.extendClass(H.Point, pointProps);\n  }\n\n  return seriesTypes[type];\n};\n/**\n * Get a unique key for using in internal element id's and pointers. The key is\n * composed of a random hash specific to this Highcharts instance, and a\n * counter.\n *\n * @example\n * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'\n *\n * @function Highcharts.uniqueKey\n *\n * @return {string}\n *         A unique key.\n */\n\n\nH.uniqueKey = function () {\n  var uniqueKeyHash = Math.random().toString(36).substring(2, 9),\n      idCounter = 0;\n  return function () {\n    return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;\n  };\n}(); // Register Highcharts as a plugin in jQuery\n\n\nif (win.jQuery) {\n  /**\n   * Highcharts-extended JQuery.\n   *\n   * @external JQuery\n   */\n\n  /**\n   * Factory function to create a chart in the current JQuery selector\n   * element.\n   *\n   * @function external:JQuery#highcharts\n   *\n   * @param {\"Chart\"|\"Map\"|\"StockChart\"|string} [className]\n   *        Name of the factory class in the Highcharts namespace.\n   *\n   * @param {Highcharts.Options} options\n   *        The chart options structure.\n   *\n   * @param {Highcharts.ChartCallbackFunction} [callback]\n   *        Function to run when the chart has loaded and and all external\n   *        images are loaded. Defining a [chart.event.load\n   *        ](https://api.highcharts.com/highcharts/chart.events.load) handler\n   *        is equivalent.\n   *\n   * @return {JQuery}\n   *         The current JQuery selector.\n   */\n  win.jQuery.fn.highcharts = function () {\n    var args = [].slice.call(arguments);\n\n    if (this[0]) {\n      // this[0] is the renderTo div\n      // Create the chart\n      if (args[0]) {\n        new H[// eslint-disable-line no-new\n        // Constructor defaults to Chart\n        H.isString(args[0]) ? args.shift() : 'Chart'](this[0], args[0], args[1]);\n        return this;\n      } // When called without parameters or with the return argument,\n      // return an existing chart\n\n\n      return charts[H.attr(this[0], 'data-highcharts-chart')];\n    }\n  };\n}"
    },
    {
     "id": 238,
     "name": "../node_modules/highcharts/js/es-modules/parts/Series.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Translation and scale for the plot area of a series.\n *\n * @typedef Highcharts.SeriesPlotBoxObject\n *\n * @property {number} translateX\n *\n * @property {number} translateY\n *\n * @property {number} scaleX\n *\n * @property {number} scaleY\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Options.js';\nimport './Legend.js';\nimport './Point.js';\nimport './SvgRenderer.js';\nvar addEvent = H.addEvent,\n    animObject = H.animObject,\n    arrayMax = H.arrayMax,\n    arrayMin = H.arrayMin,\n    correctFloat = H.correctFloat,\n    defaultOptions = H.defaultOptions,\n    defaultPlotOptions = H.defaultPlotOptions,\n    defined = H.defined,\n    each = H.each,\n    erase = H.erase,\n    extend = H.extend,\n    fireEvent = H.fireEvent,\n    grep = H.grep,\n    isArray = H.isArray,\n    isNumber = H.isNumber,\n    isString = H.isString,\n    LegendSymbolMixin = H.LegendSymbolMixin,\n    // @todo add as a requirement\nmerge = H.merge,\n    objectEach = H.objectEach,\n    pick = H.pick,\n    Point = H.Point,\n    // @todo  add as a requirement\nremoveEvent = H.removeEvent,\n    splat = H.splat,\n    SVGElement = H.SVGElement,\n    syncTimeout = H.syncTimeout,\n    win = H.win;\n/**\n * This is the base series prototype that all other series types inherit from.\n * A new series is initialized either through the\n * {@link https://api.highcharts.com/highcharts/series|series}\n * option structure, or after the chart is initialized, through\n * {@link Highcharts.Chart#addSeries}.\n *\n * The object can be accessed in a number of ways. All series and point event\n * handlers give a reference to the `series` object. The chart object has a\n * {@link Highcharts.Chart.series|series} property that is a collection of all\n * the chart's series. The point objects and axis objects also have the same\n * reference.\n *\n * Another way to reference the series programmatically is by `id`. Add an id\n * in the series configuration options, and get the series object by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the series are given in three levels. Options for\n * all series in a chart are given in the\n * {@link https://api.highcharts.com/highcharts/plotOptions.series|\n * plotOptions.series} object. Then options for all series of a specific type\n * are given in the plotOptions of that type, for example `plotOptions.line`.\n * Next, options for one single series are given in the series array, or as\n * arguements to `chart.addSeries`.\n *\n * The data in the series is stored in various arrays.\n *\n * - First, `series.options.data` contains all the original config options for\n *   each point whether added by options or methods like `series.addPoint`.\n *\n * - Next, `series.data` contains those values converted to points, but in case\n *   the series data length exceeds the `cropThreshold`, or if the data is\n *   grouped, `series.data` doesn't contain all the points. It only contains the\n *   points that have been created on demand.\n *\n * - Then there's `series.points` that contains all currently visible point\n *   objects. In case of cropping, the cropped-away points are not part of this\n *   array. The `series.points` array starts at `series.cropStart` compared to\n *   `series.data` and `series.options.data`. If however the series data is\n *   grouped, these can't be correlated one to one.\n *\n * - `series.xData` and `series.processedXData` contain clean x values,\n *   equivalent to `series.data` and `series.points`.\n *\n * - `series.yData` and `series.processedYData` contain clean y values,\n *   equivalent to `series.data` and `series.points`.\n *\n * @class\n * @name Highcharts.Series\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @param {Highcharts.PlotSeriesOptions} options\n *        The series options.\n */\n\n/**\n* The line series is the base type and is therefor the series base prototype.\n*\n* @private\n* @class\n* @name Highcharts.seriesTypes.line\n*\n* @augments Highcharts.Series\n*/\n\nH.Series = H.seriesType('line', null\n/**\n * General options for all series types.\n *\n * @optionparent plotOptions.series\n */\n, {\n  // base series options\n\n  /**\n   * For some series, there is a limit that shuts down initial animation\n   * by default when the total number of points in the chart is too high.\n   * For example, for a column chart and its derivatives, animation doesn't\n   * run if there is more than 250 points totally. To disable this cap, set\n   * `animationLimit` to `Infinity`.\n   *\n   * @type      {number}\n   * @apioption plotOptions.series.animationLimit\n   */\n\n  /**\n   * Allow this series' points to be selected by clicking on the graphic\n   * (columns, point markers, pie slices, map areas etc).\n   *\n   * @see {@link Highcharts.Chart#getSelectedPoints}.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/\n   *         Line\n   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/\n   *         Column\n   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/\n   *         Pie\n   * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n   *         Map area\n   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/\n   *         Map bubble\n   *\n   * @since 1.2.0\n   */\n  allowPointSelect: false,\n\n  /**\n   * If true, a checkbox is displayed next to the legend item to allow\n   * selecting the series. The state of the checkbox is determined by\n   * the `selected` option.\n   *\n   * @productdesc {highmaps}\n   * Note that if a `colorAxis` is defined, the color axis is represented in\n   * the legend, not the series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/\n   *         Show select box\n   *\n   * @since 1.2.0\n   */\n  showCheckbox: false,\n\n  /**\n   * Enable or disable the initial animation when a series is displayed.\n   * The animation can also be set as a configuration object. Please\n   * note that this option only applies to the initial animation of the\n   * series itself. For other animations, see [chart.animation](\n   * #chart.animation) and the animation parameter under the API methods. The\n   * following properties are supported:\n   *\n   * <dl>\n   *\n   * <dt>duration</dt>\n   *\n   * <dd>The duration of the animation in milliseconds.</dd>\n   *\n   * <dt>easing</dt>\n   *\n   * <dd>Can be a string reference to an easing function set on the `Math`\n   * object or a function. See the _Custom easing function_ demo below.</dd>\n   *\n   * </dl>\n   *\n   * Due to poor performance, animation is disabled in old IE browsers\n   * for several chart types.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/\n   *         Animation disabled\n   * @sample {highcharts} highcharts/plotoptions/series-animation-slower/\n   *         Slower animation\n   * @sample {highcharts} highcharts/plotoptions/series-animation-easing/\n   *         Custom easing function\n   * @sample {highstock} stock/plotoptions/animation-slower/\n   *         Slower animation\n   * @sample {highstock} stock/plotoptions/animation-easing/\n   *         Custom easing function\n   * @sample {highmaps} maps/plotoptions/series-animation-true/\n   *         Animation enabled on map series\n   * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/\n   *         Disabled on mapbubble series\n   *\n   * @type    {boolean|Highcharts.AnimationOptionsObject}\n   * @default {highcharts} true\n   * @default {highstock} true\n   * @default {highmaps} false\n   */\n  animation: {\n    /**\n     * @type      {number}\n     * @default   1000\n     * @apioption plotOptions.series.animation.duration\n     */\n    duration: 1000\n  },\n\n  /**\n   * An additional class name to apply to the series' graphical elements. This\n   * option does not replace default class names of the graphical element.\n   *\n   * @type      {string}\n   * @since     5.0.0\n   * @apioption plotOptions.series.className\n   */\n\n  /**\n   * Disable this option to allow series rendering in the whole plotting\n   * area.\n   *\n   * **Note:** Clipping should be always enabled when\n   * [chart.zoomType](#chart.zoomType) is set\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-clip/\n   *         Disabled clipping\n   *\n   * @default   true\n   * @type      {boolean}\n   * @since     3.0.0\n   * @apioption plotOptions.series.clip\n   */\n\n  /**\n   * The main color of the series. In line type series it applies to the\n   * line and the point markers unless otherwise specified. In bar type\n   * series it applies to the bars unless a color is specified per point.\n   * The default value is pulled from the `options.colors` array.\n   *\n   * In styled mode, the color can be defined by the\n   * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series\n   * color can be set with the `.highcharts-series`, `.highcharts-color-{n}`,\n   * `.highcharts-{type}-series` or `.highcharts-series-{n}` class, or\n   * individual classes given by the `className` option.\n   *\n   * @productdesc {highmaps}\n   * In maps, the series color is rarely used, as most choropleth maps use the\n   * color to denote the value of each point. The series color can however be\n   * used in a map with multiple series holding categorized data.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-color-general/\n   *         General plot option\n   * @sample {highcharts} highcharts/plotoptions/series-color-specific/\n   *         One specific series\n   * @sample {highcharts} highcharts/plotoptions/series-color-area/\n   *         Area color\n   * @sample {highcharts} highcharts/series/infographic/\n   *         Pattern fill\n   * @sample {highmaps} maps/demo/category-map/\n   *         Category map by multiple series\n   *\n   * @type      {Highcharts.ColorString}\n   * @apioption plotOptions.series.color\n   */\n\n  /**\n   * Styled mode only. A specific color index to use for the series, so its\n   * graphic representations are given the class name `highcharts-color-{n}`.\n   *\n   * @type      {number}\n   * @since     5.0.0\n   * @apioption plotOptions.series.colorIndex\n   */\n\n  /**\n   * Whether to connect a graph line across null points, or render a gap\n   * between the two points on either side of the null.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/\n   *         False by default\n   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/\n   *         True\n   *\n   * @type      {boolean}\n   * @default   false\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.connectNulls\n   */\n\n  /**\n   * You can set the cursor to \"pointer\" if you have click events attached\n   * to the series, to signal to the user that the points and lines can\n   * be clicked.\n   *\n   * In styled mode, the series cursor can be set with the same classes\n   * as listed under [series.color](#plotOptions.series.color).\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-cursor-line/\n   *         On line graph\n   * @sample {highcharts} highcharts/plotoptions/series-cursor-column/\n   *         On columns\n   * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/\n   *         On scatter markers\n   * @sample {highstock} stock/plotoptions/cursor/\n   *         Pointer on a line graph\n   * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n   *         Map area\n   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/\n   *         Map bubble\n   *\n   * @type       {string}\n   * @validvalue [\"crosshair\",\"default\",\"help\",\"none\",\"pointer\"]\n   * @apioption  plotOptions.series.cursor\n   */\n\n  /**\n   * A name for the dash style to use for the graph, or for some series types\n   * the outline of each shape.\n   *\n   * In styled mode, the [stroke dash-array](https://jsfiddle.net/gh/get/\n   * library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/\n   * series-dashstyle/) can be set with the same classes as listed under\n   * [series.color](#plotOptions.series.color).\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/\n   *         Possible values demonstrated\n   * @sample {highcharts} highcharts/plotoptions/series-dashstyle/\n   *         Chart suitable for printing in black and white\n   * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/\n   *         Possible values demonstrated\n   * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/\n   *         Possible values demonstrated\n   * @sample {highmaps} maps/plotoptions/series-dashstyle/\n   *         Dotted borders on a map\n   *\n   * @type       {string}\n   * @default    Solid\n   * @since      2.1\n   * @validvalue [\"Dash\",\"DashDot\",\"Dot\",\"LongDash\",\"LongDashDot\",\n   *             \"LongDashDotDot\",\"ShortDash\",\"ShortDashDot\",\n   *             \"ShortDashDotDot\",\"ShortDot\",\"Solid\"]\n   * @apioption  plotOptions.series.dashStyle\n   */\n\n  /**\n   * Requires the Accessibility module.\n   *\n   * A description of the series to add to the screen reader information\n   * about the series.\n   *\n   * @type      {string}\n   * @since     5.0.0\n   * @apioption plotOptions.series.description\n   */\n\n  /**\n   * Enable or disable the mouse tracking for a specific series. This\n   * includes point tooltips and click events on graphs and points. For\n   * large datasets it improves performance.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/\n   *         No mouse tracking\n   * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/\n   *         No mouse tracking\n   *\n   * @type      {boolean}\n   * @default   true\n   * @apioption plotOptions.series.enableMouseTracking\n   */\n\n  /**\n   * By default, series are exposed to screen readers as regions. By enabling\n   * this option, the series element itself will be exposed in the same\n   * way as the data points. This is useful if the series is not used\n   * as a grouping entity in the chart, but you still want to attach a\n   * description to the series.\n   *\n   * Requires the Accessibility module.\n   *\n   * @sample highcharts/accessibility/art-grants/\n   *         Accessible data visualization\n   *\n   * @type      {boolean}\n   * @since     5.0.12\n   * @apioption plotOptions.series.exposeElementToA11y\n   */\n\n  /**\n   * Whether to use the Y extremes of the total chart width or only the\n   * zoomed area when zooming in on parts of the X axis. By default, the\n   * Y axis adjusts to the min and max of the visible data. Cartesian\n   * series only.\n   *\n   * @type      {boolean}\n   * @default   false\n   * @since     4.1.6\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.getExtremesFromAll\n   */\n\n  /**\n   * An array specifying which option maps to which key in the data point\n   * array. This makes it convenient to work with unstructured data arrays\n   * from different sources.\n   *\n   * @see [series.data](#series.line.data)\n   *\n   * @sample {highcharts|highstock} highcharts/series/data-keys/\n   *         An extended data array with keys\n   * @sample {highcharts|highstock} highcharts/series/data-nested-keys/\n   *         Nested keys used to access object properties\n   *\n   * @type      {Array<string>}\n   * @since     4.1.6\n   * @apioption plotOptions.series.keys\n   */\n\n  /**\n   * The line cap used for line ends and line joins on the graph.\n   *\n   * @type       {string}\n   * @product    highcharts highstock\n   * @validvalue [\"round\", \"square\"]\n   * @apioption  plotOptions.series.linecap\n   */\n\n  /**\n   * The [id](#series.id) of another series to link to. Additionally,\n   * the value can be \":previous\" to link to the previous series. When\n   * two series are linked, only the first one appears in the legend.\n   * Toggling the visibility of this also toggles the linked series.\n   *\n   * @sample {highcharts|highstock} highcharts/demo/arearange-line/\n   *         Linked series\n   *\n   * @type      {string}\n   * @since     3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.linkedTo\n   */\n\n  /**\n   * Options for the corresponding navigator series if `showInNavigator`\n   * is `true` for this series. Available options are the same as any\n   * series, documented at [plotOptions](#plotOptions.series) and\n   * [series](#series).\n   *\n   * These options are merged with options in [navigator.series](\n   * #navigator.series), and will take precedence if the same option is\n   * defined both places.\n   *\n   * @see [navigator.series](#navigator.series)\n   *\n   * @type      {*}\n   * @since     5.0.0\n   * @product   highstock\n   * @apioption plotOptions.series.navigatorOptions\n   */\n\n  /**\n   * The color for the parts of the graph or points that are below the\n   * [threshold](#plotOptions.series.threshold).\n   *\n   * @see In styled mode, a negative color is applied by setting this option\n   *      to `true` combined with the `.highcharts-negative` class name.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-negative-color/\n   *         Spline, area and column\n   * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/\n   *         Arearange\n   * @sample {highcharts} highcharts/css/series-negative-color/\n   *         Styled mode\n   * @sample {highstock} highcharts/plotoptions/series-negative-color/\n   *         Spline, area and column\n   * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/\n   *         Arearange\n   * @sample {highmaps} highcharts/plotoptions/series-negative-color/\n   *         Spline, area and column\n   * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/\n   *         Arearange\n   *\n   * @type      {Highcharts.ColorString}\n   * @since     3.0\n   * @apioption plotOptions.series.negativeColor\n   */\n\n  /**\n   * Same as [accessibility.pointDescriptionFormatter](\n   * #accessibility.pointDescriptionFormatter), but for an individual series.\n   * Overrides the chart wide configuration.\n   *\n   * @type      {Function}\n   * @since     5.0.12\n   * @apioption plotOptions.series.pointDescriptionFormatter\n   */\n\n  /**\n   * If no x values are given for the points in a series, `pointInterval`\n   * defines the interval of the x values. For example, if a series contains\n   * one value every decade starting from year 0, set `pointInterval` to\n   * `10`. In true `datetime` axes, the `pointInterval` is set in\n   * milliseconds.\n   *\n   * It can be also be combined with `pointIntervalUnit` to draw irregular\n   * time intervals.\n   *\n   * Please note that this options applies to the _series data_, not the\n   * interval of the axis ticks, which is independent.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/\n   *         Datetime X axis\n   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/\n   *         Using pointStart and pointInterval\n   *\n   * @type      {number}\n   * @default   1\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.pointInterval\n   */\n\n  /**\n   * On datetime series, this allows for setting the\n   * [pointInterval](#plotOptions.series.pointInterval) to irregular time\n   * units, `day`, `month` and `year`. A day is usually the same as 24 hours,\n   * but `pointIntervalUnit` also takes the DST crossover into consideration\n   * when dealing with local time. Combine this option with `pointInterval`\n   * to draw weeks, quarters, 6 months, 10 years etc.\n   *\n   * Please note that this options applies to the _series data_, not the\n   * interval of the axis ticks, which is independent.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/\n   *         One point a month\n   * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/\n   *         One point a month\n   *\n   * @type       {string}\n   * @since      4.1.0\n   * @product    highcharts highstock\n   * @validvalue [\"day\", \"month\", \"year\"]\n   * @apioption  plotOptions.series.pointIntervalUnit\n   */\n\n  /**\n   * Possible values: `\"on\"`, `\"between\"`, `number`.\n   *\n   * In a column chart, when pointPlacement is `\"on\"`, the point will\n   * not create any padding of the X axis. In a polar column chart this\n   * means that the first column points directly north. If the pointPlacement\n   * is `\"between\"`, the columns will be laid out between ticks. This\n   * is useful for example for visualising an amount between two points\n   * in time or in a certain sector of a polar chart.\n   *\n   * Since Highcharts 3.0.2, the point placement can also be numeric,\n   * where 0 is on the axis value, -0.5 is between this value and the\n   * previous, and 0.5 is between this value and the next. Unlike the\n   * textual options, numeric point placement options won't affect axis\n   * padding.\n   *\n   * Note that pointPlacement needs a [pointRange](\n   * #plotOptions.series.pointRange) to work. For column series this is\n   * computed, but for line-type series it needs to be set.\n   *\n   * Defaults to `undefined` in cartesian charts, `\"between\"` in polar charts.\n   *\n   * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)\n   *\n   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/\n   *         Between in a column chart\n   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/\n   *         Numeric placement for custom layout\n   *\n   * @type      {string|number}\n   * @since     2.3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.pointPlacement\n   */\n\n  /**\n   * If no x values are given for the points in a series, pointStart defines\n   * on what value to start. For example, if a series contains one yearly\n   * value starting from 1945, set pointStart to 1945.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/\n   *         Linear\n   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/\n   *         Datetime\n   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/\n   *         Using pointStart and pointInterval\n   *\n   * @type      {number}\n   * @default   0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.pointStart\n   */\n\n  /**\n   * Whether to select the series initially. If `showCheckbox` is true,\n   * the checkbox next to the series name in the legend will be checked for a\n   * selected series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-selected/\n   *         One out of two series selected\n   *\n   * @type      {boolean}\n   * @default   false\n   * @since     1.2.0\n   * @apioption plotOptions.series.selected\n   */\n\n  /**\n   * Whether to apply a drop shadow to the graph line. Since 2.3 the shadow\n   * can be an object configuration containing `color`, `offsetX`, `offsetY`,\n   * `opacity` and `width`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-shadow/\n   *         Shadow enabled\n   *\n   * @type      {boolean|Highcharts.ShadowOptionsObject}\n   * @default   false\n   * @apioption plotOptions.series.shadow\n   */\n\n  /**\n   * Whether to display this particular series or series type in the legend.\n   * The default value is `true` for standalone series, `false` for linked\n   * series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-showinlegend/\n   *         One series in the legend, one hidden\n   *\n   * @type      {boolean}\n   * @default   true\n   * @apioption plotOptions.series.showInLegend\n   */\n\n  /**\n   * Whether or not to show the series in the navigator. Takes precedence\n   * over [navigator.baseSeries](#navigator.baseSeries) if defined.\n   *\n   * @type      {boolean}\n   * @since     5.0.0\n   * @product   highstock\n   * @apioption plotOptions.series.showInNavigator\n   */\n\n  /**\n   * If set to `true`, the accessibility module will skip past the points\n   * in this series for keyboard navigation.\n   *\n   * @type      {boolean}\n   * @since     5.0.12\n   * @apioption plotOptions.series.skipKeyboardNavigation\n   */\n\n  /**\n   * Whether to stack the values of each series on top of each other. Possible\n   * values are `undefined` to disable, `\"normal\"` to stack by value or\n   * `\"percent\"`. When stacking is enabled, data must be sorted in ascending\n   * X order. A special stacking option is with the streamgraph series type,\n   * where the stacking option is set to `\"stream\"`.\n   *\n   * @see [yAxis.reversedStacks](#yAxis.reversedStacks)\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-line/\n   *         Line\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-column/\n   *         Column\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/\n   *         Bar\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-area/\n   *         Area\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/\n   *         Line\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/\n   *         Column\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/\n   *         Bar\n   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/\n   *         Area\n   * @sample {highstock} stock/plotoptions/stacking/\n   *         Area\n   *\n   * @type       {string}\n   * @product    highcharts highstock\n   * @validvalue [\"normal\", \"percent\"]\n   * @apioption  plotOptions.series.stacking\n   */\n\n  /**\n   * Whether to apply steps to the line. Possible values are `left`, `center`\n   * and `right`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/line-step/\n   *         Different step line options\n   * @sample {highcharts} highcharts/plotoptions/area-step/\n   *         Stepped, stacked area\n   * @sample {highstock} stock/plotoptions/line-step/\n   *         Step line\n   *\n   * @type       {string}\n   * @since      1.2.5\n   * @product    highcharts highstock\n   * @validvalue [\"left\", \"center\", \"right\"]\n   * @apioption  plotOptions.series.step\n   */\n\n  /**\n   * The threshold, also called zero level or base level. For line type\n   * series this is only used in conjunction with\n   * [negativeColor](#plotOptions.series.negativeColor).\n   *\n   * @see [softThreshold](#plotOptions.series.softThreshold).\n   *\n   * @type      {number}\n   * @default   0\n   * @since     3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.threshold\n   */\n\n  /**\n   * Set the initial visibility of the series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-visible/\n   *         Two series, one hidden and one visible\n   * @sample {highstock} stock/plotoptions/series-visibility/\n   *         Hidden series\n   *\n   * @type      {boolean}\n   * @default   true\n   * @apioption plotOptions.series.visible\n   */\n\n  /**\n   * Defines the Axis on which the zones are applied.\n   *\n   * @see [zones](#plotOptions.series.zones)\n   *\n   * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/\n   *         Zones on the X-Axis\n   * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/\n   *         Zones on the X-Axis\n   *\n   * @type      {string}\n   * @default   y\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zoneAxis\n   */\n\n  /**\n   * General event handlers for the series items. These event hooks can also\n   * be attached to the series at run time using the `Highcharts.addEvent`\n   * function.\n   */\n  events: {},\n\n  /**\n   * Fires after the series has finished its initial animation, or in\n   * case animation is disabled, immediately as the series is displayed.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/\n   *         Show label after animate\n   * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/\n   *         Show label after animate\n   *\n   * @type      {Function}\n   * @since     4.0\n   * @product   highcharts highstock\n   * @context   Series\n   * @apioption plotOptions.series.events.afterAnimate\n   */\n\n  /**\n   * Fires when the checkbox next to the series' name in the legend is\n   * clicked. One parameter, `event`, is passed to the function. The state\n   * of the checkbox is found by `event.checked`. The checked item is\n   * found by `event.item`. Return `false` to prevent the default action\n   * which is to toggle the select state of the series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/\n   *         Alert checkbox status\n   *\n   * @type      {Function}\n   * @since     1.2.0\n   * @context   Series\n   * @apioption plotOptions.series.events.checkboxClick\n   */\n\n  /**\n   * Fires when the series is clicked. One parameter, `event`, is passed to\n   * the function, containing common event information. Additionally,\n   * `event.point` holds a pointer to the nearest point on the graph.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-click/\n   *         Alert click info\n   * @sample {highstock} stock/plotoptions/series-events-click/\n   *         Alert click info\n   * @sample {highmaps} maps/plotoptions/series-events-click/\n   *         Display click info in subtitle\n   *\n   * @type      {Function}\n   * @context   Series\n   * @apioption plotOptions.series.events.click\n   */\n\n  /**\n   * Fires when the series is hidden after chart generation time, either\n   * by clicking the legend item or by calling `.hide()`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-hide/\n   *         Alert when the series is hidden by clicking the legend item\n   *\n   * @type      {Function}\n   * @since     1.2.0\n   * @context   Series\n   * @apioption plotOptions.series.events.hide\n   */\n\n  /**\n   * Fires when the legend item belonging to the series is clicked. One\n   * parameter, `event`, is passed to the function. The default action\n   * is to toggle the visibility of the series. This can be prevented\n   * by returning `false` or calling `event.preventDefault()`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-legenditemclick/\n   *         Confirm hiding and showing\n   *\n   * @type      {Function}\n   * @context   Series\n   * @apioption plotOptions.series.events.legendItemClick\n   */\n\n  /**\n   * Fires when the mouse leaves the graph. One parameter, `event`, is\n   * passed to the function, containing common event information. If the\n   * [stickyTracking](#plotOptions.series) option is true, `mouseOut`\n   * doesn't happen before the mouse enters another graph or leaves the\n   * plot area.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/\n   *         With sticky tracking by default\n   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/\n   *         Without sticky tracking\n   *\n   * @type      {Function}\n   * @context   Series\n   * @apioption plotOptions.series.events.mouseOut\n   */\n\n  /**\n   * Fires when the mouse enters the graph. One parameter, `event`, is\n   * passed to the function, containing common event information.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/\n   *         With sticky tracking by default\n   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/\n   *         Without sticky tracking\n   *\n   * @type      {Function}\n   * @context   Series\n   * @apioption plotOptions.series.events.mouseOver\n   */\n\n  /**\n   * Fires when the series is shown after chart generation time, either\n   * by clicking the legend item or by calling `.show()`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-events-show/\n   *         Alert when the series is shown by clicking the legend item.\n   *\n   * @type      {Function}\n   * @since     1.2.0\n   * @context   Series\n   * @apioption plotOptions.series.events.show\n   */\n\n  /**\n   * Options for the point markers of line-like series. Properties like\n   * `fillColor`, `lineColor` and `lineWidth` define the visual appearance\n   * of the markers. Other series types, like column series, don't have\n   * markers, but have visual options on the series level instead.\n   *\n   * In styled mode, the markers can be styled with the `.highcharts-point`,\n   * `.highcharts-point-hover` and `.highcharts-point-select`\n   * class names.\n   */\n  marker: {\n    /**\n     * Enable or disable the point marker. If `undefined`, the markers are\n     * hidden when the data is dense, and shown for more widespread data\n     * points.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/\n     *         Disabled markers\n     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/\n     *         Disabled in normal state but enabled on hover\n     * @sample {highstock} stock/plotoptions/series-marker/\n     *         Enabled markers\n     *\n     * @type      {boolean}\n     * @default   {highcharts} undefined\n     * @default   {highstock} false\n     * @apioption plotOptions.series.marker.enabled\n     */\n\n    /**\n     * Image markers only. Set the image width explicitly. When using this\n     * option, a `width` must also be set.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/\n     *         Fixed width and height\n     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/\n     *         Fixed width and height\n     *\n     * @type      {number}\n     * @since     4.0.4\n     * @apioption plotOptions.series.marker.height\n     */\n\n    /**\n     * A predefined shape or symbol for the marker. When undefined, the\n     * symbol is pulled from options.symbols. Other possible values are\n     * \"circle\", \"square\", \"diamond\", \"triangle\" and \"triangle-down\".\n     *\n     * Additionally, the URL to a graphic can be given on this form:\n     * \"url(graphic.png)\". Note that for the image to be applied to exported\n     * charts, its URL needs to be accessible by the export server.\n     *\n     * Custom callbacks for symbol path generation can also be added to\n     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n     * used by its method name, as shown in the demo.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/\n     *         Predefined, graphic and custom markers\n     * @sample {highstock} highcharts/plotoptions/series-marker-symbol/\n     *         Predefined, graphic and custom markers\n     *\n     * @type      {string}\n     * @apioption plotOptions.series.marker.symbol\n     */\n\n    /**\n     * The threshold for how dense the point markers should be before they\n     * are hidden, given that `enabled` is not defined. The number indicates\n     * the horizontal distance between the two closest points in the series,\n     * as multiples of the `marker.radius`. In other words, the default\n     * value of 2 means points are hidden if overlapping horizontally.\n     *\n     * @sample highcharts/plotoptions/series-marker-enabledthreshold\n     *         A higher threshold\n     *\n     * @since 6.0.5\n     */\n    enabledThreshold: 2,\n\n    /**\n     * The radius of the point marker.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-radius/\n     *         Bigger markers\n     */\n    radius: 4,\n\n    /**\n     * Image markers only. Set the image width explicitly. When using this\n     * option, a `height` must also be set.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/\n     *         Fixed width and height\n     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/\n     *         Fixed width and height\n     *\n     * @type      {number}\n     * @since     4.0.4\n     * @apioption plotOptions.series.marker.width\n     */\n\n    /**\n     * States for a single point marker.\n     */\n    states: {\n      /**\n       * The normal state of a single point marker. Currently only used\n       * for setting animation when returning to normal state from hover.\n       */\n      normal: {\n        /**\n         * Animation when returning to normal state after hovering.\n         *\n         * @type {boolean|Highcharts.AnimationOptionsObject}\n         */\n        animation: true\n      },\n\n      /**\n       * The hover state for a single point marker.\n       */\n      hover: {\n        /**\n         * Animation when hovering over the marker.\n         *\n         * @type {boolean|Highcharts.AnimationOptionsObject}\n         */\n        animation: {\n          duration: 50\n        },\n\n        /**\n         * Enable or disable the point marker.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/\n         *         Disabled hover state\n         */\n        enabled: true,\n\n        /**\n         * The fill color of the marker in hover state. When\n         * `undefined`, the series' or point's fillColor for normal\n         * state is used.\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption plotOptions.series.marker.states.hover.fillColor\n         */\n\n        /**\n         * The color of the point marker's outline. When `undefined`,\n         * the series' or point's lineColor for normal state is used.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/\n         *         White fill color, black line color\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption plotOptions.series.marker.states.hover.lineColor\n         */\n\n        /**\n         * The width of the point marker's outline. When `undefined`,\n         * the series' or point's lineWidth for normal state is used.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/\n         *         3px line width\n         *\n         * @type      {number}\n         * @apioption plotOptions.series.marker.states.hover.lineWidth\n         */\n\n        /**\n         * The radius of the point marker. In hover state, it defaults\n         * to the normal state's radius + 2 as per the [radiusPlus](\n         * #plotOptions.series.marker.states.hover.radiusPlus)\n         * option.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/\n         *         10px radius\n         *\n         * @type      {number}\n         * @apioption plotOptions.series.marker.states.hover.radius\n         */\n\n        /**\n         * The number of pixels to increase the radius of the hovered\n         * point.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/\n         *         5 pixels greater radius on hover\n         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/\n         *         5 pixels greater radius on hover\n         *\n         * @since 4.0.3\n         */\n        radiusPlus: 2\n      }\n    }\n  },\n\n  /**\n   * Properties for each single point.\n   */\n  point: {\n    /**\n     * Fires when a point is clicked. One parameter, `event`, is passed\n     * to the function, containing common event information.\n     *\n     * If the `series.allowPointSelect` option is true, the default\n     * action for the point's click event is to toggle the point's\n     * select state. Returning `false` cancels this action.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-click/\n     *         Click marker to alert values\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/\n     *         Click column\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/\n     *         Go to URL\n     * @sample {highmaps} maps/plotoptions/series-point-events-click/\n     *         Click marker to display values\n     * @sample {highmaps} maps/plotoptions/series-point-events-click-url/\n     *         Go to URL\n     *\n     * @type      {Function}\n     * @context   Point\n     * @apioption plotOptions.series.point.events.click\n     */\n\n    /**\n     * Fires when the mouse leaves the area close to the point. One\n     * parameter, `event`, is passed to the function, containing common\n     * event information.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/\n     *         Show values in the chart's corner on mouse over\n     *\n     * @type      {Function}\n     * @context   Point\n     * @apioption plotOptions.series.point.events.mouseOut\n     */\n\n    /**\n     * Fires when the mouse enters the area close to the point. One\n     * parameter, `event`, is passed to the function, containing common\n     * event information.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/\n     *         Show values in the chart's corner on mouse over\n     *\n     * @type      {Function}\n     * @context   Point\n     * @apioption plotOptions.series.point.events.mouseOver\n     */\n\n    /**\n     * Fires when the point is removed using the `.remove()` method. One\n     * parameter, `event`, is passed to the function. Returning `false`\n     * cancels the operation.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/\n     *         Remove point and confirm\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Point\n     * @apioption plotOptions.series.point.events.remove\n     */\n\n    /**\n     * Fires when the point is selected either programmatically or\n     * following a click on the point. One parameter, `event`, is passed\n     * to the function. Returning `false` cancels the operation.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-select/\n     *         Report the last selected point\n     * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n     *         Report select and unselect\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Point\n     * @apioption plotOptions.series.point.events.select\n     */\n\n    /**\n     * Fires when the point is unselected either programmatically or\n     * following a click on the point. One parameter, `event`, is passed\n     * to the function.\n     *  Returning `false` cancels the operation.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/\n     *         Report the last unselected point\n     * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n     *         Report select and unselect\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Point\n     * @apioption plotOptions.series.point.events.unselect\n     */\n\n    /**\n     * Fires when the point is updated programmatically through the\n     * `.update()` method. One parameter, `event`, is passed to the\n     * function. The new point options can be accessed through\n     * `event.options`. Returning `false` cancels the operation.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-point-events-update/\n     *         Confirm point updating\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Point\n     * @apioption plotOptions.series.point.events.update\n     */\n\n    /**\n     * Events for each single point.\n     */\n    events: {}\n  },\n\n  /**\n   * Options for the series data labels, appearing next to each data point.\n   *\n   * In styled mode, the data labels can be styled with the\n   * `.highcharts-data-label-box` and `.highcharts-data-label` class names\n   * ([see example](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-datalabels)).\n   */\n  dataLabels: {\n    /**\n     * The alignment of the data label compared to the point. If `right`,\n     * the right side of the label should be touching the point. For\n     * points with an extent, like columns, the alignments also dictates\n     * how to align it inside the box, as given with the\n     * [inside](#plotOptions.column.dataLabels.inside) option. Can be one of\n     * `left`, `center` or `right`.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/\n     *         Left aligned\n     *\n     * @validvalue [\"left\", \"center\", \"right\"]\n     */\n    align: 'center',\n\n    /**\n     * Whether to allow data labels to overlap. To make the labels less\n     * sensitive for overlapping, the [dataLabels.padding](\n     * #plotOptions.series.dataLabels.padding) can be set to 0.\n     *\n     * @sample highcharts/plotoptions/series-datalabels-allowoverlap-false/\n     *         Don't allow overlap\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     4.1.0\n     * @apioption plotOptions.series.dataLabels.allowOverlap\n     */\n\n    /**\n     * The border radius in pixels for the data label.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     * @sample {highstock} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     * @sample {highmaps} maps/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     *\n     * @type      {number}\n     * @default   0\n     * @since     2.2.1\n     * @apioption plotOptions.series.dataLabels.borderRadius\n     */\n\n    /**\n     * The border width in pixels for the data label.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     * @sample {highstock} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     *\n     * @type      {number}\n     * @default   0\n     * @since     2.2.1\n     * @apioption plotOptions.series.dataLabels.borderWidth\n     */\n\n    /**\n     * A class name for the data label. Particularly in styled mode, this\n     * can be used to give each series' or point's data label unique\n     * styling. In addition to this option, a default color class name is\n     * added so that we can give the labels a\n     * [contrast text shadow](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/data-label-contrast/).\n     *\n     * @sample {highcharts} highcharts/css/series-datalabels/\n     *         Styling by CSS\n     * @sample {highstock} highcharts/css/series-datalabels/\n     *         Styling by CSS\n     * @sample {highmaps} highcharts/css/series-datalabels/\n     *         Styling by CSS\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption plotOptions.series.dataLabels.className\n     */\n\n    /**\n     * The text color for the data labels. Defaults to `undefined`. For\n     * certain series types, like column or map, the data labels can be\n     * drawn inside the points. In this case the data label will be drawn\n     * with maximum contrast by default. Additionally, it will be given a\n     * `text-outline` style with the opposite color, to further increase the\n     * contrast. This can be overridden by setting the `text-outline` style\n     * to `none` in the `dataLabels.style` option.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/\n     *         Red data labels\n     * @sample {highmaps} maps/demo/color-axis/\n     *         White data labels\n     *\n     * @type      {Highcharts.ColorString}\n     * @apioption plotOptions.series.dataLabels.color\n     */\n\n    /**\n     * Whether to hide data labels that are outside the plot area. By\n     * default, the data label is moved inside the plot area according to\n     * the [overflow](#plotOptions.series.dataLabels.overflow) option.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     2.3.3\n     * @apioption plotOptions.series.dataLabels.crop\n     */\n\n    /**\n     * Whether to defer displaying the data labels until the initial series\n     * animation has finished.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.dataLabels.defer\n     */\n\n    /**\n     * Enable or disable the data labels.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/\n     *         Data labels enabled\n     * @sample {highmaps} maps/demo/color-axis/\n     *         Data labels enabled\n     *\n     * @type      {boolean}\n     * @default   false\n     * @apioption plotOptions.series.dataLabels.enabled\n     */\n\n    /**\n     * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)\n     * for the data label. Available variables are the same as for\n     * `formatter`.\n     *\n     * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-format/\n     *         Add a unit\n     * @sample {highmaps} maps/plotoptions/series-datalabels-format/\n     *         Formatted value in the data label\n     *\n     * @type      {string}\n     * @default   {highcharts} {y}\n     * @default   {highstock} {y}\n     * @default   {highmaps} {point.value}\n     * @since     3.0\n     * @apioption plotOptions.series.dataLabels.format\n     */\n\n    /**\n     * Callback JavaScript function to format the data label. Note that if a\n     * `format` is defined, the format takes precedence and the formatter is\n     * ignored. Available data are:\n     *\n     * <table>\n     *\n     * <tbody>\n     *\n     * <tr>\n     *\n     * <td>`this.percentage`</td>\n     *\n     * <td>Stacked series and pies only. The point's percentage of the\n     * total.</td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.point`</td>\n     *\n     * <td>The point object. The point name, if defined, is available\n     * through `this.point.name`.</td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.series`:</td>\n     *\n     * <td>The series object. The series name is available through\n     * `this.series.name`.</td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.total`</td>\n     *\n     * <td>Stacked series only. The total value at this point's x value.\n     * </td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.x`:</td>\n     *\n     * <td>The x value.</td>\n     *\n     * </tr>\n     *\n     * <tr>\n     *\n     * <td>`this.y`:</td>\n     *\n     * <td>The y value.</td>\n     *\n     * </tr>\n     *\n     * </tbody>\n     *\n     * </table>\n     *\n     * @sample {highmaps} maps/plotoptions/series-datalabels-format/\n     *         Formatted value\n     *\n     * @type    {Highcharts.FormatterCallbackFunction}\n     * @default function () { return this.y; }\n     */\n    formatter: function () {\n      return this.y === null ? '' : H.numberFormat(this.y, -1);\n    },\n\n    /**\n     * For points with an extent, like columns or map areas, whether to\n     * align the data label inside the box or to the actual value point.\n     * Defaults to `false` in most cases, `true` in stacked columns.\n     *\n     * @type      {boolean}\n     * @since     3.0\n     * @apioption plotOptions.series.dataLabels.inside\n     */\n\n    /**\n     * How to handle data labels that flow outside the plot area. The\n     * default is `\"justify\"`, which aligns them inside the plot area. For\n     * columns and bars, this means it will be moved inside the bar. To\n     * display data labels outside the plot area, set `crop` to `false` and\n     * `overflow` to `\"allow\"`.\n     *\n     * @type       {string}\n     * @default    justify\n     * @since      3.0.6\n     * @validvalue [\"allow\", \"justify\"]\n     * @apioption  plotOptions.series.dataLabels.overflow\n     */\n\n    /**\n     * Text rotation in degrees. Note that due to a more complex structure,\n     * backgrounds, borders and padding will be lost on a rotated data\n     * label.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/\n     *         Vertical labels\n     *\n     * @type      {number}\n     * @default   0\n     * @apioption plotOptions.series.dataLabels.rotation\n     */\n\n    /**\n     * Whether to\n     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)\n     * to render the labels.\n     *\n     * @type      {boolean}\n     * @default   false\n     * @apioption plotOptions.series.dataLabels.useHTML\n     */\n\n    /**\n     * The vertical alignment of a data label. Can be one of `top`, `middle`\n     * or `bottom`. The default value depends on the data, for instance\n     * in a column chart, the label is above positive values and below\n     * negative values.\n     *\n     * @since      2.3.3\n     * @validvalue [\"top\", \"middle\", \"bottom\"]\n     */\n    verticalAlign: 'bottom',\n    // above singular point\n\n    /**\n     * The x position offset of the label relative to the point in pixels.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/\n     *         Vertical and positioned\n     */\n    x: 0,\n\n    /**\n     * The y position offset of the label relative to the point in pixels.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/\n     *         Vertical and positioned\n     */\n    y: 0,\n\n    /**\n     * When either the `borderWidth` or the `backgroundColor` is set,\n     * this is the padding within the box.\n     *\n     * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     * @sample {highmaps} maps/plotoptions/series-datalabels-box/\n     *         Data labels box options\n     *\n     * @default {highcharts} 5\n     * @default {highstock} 5\n     * @default {highmaps} 0\n     * @since   2.2.1\n     */\n    padding: 5\n  },\n\n  /**\n   * When the series contains less points than the crop threshold, all\n   * points are drawn, even if the points fall outside the visible plot\n   * area at the current zoom. The advantage of drawing all points (including\n   * markers and columns), is that animation is performed on updates.\n   * On the other hand, when the series contains more points than the\n   * crop threshold, the series data is cropped to only contain points\n   * that fall within the plot area. The advantage of cropping away invisible\n   * points is to increase performance on large series.\n   *\n   * @since   2.2\n   * @product highcharts highstock\n   */\n  cropThreshold: 300,\n\n  /**\n   * The width of each point on the x axis. For example in a column chart\n   * with one value each day, the pointRange would be 1 day (= 24 * 3600\n   * * 1000 milliseconds). This is normally computed automatically, but\n   * this option can be used to override the automatic value.\n   *\n   * @product highstock\n   */\n  pointRange: 0,\n\n  /**\n   * When this is true, the series will not cause the Y axis to cross\n   * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n   * unless the data actually crosses the plane.\n   *\n   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n   * 3 will make the Y axis show negative values according to the `minPadding`\n   * option. If `softThreshold` is `true`, the Y axis starts at 0.\n   *\n   * @since   4.1.9\n   * @product highcharts highstock\n   */\n  softThreshold: true,\n\n  /**\n   * A wrapper object for all the series options in specific states.\n   */\n  states: {\n    /**\n     * The normal state of a series, or for point items in column, pie and\n     * similar series. Currently only used for setting animation when\n     * returning to normal state from hover.\n     */\n    normal: {\n      /**\n       * Animation when returning to normal state after hovering.\n       *\n       * @type {boolean|Highcharts.AnimationOptionsObject}\n       */\n      animation: true\n    },\n\n    /**\n     * Options for the hovered series. These settings override the normal\n     * state options when a series is moused over or touched.\n     */\n    hover: {\n      /**\n       * Enable separate styles for the hovered series to visualize that\n       * the user hovers either the series itself or the legend. .\n       *\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/\n       *         Line\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/\n       *         Column\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/\n       *         Pie\n       *\n       * @type      {boolean}\n       * @default   true\n       * @since     1.2\n       * @apioption plotOptions.series.states.hover.enabled\n       */\n\n      /**\n       * Animation setting for hovering the graph in line-type series.\n       *\n       * @type    {boolean|Highcharts.AnimationOptionsObject}\n       * @since   5.0.8\n       * @product highcharts\n       */\n      animation: {\n        /**\n         * The duration of the hover animation in milliseconds. By\n         * default the hover state animates quickly in, and slowly back\n         * to normal.\n         */\n        duration: 50\n      },\n\n      /**\n       * Pixel width of the graph line. By default this property is\n       * undefined, and the `lineWidthPlus` property dictates how much\n       * to increase the linewidth from normal state.\n       *\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/\n       *         5px line on hover\n       *\n       * @type      {number}\n       * @product   highcharts highstock\n       * @apioption plotOptions.series.states.hover.lineWidth\n       */\n\n      /**\n       * The additional line width for the graph of a hovered series.\n       *\n       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/\n       *         5 pixels wider\n       * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/\n       *         5 pixels wider\n       *\n       * @since   4.0.3\n       * @product highcharts highstock\n       */\n      lineWidthPlus: 1,\n\n      /**\n       * In Highcharts 1.0, the appearance of all markers belonging to the\n       * hovered series. For settings on the hover state of the individual\n       * point, see\n       * [marker.states.hover](#plotOptions.series.marker.states.hover).\n       *\n       * @deprecated\n       *\n       * @extends plotOptions.series.marker\n       * @product highcharts highstock\n       */\n      marker: {// lineWidth: base + 1,\n        // radius: base + 1\n      },\n\n      /**\n       * Options for the halo appearing around the hovered point in line-\n       * type series as well as outside the hovered slice in pie charts.\n       * By default the halo is filled by the current point or series\n       * color with an opacity of 0.25\\. The halo can be disabled by\n       * setting the `halo` option to `false`.\n       *\n       * In styled mode, the halo is styled with the `.highcharts-halo`\n       * class, with colors inherited from `.highcharts-color-{n}`.\n       *\n       * @sample {highcharts} highcharts/plotoptions/halo/\n       *         Halo options\n       * @sample {highstock} highcharts/plotoptions/halo/\n       *         Halo options\n       *\n       * @since   4.0\n       * @product highcharts highstock\n       */\n      halo: {\n        /**\n         * A collection of SVG attributes to override the appearance of\n         * the halo, for example `fill`, `stroke` and `stroke-width`.\n         *\n         * @type      {Highcharts.SVGAttributes}\n         * @since     4.0\n         * @product   highcharts highstock\n         * @apioption plotOptions.series.states.hover.halo.attributes\n         */\n\n        /**\n         * The pixel size of the halo. For point markers this is the\n         * radius of the halo. For pie slices it is the width of the\n         * halo outside the slice. For bubbles it defaults to 5 and is\n         * the width of the halo outside the bubble.\n         *\n         * @since   4.0\n         * @product highcharts highstock\n         */\n        size: 10\n      }\n    },\n\n    /**\n     * Specific options for point in selected states, after being selected\n     * by [allowPointSelect](#plotOptions.series.allowPointSelect) or\n     * programmatically.\n     *\n     * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n     *         Allow point select demo\n     *\n     * @extends   plotOptions.series.states.hover\n     * @excluding brightness\n     * @product   highmaps\n     */\n    select: {// marker: {}\n    }\n  },\n\n  /**\n   * Sticky tracking of mouse events. When true, the `mouseOut` event\n   * on a series isn't triggered until the mouse moves over another series,\n   * or out of the plot area. When false, the `mouseOut` event on a\n   * series is triggered when the mouse leaves the area around the series'\n   * graph or markers. This also implies the tooltip when not shared. When\n   * `stickyTracking` is false and `tooltip.shared` is false, the tooltip will\n   * be hidden when moving the mouse between series. Defaults to true for line\n   * and area type series, but to false for columns, pies etc.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/\n   *         True by default\n   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/\n   *         False\n   *\n   * @default {highcharts} true\n   * @default {highstock} true\n   * @default {highmaps} false\n   * @since   2.0\n   */\n  stickyTracking: true,\n\n  /**\n   * A configuration object for the tooltip rendering of each single series.\n   * Properties are inherited from [tooltip](#tooltip), but only the\n   * following properties can be defined on a series level.\n   *\n   * @since     2.3\n   * @extends   tooltip\n   * @excluding animation,backgroundColor,borderColor,borderRadius,\n   *            borderWidth,crosshairs,enabled,formatter,positioner,shadow,\n   *            shared,shape,snap,style,useHTML\n   * @apioption plotOptions.series.tooltip\n   */\n\n  /**\n   * When a series contains a data array that is longer than this, only\n   * one dimensional arrays of numbers, or two dimensional arrays with\n   * x and y values are allowed. Also, only the first point is tested,\n   * and the rest are assumed to be the same format. This saves expensive\n   * data checking and indexing in long series. Set it to `0` disable.\n   *\n   * @since   2.2\n   * @product highcharts highstock\n   */\n  turboThreshold: 1000,\n\n  /**\n   * An array defining zones within a series. Zones can be applied to\n   * the X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`\n   * option. The zone definitions have to be in ascending order regarding to\n   * the value.\n   *\n   * In styled mode, the color zones are styled with the\n   * `.highcharts-zone-{n}` class, or custom classed from the `className`\n   * option\n   * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).\n   *\n   * @see [zoneAxis](#plotOptions.series.zoneAxis)\n   *\n   * @sample {highcharts} highcharts/series/color-zones-simple/\n   *         Color zones\n   * @sample {highstock} highcharts/series/color-zones-simple/\n   *         Color zones\n   *\n   * @type      {Array<*>}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones\n   */\n\n  /**\n   * Styled mode only. A custom class name for the zone.\n   *\n   * @sample highcharts/css/color-zones/\n   *         Zones styled by class name\n   *\n   * @type      {string}\n   * @since     5.0.0\n   * @apioption plotOptions.series.zones.className\n   */\n\n  /**\n   * Defines the color of the series.\n   *\n   * @see [series color](#plotOptions.series.color)\n   *\n   * @type      {Highcharts.ColorString}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones.color\n   */\n\n  /**\n   * A name for the dash style to use for the graph.\n   *\n   * @see [series.dashStyle](#plotOptions.series.dashStyle)\n   *\n   * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/\n   *         Dashed line indicates prognosis\n   *\n   * @type      {string}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones.dashStyle\n   */\n\n  /**\n   * Defines the fill color for the series (in area type series)\n   *\n   * @see [fillColor](#plotOptions.area.fillColor)\n   *\n   * @type      {Highcharts.ColorString}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones.fillColor\n   */\n\n  /**\n   * The value up to where the zone extends, if undefined the zones stretches\n   * to the last value in the series.\n   *\n   * @type      {number}\n   * @since     4.1.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.series.zones.value\n   */\n\n  /**\n   * Determines whether the series should look for the nearest point\n   * in both dimensions or just the x-dimension when hovering the series.\n   * Defaults to `'xy'` for scatter series and `'x'` for most other\n   * series. If the data has duplicate x-values, it is recommended to\n   * set this to `'xy'` to allow hovering over all points.\n   *\n   * Applies only to series types using nearest neighbor search (not\n   * direct hover) for tooltip.\n   *\n   * @sample {highcharts} highcharts/series/findnearestpointby/\n   *         Different hover behaviors\n   * @sample {highstock} highcharts/series/findnearestpointby/\n   *         Different hover behaviors\n   * @sample {highmaps} highcharts/series/findnearestpointby/\n   *         Different hover behaviors\n   *\n   * @since      5.0.10\n   * @validvalue [\"x\", \"xy\"]\n   */\n  findNearestPointBy: 'x'\n},\n/** @lends Highcharts.Series.prototype */\n{\n  /**\n   * Series options for specific data and the data itself. In TypeScript you\n   * have to cast the series options to specific series types, to get all\n   * possible options for a series.\n   *\n   * @example\n   * // TypeScript example\n   * Highcharts.chart('container', {\n   *     series: [{\n   *         color: '#06C',\n   *         data: [[0, 1], [2, 3]]\n   *     } as Highcharts.SeriesLineOptions ]\n   * });\n   *\n   *\n   * @type      {Array<*>}\n   * @apioption series\n   */\n\n  /**\n   * An id for the series. This can be used after render time to get a pointer\n   * to the series object through `chart.get()`.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-id/\n   *         Get series by id\n   *\n   * @type      {string}\n   * @since     1.2.0\n   * @apioption series.id\n   */\n\n  /**\n   * The index of the series in the chart, affecting the internal index in the\n   * `chart.series` array, the visible Z index as well as the order in the\n   * legend.\n   *\n   * @type      {number}\n   * @since     2.3.0\n   * @apioption series.index\n   */\n\n  /**\n   * The sequential index of the series in the legend.\n   *\n   * @see [legend.reversed](#legend.reversed),\n   *      [yAxis.reversedStacks](#yAxis.reversedStacks)\n   *\n   * @sample {highcharts|highstock} highcharts/series/legendindex/\n   *         Legend in opposite order\n   *\n   * @type      {number}\n   * @apioption series.legendIndex\n   */\n\n  /**\n   * The name of the series as shown in the legend, tooltip etc.\n   *\n   * @sample {highcharts} highcharts/series/name/\n   *         Series name\n   * @sample {highmaps} maps/demo/category-map/\n   *         Series name\n   *\n   * @type      {string}\n   * @apioption series.name\n   */\n\n  /**\n   * This option allows grouping series in a stacked chart. The stack option\n   * can be a string or anything else, as long as the grouped series' stack\n   * options match each other after conversion into a string.\n   *\n   * @sample {highcharts} highcharts/series/stack/\n   *         Stacked and grouped columns\n   *\n   * @type      {string|*}\n   * @since     2.1\n   * @product   highcharts highstock\n   * @apioption series.stack\n   */\n\n  /**\n   * The type of series, for example `line` or `column`. By default, the\n   * series type is inherited from [chart.type](#chart.type), so unless the\n   * chart is a combination of series types, there is no need to set it on the\n   * series level.\n   *\n   * @sample {highcharts} highcharts/series/type/\n   *         Line and column in the same chart\n   * @sample {highmaps} maps/demo/mapline-mappoint/\n   *         Multiple types in the same map\n   *\n   * @type      {string}\n   * @apioption series.type\n   */\n\n  /**\n   * When using dual or multiple x axes, this number defines which xAxis the\n   * particular series is connected to. It refers to either the\n   * {@link #xAxis.id|axis id}\n   * or the index of the axis in the xAxis array, with 0 being the first.\n   *\n   * @type      {number|string}\n   * @default   0\n   * @product   highcharts highstock\n   * @apioption series.xAxis\n   */\n\n  /**\n   * When using dual or multiple y axes, this number defines which yAxis the\n   * particular series is connected to. It refers to either the\n   * {@link #yAxis.id|axis id}\n   * or the index of the axis in the yAxis array, with 0 being the first.\n   *\n   * @sample {highcharts} highcharts/series/yaxis/\n   *         Apply the column series to the secondary Y axis\n   *\n   * @type      {number|string}\n   * @default   0\n   * @product   highcharts highstock\n   * @apioption series.yAxis\n   */\n\n  /**\n   * Define the visual z index of the series.\n   *\n   * @sample {highcharts} highcharts/plotoptions/series-zindex-default/\n   *         With no z index, the series defined last are on top\n   * @sample {highcharts} highcharts/plotoptions/series-zindex/\n   *         With a z index, the series with the highest z index is on top\n   * @sample {highstock} highcharts/plotoptions/series-zindex-default/\n   *         With no z index, the series defined last are on top\n   * @sample {highstock} highcharts/plotoptions/series-zindex/\n   *         With a z index, the series with the highest z index is on top\n   *\n   * @type      {number}\n   * @product   highcharts highstock\n   * @apioption series.zIndex\n   */\n  isCartesian: true,\n  pointClass: Point,\n  sorted: true,\n  // requires the data to be sorted\n  requireSorting: true,\n  directTouch: false,\n  axisTypes: ['xAxis', 'yAxis'],\n  colorCounter: 0,\n  // each point's x and y values are stored in this.xData and this.yData\n  parallelArrays: ['x', 'y'],\n  coll: 'series',\n  init: function (chart, options) {\n    var series = this,\n        events,\n        chartSeries = chart.series,\n        lastSeries;\n    /**\n     * Read only. The chart that the series belongs to.\n     *\n     * @name Highcharts.Series#chart\n     * @type {Highcharts.Chart}\n     */\n\n    series.chart = chart;\n    /**\n     * Read only. The series' type, like \"line\", \"area\", \"column\" etc. The\n     * type in the series options anc can be altered using {@link\n     * Series#update}.\n     *\n     * @name Highcharts.Series#type\n     * @type {string}\n     */\n\n    /**\n     * Read only. The series' current options. To update, use {@link\n     * Series#update}.\n     *\n     * @name Highcharts.Series#options\n     * @type {Highcharts.PlotSeriesOptions}\n     */\n\n    series.options = options = series.setOptions(options);\n    series.linkedSeries = []; // bind the axes\n\n    series.bindAxes(); // set some variables\n\n    extend(series, {\n      /**\n       * The series name as given in the options. Defaults to\n       * \"Series {n}\".\n       *\n       * @name Highcharts.Series#name\n       * @type {string}\n       */\n      name: options.name,\n      state: '',\n\n      /**\n       * Read only. The series' visibility state as set by {@link\n       * Series#show}, {@link Series#hide}, or in the initial\n       * configuration.\n       *\n       * @name Highcharts.Series#visible\n       * @type {boolean}\n       */\n      visible: options.visible !== false,\n      // true by default\n\n      /**\n       * Read only. The series' selected state as set by {@link\n       * Highcharts.Series#select}.\n       *\n       * @name Highcharts.Series#selected\n       * @type {boolean}\n       */\n      selected: options.selected === true // false by default\n\n    }); // register event listeners\n\n    events = options.events;\n    objectEach(events, function (event, eventType) {\n      addEvent(series, eventType, event);\n    });\n\n    if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {\n      chart.runTrackerClick = true;\n    }\n\n    series.getColor();\n    series.getSymbol(); // Set the data\n\n    each(series.parallelArrays, function (key) {\n      series[key + 'Data'] = [];\n    });\n    series.setData(options.data, false); // Mark cartesian\n\n    if (series.isCartesian) {\n      chart.hasCartesianSeries = true;\n    } // Get the index and register the series in the chart. The index is one\n    // more than the current latest series index (#5960).\n\n\n    if (chartSeries.length) {\n      lastSeries = chartSeries[chartSeries.length - 1];\n    }\n\n    series._i = pick(lastSeries && lastSeries._i, -1) + 1; // Insert the series and re-order all series above the insertion point.\n\n    chart.orderSeries(this.insert(chartSeries));\n    fireEvent(this, 'afterInit');\n  },\n\n  /**\n   * Insert the series in a collection with other series, either the chart\n   * series or yAxis series, in the correct order according to the index\n   * option. Used internally when adding series.\n   *\n   * @private\n   * @function Highcharts.Series#insert\n   *\n   * @param {Array<Highcharts.Series>} collection\n   *        A collection of series, like `chart.series` or `xAxis.series`.\n   *\n   * @return {number}\n   *         The index of the series in the collection.\n   */\n  insert: function (collection) {\n    var indexOption = this.options.index,\n        i; // Insert by index option\n\n    if (isNumber(indexOption)) {\n      i = collection.length;\n\n      while (i--) {\n        // Loop down until the interted element has higher index\n        if (indexOption >= pick(collection[i].options.index, collection[i]._i)) {\n          collection.splice(i + 1, 0, this);\n          break;\n        }\n      }\n\n      if (i === -1) {\n        collection.unshift(this);\n      }\n\n      i = i + 1; // Or just push it to the end\n    } else {\n      collection.push(this);\n    }\n\n    return pick(i, collection.length - 1);\n  },\n\n  /**\n   * Set the xAxis and yAxis properties of cartesian series, and register the\n   * series in the `axis.series` array.\n   *\n   * @private\n   * @function Highcharts.Series#bindAxes\n   *\n   * @exception 18\n   */\n  bindAxes: function () {\n    var series = this,\n        seriesOptions = series.options,\n        chart = series.chart,\n        axisOptions; // repeat for xAxis and yAxis\n\n    each(series.axisTypes || [], function (AXIS) {\n      // loop through the chart's axis objects\n      each(chart[AXIS], function (axis) {\n        axisOptions = axis.options; // apply if the series xAxis or yAxis option mathches the number\n        // of the axis, or if undefined, use the first axis\n\n        if (seriesOptions[AXIS] === axisOptions.index || seriesOptions[AXIS] !== undefined && seriesOptions[AXIS] === axisOptions.id || seriesOptions[AXIS] === undefined && axisOptions.index === 0) {\n          // register this series in the axis.series lookup\n          series.insert(axis.series); // set this series.xAxis or series.yAxis reference\n\n          /**\n           * Read only. The unique xAxis object associated with the\n           * series.\n           *\n           * @name Highcharts.Series#xAxis\n           * @type {Highcharts.Axis}\n           */\n\n          /**\n           * Read only. The unique yAxis object associated with the\n           * series.\n           *\n           * @name Highcharts.Series#yAxis\n           * @type {Highcharts.Axis}\n           */\n\n          series[AXIS] = axis; // mark dirty for redraw\n\n          axis.isDirty = true;\n        }\n      }); // The series needs an X and an Y axis\n\n      if (!series[AXIS] && series.optionalAxis !== AXIS) {\n        H.error(18, true);\n      }\n    });\n  },\n\n  /**\n   * For simple series types like line and column, the data values are held in\n   * arrays like xData and yData for quick lookup to find extremes and more.\n   * For multidimensional series like bubble and map, this can be extended\n   * with arrays like zData and valueData by adding to the\n   * `series.parallelArrays` array.\n   *\n   * @private\n   * @function Highcharts.Series#updateParallelArrays\n   *\n   * @param {Highcharts.Point} point\n   *\n   * @param {number|string} i\n   */\n  updateParallelArrays: function (point, i) {\n    var series = point.series,\n        args = arguments,\n        fn = isNumber(i) ? // Insert the value in the given position\n    function (key) {\n      var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n      series[key + 'Data'][i] = val;\n    } : // Apply the method specified in i with the following arguments\n    // as arguments\n    function (key) {\n      Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n    };\n    each(series.parallelArrays, fn);\n  },\n\n  /**\n   * Return an auto incremented x value based on the pointStart and\n   * pointInterval options. This is only used if an x value is not given for\n   * the point that calls autoIncrement.\n   *\n   * @private\n   * @function Highcharts.Series#autoIncrement\n   *\n   * @return {number}\n   */\n  autoIncrement: function () {\n    var options = this.options,\n        xIncrement = this.xIncrement,\n        date,\n        pointInterval,\n        pointIntervalUnit = options.pointIntervalUnit,\n        time = this.chart.time;\n    xIncrement = pick(xIncrement, options.pointStart, 0);\n    this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1); // Added code for pointInterval strings\n\n    if (pointIntervalUnit) {\n      date = new time.Date(xIncrement);\n\n      if (pointIntervalUnit === 'day') {\n        time.set('Date', date, time.get('Date', date) + pointInterval);\n      } else if (pointIntervalUnit === 'month') {\n        time.set('Month', date, time.get('Month', date) + pointInterval);\n      } else if (pointIntervalUnit === 'year') {\n        time.set('FullYear', date, time.get('FullYear', date) + pointInterval);\n      }\n\n      pointInterval = date.getTime() - xIncrement;\n    }\n\n    this.xIncrement = xIncrement + pointInterval;\n    return xIncrement;\n  },\n\n  /**\n   * Set the series options by merging from the options tree. Called\n   * internally on initiating and updating series. This function will not\n   * redraw the series. For API usage, use {@link Series#update}.\n   *\n   * @function Highcharts.Series#setOptions\n   *\n   * @param {Highcharts.PlotSeriesOptions} itemOptions\n   *        The series options.\n   *\n   * @return {Highcharts.PlotSeriesOptions}\n   *\n   * @fires Highcharts.Series#event:afterSetOptions\n   */\n  setOptions: function (itemOptions) {\n    var chart = this.chart,\n        chartOptions = chart.options,\n        plotOptions = chartOptions.plotOptions,\n        userOptions = chart.userOptions || {},\n        userPlotOptions = userOptions.plotOptions || {},\n        typeOptions = plotOptions[this.type],\n        options,\n        zones;\n    this.userOptions = itemOptions; // General series options take precedence over type options because\n    // otherwise, default type options like column.animation would be\n    // overwritten by the general option. But issues have been raised here\n    // (#3881), and the solution may be to distinguish between default\n    // option and userOptions like in the tooltip below.\n\n    options = merge(typeOptions, plotOptions.series, itemOptions); // The tooltip options are merged between global and series specific\n    // options. Importance order asscendingly:\n    // globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]\n    // init userOptions with possible later updates: 4-6 like 1-3 and\n    // (7)this series options\n\n    this.tooltipOptions = merge(defaultOptions.tooltip, // 1\n    defaultOptions.plotOptions.series && defaultOptions.plotOptions.series.tooltip, // 2\n    defaultOptions.plotOptions[this.type].tooltip, // 3\n    chartOptions.tooltip.userOptions, // 4\n    plotOptions.series && plotOptions.series.tooltip, // 5\n    plotOptions[this.type].tooltip, // 6\n    itemOptions.tooltip // 7\n    ); // When shared tooltip, stickyTracking is true by default,\n    // unless user says otherwise.\n\n    this.stickyTracking = pick(itemOptions.stickyTracking, userPlotOptions[this.type] && userPlotOptions[this.type].stickyTracking, userPlotOptions.series && userPlotOptions.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking); // Delete marker object if not allowed (#1125)\n\n    if (typeOptions.marker === null) {\n      delete options.marker;\n    } // Handle color zones\n\n\n    this.zoneAxis = options.zoneAxis;\n    zones = this.zones = (options.zones || []).slice();\n\n    if ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n      zones.push({\n        value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n        className: 'highcharts-negative'\n      });\n    }\n\n    if (zones.length) {\n      // Push one extra zone for the rest\n      if (defined(zones[zones.length - 1].value)) {\n        zones.push({});\n      }\n    }\n\n    fireEvent(this, 'afterSetOptions', {\n      options: options\n    });\n    return options;\n  },\n\n  /**\n   * Return series name in \"Series {Number}\" format or the one defined by a\n   * user. This method can be simply overridden as series name format can\n   * vary (e.g. technical indicators).\n   *\n   * @function Highcharts.Series#getName\n   *\n   * @return {string}\n   *         The series name.\n   */\n  getName: function () {\n    return this.name || 'Series ' + (this.index + 1);\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Series#getCyclic\n   *\n   * @param {string} prop\n   *\n   * @param {*} value\n   *\n   * @param {*} [defaults]\n   */\n  getCyclic: function (prop, value, defaults) {\n    var i,\n        chart = this.chart,\n        userOptions = this.userOptions,\n        indexName = prop + 'Index',\n        counterName = prop + 'Counter',\n        len = defaults ? defaults.length : pick(chart.options.chart[prop + 'Count'], chart[prop + 'Count']),\n        setting;\n\n    if (!value) {\n      // Pick up either the colorIndex option, or the _colorIndex after\n      // Series.update()\n      setting = pick(userOptions[indexName], userOptions['_' + indexName]);\n\n      if (defined(setting)) {\n        // after Series.update()\n        i = setting;\n      } else {\n        // #6138\n        if (!chart.series.length) {\n          chart[counterName] = 0;\n        }\n\n        userOptions['_' + indexName] = i = chart[counterName] % len;\n        chart[counterName] += 1;\n      }\n\n      if (defaults) {\n        value = defaults[i];\n      }\n    } // Set the colorIndex\n\n\n    if (i !== undefined) {\n      this[indexName] = i;\n    }\n\n    this[prop] = value;\n  },\n\n  /**\n   * Get the series' color based on either the options or pulled from global\n   * options.\n   *\n   * @function Highcharts.Series#getColor\n   */\n  getColor: function () {\n    this.getCyclic('color');\n  },\n\n  /**\n   * Get the series' symbol based on either the options or pulled from global\n   * options.\n   *\n   * @function Highcharts.Series#getSymbol\n   */\n  getSymbol: function () {\n    var seriesMarkerOption = this.options.marker;\n    this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n  },\n\n  /**\n   * @private\n   * @borrows LegendSymbolMixin.drawLineMarker as Highcharts.Series#drawLegendSymbol\n   */\n  drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n  /**\n   * Internal function called from setData. If the point count is the same as\n   * is was, or if there are overlapping X values, just run Point.update which\n   * is cheaper, allows animation, and keeps references to points. This also\n   * allows adding or removing points if the X-es don't match.\n   *\n   * @private\n   * @function Highcharts.Series#updateData\n   *\n   * @param {Array<*>} data\n   *\n   * @return {boolean}\n   */\n  updateData: function (data) {\n    var options = this.options,\n        oldData = this.points,\n        pointsToAdd = [],\n        hasUpdatedByKey,\n        i,\n        point,\n        lastIndex,\n        requireSorting = this.requireSorting; // Iterate the new data\n\n    each(data, function (pointOptions) {\n      var x, pointIndex; // Get the x of the new data point\n\n      x = H.defined(pointOptions) && this.pointClass.prototype.optionsToObject.call({\n        series: this\n      }, pointOptions).x;\n\n      if (isNumber(x)) {\n        // Search for the same X in the existing data set\n        pointIndex = H.inArray(x, this.xData, lastIndex); // Matching X not found\n        // or used already due to ununique x values (#8995),\n        // add point (but later)\n\n        if (pointIndex === -1 || oldData[pointIndex].touched) {\n          pointsToAdd.push(pointOptions); // Matching X found, update\n        } else if (pointOptions !== options.data[pointIndex]) {\n          oldData[pointIndex].update(pointOptions, false, null, false); // Mark it touched, below we will remove all points that\n          // are not touched.\n\n          oldData[pointIndex].touched = true; // Speed optimize by only searching after last known index.\n          // Performs ~20% bettor on large data sets.\n\n          if (requireSorting) {\n            lastIndex = pointIndex + 1;\n          } // Point exists, no changes, don't remove it\n\n        } else if (oldData[pointIndex]) {\n          oldData[pointIndex].touched = true;\n        }\n\n        hasUpdatedByKey = true;\n      }\n    }, this); // Remove points that don't exist in the updated data set\n\n    if (hasUpdatedByKey) {\n      i = oldData.length;\n\n      while (i--) {\n        point = oldData[i];\n\n        if (!point.touched) {\n          point.remove(false);\n        }\n\n        point.touched = false;\n      } // If we did not find keys (x-values), and the length is the same,\n      // update one-to-one\n\n    } else if (data.length === oldData.length) {\n      each(data, function (point, i) {\n        // .update doesn't exist on a linked, hidden series (#3709)\n        if (oldData[i].update && point !== options.data[i]) {\n          oldData[i].update(point, false, null, false);\n        }\n      }); // Did not succeed in updating data\n    } else {\n      return false;\n    } // Add new points\n\n\n    each(pointsToAdd, function (point) {\n      this.addPoint(point, false);\n    }, this);\n    return true;\n  },\n\n  /**\n   * Apply a new set of data to the series and optionally redraw it. The new\n   * data array is passed by reference (except in case of `updatePoints`), and\n   * may later be mutated when updating the chart data.\n   *\n   * Note the difference in behaviour when setting the same amount of points,\n   * or a different amount of points, as handled by the `updatePoints`\n   * parameter.\n   *\n   * @sample highcharts/members/series-setdata/\n   *         Set new data from a button\n   * @sample highcharts/members/series-setdata-pie/\n   *         Set data in a pie\n   * @sample stock/members/series-setdata/\n   *         Set new data in Highstock\n   * @sample maps/members/series-setdata/\n   *         Set new data in Highmaps\n   *\n   * @function Highcharts.Series#setData\n   *\n   * @param {Array<*>} data\n   *        Takes an array of data in the same format as described under\n   *        `series.{type}.data` for the given series type, for example a\n   *        line series would take data in the form described under\n   *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart after the series is altered. If doing\n   *        more operations on the chart, it is a good idea to set redraw to\n   *        false and call {@link Chart#redraw} after.\n   *\n   * @param {Highcharts.AnimationOptionsObject} [animation]\n   *        When the updated data is the same length as the existing data,\n   *        points will be updated by default, and animation visualizes how\n   *        the points are changed. Set false to disable animation, or a\n   *        configuration object to set duration or easing.\n   *\n   * @param {boolean} [updatePoints=true]\n   *        When the updated data is the same length as the existing data, or\n   *        points can be matched by X values, points will be updated instead\n   *        of replaced. This allows updating with animation and performs\n   *        better. In this case, the original array is not passed by\n   *        reference. Set `false` to prevent.\n   */\n  setData: function (data, redraw, animation, updatePoints) {\n    var series = this,\n        oldData = series.points,\n        oldDataLength = oldData && oldData.length || 0,\n        dataLength,\n        options = series.options,\n        chart = series.chart,\n        firstPoint = null,\n        xAxis = series.xAxis,\n        i,\n        turboThreshold = options.turboThreshold,\n        pt,\n        xData = this.xData,\n        yData = this.yData,\n        pointArrayMap = series.pointArrayMap,\n        valueCount = pointArrayMap && pointArrayMap.length,\n        updatedData;\n    data = data || [];\n    dataLength = data.length;\n    redraw = pick(redraw, true); // If the point count is the same as is was, just run Point.update which\n    // is cheaper, allows animation, and keeps references to points.\n\n    if (updatePoints !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && // Soft updating has no benefit in boost, and causes JS error\n    // (#8355)\n    !series.isSeriesBoosting) {\n      updatedData = this.updateData(data);\n    }\n\n    if (!updatedData) {\n      // Reset properties\n      series.xIncrement = null;\n      series.colorCounter = 0; // for series with colorByPoint (#1547)\n      // Update parallel arrays\n\n      each(this.parallelArrays, function (key) {\n        series[key + 'Data'].length = 0;\n      }); // In turbo mode, only one- or twodimensional arrays of numbers are\n      // allowed. The first value is tested, and we assume that all the\n      // rest are defined the same way. Although the 'for' loops are\n      // similar, they are repeated inside each if-else conditional for\n      // max performance.\n\n      if (turboThreshold && dataLength > turboThreshold) {\n        // find the first non-null point\n        i = 0;\n\n        while (firstPoint === null && i < dataLength) {\n          firstPoint = data[i];\n          i++;\n        }\n\n        if (isNumber(firstPoint)) {\n          // assume all points are numbers\n          for (i = 0; i < dataLength; i++) {\n            xData[i] = this.autoIncrement();\n            yData[i] = data[i];\n          } // Assume all points are arrays when first point is\n\n        } else if (isArray(firstPoint)) {\n          if (valueCount) {\n            // [x, low, high] or [x, o, h, l, c]\n            for (i = 0; i < dataLength; i++) {\n              pt = data[i];\n              xData[i] = pt[0];\n              yData[i] = pt.slice(1, valueCount + 1);\n            }\n          } else {\n            // [x, y]\n            for (i = 0; i < dataLength; i++) {\n              pt = data[i];\n              xData[i] = pt[0];\n              yData[i] = pt[1];\n            }\n          }\n        } else {\n          // Highcharts expects configs to be numbers or arrays in\n          // turbo mode\n          H.error(12);\n        }\n      } else {\n        for (i = 0; i < dataLength; i++) {\n          if (data[i] !== undefined) {\n            // stray commas in oldIE\n            pt = {\n              series: series\n            };\n            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n            series.updateParallelArrays(pt, i);\n          }\n        }\n      } // Forgetting to cast strings to numbers is a common caveat when\n      // handling CSV or JSON\n\n\n      if (yData && isString(yData[0])) {\n        H.error(14, true);\n      }\n\n      series.data = [];\n      series.options.data = series.userOptions.data = data; // destroy old points\n\n      i = oldDataLength;\n\n      while (i--) {\n        if (oldData[i] && oldData[i].destroy) {\n          oldData[i].destroy();\n        }\n      } // reset minRange (#878)\n\n\n      if (xAxis) {\n        xAxis.minRange = xAxis.userMinRange;\n      } // redraw\n\n\n      series.isDirty = chart.isDirtyBox = true;\n      series.isDirtyData = !!oldData;\n      animation = false;\n    } // Typically for pie series, points need to be processed and generated\n    // prior to rendering the legend\n\n\n    if (options.legendType === 'point') {\n      this.processData();\n      this.generatePoints();\n    }\n\n    if (redraw) {\n      chart.redraw(animation);\n    }\n  },\n\n  /**\n   * Internal function to process the data by cropping away unused data points\n   * if the series is longer than the crop threshold. This saves computing\n   * time for large series. In Highstock, this function is extended to\n   * provide data grouping.\n   *\n   * @private\n   * @function Highcharts.Series#processData\n   *\n   * @param {boolean} force\n   *        Force data grouping.\n   *\n   * @return {boolean|undefined}\n   */\n  processData: function (force) {\n    var series = this,\n        processedXData = series.xData,\n        // copied during slice operation\n    processedYData = series.yData,\n        dataLength = processedXData.length,\n        croppedData,\n        cropStart = 0,\n        cropped,\n        distance,\n        closestPointRange,\n        xAxis = series.xAxis,\n        i,\n        // loop variable\n    options = series.options,\n        cropThreshold = options.cropThreshold,\n        getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll,\n        // #4599\n    isCartesian = series.isCartesian,\n        xExtremes,\n        val2lin = xAxis && xAxis.val2lin,\n        isLog = xAxis && xAxis.isLog,\n        throwOnUnsorted = series.requireSorting,\n        min,\n        max; // If the series data or axes haven't changed, don't go through this.\n    // Return false to pass the message on to override methods like in data\n    // grouping.\n\n    if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n      return false;\n    }\n\n    if (xAxis) {\n      xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n\n      min = xExtremes.min;\n      max = xExtremes.max;\n    } // optionally filter out points outside the plot area\n\n\n    if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n      // it's outside current extremes\n      if (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n        processedXData = [];\n        processedYData = []; // only crop if it's actually spilling out\n      } else if (series.yData && (processedXData[0] < min || processedXData[dataLength - 1] > max)) {\n        croppedData = this.cropData(series.xData, series.yData, min, max);\n        processedXData = croppedData.xData;\n        processedYData = croppedData.yData;\n        cropStart = croppedData.start;\n        cropped = true;\n      }\n    } // Find the closest distance between processed points\n\n\n    i = processedXData.length || 1;\n\n    while (--i) {\n      distance = isLog ? val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) : processedXData[i] - processedXData[i - 1];\n\n      if (distance > 0 && (closestPointRange === undefined || distance < closestPointRange)) {\n        closestPointRange = distance; // Unsorted data is not supported by the line tooltip, as well as\n        // data grouping and navigation in Stock charts (#725) and width\n        // calculation of columns (#1900)\n      } else if (distance < 0 && throwOnUnsorted) {\n        H.error(15);\n        throwOnUnsorted = false; // Only once\n      }\n    } // Record the properties\n\n\n    series.cropped = cropped; // undefined or true\n\n    series.cropStart = cropStart;\n    series.processedXData = processedXData;\n    series.processedYData = processedYData;\n    series.closestPointRange = closestPointRange;\n  },\n\n  /**\n   * Iterate over xData and crop values between min and max. Returns object\n   * containing crop start/end cropped xData with corresponding part of yData,\n   * dataMin and dataMax within the cropped range.\n   *\n   * @private\n   * @function Highcharts.Series#cropData\n   *\n   * @param {Array<number>} xData\n   *\n   * @param {Array<number>} yData\n   *\n   * @param {number} min\n   *\n   * @param {number} max\n   *\n   * @param {number} [cropShoulder]\n   *\n   * @return {*}\n   */\n  cropData: function (xData, yData, min, max, cropShoulder) {\n    var dataLength = xData.length,\n        cropStart = 0,\n        cropEnd = dataLength,\n        i,\n        j; // line-type series need one point outside\n\n    cropShoulder = pick(cropShoulder, this.cropShoulder, 1); // iterate up to find slice start\n\n    for (i = 0; i < dataLength; i++) {\n      if (xData[i] >= min) {\n        cropStart = Math.max(0, i - cropShoulder);\n        break;\n      }\n    } // proceed to find slice end\n\n\n    for (j = i; j < dataLength; j++) {\n      if (xData[j] > max) {\n        cropEnd = j + cropShoulder;\n        break;\n      }\n    }\n\n    return {\n      xData: xData.slice(cropStart, cropEnd),\n      yData: yData.slice(cropStart, cropEnd),\n      start: cropStart,\n      end: cropEnd\n    };\n  },\n\n  /**\n   * Generate the data point after the data has been processed by cropping\n   * away unused points and optionally grouped in Highcharts Stock.\n   *\n   * @private\n   * @function Highcharts.Series#generatePoints\n   */\n  generatePoints: function () {\n    var series = this,\n        options = series.options,\n        dataOptions = options.data,\n        data = series.data,\n        dataLength,\n        processedXData = series.processedXData,\n        processedYData = series.processedYData,\n        PointClass = series.pointClass,\n        processedDataLength = processedXData.length,\n        cropStart = series.cropStart || 0,\n        cursor,\n        hasGroupedData = series.hasGroupedData,\n        keys = options.keys,\n        point,\n        points = [],\n        i;\n\n    if (!data && !hasGroupedData) {\n      var arr = [];\n      arr.length = dataOptions.length;\n      data = series.data = arr;\n    }\n\n    if (keys && hasGroupedData) {\n      // grouped data has already applied keys (#6590)\n      series.options.keys = false;\n    }\n\n    for (i = 0; i < processedDataLength; i++) {\n      cursor = cropStart + i;\n\n      if (!hasGroupedData) {\n        point = data[cursor];\n\n        if (!point && dataOptions[cursor] !== undefined) {\n          // #970\n          data[cursor] = point = new PointClass().init(series, dataOptions[cursor], processedXData[i]);\n        }\n      } else {\n        // splat the y data in case of ohlc data array\n        point = new PointClass().init(series, [processedXData[i]].concat(splat(processedYData[i])));\n        /**\n         * Highstock only. If a point object is created by data\n         * grouping, it doesn't reflect actual points in the raw data.\n         * In this case, the `dataGroup` property holds information\n         * that points back to the raw data.\n         *\n         * - `dataGroup.start` is the index of the first raw data point\n         * in the group.\n         * - `dataGroup.length` is the amount of points in the group.\n         *\n         * @name Highcharts.Point#dataGroup\n         * @type {Highcharts.SVGElement|undefined}\n         *\n         * @product highstock\n         */\n\n        point.dataGroup = series.groupMap[i];\n\n        if (point.dataGroup.options) {\n          point.options = point.dataGroup.options;\n          extend(point, point.dataGroup.options);\n        }\n      }\n\n      if (point) {\n        // #6279\n        point.index = cursor; // For faster access in Point.update\n\n        points[i] = point;\n      }\n    } // restore keys options (#6590)\n\n\n    series.options.keys = keys; // Hide cropped-away points - this only runs when the number of points\n    // is above cropThreshold, or when swithching view from non-grouped\n    // data to grouped data (#637)\n\n    if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n      for (i = 0; i < dataLength; i++) {\n        // when has grouped data, clear all points\n        if (i === cropStart && !hasGroupedData) {\n          i += processedDataLength;\n        }\n\n        if (data[i]) {\n          data[i].destroyElements();\n          data[i].plotX = undefined; // #1003\n        }\n      }\n    }\n    /**\n     * Read only. An array containing those values converted to points.\n     * In case the series data length exceeds the `cropThreshold`, or if the\n     * data is grouped, `series.data` doesn't contain all the points. Also,\n     * in case a series is hidden, the `data` array may be empty. To access\n     * raw values, `series.options.data` will always be up to date.\n     * `Series.data` only contains the points that have been created on\n     * demand. To modify the data, use {@link Highcharts.Series#setData} or\n     * {@link Highcharts.Point#update}.\n     *\n     * @see Series.points\n     *\n     * @name Highcharts.Series#data\n     * @type {Array<Point>}\n     */\n\n\n    series.data = data;\n    /**\n     * An array containing all currently visible point objects. In case of\n     * cropping, the cropped-away points are not part of this array. The\n     * `series.points` array starts at `series.cropStart` compared to\n     * `series.data` and `series.options.data`. If however the series data\n     * is grouped, these can't be correlated one to one. To\n     * modify the data, use {@link Highcharts.Series#setData} or {@link\n     * Highcharts.Point#update}.\n     *\n     * @name Highcharts.Series#points\n     * @type {Array<Highcharts.Point>}\n     */\n\n    series.points = points;\n  },\n\n  /**\n   * Calculate Y extremes for the visible data. The result is set as\n   * `dataMin` and `dataMax` on the Series item.\n   *\n   * @function Highcharts.Series#getExtremes\n   *\n   * @param {Array<number>} [yData]\n   *        The data to inspect. Defaults to the current data within the\n   *        visible range.\n   */\n  getExtremes: function (yData) {\n    var xAxis = this.xAxis,\n        yAxis = this.yAxis,\n        xData = this.processedXData,\n        yDataLength,\n        activeYData = [],\n        activeCounter = 0,\n        // #2117, need to compensate for log X axis\n    xExtremes = xAxis.getExtremes(),\n        xMin = xExtremes.min,\n        xMax = xExtremes.max,\n        validValue,\n        withinRange,\n        // Handle X outside the viewed area. This does not work with non-\n    // sorted data like scatter (#7639).\n    shoulder = this.requireSorting ? 1 : 0,\n        x,\n        y,\n        i,\n        j;\n    yData = yData || this.stackedYData || this.processedYData || [];\n    yDataLength = yData.length;\n\n    for (i = 0; i < yDataLength; i++) {\n      x = xData[i];\n      y = yData[i]; // For points within the visible range, including the first point\n      // outside the visible range (#7061), consider y extremes.\n\n      validValue = (isNumber(y, true) || isArray(y)) && (!yAxis.positiveValuesOnly || y.length || y > 0);\n      withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax;\n\n      if (validValue && withinRange) {\n        j = y.length;\n\n        if (j) {\n          // array, like ohlc or range data\n          while (j--) {\n            if (typeof y[j] === 'number') {\n              // #7380\n              activeYData[activeCounter++] = y[j];\n            }\n          }\n        } else {\n          activeYData[activeCounter++] = y;\n        }\n      }\n    }\n\n    this.dataMin = arrayMin(activeYData);\n    this.dataMax = arrayMax(activeYData);\n  },\n\n  /**\n   * Translate data points from raw data values to chart specific positioning\n   * data needed later in the `drawPoints` and `drawGraph` functions. This\n   * function can be overridden in plugins and custom series type\n   * implementations.\n   *\n   * @function Highcharts.Series#translate\n   *\n   * @todo\n   * Make events official: Fires the event `afterTranslate`.\n   */\n  translate: function () {\n    if (!this.processedXData) {\n      // hidden series\n      this.processData();\n    }\n\n    this.generatePoints();\n    var series = this,\n        options = series.options,\n        stacking = options.stacking,\n        xAxis = series.xAxis,\n        categories = xAxis.categories,\n        yAxis = series.yAxis,\n        points = series.points,\n        dataLength = points.length,\n        hasModifyValue = !!series.modifyValue,\n        i,\n        pointPlacement = options.pointPlacement,\n        dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),\n        threshold = options.threshold,\n        stackThreshold = options.startFromThreshold ? threshold : 0,\n        plotX,\n        plotY,\n        lastPlotX,\n        stackIndicator,\n        closestPointRangePx = Number.MAX_VALUE;\n    /*\n     * Plotted coordinates need to be within a limited range. Drawing too\n     * far outside the viewport causes various rendering issues (#3201,\n     * #3923, #7555).\n     */\n\n    function limitedRange(val) {\n      return Math.min(Math.max(-1e5, val), 1e5);\n    } // Point placement is relative to each series pointRange (#5889)\n\n\n    if (pointPlacement === 'between') {\n      pointPlacement = 0.5;\n    }\n\n    if (isNumber(pointPlacement)) {\n      pointPlacement *= pick(options.pointRange || xAxis.pointRange);\n    } // Translate each point\n\n\n    for (i = 0; i < dataLength; i++) {\n      var point = points[i],\n          xValue = point.x,\n          yValue = point.y,\n          yBottom = point.low,\n          stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],\n          pointStack,\n          stackValues; // Discard disallowed y values for log axes (#3434)\n\n      if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {\n        point.isNull = true;\n      } // Get the plotX translation\n\n\n      point.plotX = plotX = correctFloat( // #5236\n      limitedRange(xAxis.translate( // #3923\n      xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')) // #3923\n      ); // Calculate the bottom y value for stacked series\n\n      if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {\n        stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);\n        pointStack = stack[xValue];\n        stackValues = pointStack.points[stackIndicator.key];\n        yBottom = stackValues[0];\n        yValue = stackValues[1];\n\n        if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {\n          yBottom = pick(isNumber(threshold) && threshold, yAxis.min);\n        }\n\n        if (yAxis.positiveValuesOnly && yBottom <= 0) {\n          // #1200, #1232\n          yBottom = null;\n        }\n\n        point.total = point.stackTotal = pointStack.total;\n        point.percentage = pointStack.total && point.y / pointStack.total * 100;\n        point.stackY = yValue; // Place the stack label\n\n        pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);\n      } // Set translated yBottom or remove it\n\n\n      point.yBottom = defined(yBottom) ? limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) : null; // general hook, used for Highstock compare mode\n\n      if (hasModifyValue) {\n        yValue = series.modifyValue(yValue, point);\n      } // Set the the plotY value, reset it for redraws\n\n\n      point.plotY = plotY = typeof yValue === 'number' && yValue !== Infinity ? limitedRange(yAxis.translate(yValue, 0, 1, 0, 1)) : // #3201\n      undefined;\n      point.isInside = plotY !== undefined && plotY >= 0 && plotY <= yAxis.len && // #3519\n      plotX >= 0 && plotX <= xAxis.len; // Set client related positions for mouse tracking\n\n      point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)) : plotX; // #1514, #5383, #5518\n\n      point.negative = point.y < (threshold || 0); // some API data\n\n      point.category = categories && categories[point.x] !== undefined ? categories[point.x] : point.x; // Determine auto enabling of markers (#3635, #5099)\n\n      if (!point.isNull) {\n        if (lastPlotX !== undefined) {\n          closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));\n        }\n\n        lastPlotX = plotX;\n      } // Find point zone\n\n\n      point.zone = this.zones.length && point.getZone();\n    }\n\n    series.closestPointRangePx = closestPointRangePx;\n    fireEvent(this, 'afterTranslate');\n  },\n\n  /**\n   * Return the series points with null points filtered out.\n   *\n   * @param {Array<Highcharts.Point>} [points]\n   *        The points to inspect, defaults to {@link Series.points}.\n   *\n   * @param {boolean} [insideOnly=false]\n   *        Whether to inspect only the points that are inside the visible\n   *        view.\n   *\n   * @return {Array<Highcharts.Point>}\n   *         The valid points.\n   */\n  getValidPoints: function (points, insideOnly) {\n    var chart = this.chart; // #3916, #5029, #5085\n\n    return grep(points || this.points || [], function isValidPoint(point) {\n      if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, chart.inverted)) {\n        return false;\n      }\n\n      return !point.isNull;\n    });\n  },\n\n  /**\n   * Set the clipping for the series. For animated series it is called twice,\n   * first to initiate animating the clip then the second time without the\n   * animation to set the final clip.\n   *\n   * @private\n   * @function Highcharts.Series#setClip\n   *\n   * @param {boolean} [animation]\n   */\n  setClip: function (animation) {\n    var chart = this.chart,\n        options = this.options,\n        renderer = chart.renderer,\n        inverted = chart.inverted,\n        seriesClipBox = this.clipBox,\n        clipBox = seriesClipBox || chart.clipBox,\n        sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','),\n        // #4526\n    clipRect = chart[sharedClipKey],\n        markerClipRect = chart[sharedClipKey + 'm']; // If a clipping rectangle with the same properties is currently present\n    // in the chart, use that.\n\n    if (!clipRect) {\n      // When animation is set, prepare the initial positions\n      if (animation) {\n        clipBox.width = 0;\n\n        if (inverted) {\n          clipBox.x = chart.plotSizeX;\n        }\n\n        chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect( // include the width of the first marker\n        inverted ? chart.plotSizeX + 99 : -99, inverted ? -chart.plotLeft : -chart.plotTop, 99, inverted ? chart.chartWidth : chart.chartHeight);\n      }\n\n      chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox); // Create hashmap for series indexes\n\n      clipRect.count = {\n        length: 0\n      };\n    }\n\n    if (animation) {\n      if (!clipRect.count[this.index]) {\n        clipRect.count[this.index] = true;\n        clipRect.count.length += 1;\n      }\n    }\n\n    if (options.clip !== false) {\n      this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n      this.markerGroup.clip(markerClipRect);\n      this.sharedClipKey = sharedClipKey;\n    } // Remove the shared clipping rectangle when all series are shown\n\n\n    if (!animation) {\n      if (clipRect.count[this.index]) {\n        delete clipRect.count[this.index];\n        clipRect.count.length -= 1;\n      }\n\n      if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {\n        if (!seriesClipBox) {\n          chart[sharedClipKey] = chart[sharedClipKey].destroy();\n        }\n\n        if (chart[sharedClipKey + 'm']) {\n          chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n        }\n      }\n    }\n  },\n\n  /**\n   * Animate in the series. Called internally twice. First with the `init`\n   * parameter set to true, which sets up the initial state of the animation.\n   * Then when ready, it is called with the `init` parameter undefined, in\n   * order to perform the actual animation. After the second run, the function\n   * is removed.\n   *\n   * @function Highcharts.Series#animate\n   *\n   * @param {boolean} init\n   *        Initialize the animation.\n   */\n  animate: function (init) {\n    var series = this,\n        chart = series.chart,\n        clipRect,\n        animation = animObject(series.options.animation),\n        sharedClipKey; // Initialize the animation. Set up the clipping rectangle.\n\n    if (init) {\n      series.setClip(animation); // Run the animation\n    } else {\n      sharedClipKey = this.sharedClipKey;\n      clipRect = chart[sharedClipKey];\n\n      if (clipRect) {\n        clipRect.animate({\n          width: chart.plotSizeX,\n          x: 0\n        }, animation);\n      }\n\n      if (chart[sharedClipKey + 'm']) {\n        chart[sharedClipKey + 'm'].animate({\n          width: chart.plotSizeX + 99,\n          x: 0\n        }, animation);\n      } // Delete this function to allow it only once\n\n\n      series.animate = null;\n    }\n  },\n\n  /**\n   * This runs after animation to land on the final plot clipping.\n   *\n   * @private\n   * @function Highcharts.Series#afterAnimate\n   *\n   * @todo\n   * Make events official: Fires the event `afterAnimate`.\n   */\n  afterAnimate: function () {\n    this.setClip();\n    fireEvent(this, 'afterAnimate');\n    this.finishedAnimating = true;\n  },\n\n  /**\n   * Draw the markers for line-like series types, and columns or other\n   * graphical representation for {@link Point} objects for other series\n   * types. The resulting element is typically stored as {@link\n   * Point.graphic}, and is created on the first call and updated and moved on\n   * subsequent calls.\n   *\n   * @function Highcharts.Series#drawPoints\n   */\n  drawPoints: function () {\n    var series = this,\n        points = series.points,\n        chart = series.chart,\n        i,\n        point,\n        symbol,\n        graphic,\n        options = series.options,\n        seriesMarkerOptions = options.marker,\n        pointMarkerOptions,\n        hasPointMarker,\n        enabled,\n        isInside,\n        markerGroup = series[series.specialGroup] || series.markerGroup,\n        xAxis = series.xAxis,\n        markerAttribs,\n        globallyEnabled = pick(seriesMarkerOptions.enabled, xAxis.isRadial ? true : null, // Use larger or equal as radius is null in bubbles (#6321)\n    series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius);\n\n    if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n      for (i = 0; i < points.length; i++) {\n        point = points[i];\n        graphic = point.graphic;\n        pointMarkerOptions = point.marker || {};\n        hasPointMarker = !!point.marker;\n        enabled = globallyEnabled && pointMarkerOptions.enabled === undefined || pointMarkerOptions.enabled;\n        isInside = point.isInside; // only draw the point if y is defined\n\n        if (enabled && !point.isNull) {\n          // Shortcuts\n          symbol = pick(pointMarkerOptions.symbol, series.symbol);\n          markerAttribs = series.markerAttribs(point, point.selected && 'select');\n\n          if (graphic) {\n            // update\n            // Since the marker group isn't clipped, each individual\n            // marker must be toggled\n            graphic[isInside ? 'show' : 'hide'](true).animate(markerAttribs);\n          } else if (isInside && (markerAttribs.width > 0 || point.hasImage)) {\n            /**\n             * The graphic representation of the point. Typically\n             * this is a simple shape, like a `rect` for column\n             * charts or `path` for line markers, but for some\n             * complex series types like boxplot or 3D charts, the\n             * graphic may be a `g` element containing other shapes.\n             * The graphic is generated the first time {@link\n             * Series#drawPoints} runs, and updated and moved on\n             * subsequent runs.\n             *\n             * @memberof Point\n             * @name graphic\n             * @type {SVGElement}\n             */\n            point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);\n          }\n\n          if (graphic) {\n            graphic.addClass(point.getClassName(), true);\n          }\n        } else if (graphic) {\n          point.graphic = graphic.destroy(); // #1269\n        }\n      }\n    }\n  },\n\n  /**\n   * Get non-presentational attributes for a point. Used internally for both\n   * styled mode and classic. Can be overridden for different series types.\n   *\n   * @see Series#pointAttribs\n   *\n   * @param {Highcharts.Point} point\n   *        The Point to inspect.\n   *\n   * @param {string} [state]\n   *        The state, can be either `hover`, `select` or undefined.\n   *\n   * @return {Highcharts.SVGAttributes}\n   *         A hash containing those attributes that are not settable from\n   *         CSS.\n   */\n  markerAttribs: function (point, state) {\n    var seriesMarkerOptions = this.options.marker,\n        seriesStateOptions,\n        pointMarkerOptions = point.marker || {},\n        symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol,\n        pointStateOptions,\n        radius = pick(pointMarkerOptions.radius, seriesMarkerOptions.radius),\n        attribs; // Handle hover and select states\n\n    if (state) {\n      seriesStateOptions = seriesMarkerOptions.states[state];\n      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];\n      radius = pick(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0));\n    }\n\n    point.hasImage = symbol && symbol.indexOf('url') === 0;\n\n    if (point.hasImage) {\n      radius = 0; // and subsequently width and height is not set\n    }\n\n    attribs = {\n      x: Math.floor(point.plotX) - radius,\n      // Math.floor for #1843\n      y: point.plotY - radius\n    };\n\n    if (radius) {\n      attribs.width = attribs.height = 2 * radius;\n    }\n\n    return attribs;\n  },\n\n  /**\n   * Clear DOM objects and free up memory.\n   *\n   * @private\n   * @function Highcharts.Series#destroy\n   *\n   * @todo\n   * Make events official: Fires the event `destroy`.\n   */\n  destroy: function () {\n    var series = this,\n        chart = series.chart,\n        issue134 = /AppleWebKit\\/533/.test(win.navigator.userAgent),\n        destroy,\n        i,\n        data = series.data || [],\n        point,\n        axis; // add event hook\n\n    fireEvent(series, 'destroy'); // remove all events\n\n    removeEvent(series); // erase from axes\n\n    each(series.axisTypes || [], function (AXIS) {\n      axis = series[AXIS];\n\n      if (axis && axis.series) {\n        erase(axis.series, series);\n        axis.isDirty = axis.forceRedraw = true;\n      }\n    }); // remove legend items\n\n    if (series.legendItem) {\n      series.chart.legend.destroyItem(series);\n    } // destroy all points with their elements\n\n\n    i = data.length;\n\n    while (i--) {\n      point = data[i];\n\n      if (point && point.destroy) {\n        point.destroy();\n      }\n    }\n\n    series.points = null; // Clear the animation timeout if we are destroying the series during\n    // initial animation\n\n    H.clearTimeout(series.animationTimeout); // Destroy all SVGElements associated to the series\n\n    objectEach(series, function (val, prop) {\n      // Survive provides a hook for not destroying\n      if (val instanceof SVGElement && !val.survive) {\n        // issue 134 workaround\n        destroy = issue134 && prop === 'group' ? 'hide' : 'destroy';\n        val[destroy]();\n      }\n    }); // remove from hoverSeries\n\n    if (chart.hoverSeries === series) {\n      chart.hoverSeries = null;\n    }\n\n    erase(chart.series, series);\n    chart.orderSeries(); // clear all members\n\n    objectEach(series, function (val, prop) {\n      delete series[prop];\n    });\n  },\n\n  /**\n   * Get the graph path.\n   *\n   * @private\n   * @function Highcharts.Series#getGraphPath\n   *\n   * @param {Array<*>} points\n   *\n   * @param {boolean} nullsAsZeroes\n   *\n   * @param {boolean} connectCliffs\n   *\n   * @return {Array<number|string>}\n   */\n  getGraphPath: function (points, nullsAsZeroes, connectCliffs) {\n    var series = this,\n        options = series.options,\n        step = options.step,\n        reversed,\n        graphPath = [],\n        xMap = [],\n        gap;\n    points = points || series.points; // Bottom of a stack is reversed\n\n    reversed = points.reversed;\n\n    if (reversed) {\n      points.reverse();\n    } // Reverse the steps (#5004)\n\n\n    step = {\n      right: 1,\n      center: 2\n    }[step] || step && 3;\n\n    if (step && reversed) {\n      step = 4 - step;\n    } // Remove invalid points, especially in spline (#5015)\n\n\n    if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {\n      points = this.getValidPoints(points);\n    } // Build the line\n\n\n    each(points, function (point, i) {\n      var plotX = point.plotX,\n          plotY = point.plotY,\n          lastPoint = points[i - 1],\n          pathToPoint; // the path to this point from the previous\n\n      if ((point.leftCliff || lastPoint && lastPoint.rightCliff) && !connectCliffs) {\n        gap = true; // ... and continue\n      } // Line series, nullsAsZeroes is not handled\n\n\n      if (point.isNull && !defined(nullsAsZeroes) && i > 0) {\n        gap = !options.connectNulls; // Area series, nullsAsZeroes is set\n      } else if (point.isNull && !nullsAsZeroes) {\n        gap = true;\n      } else {\n        if (i === 0 || gap) {\n          pathToPoint = ['M', point.plotX, point.plotY]; // Generate the spline as defined in the SplineSeries object\n        } else if (series.getPointSpline) {\n          pathToPoint = series.getPointSpline(points, point, i);\n        } else if (step) {\n          if (step === 1) {\n            // right\n            pathToPoint = ['L', lastPoint.plotX, plotY];\n          } else if (step === 2) {\n            // center\n            pathToPoint = ['L', (lastPoint.plotX + plotX) / 2, lastPoint.plotY, 'L', (lastPoint.plotX + plotX) / 2, plotY];\n          } else {\n            pathToPoint = ['L', plotX, lastPoint.plotY];\n          }\n\n          pathToPoint.push('L', plotX, plotY);\n        } else {\n          // normal line to next point\n          pathToPoint = ['L', plotX, plotY];\n        } // Prepare for animation. When step is enabled, there are two\n        // path nodes for each x value.\n\n\n        xMap.push(point.x);\n\n        if (step) {\n          xMap.push(point.x);\n\n          if (step === 2) {\n            // step = center (#8073)\n            xMap.push(point.x);\n          }\n        }\n\n        graphPath.push.apply(graphPath, pathToPoint);\n        gap = false;\n      }\n    });\n    graphPath.xMap = xMap;\n    series.graphPath = graphPath;\n    return graphPath;\n  },\n\n  /**\n   * Draw the graph. Called internally when rendering line-like series types.\n   * The first time it generates the `series.graph` item and optionally other\n   * series-wide items like `series.area` for area charts. On subsequent calls\n   * these items are updated with new positions and attributes.\n   *\n   * @function Highcharts.Series#drawGraph\n   */\n  drawGraph: function () {\n    var series = this,\n        options = this.options,\n        graphPath = (this.gappedPath || this.getGraphPath).call(this),\n        props = [['graph', 'highcharts-graph']];\n    props = series.getZonesGraphs(props); // Draw the graph\n\n    each(props, function (prop, i) {\n      var graphKey = prop[0],\n          graph = series[graphKey],\n          attribs;\n\n      if (graph) {\n        graph.endX = series.preventGraphAnimation ? null : graphPath.xMap;\n        graph.animate({\n          d: graphPath\n        });\n      } else if (graphPath.length) {\n        // #1487\n        series[graphKey] = series.chart.renderer.path(graphPath).addClass(prop[1]).attr({\n          zIndex: 1\n        }) // #1069\n        .add(series.group);\n      } // Helpers for animation\n\n\n      if (graph) {\n        graph.startX = graphPath.xMap;\n        graph.isArea = graphPath.isArea; // For arearange animation\n      }\n    });\n  },\n\n  /**\n   * Get zones properties for building graphs.\n   * Extendable by series with multiple lines within one series.\n   *\n   * @private\n   * @function Highcharts.Series#getZonesGraphs\n   *\n   * @param {Array<Array<string>>} props\n   *\n   * @return {Array<Array<string>>}\n   */\n  getZonesGraphs: function (props) {\n    // Add the zone properties if any\n    each(this.zones, function (zone, i) {\n      props.push(['zone-graph-' + i, 'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || '')]);\n    }, this);\n    return props;\n  },\n\n  /**\n   * Clip the graphs into zones for colors and styling.\n   *\n   * @private\n   * @function Highcharts.Series#applyZones\n   */\n  applyZones: function () {\n    var series = this,\n        chart = this.chart,\n        renderer = chart.renderer,\n        zones = this.zones,\n        translatedFrom,\n        translatedTo,\n        clips = this.clips || [],\n        clipAttr,\n        graph = this.graph,\n        area = this.area,\n        chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),\n        axis = this[(this.zoneAxis || 'y') + 'Axis'],\n        extremes,\n        reversed,\n        inverted = chart.inverted,\n        horiz,\n        pxRange,\n        pxPosMin,\n        pxPosMax,\n        ignoreZones = false;\n\n    if (zones.length && (graph || area) && axis && axis.min !== undefined) {\n      reversed = axis.reversed;\n      horiz = axis.horiz; // The use of the Color Threshold assumes there are no gaps\n      // so it is safe to hide the original graph and area\n      // unless it is not waterfall series, then use showLine property to\n      // set lines between columns to be visible (#7862)\n\n      if (graph && !this.showLine) {\n        graph.hide();\n      }\n\n      if (area) {\n        area.hide();\n      } // Create the clips\n\n\n      extremes = axis.getExtremes();\n      each(zones, function (threshold, i) {\n        translatedFrom = reversed ? horiz ? chart.plotWidth : 0 : horiz ? 0 : axis.toPixels(extremes.min);\n        translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);\n        translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);\n\n        if (ignoreZones) {\n          translatedFrom = translatedTo = axis.toPixels(extremes.max);\n        }\n\n        pxRange = Math.abs(translatedFrom - translatedTo);\n        pxPosMin = Math.min(translatedFrom, translatedTo);\n        pxPosMax = Math.max(translatedFrom, translatedTo);\n\n        if (axis.isXAxis) {\n          clipAttr = {\n            x: inverted ? pxPosMax : pxPosMin,\n            y: 0,\n            width: pxRange,\n            height: chartSizeMax\n          };\n\n          if (!horiz) {\n            clipAttr.x = chart.plotHeight - clipAttr.x;\n          }\n        } else {\n          clipAttr = {\n            x: 0,\n            y: inverted ? pxPosMax : pxPosMin,\n            width: chartSizeMax,\n            height: pxRange\n          };\n\n          if (horiz) {\n            clipAttr.y = chart.plotWidth - clipAttr.y;\n          }\n        }\n\n        if (clips[i]) {\n          clips[i].animate(clipAttr);\n        } else {\n          clips[i] = renderer.clipRect(clipAttr);\n\n          if (graph) {\n            series['zone-graph-' + i].clip(clips[i]);\n          }\n\n          if (area) {\n            series['zone-area-' + i].clip(clips[i]);\n          }\n        } // if this zone extends out of the axis, ignore the others\n\n\n        ignoreZones = threshold.value > extremes.max; // Clear translatedTo for indicators\n\n        if (series.resetZones && translatedTo === 0) {\n          translatedTo = undefined;\n        }\n      });\n      this.clips = clips;\n    }\n  },\n\n  /**\n   * Initialize and perform group inversion on series.group and\n   * series.markerGroup.\n   *\n   * @private\n   * @function Highcharts.Series#invertGroups\n   *\n   * @param {boolean} inverted\n   */\n  invertGroups: function (inverted) {\n    var series = this,\n        chart = series.chart,\n        remover;\n\n    function setInvert() {\n      each(['group', 'markerGroup'], function (groupName) {\n        if (series[groupName]) {\n          // VML/HTML needs explicit attributes for flipping\n          if (chart.renderer.isVML) {\n            series[groupName].attr({\n              width: series.yAxis.len,\n              height: series.xAxis.len\n            });\n          }\n\n          series[groupName].width = series.yAxis.len;\n          series[groupName].height = series.xAxis.len;\n          series[groupName].invert(inverted);\n        }\n      });\n    } // Pie, go away (#1736)\n\n\n    if (!series.xAxis) {\n      return;\n    } // A fixed size is needed for inversion to work\n\n\n    remover = addEvent(chart, 'resize', setInvert);\n    addEvent(series, 'destroy', remover); // Do it now\n\n    setInvert(inverted); // do it now\n    // On subsequent render and redraw, just do setInvert without setting up\n    // events again\n\n    series.invertGroups = setInvert;\n  },\n\n  /**\n   * General abstraction for creating plot groups like series.group,\n   * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the\n   * group will only be adjusted to the updated plot size.\n   *\n   * @private\n   * @function Highcharts.Series#plotGroup\n   *\n   * @param {string} prop\n   *\n   * @param {string} name\n   *\n   * @param {string} visibility\n   *\n   * @param {number} zIndex\n   *\n   * @param {Highcharts.SVGElement} parent\n   *\n   * @return {Highcharts.SVGElement}\n   */\n  plotGroup: function (prop, name, visibility, zIndex, parent) {\n    var group = this[prop],\n        isNew = !group; // Generate it on first call\n\n    if (isNew) {\n      this[prop] = group = this.chart.renderer.g().attr({\n        zIndex: zIndex || 0.1 // IE8 and pointer logic use this\n\n      }).add(parent);\n    } // Add the class names, and replace existing ones as response to\n    // Series.update (#6660)\n\n\n    group.addClass('highcharts-' + name + ' highcharts-series-' + this.index + ' highcharts-' + this.type + '-series ' + (defined(this.colorIndex) ? 'highcharts-color-' + this.colorIndex + ' ' : '') + (this.options.className || '') + (group.hasClass('highcharts-tracker') ? ' highcharts-tracker' : ''), true); // Place it on first and subsequent (redraw) calls\n\n    group.attr({\n      visibility: visibility\n    })[isNew ? 'attr' : 'animate'](this.getPlotBox());\n    return group;\n  },\n\n  /**\n   * Get the translation and scale for the plot area of this series.\n   *\n   * @function Highcharts.Series#getPlotBox\n   *\n   * @return {Highcharts.SeriesPlotBoxObject}\n   */\n  getPlotBox: function () {\n    var chart = this.chart,\n        xAxis = this.xAxis,\n        yAxis = this.yAxis; // Swap axes for inverted (#2339)\n\n    if (chart.inverted) {\n      xAxis = yAxis;\n      yAxis = this.xAxis;\n    }\n\n    return {\n      translateX: xAxis ? xAxis.left : chart.plotLeft,\n      translateY: yAxis ? yAxis.top : chart.plotTop,\n      scaleX: 1,\n      // #1623\n      scaleY: 1\n    };\n  },\n\n  /**\n   * Render the graph and markers. Called internally when first rendering and\n   * later when redrawing the chart. This function can be extended in plugins,\n   * but normally shouldn't be called directly.\n   *\n   * @function Highcharts.Series#render\n   *\n   * @todo\n   * Make events official: Fires the event `afterRender`.\n   */\n  render: function () {\n    var series = this,\n        chart = series.chart,\n        group,\n        options = series.options,\n        // Animation doesn't work in IE8 quirks when the group div is\n    // hidden, and looks bad in other oldIE\n    animDuration = !!series.animate && chart.renderer.isSVG && animObject(options.animation).duration,\n        visibility = series.visible ? 'inherit' : 'hidden',\n        // #2597\n    zIndex = options.zIndex,\n        hasRendered = series.hasRendered,\n        chartSeriesGroup = chart.seriesGroup,\n        inverted = chart.inverted; // the group\n\n    group = series.plotGroup('group', 'series', visibility, zIndex, chartSeriesGroup);\n    series.markerGroup = series.plotGroup('markerGroup', 'markers', visibility, zIndex, chartSeriesGroup); // initiate the animation\n\n    if (animDuration) {\n      series.animate(true);\n    } // SVGRenderer needs to know this before drawing elements (#1089, #1795)\n\n\n    group.inverted = series.isCartesian ? inverted : false; // draw the graph if any\n\n    if (series.drawGraph) {\n      series.drawGraph();\n      series.applyZones();\n    }\n    /*        each(series.points, function (point) {\n                if (point.redraw) {\n                    point.redraw();\n                }\n            });*/\n    // draw the data labels (inn pies they go before the points)\n\n\n    if (series.drawDataLabels) {\n      series.drawDataLabels();\n    } // draw the points\n\n\n    if (series.visible) {\n      series.drawPoints();\n    } // draw the mouse tracking area\n\n\n    if (series.drawTracker && series.options.enableMouseTracking !== false) {\n      series.drawTracker();\n    } // Handle inverted series and tracker groups\n\n\n    series.invertGroups(inverted); // Initial clipping, must be defined after inverting groups for VML.\n    // Applies to columns etc. (#3839).\n\n    if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n      group.clip(chart.clipRect);\n    } // Run the animation\n\n\n    if (animDuration) {\n      series.animate();\n    } // Call the afterAnimate function on animation complete (but don't\n    // overwrite the animation.complete option which should be available to\n    // the user).\n\n\n    if (!hasRendered) {\n      series.animationTimeout = syncTimeout(function () {\n        series.afterAnimate();\n      }, animDuration);\n    }\n\n    series.isDirty = false; // means data is in accordance with what you see\n    // (See #322) series.isDirty = series.isDirtyData = false; // means\n    // data is in accordance with what you see\n\n    series.hasRendered = true;\n    fireEvent(series, 'afterRender');\n  },\n\n  /**\n   * Redraw the series. This function is called internally from `chart.redraw`\n   * and normally shouldn't be called directly.\n   *\n   * @private\n   * @function Highcharts.Series#redraw\n   */\n  redraw: function () {\n    var series = this,\n        chart = series.chart,\n        // cache it here as it is set to false in render, but used after\n    wasDirty = series.isDirty || series.isDirtyData,\n        group = series.group,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis; // reposition on resize\n\n    if (group) {\n      if (chart.inverted) {\n        group.attr({\n          width: chart.plotWidth,\n          height: chart.plotHeight\n        });\n      }\n\n      group.animate({\n        translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n        translateY: pick(yAxis && yAxis.top, chart.plotTop)\n      });\n    }\n\n    series.translate();\n    series.render();\n\n    if (wasDirty) {\n      // #3868, #3945\n      delete this.kdTree;\n    }\n  },\n  kdAxisArray: ['clientX', 'plotY'],\n\n  /**\n   * @private\n   * @function Highcharts.Series#searchPoint\n   *\n   * @param {*} e\n   *\n   * @param {*} compareX\n   *\n   * @return {Highcharts.Point}\n   */\n  searchPoint: function (e, compareX) {\n    var series = this,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis,\n        inverted = series.chart.inverted;\n    return this.searchKDTree({\n      clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n      plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n    }, compareX);\n  },\n\n  /**\n   * Build the k-d-tree that is used by mouse and touch interaction to get the\n   * closest point. Line-like series typically have a one-dimensional tree\n   * where points are searched along the X axis, while scatter-like series\n   * typically search in two dimensions, X and Y.\n   *\n   * @private\n   * @function Highcharts.Series#buildKDTree\n   */\n  buildKDTree: function () {\n    // Prevent multiple k-d-trees from being built simultaneously (#6235)\n    this.buildingKdTree = true;\n    var series = this,\n        dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ? 2 : 1; // Internal function\n\n    function _kdtree(points, depth, dimensions) {\n      var axis,\n          median,\n          length = points && points.length;\n\n      if (length) {\n        // alternate between the axis\n        axis = series.kdAxisArray[depth % dimensions]; // sort point array\n\n        points.sort(function (a, b) {\n          return a[axis] - b[axis];\n        });\n        median = Math.floor(length / 2); // build and return nod\n\n        return {\n          point: points[median],\n          left: _kdtree(points.slice(0, median), depth + 1, dimensions),\n          right: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n        };\n      }\n    } // Start the recursive build process with a clone of the points array\n    // and null points filtered out (#3873)\n\n\n    function startRecursive() {\n      series.kdTree = _kdtree(series.getValidPoints(null, // For line-type series restrict to plot area, but\n      // column-type series not (#3916, #4511)\n      !series.directTouch), dimensions, dimensions);\n      series.buildingKdTree = false;\n    }\n\n    delete series.kdTree; // For testing tooltips, don't build async\n\n    syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Series#searchKDTree\n   *\n   * @param {*} point\n   *\n   * @param {*} compareX\n   *\n   * @return {Highcharts.Point}\n   */\n  searchKDTree: function (point, compareX) {\n    var series = this,\n        kdX = this.kdAxisArray[0],\n        kdY = this.kdAxisArray[1],\n        kdComparer = compareX ? 'distX' : 'dist',\n        kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ? 2 : 1; // Set the one and two dimensional distance on the point object\n\n    function setDistance(p1, p2) {\n      var x = defined(p1[kdX]) && defined(p2[kdX]) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,\n          y = defined(p1[kdY]) && defined(p2[kdY]) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,\n          r = (x || 0) + (y || 0);\n      p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n      p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n    }\n\n    function _search(search, tree, depth, dimensions) {\n      var point = tree.point,\n          axis = series.kdAxisArray[depth % dimensions],\n          tdist,\n          sideA,\n          sideB,\n          ret = point,\n          nPoint1,\n          nPoint2;\n      setDistance(search, point); // Pick side based on distance to splitting point\n\n      tdist = search[axis] - point[axis];\n      sideA = tdist < 0 ? 'left' : 'right';\n      sideB = tdist < 0 ? 'right' : 'left'; // End of tree\n\n      if (tree[sideA]) {\n        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n        ret = nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point;\n      }\n\n      if (tree[sideB]) {\n        // compare distance to current best to splitting point to decide\n        // wether to check side B or not\n        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n          nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n          ret = nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret;\n        }\n      }\n\n      return ret;\n    }\n\n    if (!this.kdTree && !this.buildingKdTree) {\n      this.buildKDTree();\n    }\n\n    if (this.kdTree) {\n      return _search(point, this.kdTree, kdDimensions, kdDimensions);\n    }\n  }\n}); // end Series prototype\n\n/**\n * A line series displays information as a series of data points connected by\n * straight line segments.\n *\n * @sample {highcharts} highcharts/demo/line-basic/\n *         Line chart\n * @sample {highstock} stock/demo/basic-line/\n *         Line chart\n *\n * @extends   plotOptions.series\n * @product   highcharts highstock\n * @apioption plotOptions.line\n */\n\n/**\n * A `line` series. If the [type](#series.line.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.line\n * @excluding dataParser,dataURL\n * @product   highcharts highstock\n * @apioption series.line\n */\n\n/**\n * An array of data points for the series. For the `line` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 1],\n *         [1, 2],\n *         [2, 8]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.line.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 6,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<number|string|Date>|*>}\n * @apioption series.line.data\n */\n\n/**\n * An additional, individual class name for the data point's graphic\n * representation.\n *\n * @type      {string}\n * @since     5.0.0\n * @product   highcharts\n * @apioption series.line.data.className\n */\n\n/**\n * Individual color for the point. By default the color is pulled from\n * the global `colors` array.\n *\n * In styled mode, the `color` option doesn't take effect. Instead, use\n * `colorIndex`.\n *\n * @sample {highcharts} highcharts/point/color/\n *         Mark the highest point\n *\n * @type      {Highcharts.ColorString}\n * @product   highcharts highstock\n * @apioption series.line.data.color\n */\n\n/**\n * A specific color index to use for the point, so its graphic representations\n * are given the class name `highcharts-color-{n}`. In styled mode this will\n * change the color of the graphic. In non-styled mode, the color by is set by\n * the `fill` attribute, so the change in class name won't have a visual effect\n * by default.\n *\n * @type      {number}\n * @since     5.0.0\n * @product   highcharts\n * @apioption series.line.data.colorIndex\n */\n\n/**\n * Individual data label for each point. The options are the same as\n * the ones for [plotOptions.series.dataLabels](\n * #plotOptions.series.dataLabels).\n *\n * @sample highcharts/point/datalabels/\n *         Show a label for the last value\n *\n * @type      {Highcharts.PlotSeriesDataLabelsOptions}\n * @product   highcharts highstock\n * @apioption series.line.data.dataLabels\n */\n\n/**\n * A description of the point to add to the screen reader information\n * about the point. Requires the Accessibility module.\n *\n * @type      {string}\n * @since     5.0.0\n * @apioption series.line.data.description\n */\n\n/**\n * An id for the point. This can be used after render time to get a\n * pointer to the point object through `chart.get()`.\n *\n * @sample {highcharts} highcharts/point/id/\n *         Remove an id'd point\n *\n * @type      {string}\n * @since     1.2.0\n * @product   highcharts highstock\n * @apioption series.line.data.id\n */\n\n/**\n * The rank for this point's data label in case of collision. If two\n * data labels are about to overlap, only the one with the highest `labelrank`\n * will be drawn.\n *\n * @type      {number}\n * @apioption series.line.data.labelrank\n */\n\n/**\n * The name of the point as shown in the legend, tooltip, dataLabel\n * etc.\n *\n * @see [xAxis.uniqueNames](#xAxis.uniqueNames)\n *\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Point names\n *\n * @type      {string}\n * @apioption series.line.data.name\n */\n\n/**\n * Whether the data point is selected initially.\n *\n * @type      {boolean}\n * @default   false\n * @product   highcharts highstock\n * @apioption series.line.data.selected\n */\n\n/**\n * The x value of the point. For datetime axes, the X value is the timestamp\n * in milliseconds since 1970.\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.line.data.x\n */\n\n/**\n * The y value of the point.\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.line.data.y\n */\n\n/**\n * Individual point events\n *\n * @extends   plotOptions.series.point.events\n * @product   highcharts highstock\n * @apioption series.line.data.events\n */\n\n/**\n * @extends   plotOptions.series.marker\n * @product   highcharts highstock\n * @apioption series.line.data.marker\n */"
    },
    {
     "id": 240,
     "name": "../node_modules/highcharts/js/es-modules/parts/Options.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 242,
     "name": "../node_modules/highcharts/js/es-modules/parts/Chart.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Callback for chart constructors.\n *\n * @callback Highcharts.ChartCallbackFunction\n *\n * @param {Highcharts.Chart} chart\n *        Created chart.\n */\n\n/**\n * The chart title. The title has an `update` method that allows modifying the\n * options directly or indirectly via `chart.update`.\n *\n * @interface Highcharts.TitleObject\n * @extends Highcharts.SVGElement\n */\n\n/**\n* Modify options for the title.\n*\n* @function Highcharts.TitleObject#update\n*\n* @param {Highcharts.TitleOptions} titleOptions\n*        Options to modify.\n*/\n\n/**\n * The chart subtitle. The subtitle has an `update` method that\n * allows modifying the options directly or indirectly via\n * `chart.update`.\n *\n * @interface Highcharts.SubtitleObject\n * @extends Highcharts.SVGElement\n */\n\n/**\n* Modify options for the subtitle.\n*\n* @function Highcharts.SubtitleObject#update\n*\n* @param {Highcharts.SubtitleOptions} subtitleOptions\n*        Options to modify.\n*/\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Axis.js';\nimport './Legend.js';\nimport './Options.js';\nimport './Pointer.js';\nvar addEvent = H.addEvent,\n    animate = H.animate,\n    animObject = H.animObject,\n    attr = H.attr,\n    doc = H.doc,\n    Axis = H.Axis,\n    // @todo add as requirement\ncreateElement = H.createElement,\n    defaultOptions = H.defaultOptions,\n    discardElement = H.discardElement,\n    charts = H.charts,\n    css = H.css,\n    defined = H.defined,\n    each = H.each,\n    extend = H.extend,\n    find = H.find,\n    fireEvent = H.fireEvent,\n    grep = H.grep,\n    isNumber = H.isNumber,\n    isObject = H.isObject,\n    isString = H.isString,\n    Legend = H.Legend,\n    // @todo add as requirement\nmarginNames = H.marginNames,\n    merge = H.merge,\n    objectEach = H.objectEach,\n    Pointer = H.Pointer,\n    // @todo add as requirement\npick = H.pick,\n    pInt = H.pInt,\n    removeEvent = H.removeEvent,\n    seriesTypes = H.seriesTypes,\n    splat = H.splat,\n    syncTimeout = H.syncTimeout,\n    win = H.win;\n/**\n * The Chart class. The recommended constructor is {@link Highcharts#chart}.\n *\n * @example\n * var chart = Highcharts.chart('container', {\n *        title: {\n *               text: 'My chart'\n *        },\n *        series: [{\n *            data: [1, 3, 2, 4]\n *        }]\n * })\n *\n * @class\n * @name Highcharts.Chart\n *\n * @param {Highcharts.Options} options\n *        The chart options structure.\n *\n * @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n *        Function to run when the chart has loaded and and all external images\n *        are loaded. Defining a\n *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n *        handler is equivalent.\n */\n\n/**\n* @class\n* @name Highcharts.Chart\n*\n* @param {string|Highcharts.HTMLDOMElement} renderTo\n*        The DOM element to render to, or its id.\n*\n* @param {Highcharts.Options} options\n*        The chart options structure.\n*\n* @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n*        Function to run when the chart has loaded and and all external images\n*        are loaded. Defining a\n*        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n*        handler is equivalent.\n*/\n\nvar Chart = H.Chart = function () {\n  this.getArgs.apply(this, arguments);\n};\n/**\n * Factory function for basic charts.\n *\n * @example\n * // Render a chart in to div#container\n * var chart = Highcharts.chart('container', {\n *     title: {\n *         text: 'My chart'\n *     },\n *     series: [{\n *         data: [1, 3, 2, 4]\n *     }]\n * });\n *\n * @function Highcharts.chart\n *\n * @param {Highcharts.Options} options\n *        The chart options structure.\n *\n * @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n *        Function to run when the chart has loaded and and all external images\n *        are loaded. Defining a\n *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n *        handler is equivalent.\n *\n * @return {Highcharts.Chart}\n *         Returns the Chart object.\n */\n\n/**\n* @function Highcharts.chart\n*\n* @param {string|Highcharts.HTMLDOMElement} renderTo\n*        The DOM element to render to, or its id.\n*\n* @param {Highcharts.Options} options\n*        The chart options structure.\n*\n* @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n*        Function to run when the chart has loaded and and all external images\n*        are loaded. Defining a\n*        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n*        handler is equivalent.\n*\n* @return {Highcharts.Chart}\n*         Returns the Chart object.\n*/\n\n\nH.chart = function (a, b, c) {\n  return new Chart(a, b, c);\n};\n\nextend(Chart.prototype,\n/** @lends Highcharts.Chart.prototype */\n{\n  // Hook for adding callbacks in modules\n  callbacks: [],\n\n  /**\n   * Handle the arguments passed to the constructor.\n   *\n   * @private\n   * @function Highcharts.Chart#getArgs\n   *\n   * @param {...Array<*>} arguments\n   *        All arguments for the constructor.\n   *\n   * @return {Array<*>}\n   *         Passed arguments without renderTo.\n   *\n   * @fires Highcharts.Chart#event:init\n   * @fires Highcharts.Chart#event:afterInit\n   */\n  getArgs: function () {\n    var args = [].slice.call(arguments); // Remove the optional first argument, renderTo, and\n    // set it on this.\n\n    if (isString(args[0]) || args[0].nodeName) {\n      this.renderTo = args.shift();\n    }\n\n    this.init(args[0], args[1]);\n  },\n\n  /**\n   * Overridable function that initializes the chart. The constructor's\n   * arguments are passed on directly.\n   *\n   * @function Highcharts.Chart#init\n   *\n   * @param {Highcharts.Options} userOptions\n   *        Custom options.\n   *\n   * @param {Function|undefined} [callback]\n   *        Function to run when the chart has loaded and and all external\n   *        images are loaded.\n   *\n   * @fires Highcharts.Chart#event:init\n   * @fires Highcharts.Chart#event:afterInit\n   */\n  init: function (userOptions, callback) {\n    // Handle regular options\n    var options,\n        type,\n        // skip merging data points to increase performance\n    seriesOptions = userOptions.series,\n        userPlotOptions = userOptions.plotOptions || {}; // Fire the event with a default function\n\n    fireEvent(this, 'init', {\n      args: arguments\n    }, function () {\n      userOptions.series = null;\n      options = merge(defaultOptions, userOptions); // do the merge\n      // Override (by copy of user options) or clear tooltip options\n      // in chart.options.plotOptions (#6218)\n\n      for (type in options.plotOptions) {\n        options.plotOptions[type].tooltip = userPlotOptions[type] && merge(userPlotOptions[type].tooltip) // override by copy\n        || undefined; // or clear\n      } // User options have higher priority than default options\n      // (#6218). In case of exporting: path is changed\n\n\n      options.tooltip.userOptions = userOptions.chart && userOptions.chart.forExport && userOptions.tooltip.userOptions || userOptions.tooltip; // set back the series data\n\n      options.series = userOptions.series = seriesOptions;\n      this.userOptions = userOptions;\n      var optionsChart = options.chart;\n      var chartEvents = optionsChart.events;\n      this.margin = [];\n      this.spacing = []; // Pixel data bounds for touch zoom\n\n      this.bounds = {\n        h: {},\n        v: {}\n      }; // An array of functions that returns labels that should be\n      // considered for anti-collision\n\n      this.labelCollectors = [];\n      this.callback = callback;\n      this.isResizing = 0;\n      /**\n       * The options structure for the chart. It contains members for\n       * the sub elements like series, legend, tooltip etc.\n       *\n       * @name Highcharts.Chart#options\n       * @type {Highcharts.Options}\n       */\n\n      this.options = options;\n      /**\n       * All the axes in the chart.\n       *\n       * @see  Highcharts.Chart.xAxis\n       * @see  Highcharts.Chart.yAxis\n       *\n       * @name Highcharts.Chart#axes\n       * @type {Array<Highcharts.Axis>}\n       */\n\n      this.axes = [];\n      /**\n       * All the current series in the chart.\n       *\n       * @name Highcharts.Chart#series\n       * @type {Array<Highcharts.Series>}\n       */\n\n      this.series = [];\n      /**\n       * The `Time` object associated with the chart. Since v6.0.5,\n       * time settings can be applied individually for each chart. If\n       * no individual settings apply, the `Time` object is shared by\n       * all instances.\n       *\n       * @name Highcharts.Chart#time\n       * @type {Highcharts.Time}\n       */\n\n      this.time = userOptions.time && H.keys(userOptions.time).length ? new H.Time(userOptions.time) : H.time;\n      this.hasCartesianSeries = optionsChart.showAxes;\n      var chart = this; // Add the chart to the global lookup\n\n      chart.index = charts.length;\n      charts.push(chart);\n      H.chartCount++; // Chart event handlers\n\n      if (chartEvents) {\n        objectEach(chartEvents, function (event, eventType) {\n          addEvent(chart, eventType, event);\n        });\n      }\n      /**\n       * A collection of the X axes in the chart.\n       *\n       * @name Highcharts.Chart#xAxis\n       * @type {Array<Highcharts.Axis>}\n       */\n\n\n      chart.xAxis = [];\n      /**\n       * A collection of the Y axes in the chart.\n       *\n       * @name Highcharts.Chart#yAxis\n       * @type {Array<Highcharts.Axis>}\n       *\n       * @todo\n       * Make events official: Fire the event `afterInit`.\n       */\n\n      chart.yAxis = [];\n      chart.pointCount = chart.colorCounter = chart.symbolCounter = 0; // Fire after init but before first render, before axes and series\n      // have been initialized.\n\n      fireEvent(chart, 'afterInit');\n      chart.firstRender();\n    });\n  },\n\n  /**\n   * Internal function to unitialize an individual series.\n   *\n   * @private\n   * @function Highcharts.Chart#initSeries\n   *\n   * @param {Highcharts.ChartOptions} options\n   *\n   * @return {Highcharts.Series}\n   */\n  initSeries: function (options) {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n        series,\n        Constr = seriesTypes[type]; // No such series type\n\n    if (!Constr) {\n      H.error(17, true);\n    }\n\n    series = new Constr();\n    series.init(this, options);\n    return series;\n  },\n\n  /**\n   * Order all series above a given index. When series are added and ordered\n   * by configuration, only the last series is handled (#248, #1123, #2456,\n   * #6112). This function is called on series initialization and destroy.\n   *\n   * @private\n   * @function Highcharts.Series#orderSeries\n   *\n   * @param {number} fromIndex\n   *        If this is given, only the series above this index are handled.\n   */\n  orderSeries: function (fromIndex) {\n    var series = this.series,\n        i = fromIndex || 0;\n\n    for (; i < series.length; i++) {\n      if (series[i]) {\n        series[i].index = i;\n        series[i].name = series[i].getName();\n      }\n    }\n  },\n\n  /**\n   * Check whether a given point is within the plot area.\n   *\n   * @function Highcharts.Chart#isInsidePlot\n   *\n   * @param {number} plotX\n   *        Pixel x relative to the plot area.\n   *\n   * @param {number} plotY\n   *        Pixel y relative to the plot area.\n   *\n   * @param {boolean} inverted\n   *        Whether the chart is inverted.\n   *\n   * @return {boolean}\n   *         Returns true if the given point is inside the plot area.\n   */\n  isInsidePlot: function (plotX, plotY, inverted) {\n    var x = inverted ? plotY : plotX,\n        y = inverted ? plotX : plotY;\n    return x >= 0 && x <= this.plotWidth && y >= 0 && y <= this.plotHeight;\n  },\n\n  /**\n   * Redraw the chart after changes have been done to the data, axis extremes\n   * chart size or chart elements. All methods for updating axes, series or\n   * points have a parameter for redrawing the chart. This is `true` by\n   * default. But in many cases you want to do more than one operation on the\n   * chart before redrawing, for example add a number of points. In those\n   * cases it is a waste of resources to redraw the chart for each new point\n   * added. So you add the points and call `chart.redraw()` after.\n   *\n   * @function Highcharts.Chart#redraw\n   *\n   * @param {boolean|Highcharts.AnimationOptionsObject|undefined} [animation]\n   *        If or how to apply animation to the redraw.\n   *\n   * @fires Highcharts.Chart#event:afterSetExtremes\n   * @fires Highcharts.Chart#event:beforeRedraw\n   * @fires Highcharts.Chart#event:predraw\n   * @fires Highcharts.Chart#event:redraw\n   * @fires Highcharts.Chart#event:render\n   * @fires Highcharts.Chart#event:updatedData\n   */\n  redraw: function (animation) {\n    fireEvent(this, 'beforeRedraw');\n    var chart = this,\n        axes = chart.axes,\n        series = chart.series,\n        pointer = chart.pointer,\n        legend = chart.legend,\n        legendUserOptions = chart.userOptions.legend,\n        redrawLegend = chart.isDirtyLegend,\n        hasStackedSeries,\n        hasDirtyStacks,\n        hasCartesianSeries = chart.hasCartesianSeries,\n        isDirtyBox = chart.isDirtyBox,\n        i,\n        serie,\n        renderer = chart.renderer,\n        isHiddenChart = renderer.isHidden(),\n        afterRedraw = []; // Handle responsive rules, not only on resize (#6130)\n\n    if (chart.setResponsive) {\n      chart.setResponsive(false);\n    }\n\n    H.setAnimation(animation, chart);\n\n    if (isHiddenChart) {\n      chart.temporaryDisplay();\n    } // Adjust title layout (reflow multiline text)\n\n\n    chart.layOutTitles(); // link stacked series\n\n    i = series.length;\n\n    while (i--) {\n      serie = series[i];\n\n      if (serie.options.stacking) {\n        hasStackedSeries = true;\n\n        if (serie.isDirty) {\n          hasDirtyStacks = true;\n          break;\n        }\n      }\n    }\n\n    if (hasDirtyStacks) {\n      // mark others as dirty\n      i = series.length;\n\n      while (i--) {\n        serie = series[i];\n\n        if (serie.options.stacking) {\n          serie.isDirty = true;\n        }\n      }\n    } // Handle updated data in the series\n\n\n    each(series, function (serie) {\n      if (serie.isDirty) {\n        if (serie.options.legendType === 'point') {\n          if (serie.updateTotals) {\n            serie.updateTotals();\n          }\n\n          redrawLegend = true;\n        } else if (legendUserOptions && (legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {\n          redrawLegend = true; // #2165\n        }\n      }\n\n      if (serie.isDirtyData) {\n        fireEvent(serie, 'updatedData');\n      }\n    }); // handle added or removed series\n\n    if (redrawLegend && legend && legend.options.enabled) {\n      // draw legend graphics\n      legend.render();\n      chart.isDirtyLegend = false;\n    } // reset stacks\n\n\n    if (hasStackedSeries) {\n      chart.getStacks();\n    }\n\n    if (hasCartesianSeries) {\n      // set axes scales\n      each(axes, function (axis) {\n        axis.updateNames();\n        axis.setScale();\n      });\n    }\n\n    chart.getMargins(); // #3098\n\n    if (hasCartesianSeries) {\n      // If one axis is dirty, all axes must be redrawn (#792, #2169)\n      each(axes, function (axis) {\n        if (axis.isDirty) {\n          isDirtyBox = true;\n        }\n      }); // redraw axes\n\n      each(axes, function (axis) {\n        // Fire 'afterSetExtremes' only if extremes are set\n        var key = axis.min + ',' + axis.max;\n\n        if (axis.extKey !== key) {\n          // #821, #4452\n          axis.extKey = key; // prevent a recursive call to chart.redraw() (#1119)\n\n          afterRedraw.push(function () {\n            fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n\n            delete axis.eventArgs;\n          });\n        }\n\n        if (isDirtyBox || hasStackedSeries) {\n          axis.redraw();\n        }\n      });\n    } // the plot areas size has changed\n\n\n    if (isDirtyBox) {\n      chart.drawChartBox();\n    } // Fire an event before redrawing series, used by the boost module to\n    // clear previous series renderings.\n\n\n    fireEvent(chart, 'predraw'); // redraw affected series\n\n    each(series, function (serie) {\n      if ((isDirtyBox || serie.isDirty) && serie.visible) {\n        serie.redraw();\n      } // Set it here, otherwise we will have unlimited 'updatedData' calls\n      // for a hidden series after setData(). Fixes #6012\n\n\n      serie.isDirtyData = false;\n    }); // move tooltip or reset\n\n    if (pointer) {\n      pointer.reset(true);\n    } // redraw if canvas\n\n\n    renderer.draw(); // Fire the events\n\n    fireEvent(chart, 'redraw');\n    fireEvent(chart, 'render');\n\n    if (isHiddenChart) {\n      chart.temporaryDisplay(true);\n    } // Fire callbacks that are put on hold until after the redraw\n\n\n    each(afterRedraw, function (callback) {\n      callback.call();\n    });\n  },\n\n  /**\n   * Get an axis, series or point object by `id` as given in the configuration\n   * options. Returns `undefined` if no item is found.\n   *\n   * @sample highcharts/plotoptions/series-id/\n   *         Get series by id\n   *\n   * @function Highcharts.Chart#get\n   *\n   * @param {string} id\n   *        The id as given in the configuration options.\n   *\n   * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}\n   *         The retrieved item.\n   */\n  get: function (id) {\n    var ret,\n        series = this.series,\n        i;\n\n    function itemById(item) {\n      return item.id === id || item.options && item.options.id === id;\n    }\n\n    ret = // Search axes\n    find(this.axes, itemById) || // Search series\n    find(this.series, itemById); // Search points\n\n    for (i = 0; !ret && i < series.length; i++) {\n      ret = find(series[i].points || [], itemById);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Create the Axis instances based on the config options.\n   *\n   * @private\n   * @function Highcharts.Chart#getAxes\n   *\n   * @fires Highcharts.Chart#event:afterGetAxes\n   * @fires Highcharts.Chart#event:getAxes\n   */\n  getAxes: function () {\n    var chart = this,\n        options = this.options,\n        xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n        yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n        optionsArray;\n    fireEvent(this, 'getAxes'); // make sure the options are arrays and add some members\n\n    each(xAxisOptions, function (axis, i) {\n      axis.index = i;\n      axis.isX = true;\n    });\n    each(yAxisOptions, function (axis, i) {\n      axis.index = i;\n    }); // concatenate all axis options into one array\n\n    optionsArray = xAxisOptions.concat(yAxisOptions);\n    each(optionsArray, function (axisOptions) {\n      new Axis(chart, axisOptions); // eslint-disable-line no-new\n    });\n    fireEvent(this, 'afterGetAxes');\n  },\n\n  /**\n   * Returns an array of all currently selected points in the chart. Points\n   * can be selected by clicking or programmatically by the\n   * {@link Highcharts.Point#select}\n   * function.\n   *\n   * @sample highcharts/plotoptions/series-allowpointselect-line/\n   *         Get selected points\n   *\n   * @function Highcharts.Chart#getSelectedPoints\n   *\n   * @return {Array<Highcharts.Point>}\n   *         The currently selected points.\n   */\n  getSelectedPoints: function () {\n    var points = [];\n    each(this.series, function (serie) {\n      // series.data - for points outside of viewed range (#6445)\n      points = points.concat(grep(serie.data || [], function (point) {\n        return point.selected;\n      }));\n    });\n    return points;\n  },\n\n  /**\n   * Returns an array of all currently selected series in the chart. Series\n   * can be selected either programmatically by the\n   * {@link Highcharts.Series#select}\n   * function or by checking the checkbox next to the legend item if\n   * {@link https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox| series.showCheckBox}\n   * is true.\n   *\n   * @sample highcharts/members/chart-getselectedseries/\n   *         Get selected series\n   *\n   * @function Highcharts.Chart#getSelectedSeries\n   *\n   * @return {Array<Highcharts.Series>}\n   *         The currently selected series.\n   */\n  getSelectedSeries: function () {\n    return grep(this.series, function (serie) {\n      return serie.selected;\n    });\n  },\n\n  /**\n   * Set a new title or subtitle for the chart.\n   *\n   * @sample highcharts/members/chart-settitle/\n   *         Set title text and styles\n   *\n   * @function Highcharts.Chart#setTitle\n   *\n   * @param {Highcharts.TitleOptions} titleOptions\n   *        New title options. The title text itself is set by the\n   *        `titleOptions.text` property.\n   *\n   * @param {Highcharts.SubtitleOptions} subtitleOptions\n   *        New subtitle options. The subtitle text itself is set by the\n   *        `subtitleOptions.text` property.\n   *\n   * @param {boolean} redraw\n   *        Whether to redraw the chart or wait for a later call to\n   *        `chart.redraw()`.\n   */\n  setTitle: function (titleOptions, subtitleOptions, redraw) {\n    var chart = this,\n        options = chart.options,\n        chartTitleOptions,\n        chartSubtitleOptions;\n    chartTitleOptions = options.title = merge(options.title, titleOptions);\n    chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions); // add title and subtitle\n\n    /**\n     * The chart title. The title has an `update` method that allows\n     * modifying the options directly or indirectly via\n     * `chart.update`.\n     *\n     * @sample highcharts/members/title-update/\n     *         Updating titles\n     *\n     * @name Highcharts.Chart#title\n     * @type {Highcharts.TitleObject}\n     */\n\n    /**\n     * The chart subtitle. The subtitle has an `update` method that\n     * allows modifying the options directly or indirectly via\n     * `chart.update`.\n     *\n     * @name Highcharts.Chart#subtitle\n     * @type {Highcharts.SubtitleObject}\n     */\n\n    each([['title', titleOptions, chartTitleOptions], ['subtitle', subtitleOptions, chartSubtitleOptions]], function (arr, i) {\n      var name = arr[0],\n          title = chart[name],\n          titleOptions = arr[1],\n          chartTitleOptions = arr[2];\n\n      if (title && titleOptions) {\n        chart[name] = title = title.destroy(); // remove old\n      }\n\n      if (chartTitleOptions && !title) {\n        chart[name] = chart.renderer.text(chartTitleOptions.text, 0, 0, chartTitleOptions.useHTML).attr({\n          align: chartTitleOptions.align,\n          'class': 'highcharts-' + name,\n          zIndex: chartTitleOptions.zIndex || 4\n        }).add(); // Update methods, shortcut to Chart.setTitle\n\n        chart[name].update = function (o) {\n          chart.setTitle(!i && o, i && o);\n        };\n      }\n    });\n    chart.layOutTitles(redraw);\n  },\n\n  /**\n   * Internal function to lay out the chart titles and cache the full offset\n   * height for use in `getMargins`. The result is stored in\n   * `this.titleOffset`.\n   *\n   * @private\n   * @function Highcharts.Chart#layOutTitles\n   *\n   * @param {boolean|undefined} [redraw=true]\n   */\n  layOutTitles: function (redraw) {\n    var titleOffset = 0,\n        requiresDirtyBox,\n        renderer = this.renderer,\n        spacingBox = this.spacingBox; // Lay out the title and the subtitle respectively\n\n    each(['title', 'subtitle'], function (key) {\n      var title = this[key],\n          titleOptions = this.options[key],\n          offset = key === 'title' ? -3 : // Floating subtitle (#6574)\n      titleOptions.verticalAlign ? 0 : titleOffset + 2,\n          titleSize;\n\n      if (title) {\n        titleSize = renderer.fontMetrics(titleSize, title).b;\n        title.css({\n          width: (titleOptions.width || spacingBox.width + titleOptions.widthAdjust) + 'px'\n        }).align(extend({\n          y: offset + titleSize\n        }, titleOptions), false, 'spacingBox');\n\n        if (!titleOptions.floating && !titleOptions.verticalAlign) {\n          titleOffset = Math.ceil(titleOffset + // Skip the cache for HTML (#3481)\n          title.getBBox(titleOptions.useHTML).height);\n        }\n      }\n    }, this);\n    requiresDirtyBox = this.titleOffset !== titleOffset;\n    this.titleOffset = titleOffset; // used in getMargins\n\n    if (!this.isDirtyBox && requiresDirtyBox) {\n      this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox; // Redraw if necessary (#2719, #2744)\n\n      if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n        this.redraw();\n      }\n    }\n  },\n\n  /**\n   * Internal function to get the chart width and height according to options\n   * and container size. Sets\n   * {@link Chart.chartWidth} and\n   * {@link Chart.chartHeight}.\n   *\n   * @function Highcharts.Chart#getChartSize\n   *\n   * @return {void}\n   */\n  getChartSize: function () {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        widthOption = optionsChart.width,\n        heightOption = optionsChart.height,\n        renderTo = chart.renderTo; // Get inner width and height\n\n    if (!defined(widthOption)) {\n      chart.containerWidth = H.getStyle(renderTo, 'width');\n    }\n\n    if (!defined(heightOption)) {\n      chart.containerHeight = H.getStyle(renderTo, 'height');\n    }\n    /**\n     * The current pixel width of the chart.\n     *\n     * @name Highcharts.Chart#chartWidth\n     * @type {number}\n     */\n\n\n    chart.chartWidth = Math.max( // #1393\n    0, widthOption || chart.containerWidth || 600 // #1460\n    );\n    /**\n     * The current pixel height of the chart.\n     *\n     * @name Highcharts.Chart#chartHeight\n     * @type {number}\n     */\n\n    chart.chartHeight = Math.max(0, H.relativeLength(heightOption, chart.chartWidth) || (chart.containerHeight > 1 ? chart.containerHeight : 400));\n  },\n\n  /**\n   * If the renderTo element has no offsetWidth, most likely one or more of\n   * its parents are hidden. Loop up the DOM tree to temporarily display the\n   * parents, then save the original display properties, and when the true\n   * size is retrieved, reset them. Used on first render and on redraws.\n   *\n   * @private\n   * @function Highcharts.Chart#temporaryDisplay\n   *\n   * @param {boolean} revert\n   *        Revert to the saved original styles.\n   */\n  temporaryDisplay: function (revert) {\n    var node = this.renderTo,\n        tempStyle;\n\n    if (!revert) {\n      while (node && node.style) {\n        // When rendering to a detached node, it needs to be temporarily\n        // attached in order to read styling and bounding boxes (#5783,\n        // #7024).\n        if (!doc.body.contains(node) && !node.parentNode) {\n          node.hcOrigDetached = true;\n          doc.body.appendChild(node);\n        }\n\n        if (H.getStyle(node, 'display', false) === 'none' || node.hcOricDetached) {\n          node.hcOrigStyle = {\n            display: node.style.display,\n            height: node.style.height,\n            overflow: node.style.overflow\n          };\n          tempStyle = {\n            display: 'block',\n            overflow: 'hidden'\n          };\n\n          if (node !== this.renderTo) {\n            tempStyle.height = 0;\n          }\n\n          H.css(node, tempStyle); // If it still doesn't have an offset width after setting\n          // display to block, it probably has an !important priority\n          // #2631, 6803\n\n          if (!node.offsetWidth) {\n            node.style.setProperty('display', 'block', 'important');\n          }\n        }\n\n        node = node.parentNode;\n\n        if (node === doc.body) {\n          break;\n        }\n      }\n    } else {\n      while (node && node.style) {\n        if (node.hcOrigStyle) {\n          H.css(node, node.hcOrigStyle);\n          delete node.hcOrigStyle;\n        }\n\n        if (node.hcOrigDetached) {\n          doc.body.removeChild(node);\n          node.hcOrigDetached = false;\n        }\n\n        node = node.parentNode;\n      }\n    }\n  },\n\n  /**\n   * Set the {@link Chart.container|chart container's} class name, in\n   * addition to `highcharts-container`.\n   *\n   * @function Highcharts.Chart#setClassName\n   *\n   * @param {string} className\n   */\n  setClassName: function (className) {\n    this.container.className = 'highcharts-container ' + (className || '');\n  },\n\n  /**\n   * Get the containing element, determine the size and create the inner\n   * container div to hold the chart.\n   *\n   * @private\n   * @function Highcharts.Chart#afterGetContainer\n   *\n   * @fires Highcharts.Chart#event:afterGetContainer\n   */\n  getContainer: function () {\n    var chart = this,\n        container,\n        options = chart.options,\n        optionsChart = options.chart,\n        chartWidth,\n        chartHeight,\n        renderTo = chart.renderTo,\n        indexAttrName = 'data-highcharts-chart',\n        oldChartIndex,\n        Ren,\n        containerId = H.uniqueKey(),\n        containerStyle,\n        key;\n\n    if (!renderTo) {\n      chart.renderTo = renderTo = optionsChart.renderTo;\n    }\n\n    if (isString(renderTo)) {\n      chart.renderTo = renderTo = doc.getElementById(renderTo);\n    } // Display an error if the renderTo is wrong\n\n\n    if (!renderTo) {\n      H.error(13, true);\n    } // If the container already holds a chart, destroy it. The check for\n    // hasRendered is there because web pages that are saved to disk from\n    // the browser, will preserve the data-highcharts-chart attribute and\n    // the SVG contents, but not an interactive chart. So in this case,\n    // charts[oldChartIndex] will point to the wrong chart if any (#2609).\n\n\n    oldChartIndex = pInt(attr(renderTo, indexAttrName));\n\n    if (isNumber(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {\n      charts[oldChartIndex].destroy();\n    } // Make a reference to the chart from the div\n\n\n    attr(renderTo, indexAttrName, chart.index); // remove previous chart\n\n    renderTo.innerHTML = ''; // If the container doesn't have an offsetWidth, it has or is a child of\n    // a node that has display:none. We need to temporarily move it out to a\n    // visible state to determine the size, else the legend and tooltips\n    // won't render properly. The skipClone option is used in sparklines as\n    // a micro optimization, saving about 1-2 ms each chart.\n\n    if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n      chart.temporaryDisplay();\n    } // get the width and height\n\n\n    chart.getChartSize();\n    chartWidth = chart.chartWidth;\n    chartHeight = chart.chartHeight; // Create the inner container\n\n    /**\n     * The containing HTML element of the chart. The container is\n     * dynamically inserted into the element given as the `renderTo`\n     * parameter in the {@link Highcharts#chart} constructor.\n     *\n     * @name Highcharts.Chart#container\n     * @type {Highcharts.HTMLDOMElement}\n     */\n\n    container = createElement('div', {\n      id: containerId\n    }, containerStyle, renderTo);\n    chart.container = container; // cache the cursor (#1650)\n\n    chart._cursor = container.style.cursor; // Initialize the renderer\n\n    Ren = H[optionsChart.renderer] || H.Renderer;\n    /**\n     * The renderer instance of the chart. Each chart instance has only one\n     * associated renderer.\n     *\n     * @name Highcharts.Chart#renderer\n     * @type {Highcharts.SVGRenderer}\n     */\n\n    chart.renderer = new Ren(container, chartWidth, chartHeight, null, optionsChart.forExport, options.exporting && options.exporting.allowHTML);\n    chart.setClassName(optionsChart.className); // Initialize definitions\n\n    for (key in options.defs) {\n      this.renderer.definition(options.defs[key]);\n    } // Add a reference to the charts index\n\n\n    chart.renderer.chartIndex = chart.index;\n    fireEvent(this, 'afterGetContainer');\n  },\n\n  /**\n   * Calculate margins by rendering axis labels in a preliminary position.\n   * Title, subtitle and legend have already been rendered at this stage, but\n   * will be moved into their final positions.\n   *\n   * @private\n   * @function Highcharts.Chart#getMargins\n   *\n   * @param  {boolean} skipAxes\n   *\n   * @fires Highcharts.Chart#event:getMargins\n   */\n  getMargins: function (skipAxes) {\n    var chart = this,\n        spacing = chart.spacing,\n        margin = chart.margin,\n        titleOffset = chart.titleOffset;\n    chart.resetMargins(); // Adjust for title and subtitle\n\n    if (titleOffset && !defined(margin[0])) {\n      chart.plotTop = Math.max(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);\n    } // Adjust for legend\n\n\n    if (chart.legend && chart.legend.display) {\n      chart.legend.adjustMargins(margin, spacing);\n    }\n\n    fireEvent(this, 'getMargins');\n\n    if (!skipAxes) {\n      this.getAxisMargins();\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Chart#getAxisMargins\n   */\n  getAxisMargins: function () {\n    var chart = this,\n        // [top, right, bottom, left]\n    axisOffset = chart.axisOffset = [0, 0, 0, 0],\n        margin = chart.margin; // pre-render axes to get labels offset width\n\n    if (chart.hasCartesianSeries) {\n      each(chart.axes, function (axis) {\n        if (axis.visible) {\n          axis.getOffset();\n        }\n      });\n    } // Add the axis offsets\n\n\n    each(marginNames, function (m, side) {\n      if (!defined(margin[side])) {\n        chart[m] += axisOffset[side];\n      }\n    });\n    chart.setChartSize();\n  },\n\n  /**\n   * Reflows the chart to its container. By default, the chart reflows\n   * automatically to its container following a `window.resize` event, as per\n   * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}\n   * option. However, there are no reliable events for div resize, so if the\n   * container is resized without a window resize event, this must be called\n   * explicitly.\n   *\n   * @sample highcharts/members/chart-reflow/\n   *         Resize div and reflow\n   * @sample highcharts/chart/events-container/\n   *         Pop up and reflow\n   *\n   * @function Highcharts.Chart#reflow\n   *\n   * @param  {global.Event} e\n   *         Event arguments. Used primarily when the function is called\n   *         internally as a response to window resize.\n   */\n  reflow: function (e) {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        renderTo = chart.renderTo,\n        hasUserSize = defined(optionsChart.width) && defined(optionsChart.height),\n        width = optionsChart.width || H.getStyle(renderTo, 'width'),\n        height = optionsChart.height || H.getStyle(renderTo, 'height'),\n        target = e ? e.target : win; // Width and height checks for display:none. Target is doc in IE8 and\n    // Opera, win in Firefox, Chrome and IE9.\n\n    if (!hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) {\n      if (width !== chart.containerWidth || height !== chart.containerHeight) {\n        H.clearTimeout(chart.reflowTimeout); // When called from window.resize, e is set, else it's called\n        // directly (#2224)\n\n        chart.reflowTimeout = syncTimeout(function () {\n          // Set size, it may have been destroyed in the meantime\n          // (#1257)\n          if (chart.container) {\n            chart.setSize(undefined, undefined, false);\n          }\n        }, e ? 100 : 0);\n      }\n\n      chart.containerWidth = width;\n      chart.containerHeight = height;\n    }\n  },\n\n  /**\n   * Toggle the event handlers necessary for auto resizing, depending on the\n   * `chart.reflow` option.\n   *\n   * @private\n   * @function Highcharts.Chart#setReflow\n   *\n   * @param  {boolean} reflow\n   */\n  setReflow: function (reflow) {\n    var chart = this;\n\n    if (reflow !== false && !this.unbindReflow) {\n      this.unbindReflow = addEvent(win, 'resize', function (e) {\n        chart.reflow(e);\n      });\n      addEvent(this, 'destroy', this.unbindReflow);\n    } else if (reflow === false && this.unbindReflow) {\n      // Unbind and unset\n      this.unbindReflow = this.unbindReflow();\n    } // The following will add listeners to re-fit the chart before and after\n    // printing (#2284). However it only works in WebKit. Should have worked\n    // in Firefox, but not supported in IE.\n\n    /*\n    if (win.matchMedia) {\n        win.matchMedia('print').addListener(function reflow() {\n            chart.reflow();\n        });\n    }\n    //*/\n\n  },\n\n  /**\n   * Resize the chart to a given width and height. In order to set the width\n   * only, the height argument may be skipped. To set the height only, pass\n   * `undefined` for the width.\n   *\n   * @sample highcharts/members/chart-setsize-button/\n   *         Test resizing from buttons\n   * @sample highcharts/members/chart-setsize-jquery-resizable/\n   *         Add a jQuery UI resizable\n   * @sample stock/members/chart-setsize/\n   *         Highstock with UI resizable\n   *\n   * @function Highcharts.Chart#setSize\n   *\n   * @param  {number|null|undefined} [width]\n   *         The new pixel width of the chart. Since v4.2.6, the argument can\n   *         be `undefined` in order to preserve the current value (when\n   *         setting height only), or `null` to adapt to the width of the\n   *         containing element.\n   *\n   * @param  {number|null|undefined} [height]\n   *         The new pixel height of the chart. Since v4.2.6, the argument can\n   *         be `undefined` in order to preserve the current value, or `null`\n   *         in order to adapt to the height of the containing element.\n   *\n   * @param  {Highcharts.AnimationOptionsObject|undefined} [animation=true]\n   *         Whether and how to apply animation.\n   *\n   * @fires Highcharts.Chart#event:endResize\n   * @fires Highcharts.Chart#event:resize\n   */\n  setSize: function (width, height, animation) {\n    var chart = this,\n        renderer = chart.renderer,\n        globalAnimation; // Handle the isResizing counter\n\n    chart.isResizing += 1; // set the animation for the current process\n\n    H.setAnimation(animation, chart);\n    chart.oldChartHeight = chart.chartHeight;\n    chart.oldChartWidth = chart.chartWidth;\n\n    if (width !== undefined) {\n      chart.options.chart.width = width;\n    }\n\n    if (height !== undefined) {\n      chart.options.chart.height = height;\n    }\n\n    chart.getChartSize(); // Resize the container with the global animation applied if enabled\n    // (#2503)\n\n    chart.setChartSize(true);\n    renderer.setSize(chart.chartWidth, chart.chartHeight, animation); // handle axes\n\n    each(chart.axes, function (axis) {\n      axis.isDirty = true;\n      axis.setScale();\n    });\n    chart.isDirtyLegend = true; // force legend redraw\n\n    chart.isDirtyBox = true; // force redraw of plot and chart border\n\n    chart.layOutTitles(); // #2857\n\n    chart.getMargins();\n    chart.redraw(animation);\n    chart.oldChartHeight = null;\n    fireEvent(chart, 'resize'); // Fire endResize and set isResizing back. If animation is disabled,\n    // fire without delay\n\n    syncTimeout(function () {\n      if (chart) {\n        fireEvent(chart, 'endResize', null, function () {\n          chart.isResizing -= 1;\n        });\n      }\n    }, animObject(globalAnimation).duration);\n  },\n\n  /**\n   * Set the public chart properties. This is done before and after the\n   * pre-render to determine margin sizes.\n   *\n   * @private\n   * @function Highcharts.Chart#setChartSize\n   *\n   * @param  {boolean} skipAxes\n   *\n   * @fires Highcharts.Chart#event:afterSetChartSize\n   */\n  setChartSize: function (skipAxes) {\n    var chart = this,\n        inverted = chart.inverted,\n        renderer = chart.renderer,\n        chartWidth = chart.chartWidth,\n        chartHeight = chart.chartHeight,\n        optionsChart = chart.options.chart,\n        spacing = chart.spacing,\n        clipOffset = chart.clipOffset,\n        clipX,\n        clipY,\n        plotLeft,\n        plotTop,\n        plotWidth,\n        plotHeight,\n        plotBorderWidth;\n    /**\n     * The current left position of the plot area in pixels.\n     *\n     * @name Highcharts.Chart#plotLeft\n     * @type {number}\n     */\n\n    chart.plotLeft = plotLeft = Math.round(chart.plotLeft);\n    /**\n     * The current top position of the plot area in pixels.\n     *\n     * @name Highcharts.Chart#plotTop\n     * @type {number}\n     */\n\n    chart.plotTop = plotTop = Math.round(chart.plotTop);\n    /**\n     * The current width of the plot area in pixels.\n     *\n     * @name Highcharts.Chart#plotWidth\n     * @type {number}\n     */\n\n    chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));\n    /**\n     * The current height of the plot area in pixels.\n     *\n     * @name Highcharts.Chart#plotHeight\n     * @type {number}\n     */\n\n    chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));\n    chart.plotSizeX = inverted ? plotHeight : plotWidth;\n    chart.plotSizeY = inverted ? plotWidth : plotHeight;\n    chart.plotBorderWidth = optionsChart.plotBorderWidth || 0; // Set boxes used for alignment\n\n    chart.spacingBox = renderer.spacingBox = {\n      x: spacing[3],\n      y: spacing[0],\n      width: chartWidth - spacing[3] - spacing[1],\n      height: chartHeight - spacing[0] - spacing[2]\n    };\n    chart.plotBox = renderer.plotBox = {\n      x: plotLeft,\n      y: plotTop,\n      width: plotWidth,\n      height: plotHeight\n    };\n    plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);\n    clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2);\n    clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);\n    chart.clipBox = {\n      x: clipX,\n      y: clipY,\n      width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX),\n      height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))\n    };\n\n    if (!skipAxes) {\n      each(chart.axes, function (axis) {\n        axis.setAxisSize();\n        axis.setAxisTranslation();\n      });\n    }\n\n    fireEvent(chart, 'afterSetChartSize', {\n      skipAxes: skipAxes\n    });\n  },\n\n  /**\n   * Initial margins before auto size margins are applied.\n   *\n   * @private\n   * @function Highcharts.Chart#resetMargins\n   */\n  resetMargins: function () {\n    var chart = this,\n        chartOptions = chart.options.chart; // Create margin and spacing array\n\n    each(['margin', 'spacing'], function splashArrays(target) {\n      var value = chartOptions[target],\n          values = isObject(value) ? value : [value, value, value, value];\n      each(['Top', 'Right', 'Bottom', 'Left'], function (sideName, side) {\n        chart[target][side] = pick(chartOptions[target + sideName], values[side]);\n      });\n    }); // Set margin names like chart.plotTop, chart.plotLeft,\n    // chart.marginRight, chart.marginBottom.\n\n    each(marginNames, function (m, side) {\n      chart[m] = pick(chart.margin[side], chart.spacing[side]);\n    });\n    chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n\n    chart.clipOffset = [0, 0, 0, 0];\n  },\n\n  /**\n   * Internal function to draw or redraw the borders and backgrounds for chart\n   * and plot area.\n   *\n   * @private\n   * @function Highcharts.Chart#drawChartBox\n   *\n   * @fires Highcharts.Chart#event:afterDrawChartBox\n   */\n  drawChartBox: function () {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        renderer = chart.renderer,\n        chartWidth = chart.chartWidth,\n        chartHeight = chart.chartHeight,\n        chartBackground = chart.chartBackground,\n        plotBackground = chart.plotBackground,\n        plotBorder = chart.plotBorder,\n        chartBorderWidth,\n        mgn,\n        bgAttr,\n        plotLeft = chart.plotLeft,\n        plotTop = chart.plotTop,\n        plotWidth = chart.plotWidth,\n        plotHeight = chart.plotHeight,\n        plotBox = chart.plotBox,\n        clipRect = chart.clipRect,\n        clipBox = chart.clipBox,\n        verb = 'animate'; // Chart area\n\n    if (!chartBackground) {\n      chart.chartBackground = chartBackground = renderer.rect().addClass('highcharts-background').add();\n      verb = 'attr';\n    }\n\n    chartBorderWidth = mgn = chartBackground.strokeWidth();\n    chartBackground[verb]({\n      x: mgn / 2,\n      y: mgn / 2,\n      width: chartWidth - mgn - chartBorderWidth % 2,\n      height: chartHeight - mgn - chartBorderWidth % 2,\n      r: optionsChart.borderRadius\n    }); // Plot background\n\n    verb = 'animate';\n\n    if (!plotBackground) {\n      verb = 'attr';\n      chart.plotBackground = plotBackground = renderer.rect().addClass('highcharts-plot-background').add();\n    }\n\n    plotBackground[verb](plotBox); // Plot clip\n\n    if (!clipRect) {\n      chart.clipRect = renderer.clipRect(clipBox);\n    } else {\n      clipRect.animate({\n        width: clipBox.width,\n        height: clipBox.height\n      });\n    } // Plot area border\n\n\n    verb = 'animate';\n\n    if (!plotBorder) {\n      verb = 'attr';\n      chart.plotBorder = plotBorder = renderer.rect().addClass('highcharts-plot-border').attr({\n        zIndex: 1 // Above the grid\n\n      }).add();\n    }\n\n    plotBorder[verb](plotBorder.crisp({\n      x: plotLeft,\n      y: plotTop,\n      width: plotWidth,\n      height: plotHeight\n    }, -plotBorder.strokeWidth())); // #3282 plotBorder should be negative;\n    // reset\n\n    chart.isDirtyBox = false;\n    fireEvent(this, 'afterDrawChartBox');\n  },\n\n  /**\n   * Detect whether a certain chart property is needed based on inspecting its\n   * options and series. This mainly applies to the chart.inverted property,\n   * and in extensions to the chart.angular and chart.polar properties.\n   *\n   * @private\n   * @function Highcharts.Chart#propFromSeries\n   */\n  propFromSeries: function () {\n    var chart = this,\n        optionsChart = chart.options.chart,\n        klass,\n        seriesOptions = chart.options.series,\n        i,\n        value;\n    each(['inverted', 'angular', 'polar'], function (key) {\n      // The default series type's class\n      klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType]; // Get the value from available chart-wide properties\n\n      value = optionsChart[key] || // It is set in the options\n      klass && klass.prototype[key]; // The default series class\n      // requires it\n      // 4. Check if any the chart's series require it\n\n      i = seriesOptions && seriesOptions.length;\n\n      while (!value && i--) {\n        klass = seriesTypes[seriesOptions[i].type];\n\n        if (klass && klass.prototype[key]) {\n          value = true;\n        }\n      } // Set the chart property\n\n\n      chart[key] = value;\n    });\n  },\n\n  /**\n   * Internal function to link two or more series together, based on the\n   * `linkedTo` option. This is done from `Chart.render`, and after\n   * `Chart.addSeries` and `Series.remove`.\n   *\n   * @private\n   * @function Highcharts.Chart#linkSeries\n   *\n   * @fires Highcharts.Chart#event:afterLinkSeries\n   */\n  linkSeries: function () {\n    var chart = this,\n        chartSeries = chart.series; // Reset links\n\n    each(chartSeries, function (series) {\n      series.linkedSeries.length = 0;\n    }); // Apply new links\n\n    each(chartSeries, function (series) {\n      var linkedTo = series.options.linkedTo;\n\n      if (isString(linkedTo)) {\n        if (linkedTo === ':previous') {\n          linkedTo = chart.series[series.index - 1];\n        } else {\n          linkedTo = chart.get(linkedTo);\n        } // #3341 avoid mutual linking\n\n\n        if (linkedTo && linkedTo.linkedParent !== series) {\n          linkedTo.linkedSeries.push(series);\n          series.linkedParent = linkedTo;\n          series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible); // #3879\n        }\n      }\n    });\n    fireEvent(this, 'afterLinkSeries');\n  },\n\n  /**\n   * Render series for the chart.\n   *\n   * @private\n   * @function Highcharts.Chart#renderSeries\n   */\n  renderSeries: function () {\n    each(this.series, function (serie) {\n      serie.translate();\n      serie.render();\n    });\n  },\n\n  /**\n   * Render labels for the chart.\n   *\n   * @private\n   * @function Highcharts.Chart#renderLabels\n   */\n  renderLabels: function () {\n    var chart = this,\n        labels = chart.options.labels;\n\n    if (labels.items) {\n      each(labels.items, function (label) {\n        var style = extend(labels.style, label.style),\n            x = pInt(style.left) + chart.plotLeft,\n            y = pInt(style.top) + chart.plotTop + 12; // delete to prevent rewriting in IE\n\n        delete style.left;\n        delete style.top;\n        chart.renderer.text(label.html, x, y).attr({\n          zIndex: 2\n        }).css(style).add();\n      });\n    }\n  },\n\n  /**\n   * Render all graphics for the chart. Runs internally on initialization.\n   *\n   * @private\n   * @function Highcharts.Chart#render\n   */\n  render: function () {\n    var chart = this,\n        axes = chart.axes,\n        renderer = chart.renderer,\n        options = chart.options,\n        tempWidth,\n        tempHeight,\n        redoHorizontal,\n        redoVertical; // Title\n\n    chart.setTitle();\n    /**\n     * The overview of the chart's series.\n     *\n     * @name Highcharts.Chart#legend\n     * @type {Highcharts.Legend}\n     */\n\n    chart.legend = new Legend(chart, options.legend); // Get stacks\n\n    if (chart.getStacks) {\n      chart.getStacks();\n    } // Get chart margins\n\n\n    chart.getMargins(true);\n    chart.setChartSize(); // Record preliminary dimensions for later comparison\n\n    tempWidth = chart.plotWidth; // 21 is the most common correction for X axis labels\n    // use Math.max to prevent negative plotHeight\n\n    tempHeight = chart.plotHeight = Math.max(chart.plotHeight - 21, 0); // Get margins by pre-rendering axes\n\n    each(axes, function (axis) {\n      axis.setScale();\n    });\n    chart.getAxisMargins(); // If the plot area size has changed significantly, calculate tick\n    // positions again\n\n    redoHorizontal = tempWidth / chart.plotWidth > 1.1; // Height is more sensitive, use lower threshold\n\n    redoVertical = tempHeight / chart.plotHeight > 1.05;\n\n    if (redoHorizontal || redoVertical) {\n      each(axes, function (axis) {\n        if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {\n          // update to reflect the new margins\n          axis.setTickInterval(true);\n        }\n      });\n      chart.getMargins(); // second pass to check for new labels\n    } // Draw the borders and backgrounds\n\n\n    chart.drawChartBox(); // Axes\n\n    if (chart.hasCartesianSeries) {\n      each(axes, function (axis) {\n        if (axis.visible) {\n          axis.render();\n        }\n      });\n    } // The series\n\n\n    if (!chart.seriesGroup) {\n      chart.seriesGroup = renderer.g('series-group').attr({\n        zIndex: 3\n      }).add();\n    }\n\n    chart.renderSeries(); // Labels\n\n    chart.renderLabels(); // Credits\n\n    chart.addCredits(); // Handle responsiveness\n\n    if (chart.setResponsive) {\n      chart.setResponsive();\n    } // Set flag\n\n\n    chart.hasRendered = true;\n  },\n\n  /**\n   * Set a new credits label for the chart.\n   *\n   * @sample highcharts/credits/credits-update/\n   *         Add and update credits\n   *\n   * @function Highcharts.Chart#addCredits\n   *\n   * @param  {Highcharts.CreditsOptions} options\n   *         A configuration object for the new credits.\n   */\n  addCredits: function (credits) {\n    var chart = this;\n    credits = merge(true, this.options.credits, credits);\n\n    if (credits.enabled && !this.credits) {\n      /**\n       * The chart's credits label. The label has an `update` method that\n       * allows setting new options as per the\n       * {@link https://api.highcharts.com/highcharts/credits|credits options set}.\n       *\n       * @name Highcharts.Chart#credits\n       * @type {Highcharts.SVGElement}\n       */\n      this.credits = this.renderer.text(credits.text + (this.mapCredits || ''), 0, 0).addClass('highcharts-credits').on('click', function () {\n        if (credits.href) {\n          win.location.href = credits.href;\n        }\n      }).attr({\n        align: credits.position.align,\n        zIndex: 8\n      }).add().align(credits.position); // Dynamically update\n\n      this.credits.update = function (options) {\n        chart.credits = chart.credits.destroy();\n        chart.addCredits(options);\n      };\n    }\n  },\n\n  /**\n   * Remove the chart and purge memory. This method is called internally\n   * before adding a second chart into the same container, as well as on\n   * window unload to prevent leaks.\n   *\n   * @sample highcharts/members/chart-destroy/\n   *         Destroy the chart from a button\n   * @sample stock/members/chart-destroy/\n   *         Destroy with Highstock\n   *\n   * @function Highcharts.Chart#destroy\n   *\n   * @fires Highcharts.Chart#event:destroy\n   */\n  destroy: function () {\n    var chart = this,\n        axes = chart.axes,\n        series = chart.series,\n        container = chart.container,\n        i,\n        parentNode = container && container.parentNode; // fire the chart.destoy event\n\n    fireEvent(chart, 'destroy'); // Delete the chart from charts lookup array\n\n    if (chart.renderer.forExport) {\n      H.erase(charts, chart); // #6569\n    } else {\n      charts[chart.index] = undefined;\n    }\n\n    H.chartCount--;\n    chart.renderTo.removeAttribute('data-highcharts-chart'); // remove events\n\n    removeEvent(chart); // ==== Destroy collections:\n    // Destroy axes\n\n    i = axes.length;\n\n    while (i--) {\n      axes[i] = axes[i].destroy();\n    } // Destroy scroller & scroller series before destroying base series\n\n\n    if (this.scroller && this.scroller.destroy) {\n      this.scroller.destroy();\n    } // Destroy each series\n\n\n    i = series.length;\n\n    while (i--) {\n      series[i] = series[i].destroy();\n    } // ==== Destroy chart properties:\n\n\n    each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n      var prop = chart[name];\n\n      if (prop && prop.destroy) {\n        chart[name] = prop.destroy();\n      }\n    }); // Remove container and all SVG, check container as it can break in IE\n    // when destroyed before finished loading\n\n    if (container) {\n      container.innerHTML = '';\n      removeEvent(container);\n\n      if (parentNode) {\n        discardElement(container);\n      }\n    } // clean it all up\n\n\n    objectEach(chart, function (val, key) {\n      delete chart[key];\n    });\n  },\n\n  /**\n   * Prepare for first rendering after all data are loaded.\n   *\n   * @private\n   * @function Highcharts.Chart#firstRender\n   *\n   * @fires Highcharts.Chart#event:beforeRender\n   */\n  firstRender: function () {\n    var chart = this,\n        options = chart.options; // Hook for oldIE to check whether the chart is ready to render\n\n    if (chart.isReadyToRender && !chart.isReadyToRender()) {\n      return;\n    } // Create the container\n\n\n    chart.getContainer();\n    chart.resetMargins();\n    chart.setChartSize(); // Set the common chart properties (mainly invert) from the given series\n\n    chart.propFromSeries(); // get axes\n\n    chart.getAxes(); // Initialize the series\n\n    each(options.series || [], function (serieOptions) {\n      chart.initSeries(serieOptions);\n    });\n    chart.linkSeries(); // Run an event after axes and series are initialized, but before\n    // render. At this stage, the series data is indexed and cached in the\n    // xData and yData arrays, so we can access those before rendering. Used\n    // in Highstock.\n\n    fireEvent(chart, 'beforeRender'); // depends on inverted and on margins being set\n\n    if (Pointer) {\n      /**\n       * The Pointer that keeps track of mouse and touch interaction.\n       *\n       * @memberof Highcharts.Chart\n       * @name pointer\n       * @type {Highcharts.Pointer}\n       * @instance\n       */\n      chart.pointer = new Pointer(chart, options);\n    }\n\n    chart.render(); // Fire the load event if there are no external images\n\n    if (!chart.renderer.imgCount && chart.onload) {\n      chart.onload();\n    } // If the chart was rendered outside the top container, put it back in\n    // (#3679)\n\n\n    chart.temporaryDisplay(true);\n  },\n\n  /**\n   * Internal function that runs on chart load, async if any images are loaded\n   * in the chart. Runs the callbacks and triggers the `load` and `render`\n   * events.\n   *\n   * @private\n   * @function Highcharts.Chart#onload\n   *\n   * @fires Highcharts.Chart#event:load\n   * @fires Highcharts.Chart#event:render\n   */\n  onload: function () {\n    // Run callbacks\n    each([this.callback].concat(this.callbacks), function (fn) {\n      // Chart destroyed in its own callback (#3600)\n      if (fn && this.index !== undefined) {\n        fn.apply(this, [this]);\n      }\n    }, this);\n    fireEvent(this, 'load');\n    fireEvent(this, 'render'); // Set up auto resize, check for not destroyed (#6068)\n\n    if (defined(this.index)) {\n      this.setReflow(this.options.chart.reflow);\n    } // Don't run again\n\n\n    this.onload = null;\n  }\n}); // end Chart"
    },
    {
     "id": 244,
     "name": "../node_modules/highcharts/js/es-modules/parts/Axis.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Options for crosshairs on axes.\n *\n * @typedef {Highcharts.XAxisCrosshairOptions|Highcharts.YAxisCrosshairOptions} Highcharts.AxisCrosshairOptions\n */\n\n/**\n * Options for axes.\n *\n * @typedef {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} Highcharts.AxisOptions\n */\n\n/**\n * Position of the axis title.\n *\n * @typedef Highcharts.AxisTitlePositionObject\n *\n * @property {number} x\n *           X position.\n *\n * @property {number} y\n *           Y position.\n */\n\n/**\n * The returned object literal from the {@link Highcharts.Axis#getExtremes}\n * function.\n *\n * @typedef Highcharts.ExtremesObject\n *\n * @property {number} dataMax\n *           The maximum value of the axis' associated series.\n *\n * @property {number} dataMin\n *           The minimum value of the axis' associated series.\n *\n * @property {number} max\n *           The maximum axis value, either automatic or set manually. If\n *           the `max` option is not set, `maxPadding` is 0 and `endOnTick`\n *           is false, this value will be the same as `dataMax`.\n *\n * @property {number} min\n *           The minimum axis value, either automatic or set manually. If\n *           the `min` option is not set, `minPadding` is 0 and\n *           `startOnTick` is false, this value will be the same\n *           as `dataMin`.\n *\n * @property {number} userMax\n *           The user defined maximum, either from the `max` option or from\n *           a zoom or `setExtremes` action.\n *\n * @property {number} userMin\n *           The user defined minimum, either from the `min` option or from\n *           a zoom or `setExtremes` action.\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Color.js';\nimport './Options.js';\nimport './Tick.js';\nvar addEvent = H.addEvent,\n    animObject = H.animObject,\n    arrayMax = H.arrayMax,\n    arrayMin = H.arrayMin,\n    color = H.color,\n    correctFloat = H.correctFloat,\n    defaultOptions = H.defaultOptions,\n    defined = H.defined,\n    deg2rad = H.deg2rad,\n    destroyObjectProperties = H.destroyObjectProperties,\n    each = H.each,\n    extend = H.extend,\n    fireEvent = H.fireEvent,\n    format = H.format,\n    getMagnitude = H.getMagnitude,\n    grep = H.grep,\n    inArray = H.inArray,\n    isArray = H.isArray,\n    isNumber = H.isNumber,\n    isString = H.isString,\n    merge = H.merge,\n    normalizeTickInterval = H.normalizeTickInterval,\n    objectEach = H.objectEach,\n    pick = H.pick,\n    removeEvent = H.removeEvent,\n    splat = H.splat,\n    syncTimeout = H.syncTimeout,\n    Tick = H.Tick;\n/**\n * Create a new axis object. Called internally when instanciating a new chart or\n * adding axes by {@link Highcharts.Chart#addAxis}.\n *\n * A chart can have from 0 axes (pie chart) to multiples. In a normal, single\n * series cartesian chart, there is one X axis and one Y axis.\n *\n * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is\n * an array of Axis objects. If there is only one axis, it can be referenced\n * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same\n * pattern goes for Y axes.\n *\n * If you need to get the axes from a series object, use the `series.xAxis` and\n * `series.yAxis` properties. These are not arrays, as one series can only be\n * associated to one X and one Y axis.\n *\n * A third way to reference the axis programmatically is by `id`. Add an `id` in\n * the axis configuration options, and get the axis by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the axes are given in options.xAxis and\n * options.yAxis.\n *\n * @class\n * @name Highcharts.Axis\n *\n * @param {Highcharts.Chart} chart\n *        The Chart instance to apply the axis on.\n *\n * @param {Highcharts.AxisOptions} options\n *        Axis options.\n */\n\nvar Axis = function () {\n  this.init.apply(this, arguments);\n};\n\nH.extend(Axis.prototype,\n/** @lends Highcharts.Axis.prototype */\n{\n  /**\n   * The X axis or category axis. Normally this is the horizontal axis,\n   * though if the chart is inverted this is the vertical axis. In case of\n   * multiple axes, the xAxis node is an array of configuration objects.\n   *\n   * See [the Axis object](/class-reference/Highcharts.Axis) for\n   * programmatic access to the axis.\n   *\n   * @productdesc {highmaps}\n   * In Highmaps, the axis is hidden, but it is used behind the scenes to\n   * control features like zooming and panning. Zooming is in effect the same\n   * as setting the extremes of one of the exes.\n   *\n   * @optionparent xAxis\n   */\n  defaultOptions: {\n    /**\n     * When using multiple axis, the ticks of two or more opposite axes\n     * will automatically be aligned by adding ticks to the axis or axes\n     * with the least ticks, as if `tickAmount` were specified.\n     *\n     * This can be prevented by setting `alignTicks` to false. If the grid\n     * lines look messy, it's a good idea to hide them for the secondary\n     * axis by setting `gridLineWidth` to 0.\n     *\n     * If `startOnTick` or `endOnTick` in an Axis options are set to false,\n     * then the `alignTicks ` will be disabled for the Axis.\n     *\n     * Disabled for logarithmic axes.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @product   highcharts highstock\n     * @apioption xAxis.alignTicks\n     */\n\n    /**\n     * Whether to allow decimals in this axis' ticks. When counting\n     * integers, like persons or hits on a web page, decimals should\n     * be avoided in the labels.\n     *\n     * @see [minTickInterval](#xAxis.minTickInterval)\n     *\n     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/\n     *         True by default\n     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/\n     *         False\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     2.0\n     * @apioption xAxis.allowDecimals\n     */\n\n    /**\n     * When using an alternate grid color, a band is painted across the\n     * plot area between every other grid line.\n     *\n     * @sample {highcharts} highcharts/yaxis/alternategridcolor/\n     *         Alternate grid color on the Y axis\n     * @sample {highstock} stock/xaxis/alternategridcolor/\n     *         Alternate grid color on the Y axis\n     *\n     * @type      {Highcharts.ColorString}\n     * @apioption xAxis.alternateGridColor\n     */\n\n    /**\n     * An array defining breaks in the axis, the sections defined will be\n     * left out and all the points shifted closer to each other.\n     *\n     * @productdesc {highcharts}\n     * Requires that the broken-axis.js module is loaded.\n     *\n     * @sample {highcharts} highcharts/axisbreak/break-simple/\n     *         Simple break\n     * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/\n     *         Advanced with callback\n     * @sample {highstock} stock/demo/intraday-breaks/\n     *         Break on nights and weekends\n     *\n     * @type      {Array<*>}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks\n     */\n\n    /**\n     * A number indicating how much space should be left between the start\n     * and the end of the break. The break size is given in axis units,\n     * so for instance on a `datetime` axis, a break size of 3600000 would\n     * indicate the equivalent of an hour.\n     *\n     * @type      {number}\n     * @default   0\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks.breakSize\n     */\n\n    /**\n     * The point where the break starts.\n     *\n     * @type      {number}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks.from\n     */\n\n    /**\n     * Defines an interval after which the break appears again. By default\n     * the breaks do not repeat.\n     *\n     * @type      {number}\n     * @default   0\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks.repeat\n     */\n\n    /**\n     * The point where the break ends.\n     *\n     * @type      {number}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.breaks.to\n     */\n\n    /**\n     * If categories are present for the xAxis, names are used instead of\n     * numbers for that axis. Since Highcharts 3.0, categories can also\n     * be extracted by giving each point a [name](#series.data) and setting\n     * axis [type](#xAxis.type) to `category`. However, if you have multiple\n     * series, best practice remains defining the `categories` array.\n     *\n     * Example:\n     *\n     * <pre>categories: ['Apples', 'Bananas', 'Oranges']</pre>\n     *\n     * @sample {highcharts} highcharts/demo/line-labels/\n     *         With\n     * @sample {highcharts} highcharts/xaxis/categories/\n     *         Without\n     *\n     * @type      {Array<string>}\n     * @product   highcharts\n     * @apioption xAxis.categories\n     */\n\n    /**\n     * The highest allowed value for automatically computed axis extremes.\n     *\n     * @see [floor](#xAxis.floor)\n     *\n     * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/\n     *         Floor and ceiling\n     *\n     * @type       {number}\n     * @since      4.0\n     * @product    highcharts highstock\n     * @apioption  xAxis.ceiling\n     */\n\n    /**\n     * A class name that opens for styling the axis by CSS, especially in\n     * Highcharts styled mode. The class name is applied to group elements\n     * for the grid, axis elements and labels.\n     *\n     * @sample {highcharts|highstock|highmaps} highcharts/css/axis/\n     *         Multiple axes with separate styling\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption xAxis.className\n     */\n\n    /**\n     * Configure a crosshair that follows either the mouse pointer or the\n     * hovered point.\n     *\n     * In styled mode, the crosshairs are styled in the\n     * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or\n     * `.highcharts-xaxis-category` classes.\n     *\n     * @productdesc {highstock}\n     * In Highstock, by default, the crosshair is enabled on the X axis and\n     * disabled on the Y axis.\n     *\n     * @sample {highcharts} highcharts/xaxis/crosshair-both/\n     *         Crosshair on both axes\n     * @sample {highstock} stock/xaxis/crosshairs-xy/\n     *         Crosshair on both axes\n     * @sample {highmaps} highcharts/xaxis/crosshair-both/\n     *         Crosshair on both axes\n     *\n     * @type      {boolean|*}\n     * @default   false\n     * @since     4.1\n     * @apioption xAxis.crosshair\n     */\n\n    /**\n     * A class name for the crosshair, especially as a hook for styling.\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption xAxis.crosshair.className\n     */\n\n    /**\n     * The color of the crosshair. Defaults to `#cccccc` for numeric and\n     * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where\n     * the crosshair by default highlights the whole category.\n     *\n     * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/\n     *         Customized crosshairs\n     *\n     * @type      {Highcharts.ColorString}\n     * @default   #cccccc\n     * @since     4.1\n     * @apioption xAxis.crosshair.color\n     */\n\n    /**\n     * The dash style for the crosshair. See\n     * [series.dashStyle](#plotOptions.series.dashStyle)\n     * for possible values.\n     *\n     * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/\n     *         Dotted crosshair\n     * @sample {highstock} stock/xaxis/crosshair-dashed/\n     *         Dashed X axis crosshair\n     *\n     * @type       {string}\n     * @default    Solid\n     * @since      4.1\n     * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n     *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\", \"DashDot\",\n     *             \"LongDashDot\", \"LongDashDotDot\"]\n     * @apioption  xAxis.crosshair.dashStyle\n     */\n\n    /**\n     * A label on the axis next to the crosshair.\n     *\n     * In styled mode, the label is styled with the\n     * `.highcharts-crosshair-label` class.\n     *\n     * @sample {highstock} stock/xaxis/crosshair-label/\n     *         Crosshair labels\n     * @sample {highstock} highcharts/css/crosshair-label/\n     *         Style mode\n     *\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label\n     */\n\n    /**\n     * Alignment of the label compared to the axis. Defaults to `left` for\n     * right-side axes, `right` for left-side axes and `center` for\n     * horizontal axes.\n     *\n     * @type      {string}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.align\n     */\n\n    /**\n     * The background color for the label. Defaults to the related series\n     * color, or `#666666` if that is not available.\n     *\n     * @type      {Highcharts.ColorString}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.backgroundColor\n     */\n\n    /**\n     * The border color for the crosshair label\n     *\n     * @type      {Highcharts.ColorString}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.borderColor\n     */\n\n    /**\n     * The border corner radius of the crosshair label.\n     *\n     * @type      {number}\n     * @default   3\n     * @since     2.1.10\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.borderRadius\n     */\n\n    /**\n     * The border width for the crosshair label.\n     *\n     * @type      {number}\n     * @default   0\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.borderWidth\n     */\n\n    /**\n     * A format string for the crosshair label. Defaults to `{value}` for\n     * numeric axes and `{value:%b %d, %Y}` for datetime axes.\n     *\n     * @type      {string}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.format\n     */\n\n    /**\n     * Formatter function for the label text.\n     *\n     * @type      {Highcharts.FormatterCallbackFunction}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.formatter\n     */\n\n    /**\n     * Padding inside the crosshair label.\n     *\n     * @type      {number}\n     * @default   8\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.padding\n     */\n\n    /**\n     * The shape to use for the label box.\n     *\n     * @type      {string}\n     * @default   callout\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.shape\n     */\n\n    /**\n     * Text styles for the crosshair label.\n     *\n     * @type      {Highcharts.CSSObject}\n     * @default   {\"color\": \"white\", \"fontWeight\": \"normal\", \"fontSize\": \"11px\", \"textAlign\": \"center\"}\n     * @since     2.1\n     * @product   highstock\n     * @apioption xAxis.crosshair.label.style\n     */\n\n    /**\n     * Whether the crosshair should snap to the point or follow the pointer\n     * independent of points.\n     *\n     * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/\n     *         True by default\n     * @sample {highmaps} maps/demo/latlon-advanced/\n     *         Snap is false\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.1\n     * @apioption xAxis.crosshair.snap\n     */\n\n    /**\n     * The pixel width of the crosshair. Defaults to 1 for numeric or\n     * datetime axes, and for one category width for category axes.\n     *\n     * @sample {highcharts} highcharts/xaxis/crosshair-customized/\n     *         Customized crosshairs\n     * @sample {highstock} highcharts/xaxis/crosshair-customized/\n     *         Customized crosshairs\n     * @sample {highmaps} highcharts/xaxis/crosshair-customized/\n     *         Customized crosshairs\n     *\n     * @type      {number}\n     * @default   1\n     * @since     4.1\n     * @apioption xAxis.crosshair.width\n     */\n\n    /**\n     * The Z index of the crosshair. Higher Z indices allow drawing the\n     * crosshair on top of the series or behind the grid lines.\n     *\n     * @type      {number}\n     * @default   2\n     * @since     4.1\n     * @apioption xAxis.crosshair.zIndex\n     */\n\n    /**\n     * For a datetime axis, the scale will automatically adjust to the\n     * appropriate unit. This member gives the default string\n     * representations used for each unit. For intermediate values,\n     * different units may be used, for example the `day` unit can be used\n     * on midnight and `hour` unit be used for intermediate values on the\n     * same axis. For an overview of the replacement codes, see\n     * [dateFormat](/class-reference/Highcharts#dateFormat). Defaults to:\n     *\n     * <pre>{\n     *     millisecond: '%H:%M:%S.%L',\n     *     second: '%H:%M:%S',\n     *     minute: '%H:%M',\n     *     hour: '%H:%M',\n     *     day: '%e. %b',\n     *     week: '%e. %b',\n     *     month: '%b \\'%y',\n     *     year: '%Y'\n     * }</pre>\n     *\n     * @sample {highcharts} highcharts/xaxis/datetimelabelformats/\n     *         Different day format on X axis\n     * @sample {highstock} stock/xaxis/datetimelabelformats/\n     *         More information in x axis labels\n     *\n     * @product highcharts highstock\n     */\n    dateTimeLabelFormats: {\n      millisecond: '%H:%M:%S.%L',\n      second: '%H:%M:%S',\n      minute: '%H:%M',\n      hour: '%H:%M',\n      day: '%e. %b',\n      week: '%e. %b',\n      month: '%b \\'%y',\n      year: '%Y'\n    },\n\n    /**\n     * _Requires Accessibility module_\n     *\n     * Description of the axis to screen reader users.\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption xAxis.description\n     */\n\n    /**\n     * Whether to force the axis to end on a tick. Use this option with\n     * the `maxPadding` option to control the axis end.\n     *\n     * @productdesc {highstock}\n     * In Highstock, `endOnTick` is always false when the navigator is\n     * enabled, to prevent jumpy scrolling.\n     *\n     * @sample {highcharts} highcharts/chart/reflow-true/\n     *         True by default\n     * @sample {highcharts} highcharts/yaxis/endontick/\n     *         False\n     * @sample {highstock} stock/demo/basic-line/\n     *         True by default\n     * @sample {highstock} stock/xaxis/endontick/\n     *         False\n     *\n     * @since 1.2.0\n     */\n    endOnTick: false,\n\n    /**\n     * Event handlers for the axis.\n     *\n     * @type      {*}\n     * @apioption xAxis.events\n     */\n\n    /**\n     * An event fired after the breaks have rendered.\n     *\n     * @see [breaks](#xAxis.breaks)\n     *\n     * @sample {highcharts} highcharts/axisbreak/break-event/\n     *         AfterBreak Event\n     *\n     * @type      {Function}\n     * @since     4.1.0\n     * @product   highcharts\n     * @apioption xAxis.events.afterBreaks\n     */\n\n    /**\n     * As opposed to the `setExtremes` event, this event fires after the\n     * final min and max values are computed and corrected for `minRange`.\n     *\n     *\n     * Fires when the minimum and maximum is set for the axis, either by\n     * calling the `.setExtremes()` method or by selecting an area in the\n     * chart. One parameter, `event`, is passed to the function, containing\n     * common event information.\n     *\n     * The new user set minimum and maximum values can be found by\n     * `event.min` and `event.max`. These reflect the axis minimum and\n     * maximum in axis values. The actual data extremes are found in\n     * `event.dataMin` and `event.dataMax`.\n     *\n     * @type      {Function}\n     * @since     2.3\n     * @context   Axis\n     * @apioption xAxis.events.afterSetExtremes\n     */\n\n    /**\n     * An event fired when a break from this axis occurs on a point.\n     *\n     * @see [breaks](#xAxis.breaks)\n     *\n     * @sample {highcharts} highcharts/axisbreak/break-visualized/\n     *         Visualization of a Break\n     *\n     * @type      {Function}\n     * @since     4.1.0\n     * @product   highcharts\n     * @context   Axis\n     * @apioption xAxis.events.pointBreak\n     */\n\n    /**\n     * An event fired when a point falls inside a break from this axis.\n     *\n     * @type      {Function}\n     * @product   highcharts highstock\n     * @context   Axis\n     * @apioption xAxis.events.pointInBreak\n     */\n\n    /**\n     * Fires when the minimum and maximum is set for the axis, either by\n     * calling the `.setExtremes()` method or by selecting an area in the\n     * chart. One parameter, `event`, is passed to the function,\n     * containing common event information.\n     *\n     * The new user set minimum and maximum values can be found by\n     * `event.min` and `event.max`. These reflect the axis minimum and\n     * maximum in data values. When an axis is zoomed all the way out from\n     * the \"Reset zoom\" button, `event.min` and `event.max` are null, and\n     * the new extremes are set based on `this.dataMin` and `this.dataMax`.\n     *\n     * @sample {highstock} stock/xaxis/events-setextremes/\n     *         Log new extremes on x axis\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Axis\n     * @apioption xAxis.events.setExtremes\n     */\n\n    /**\n     * The lowest allowed value for automatically computed axis extremes.\n     *\n     * @see [ceiling](#yAxis.ceiling)\n     *\n     * @sample {highcharts} highcharts/yaxis/floor-ceiling/\n     *         Floor and ceiling\n     * @sample {highstock} stock/demo/lazy-loading/\n     *         Prevent negative stock price on Y axis\n     *\n     * @type      {number}\n     * @since     4.0\n     * @product   highcharts highstock\n     * @apioption xAxis.floor\n     */\n\n    /**\n     * The dash or dot style of the grid lines. For possible values, see\n     * [this demonstration](https://jsfiddle.net/gh/get/library/pure/\n     * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/\n     * series-dashstyle-all/).\n     *\n     * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/\n     *         Long dashes\n     * @sample {highstock} stock/xaxis/gridlinedashstyle/\n     *         Long dashes\n     *\n     * @type       {string}\n     * @default    Solid\n     * @since      1.2\n     * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n     *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\", \"DashDot\",\n     *             \"LongDashDot\", \"LongDashDotDot\"]\n     * @apioption  xAxis.gridLineDashStyle\n     */\n\n    /**\n     * The Z index of the grid lines.\n     *\n     * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/\n     *         A Z index of 4 renders the grid above the graph\n     *\n     * @type      {number}\n     * @default   1\n     * @product   highcharts highstock\n     * @apioption xAxis.gridZIndex\n     */\n\n    /**\n     * An id for the axis. This can be used after render time to get\n     * a pointer to the axis object through `chart.get()`.\n     *\n     * @sample {highcharts} highcharts/xaxis/id/\n     *         Get the object\n     * @sample {highstock} stock/xaxis/id/\n     *         Get the object\n     *\n     * @type      {string}\n     * @since     1.2.0\n     * @apioption xAxis.id\n     */\n\n    /**\n     * The axis labels show the number or category for each tick.\n     *\n     * @productdesc {highmaps}\n     * X and Y axis labels are by default disabled in Highmaps, but the\n     * functionality is inherited from Highcharts and used on `colorAxis`,\n     * and can be enabled on X and Y axes too.\n     */\n    labels: {\n      /**\n       * What part of the string the given position is anchored to.\n       * If `left`, the left side of the string is at the axis position.\n       * Can be one of `\"left\"`, `\"center\"` or `\"right\"`. Defaults to\n       * an intelligent guess based on which side of the chart the axis\n       * is on and the rotation of the label.\n       *\n       * @see [reserveSpace](#xAxis.labels.reserveSpace)\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-align-left/\n       *         Left\n       * @sample {highcharts} highcharts/xaxis/labels-align-right/\n       *         Right\n       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/\n       *         Left-aligned labels on a vertical category axis\n       *\n       * @type       {string}\n       * @validvalue [\"left\", \"center\", \"right\"]\n       * @apioption  xAxis.labels.align\n       */\n\n      /**\n       * For horizontal axes, the allowed degrees of label rotation\n       * to prevent overlapping labels. If there is enough space,\n       * labels are not rotated. As the chart gets narrower, it\n       * will start rotating the labels -45 degrees, then remove\n       * every second label and try again with rotations 0 and -45 etc.\n       * Set it to `false` to disable rotation, which will\n       * cause the labels to word-wrap if possible.\n       *\n       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/\n       *         Default auto rotation of 0 or -45\n       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/\n       *         Custom graded auto rotation\n       *\n       * @type      {Array<number>}\n       * @default   [-45]\n       * @since     4.1.0\n       * @product   highcharts highstock\n       * @apioption xAxis.labels.autoRotation\n       */\n\n      /**\n       * When each category width is more than this many pixels, we don't\n       * apply auto rotation. Instead, we lay out the axis label with word\n       * wrap. A lower limit makes sense when the label contains multiple\n       * short words that don't extend the available horizontal space for\n       * each label.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/\n       *         Lower limit\n       *\n       * @type      {number}\n       * @default   80\n       * @since     4.1.5\n       * @product   highcharts\n       * @apioption xAxis.labels.autoRotationLimit\n       */\n\n      /**\n       * Polar charts only. The label's pixel distance from the perimeter\n       * of the plot area.\n       *\n       * @type      {number}\n       * @default   15\n       * @product   highcharts\n       * @apioption xAxis.labels.distance\n       */\n\n      /**\n       * Enable or disable the axis labels.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-enabled/\n       *         X axis labels disabled\n       * @sample {highstock} stock/xaxis/labels-enabled/\n       *         X axis labels disabled\n       *\n       * @default {highcharts|highstock} true\n       * @default {highmaps} false\n       */\n      enabled: true,\n\n      /**\n       * A [format string](https://www.highcharts.com/docs/chart-\n       * concepts/labels-and-string-formatting) for the axis label.\n       *\n       * @sample {highcharts|highstock} highcharts/yaxis/labels-format/\n       *         Add units to Y axis label\n       *\n       * @type      {string}\n       * @default   {value}\n       * @since     3.0\n       * @apioption xAxis.labels.format\n       */\n\n      /**\n       * Callback JavaScript function to format the label. The value\n       * is given by `this.value`. Additional properties for `this` are\n       * `axis`, `chart`, `isFirst` and `isLast`. The value of the default\n       * label formatter can be retrieved by calling\n       * `this.axis.defaultLabelFormatter.call(this)` within the function.\n       *\n       * Defaults to:\n       *\n       * <pre>function() {\n       *     return this.value;\n       * }</pre>\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/\n       *         Linked category names\n       * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/\n       *         Modified numeric labels\n       * @sample {highstock} stock/xaxis/labels-formatter/\n       *         Added units on Y axis\n       *\n       * @type      {Function}\n       * @apioption xAxis.labels.formatter\n       */\n\n      /**\n       * Horizontal axis only. When `staggerLines` is not set,\n       * `maxStaggerLines` defines how many lines the axis is allowed to\n       * add to automatically avoid overlapping X labels. Set to `1` to\n       * disable overlap detection.\n       *\n       * @deprecated\n       * @type      {number}\n       * @default   5\n       * @since     1.3.3\n       * @product   highstock highmaps\n       * @apioption xAxis.labels.maxStaggerLines\n       */\n\n      /**\n       * How to handle overflowing labels on horizontal axis. If set to\n       * `\"allow\"`, it will not be aligned at all. By default it\n       * `\"justify\"` labels inside the chart area. If there is room to\n       * move it, it will be aligned to the edge, else it will be removed.\n       *\n       * @type       {boolean|string}\n       * @default    justify\n       * @since      2.2.5\n       * @validvalue [\"allow\", \"justify\"]\n       * @apioption  xAxis.labels.overflow\n       */\n\n      /**\n       * The pixel padding for axis labels, to ensure white space between\n       * them.\n       *\n       * @type      {number}\n       * @default   5\n       * @product   highcharts\n       * @apioption xAxis.labels.padding\n       */\n\n      /**\n       * Whether to reserve space for the labels. By default, space is\n       * reserved for the labels in these cases:\n       *\n       * * On all horizontal axes.\n       * * On vertical axes if `label.align` is `right` on a left-side\n       * axis or `left` on a right-side axis.\n       * * On vertical axes if `label.align` is `center`.\n       *\n       * This can be turned off when for example the labels are rendered\n       * inside the plot area instead of outside.\n       *\n       * @see [labels.align](#xAxis.labels.align)\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-reservespace/\n       *         No reserved space, labels inside plot\n       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/\n       *         Left-aligned labels on a vertical category axis\n       *\n       * @type      {boolean}\n       * @since     4.1.10\n       * @product   highcharts\n       * @apioption xAxis.labels.reserveSpace\n       */\n\n      /**\n       * Rotation of the labels in degrees.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-rotation/\n       *         X axis labels rotated 90\n       *\n       * @type      {number}\n       * @default   0\n       * @apioption xAxis.labels.rotation\n       */\n\n      /**\n       * Horizontal axes only. The number of lines to spread the labels\n       * over to make room or tighter labels.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-staggerlines/\n       *         Show labels over two lines\n       * @sample {highstock} stock/xaxis/labels-staggerlines/\n       *         Show labels over two lines\n       *\n       * @type      {number}\n       * @since     2.1\n       * @apioption xAxis.labels.staggerLines\n       */\n\n      /**\n       * To show only every _n_'th label on the axis, set the step to _n_.\n       * Setting the step to 2 shows every other label.\n       *\n       * By default, the step is calculated automatically to avoid\n       * overlap. To prevent this, set it to 1\\. This usually only\n       * happens on a category axis, and is often a sign that you have\n       * chosen the wrong axis type.\n       *\n       * Read more at\n       * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)\n       * => What axis should I use?\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-step/\n       *         Showing only every other axis label on a categorized\n       *         x-axis\n       * @sample {highcharts} highcharts/xaxis/labels-step-auto/\n       *         Auto steps on a category axis\n       *\n       * @type      {number}\n       * @since     2.1\n       * @apioption xAxis.labels.step\n       */\n\n      /**\n       * Whether to [use HTML](https://www.highcharts.com/docs/chart-\n       * concepts/labels-and-string-formatting#html) to render the labels.\n       *\n       * @type      {boolean}\n       * @default   false\n       * @apioption xAxis.labels.useHTML\n       */\n\n      /**\n       * The x position offset of the label relative to the tick position\n       * on the axis.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-x/\n       *         Y axis labels placed on grid lines\n       */\n      x: 0\n      /**\n       * The y position offset of the label relative to the tick position\n       * on the axis. The default makes it adapt to the font size on\n       * bottom axis.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-x/\n       *         Y axis labels placed on grid lines\n       *\n       * @type      {number}\n       * @apioption xAxis.labels.y\n       */\n\n      /**\n       * The Z index for the axis labels.\n       *\n       * @type      {number}\n       * @default   7\n       * @apioption xAxis.labels.zIndex\n       */\n\n    },\n\n    /**\n     * Index of another axis that this axis is linked to. When an axis is\n     * linked to a master axis, it will take the same extremes as\n     * the master, but as assigned by min or max or by setExtremes.\n     * It can be used to show additional info, or to ease reading the\n     * chart by duplicating the scales.\n     *\n     * @sample {highcharts} highcharts/xaxis/linkedto/\n     *         Different string formats of the same date\n     * @sample {highcharts} highcharts/yaxis/linkedto/\n     *         Y values on both sides\n     *\n     * @type      {number}\n     * @since     2.0.2\n     * @product   highcharts highstock\n     * @apioption xAxis.linkedTo\n     */\n\n    /**\n     * The maximum value of the axis. If `null`, the max value is\n     * automatically calculated.\n     *\n     * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value\n     * might be rounded up.\n     *\n     * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended\n     * beyond the set max in order to reach the given number of ticks. The\n     * same may happen in a chart with multiple axes, determined by [chart.\n     * alignTicks](#chart), where a `tickAmount` is applied internally.\n     *\n     * @sample {highcharts} highcharts/yaxis/max-200/\n     *         Y axis max of 200\n     * @sample {highcharts} highcharts/yaxis/max-logarithmic/\n     *         Y axis max on logarithmic axis\n     * @sample {highstock} stock/xaxis/min-max/\n     *         Fixed min and max on X axis\n     * @sample {highmaps} maps/axis/min-max/\n     *         Pre-zoomed to a specific area\n     *\n     * @type      {number}\n     * @apioption xAxis.max\n     */\n\n    /**\n     * Padding of the max value relative to the length of the axis. A\n     * padding of 0.05 will make a 100px axis 5px longer. This is useful\n     * when you don't want the highest data value to appear on the edge\n     * of the plot area. When the axis' `max` option is set or a max extreme\n     * is set using `axis.setExtremes()`, the maxPadding will be ignored.\n     *\n     * @sample {highcharts} highcharts/yaxis/maxpadding/\n     *         Max padding of 0.25 on y axis\n     * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n     *         Greater min- and maxPadding\n     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/\n     *         Add some padding\n     *\n     * @default   {highcharts} 0.01\n     * @default   {highstock|highmaps} 0\n     * @since     1.2.0\n     */\n    maxPadding: 0.01,\n\n    /**\n     * Deprecated. Use `minRange` instead.\n     *\n     * @deprecated\n     * @type      {number}\n     * @product   highcharts highstock\n     * @apioption xAxis.maxZoom\n     */\n\n    /**\n     * The minimum value of the axis. If `null` the min value is\n     * automatically calculated.\n     *\n     * If the [startOnTick](#yAxis.startOnTick) option is true (default),\n     * the `min` value might be rounded down.\n     *\n     * The automatically calculated minimum value is also affected by\n     * [floor](#yAxis.floor), [softMin](#yAxis.softMin),\n     * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)\n     * as well as [series.threshold](#plotOptions.series.threshold)\n     * and [series.softThreshold](#plotOptions.series.softThreshold).\n     *\n     * @sample {highcharts} highcharts/yaxis/min-startontick-false/\n     *         -50 with startOnTick to false\n     * @sample {highcharts} highcharts/yaxis/min-startontick-true/\n     *         -50 with startOnTick true by default\n     * @sample {highstock} stock/xaxis/min-max/\n     *         Set min and max on X axis\n     * @sample {highmaps} maps/axis/min-max/\n     *         Pre-zoomed to a specific area\n     *\n     * @type      {number}\n     * @apioption xAxis.min\n     */\n\n    /**\n     * The dash or dot style of the minor grid lines. For possible values,\n     * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/\n     * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/\n     * series-dashstyle-all/).\n     *\n     * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/\n     *         Long dashes on minor grid lines\n     * @sample {highstock} stock/xaxis/minorgridlinedashstyle/\n     *         Long dashes on minor grid lines\n     *\n     * @type       {string}\n     * @default    Solid\n     * @since      1.2\n     * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n     *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\",\n     *             \"DashDot\", \"LongDashDot\", \"LongDashDotDot\"]\n     * @apioption  xAxis.minorGridLineDashStyle\n     */\n\n    /**\n     * Specific tick interval in axis units for the minor ticks. On a linear\n     * axis, if `\"auto\"`, the minor tick interval is calculated as a fifth\n     * of the tickInterval. If `null` or `undefined`, minor ticks are not\n     * shown.\n     *\n     * On logarithmic axes, the unit is the power of the value. For example,\n     * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,\n     * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks\n     * between 1 and 10, 10 and 100 etc.\n     *\n     * If user settings dictate minor ticks to become too dense, they don't\n     * make sense, and will be ignored to prevent performance problems.\n     *\n     * @sample {highcharts} highcharts/yaxis/minortickinterval-null/\n     *         Null by default\n     * @sample {highcharts} highcharts/yaxis/minortickinterval-5/\n     *         5 units\n     * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/\n     *         \"auto\"\n     * @sample {highcharts} highcharts/yaxis/minortickinterval-log/\n     *         0.1\n     * @sample {highstock} stock/demo/basic-line/\n     *         Null by default\n     * @sample {highstock} stock/xaxis/minortickinterval-auto/\n     *         \"auto\"\n     *\n     * @type      {number|string|null}\n     * @apioption xAxis.minorTickInterval\n     */\n\n    /**\n     * The pixel length of the minor tick marks.\n     *\n     * @sample {highcharts} highcharts/yaxis/minorticklength/\n     *         10px on Y axis\n     * @sample {highstock} stock/xaxis/minorticks/\n     *         10px on Y axis\n     */\n    minorTickLength: 2,\n\n    /**\n     * The position of the minor tick marks relative to the axis line.\n     *  Can be one of `inside` and `outside`.\n     *\n     * @sample {highcharts} highcharts/yaxis/minortickposition-outside/\n     *         Outside by default\n     * @sample {highcharts} highcharts/yaxis/minortickposition-inside/\n     *         Inside\n     * @sample {highstock} stock/xaxis/minorticks/\n     *         Inside\n     *\n     * @validvalue [\"inside\", \"outside\"]\n     */\n    minorTickPosition: 'outside',\n\n    /**\n     * Enable or disable minor ticks. Unless\n     * [minorTickInterval](#xAxis.minorTickInterval) is set, the tick\n     * interval is calculated as a fifth of the `tickInterval`.\n     *\n     * On a logarithmic axis, minor ticks are laid out based on a best\n     * guess, attempting to enter approximately 5 minor ticks between\n     * each major tick.\n     *\n     * Prior to v6.0.0, ticks were unabled in auto layout by setting\n     * `minorTickInterval` to `\"auto\"`.\n     *\n     * @productdesc {highcharts}\n     * On axes using [categories](#xAxis.categories), minor ticks are not\n     * supported.\n     *\n     * @sample {highcharts} highcharts/yaxis/minorticks-true/\n     *         Enabled on linear Y axis\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     6.0.0\n     * @apioption xAxis.minorTicks\n     */\n\n    /**\n     * The pixel width of the minor tick mark.\n     *\n     * @sample {highcharts} highcharts/yaxis/minortickwidth/\n     *         3px width\n     * @sample {highstock} stock/xaxis/minorticks/\n     *         1px width\n     *\n     * @type      {number}\n     * @default   0\n     * @apioption xAxis.minorTickWidth\n     */\n\n    /**\n     * Padding of the min value relative to the length of the axis. A\n     * padding of 0.05 will make a 100px axis 5px longer. This is useful\n     * when you don't want the lowest data value to appear on the edge\n     * of the plot area. When the axis' `min` option is set or a min extreme\n     * is set using `axis.setExtremes()`, the minPadding will be ignored.\n     *\n     * @sample {highcharts} highcharts/yaxis/minpadding/\n     *         Min padding of 0.2\n     * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n     *         Greater min- and maxPadding\n     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/\n     *         Add some padding\n     *\n     * @default    {highcharts} 0.01\n     * @default    {highstock|highmaps} 0\n     * @since      1.2.0\n     * @product    highcharts highstock\n     */\n    minPadding: 0.01,\n\n    /**\n     * The minimum range to display on this axis. The entire axis will not\n     * be allowed to span over a smaller interval than this. For example,\n     * for a datetime axis the main unit is milliseconds. If minRange is\n     * set to 3600000, you can't zoom in more than to one hour.\n     *\n     * The default minRange for the x axis is five times the smallest\n     * interval between any of the data points.\n     *\n     * On a logarithmic axis, the unit for the minimum range is the power.\n     * So a minRange of 1 means that the axis can be zoomed to 10-100,\n     * 100-1000, 1000-10000 etc.\n     *\n     * Note that the `minPadding`, `maxPadding`, `startOnTick` and\n     * `endOnTick` settings also affect how the extremes of the axis\n     * are computed.\n     *\n     * @sample {highcharts} highcharts/xaxis/minrange/\n     *         Minimum range of 5\n     * @sample {highstock} stock/xaxis/minrange/\n     *         Max zoom of 6 months overrides user selections\n     * @sample {highmaps} maps/axis/minrange/\n     *         Minimum range of 1000\n     *\n     * @type      {number}\n     * @apioption xAxis.minRange\n     */\n\n    /**\n     * The minimum tick interval allowed in axis values. For example on\n     * zooming in on an axis with daily data, this can be used to prevent\n     * the axis from showing hours. Defaults to the closest distance between\n     * two points on the axis.\n     *\n     * @type      {number}\n     * @since     2.3.0\n     * @apioption xAxis.minTickInterval\n     */\n\n    /**\n     * The distance in pixels from the plot area to the axis line.\n     * A positive offset moves the axis with it's line, labels and ticks\n     * away from the plot area. This is typically used when two or more\n     * axes are displayed on the same side of the plot. With multiple\n     * axes the offset is dynamically adjusted to avoid collision, this\n     * can be overridden by setting offset explicitly.\n     *\n     * @sample    {highcharts} highcharts/yaxis/offset/\n     *            Y axis offset of 70\n     * @sample    {highcharts} highcharts/yaxis/offset-centered/\n     *            Axes positioned in the center of the plot\n     * @sample    {highstock} stock/xaxis/offset/\n     *            Y axis offset by 70 px\n     *\n     * @type      {number}\n     * @default   0\n     * @apioption xAxis.offset\n     */\n\n    /**\n     * Whether to display the axis on the opposite side of the normal. The\n     * normal is on the left side for vertical axes and bottom for\n     * horizontal, so the opposite sides will be right and top respectively.\n     * This is typically used with dual or multiple axes.\n     *\n     * @sample {highcharts} highcharts/yaxis/opposite/\n     *         Secondary Y axis opposite\n     * @sample {highstock} stock/xaxis/opposite/\n     *         Y axis on left side\n     *\n     * @type      {boolean}\n     * @default   false\n     * @apioption xAxis.opposite\n     */\n\n    /**\n     * In an ordinal axis, the points are equally spaced in the chart\n     * regardless of the actual time or x distance between them. This means\n     * that missing data periods (e.g. nights or weekends for a stock chart)\n     * will not take up space in the chart.\n     * Having `ordinal: false` will show any gaps created by the `gapSize`\n     * setting proportionate to their duration.\n     *\n     * In stock charts the X axis is ordinal by default, unless\n     * the boost module is used and at least one of the series' data length\n     * exceeds the [boostThreshold](#series.line.boostThreshold).\n     *\n     * @sample {highstock} stock/xaxis/ordinal-true/\n     *         True by default\n     * @sample {highstock} stock/xaxis/ordinal-false/\n     *         False\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     1.1\n     * @product   highstock\n     * @apioption xAxis.ordinal\n     */\n\n    /**\n     * Additional range on the right side of the xAxis. Works similar to\n     * `xAxis.maxPadding`, but value is set in milliseconds. Can be set for\n     * both main `xAxis` and the navigator's `xAxis`.\n     *\n     * @sample {highstock} stock/xaxis/overscroll/\n     *         One minute overscroll with live data\n     *\n     * @type      {number}\n     * @default   0\n     * @since     6.0.0\n     * @product   highstock\n     * @apioption xAxis.overscroll\n     */\n\n    /**\n     * Refers to the index in the [panes](#panes) array. Used for circular\n     * gauges and polar charts. When the option is not set then first pane\n     * will be used.\n     *\n     * @sample highcharts/demo/gauge-vu-meter\n     *         Two gauges with different center\n     *\n     * @type      {number}\n     * @product   highcharts\n     * @apioption xAxis.pane\n     */\n\n    /**\n     * The zoomed range to display when only defining one or none of `min`\n     * or `max`. For example, to show the latest month, a range of one month\n     * can be set.\n     *\n     * @sample {highstock} stock/xaxis/range/\n     *         Setting a zoomed range when the rangeSelector is disabled\n     *\n     * @type      {number}\n     * @product   highstock\n     * @apioption xAxis.range\n     */\n\n    /**\n     * Whether to reverse the axis so that the highest number is closest\n     * to the origin. If the chart is inverted, the x axis is reversed by\n     * default.\n     *\n     * @sample {highcharts} highcharts/yaxis/reversed/\n     *         Reversed Y axis\n     * @sample {highstock} stock/xaxis/reversed/\n     *         Reversed Y axis\n     *\n     * @type      {boolean}\n     * @default   false\n     * @apioption xAxis.reversed\n     */\n    // reversed: false,\n\n    /**\n     * This option determines how stacks should be ordered within a group.\n     * For example reversed xAxis also reverses stacks, so first series\n     * comes last in a group. To keep order like for non-reversed xAxis\n     * enable this option.\n     *\n     * @sample {highcharts} highcharts/xaxis/reversedstacks/\n     *         Reversed stacks comparison\n     * @sample {highstock} highcharts/xaxis/reversedstacks/\n     *         Reversed stacks comparison\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     6.1.1\n     * @product   highcharts highstock\n     * @apioption xAxis.reversedStacks\n     */\n\n    /**\n     * An optional scrollbar to display on the X axis in response to\n     * limiting the minimum and maximum of the axis values.\n     *\n     * In styled mode, all the presentational options for the scrollbar\n     * are replaced by the classes `.highcharts-scrollbar-thumb`,\n     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,\n     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.\n     *\n     * @sample {highstock} stock/yaxis/heatmap-scrollbars/\n     *         Heatmap with both scrollbars\n     *\n     * @type      {*}\n     * @extends   scrollbar\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption xAxis.scrollbar\n     */\n\n    /**\n     * Whether to show the axis line and title when the axis has no data.\n     *\n     * @sample {highcharts} highcharts/yaxis/showempty/\n     *         When clicking the legend to hide series, one axis preserves\n     *         line and title, the other doesn't\n     * @sample {highstock} highcharts/yaxis/showempty/\n     *         When clicking the legend to hide series, one axis preserves\n     *         line and title, the other doesn't\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     1.1\n     * @apioption xAxis.showEmpty\n     */\n\n    /**\n     * Whether to show the first tick label.\n     *\n     * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/\n     *         Set to false on X axis\n     * @sample {highstock} stock/xaxis/showfirstlabel/\n     *         Labels below plot lines on Y axis\n     *\n     * @type      {boolean}\n     * @default   true\n     * @apioption xAxis.showFirstLabel\n     */\n\n    /**\n     * Whether to show the last tick label. Defaults to `true` on cartesian\n     * charts, and `false` on polar charts.\n     *\n     * @sample {highcharts} highcharts/xaxis/showlastlabel-true/\n     *         Set to true on X axis\n     * @sample {highstock} stock/xaxis/showfirstlabel/\n     *         Labels below plot lines on Y axis\n     *\n     * @type      {boolean}\n     * @default   true\n     * @product   highcharts highstock\n     * @apioption xAxis.showLastLabel\n     */\n\n    /**\n     * A soft maximum for the axis. If the series data maximum is less than\n     * this, the axis will stay at this maximum, but if the series data\n     * maximum is higher, the axis will flex to show all data.\n     *\n     * @sample highcharts/yaxis/softmin-softmax/\n     *         Soft min and max\n     *\n     * @type      {number}\n     * @since     5.0.1\n     * @product   highcharts highstock\n     * @apioption xAxis.softMax\n     */\n\n    /**\n     * A soft minimum for the axis. If the series data minimum is greater\n     * than this, the axis will stay at this minimum, but if the series\n     * data minimum is lower, the axis will flex to show all data.\n     *\n     * @sample highcharts/yaxis/softmin-softmax/\n     *         Soft min and max\n     *\n     * @type      {number}\n     * @since     5.0.1\n     * @product   highcharts highstock\n     * @apioption xAxis.softMin\n     */\n\n    /**\n     * For datetime axes, this decides where to put the tick between weeks.\n     *  0 = Sunday, 1 = Monday.\n     *\n     * @sample {highcharts} highcharts/xaxis/startofweek-monday/\n     *         Monday by default\n     * @sample {highcharts} highcharts/xaxis/startofweek-sunday/\n     *         Sunday\n     * @sample {highstock} stock/xaxis/startofweek-1\n     *         Monday by default\n     * @sample {highstock} stock/xaxis/startofweek-0\n     *         Sunday\n     *\n     * @product highcharts highstock\n     */\n    startOfWeek: 1,\n\n    /**\n     * Whether to force the axis to start on a tick. Use this option with\n     * the `minPadding` option to control the axis start.\n     *\n     * @productdesc {highstock}\n     * In Highstock, `startOnTick` is always false when the navigator is\n     * enabled, to prevent jumpy scrolling.\n     *\n     * @sample {highcharts} highcharts/xaxis/startontick-false/\n     *         False by default\n     * @sample {highcharts} highcharts/xaxis/startontick-true/\n     *         True\n     * @sample {highstock} stock/xaxis/endontick/\n     *         False for Y axis\n     *\n     * @since 1.2.0\n     */\n    startOnTick: false,\n\n    /**\n     * The amount of ticks to draw on the axis. This opens up for aligning\n     * the ticks of multiple charts or panes within a chart. This option\n     * overrides the `tickPixelInterval` option.\n     *\n     * This option only has an effect on linear axes. Datetime, logarithmic\n     * or category axes are not affected.\n     *\n     * @sample {highcharts} highcharts/yaxis/tickamount/\n     *         8 ticks on Y axis\n     * @sample {highstock} highcharts/yaxis/tickamount/\n     *         8 ticks on Y axis\n     *\n     * @type      {number}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption xAxis.tickAmount\n     */\n\n    /**\n     * The interval of the tick marks in axis units. When `undefined`, the\n     * tick interval is computed to approximately follow the\n     * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime\n     * axes. On categorized axes, a `undefined` tickInterval will default to\n     * 1, one category. Note that datetime axes are based on milliseconds,\n     * so for example an interval of one day is expressed as\n     * `24 * 3600 * 1000`.\n     *\n     * On logarithmic axes, the tickInterval is based on powers, so a\n     * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A\n     * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval\n     * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,\n     * 40 etc.\n     *\n     *\n     * If the tickInterval is too dense for labels to be drawn, Highcharts\n     * may remove ticks.\n     *\n     * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)\n     * option may interfere with the `tickInterval` setting.\n     *\n     * @see [tickPixelInterval](#xAxis.tickPixelInterval)\n     * @see [tickPositions](#xAxis.tickPositions)\n     * @see [tickPositioner](#xAxis.tickPositioner)\n     *\n     * @sample {highcharts} highcharts/xaxis/tickinterval-5/\n     *         Tick interval of 5 on a linear axis\n     * @sample {highstock} stock/xaxis/tickinterval/\n     *         Tick interval of 0.01 on Y axis\n     *\n     * @type      {number}\n     * @apioption xAxis.tickInterval\n     */\n\n    /**\n     * The pixel length of the main tick marks.\n     *\n     * @sample {highcharts} highcharts/xaxis/ticklength/\n     *         20 px tick length on the X axis\n     * @sample {highstock} stock/xaxis/ticks/\n     *         Formatted ticks on X axis\n     */\n    tickLength: 10,\n\n    /**\n     * If tickInterval is `null` this option sets the approximate pixel\n     * interval of the tick marks. Not applicable to categorized axis.\n     *\n     * The tick interval is also influenced by the [minTickInterval](\n     * #xAxis.minTickInterval) option, that, by default prevents ticks from\n     * being denser than the data points.\n     *\n     * @see [tickInterval](#xAxis.tickInterval)\n     * @see [tickPositioner](#xAxis.tickPositioner)\n     * @see [tickPositions](#xAxis.tickPositions)\n     *\n     * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/\n     *         50 px on X axis\n     * @sample {highstock} stock/xaxis/tickpixelinterval/\n     *         200 px on X axis\n     */\n    tickPixelInterval: 100,\n\n    /**\n     * For categorized axes only. If `on` the tick mark is placed in the\n     * center of the category, if `between` the tick mark is placed between\n     * categories. The default is `between` if the `tickInterval` is 1,\n     *  else `on`.\n     *\n     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/\n     *         \"between\" by default\n     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/\n     *         \"on\"\n     *\n     * @product    highcharts\n     * @validvalue [null, \"on\", \"between\"]\n     */\n    tickmarkPlacement: 'between',\n\n    /**\n     * The position of the major tick marks relative to the axis line.\n     * Can be one of `inside` and `outside`.\n     *\n     * @sample {highcharts} highcharts/xaxis/tickposition-outside/\n     *         \"outside\" by default\n     * @sample {highcharts} highcharts/xaxis/tickposition-inside/\n     *         \"inside\"\n     * @sample {highstock} stock/xaxis/ticks/\n     *         Formatted ticks on X axis\n     *\n     * @validvalue [\"inside\", \"outside\"]\n     */\n    tickPosition: 'outside',\n\n    /**\n     * A callback function returning array defining where the ticks are\n     * laid out on the axis. This overrides the default behaviour of\n     * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](\n     * #xAxis.tickInterval). The automatic tick positions are accessible\n     * through `this.tickPositions` and can be modified by the callback.\n     *\n     * @see [tickPositions](#xAxis.tickPositions)\n     *\n     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/\n     *         Demo of tickPositions and tickPositioner\n     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/\n     *         Demo of tickPositions and tickPositioner\n     *\n     * @type      {Function}\n     * @apioption xAxis.tickPositioner\n     */\n\n    /**\n     * An array defining where the ticks are laid out on the axis. This\n     * overrides the default behaviour of [tickPixelInterval](\n     * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).\n     *\n     * @see [tickPositioner](#xAxis.tickPositioner)\n     *\n     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/\n     *         Demo of tickPositions and tickPositioner\n     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/\n     *         Demo of tickPositions and tickPositioner\n     *\n     * @type      {Array<number>}\n     * @apioption xAxis.tickPositions\n     */\n\n    /**\n     * The pixel width of the major tick marks.\n     *\n     * In styled mode, the stroke width is given in the `.highcharts-tick`\n     * class.\n     *\n     * @sample {highcharts} highcharts/xaxis/tickwidth/\n     *         10 px width\n     * @sample {highcharts} highcharts/css/axis-grid/\n     *         Styled mode\n     * @sample {highstock} stock/xaxis/ticks/\n     *         Formatted ticks on X axis\n     * @sample {highstock} highcharts/css/axis-grid/\n     *         Styled mode\n     *\n     * @type      {number}\n     * @default   {highcharts} 1\n     * @default   {highstock} 1\n     * @default   {highmaps} 0\n     * @apioption xAxis.tickWidth\n     */\n\n    /**\n     * The axis title, showing next to the axis line.\n     *\n     * @productdesc {highmaps}\n     * In Highmaps, the axis is hidden by default, but adding an axis title\n     * is still possible. X axis and Y axis titles will appear at the bottom\n     * and left by default.\n     */\n    title: {\n      /**\n       * Deprecated. Set the `text` to `null` to disable the title.\n       *\n       * @deprecated\n       * @type      {string}\n       * @default   middle\n       * @product   highcharts\n       * @apioption xAxis.title.enabled\n       */\n\n      /**\n       * The pixel distance between the axis labels or line and the title.\n       * Defaults to 0 for horizontal axes, 10 for vertical\n       *\n       * @sample {highcharts} highcharts/xaxis/title-margin/\n       *         Y axis title margin of 60\n       *\n       * @type      {number}\n       * @apioption xAxis.title.margin\n       */\n\n      /**\n       * The distance of the axis title from the axis line. By default,\n       * this distance is computed from the offset width of the labels,\n       * the labels' distance from the axis and the title's margin.\n       * However when the offset option is set, it overrides all this.\n       *\n       * @sample {highcharts} highcharts/yaxis/title-offset/\n       *         Place the axis title on top of the axis\n       * @sample {highstock} highcharts/yaxis/title-offset/\n       *         Place the axis title on top of the Y axis\n       *\n       * @type      {number}\n       * @since     2.2.0\n       * @apioption xAxis.title.offset\n       */\n\n      /**\n       * Whether to reserve space for the title when laying out the axis.\n       *\n       * @type      {boolean}\n       * @default   true\n       * @since     5.0.11\n       * @product   highcharts highstock\n       * @apioption xAxis.title.reserveSpace\n       */\n\n      /**\n       * The rotation of the text in degrees. 0 is horizontal, 270 is\n       * vertical reading from bottom to top.\n       *\n       * @sample {highcharts} highcharts/yaxis/title-offset/\n       *         Horizontal\n       *\n       * @type      {number}\n       * @default   0\n       * @apioption xAxis.title.rotation\n       */\n\n      /**\n       * The actual text of the axis title. It can contain basic HTML text\n       * markup like <b>, <i> and spans with style.\n       *\n       * @sample {highcharts} highcharts/xaxis/title-text/\n       *         Custom HTML\n       * @sample {highstock} stock/xaxis/title-text/\n       *         Titles for both axes\n       *\n       * @type      {string}\n       * @apioption xAxis.title.text\n       */\n\n      /**\n       * Alignment of the text, can be `\"left\"`, `\"right\"` or `\"center\"`.\n       * Default alignment depends on the\n       * [title.align](xAxis.title.align):\n       *\n       * Horizontal axes:\n       * - for `align` = `\"low\"`, `textAlign` is set to `left`\n       * - for `align` = `\"middle\"`, `textAlign` is set to `center`\n       * - for `align` = `\"high\"`, `textAlign` is set to `right`\n       *\n       * Vertical axes:\n       * - for `align` = `\"low\"` and `opposite` = `true`, `textAlign` is\n       *   set to `right`\n       * - for `align` = `\"low\"` and `opposite` = `false`, `textAlign` is\n       *   set to `left`\n       * - for `align` = `\"middle\"`, `textAlign` is set to `center`\n       * - for `align` = `\"high\"` and `opposite` = `true` `textAlign` is\n       *   set to `left`\n       * - for `align` = `\"high\"` and `opposite` = `false` `textAlign` is\n       *   set to `right`\n       *\n       * @type      {string}\n       * @apioption xAxis.title.textAlign\n       */\n\n      /**\n       * Whether to [use HTML](https://www.highcharts.com/docs/\n       * chart-concepts/labels-and-string-formatting#html) to render the\n       * axis title.\n       *\n       * @type      {boolean}\n       * @default   false\n       * @product   highcharts highstock\n       * @apioption xAxis.title.useHTML\n       */\n\n      /**\n       * Horizontal pixel offset of the title position.\n       *\n       * @type      {number}\n       * @default   0\n       * @since     4.1.6\n       * @product   highcharts highstock\n       * @apioption xAxis.title.x\n       */\n\n      /**\n       * Vertical pixel offset of the title position.\n       *\n       * @type      {number}\n       * @product   highcharts highstock\n       * @apioption xAxis.title.y\n       */\n\n      /**\n       * Alignment of the title relative to the axis values. Possible\n       * values are \"low\", \"middle\" or \"high\".\n       *\n       * @sample {highcharts} highcharts/xaxis/title-align-low/\n       *         \"low\"\n       * @sample {highcharts} highcharts/xaxis/title-align-center/\n       *         \"middle\" by default\n       * @sample {highcharts} highcharts/xaxis/title-align-high/\n       *         \"high\"\n       * @sample {highcharts} highcharts/yaxis/title-offset/\n       *         Place the Y axis title on top of the axis\n       * @sample {highstock} stock/xaxis/title-align/\n       *         Aligned to \"high\" value\n       *\n       * @validvalue [\"low\", \"middle\", \"high\"]\n       */\n      align: 'middle'\n    },\n\n    /**\n     * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`\n     * or `category`. In a datetime axis, the numbers are given in\n     * milliseconds, and tick marks are placed on appropriate values like\n     * full hours or days. In a category axis, the\n     * [point names](#series.line.data.name) of the chart's series are used\n     * for categories, if not a [categories](#xAxis.categories) array is\n     * defined.\n     *\n     * @sample {highcharts} highcharts/xaxis/type-linear/\n     *         Linear\n     * @sample {highcharts} highcharts/yaxis/type-log/\n     *         Logarithmic\n     * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/\n     *         Logarithmic with minor grid lines\n     * @sample {highcharts} highcharts/xaxis/type-log-both/\n     *         Logarithmic on two axes\n     * @sample {highcharts} highcharts/yaxis/type-log-negative/\n     *         Logarithmic with extension to emulate negative values\n     *\n     * @product    highcharts\n     * @validvalue [\"linear\", \"logarithmic\", \"datetime\", \"category\"]\n     */\n    type: 'linear'\n    /**\n     * Applies only when the axis `type` is `category`. When `uniqueNames`\n     * is true, points are placed on the X axis according to their names.\n     * If the same point name is repeated in the same or another series,\n     * the point is placed on the same X position as other points of the\n     * same name. When `uniqueNames` is false, the points are laid out in\n     * increasing X positions regardless of their names, and the X axis\n     * category will take the name of the last point in each position.\n     *\n     * @sample {highcharts} highcharts/xaxis/uniquenames-true/\n     *         True by default\n     * @sample {highcharts} highcharts/xaxis/uniquenames-false/\n     *         False\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.2.7\n     * @product   highcharts\n     * @apioption xAxis.uniqueNames\n     */\n\n    /**\n     * Datetime axis only. An array determining what time intervals the\n     * ticks are allowed to fall on. Each array item is an array where the\n     * first value is the time unit and the second value another array of\n     * allowed multiples. Defaults to:\n     *\n     * <pre>units: [[\n     *     'millisecond', // unit name\n     *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n     * ], [\n     *     'second',\n     *     [1, 2, 5, 10, 15, 30]\n     * ], [\n     *     'minute',\n     *     [1, 2, 5, 10, 15, 30]\n     * ], [\n     *     'hour',\n     *     [1, 2, 3, 4, 6, 8, 12]\n     * ], [\n     *     'day',\n     *     [1]\n     * ], [\n     *     'week',\n     *     [1]\n     * ], [\n     *     'month',\n     *     [1, 3, 6]\n     * ], [\n     *     'year',\n     *     null\n     * ]]</pre>\n     *\n     * @type      {Array<Array<string|Array<number>>>}\n     * @product   highcharts highstock\n     * @apioption xAxis.units\n     */\n\n    /**\n     * Whether axis, including axis title, line, ticks and labels, should\n     * be visible.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.1.9\n     * @product   highcharts highstock\n     * @apioption xAxis.visible\n     */\n\n  },\n\n  /**\n   * The Y axis or value axis. Normally this is the vertical axis,\n   * though if the chart is inverted this is the horizontal axis.\n   * In case of multiple axes, the yAxis node is an array of\n   * configuration objects.\n   *\n   * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic\n   * access to the axis.\n   *\n   * @extends      xAxis\n   * @excluding    ordinal, overscroll\n   * @optionparent yAxis\n   */\n  defaultYAxisOptions: {\n    /**\n     * In a polar chart, this is the angle of the Y axis in degrees, where\n     * 0 is up and 90 is right. The angle determines the position of the\n     * axis line and the labels, though the coordinate system is unaffected.\n     *\n     * @sample {highcharts} highcharts/yaxis/angle/\n     *         Dual axis polar chart\n     *\n     * @type      {number}\n     * @default   0\n     * @since     4.2.7\n     * @product   highcharts\n     * @apioption yAxis.angle\n     */\n\n    /**\n     * Polar charts only. Whether the grid lines should draw as a polygon\n     * with straight lines between categories, or as circles. Can be either\n     * `circle` or `polygon`.\n     *\n     * @sample {highcharts} highcharts/demo/polar-spider/\n     *         Polygon grid lines\n     * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/\n     *         Circle and polygon\n     *\n     * @type       {string}\n     * @product    highcharts\n     * @validvalue [\"circle\", \"polygon\"]\n     * @apioption  yAxis.gridLineInterpolation\n     */\n\n    /**\n     * The height of the Y axis. If it's a number, it is interpreted as\n     * pixels.\n     *\n     * Since Highstock 2: If it's a percentage string, it is interpreted\n     * as percentages of the total plot height.\n     *\n     * @see [yAxis.top](#yAxis.top)\n     *\n     * @sample {highstock} stock/demo/candlestick-and-volume/\n     *         Percentage height panes\n     *\n     * @type      {number|string}\n     * @product   highstock\n     * @apioption yAxis.height\n     */\n\n    /**\n     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color\n     * to represent the maximum value of the Y axis.\n     *\n     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/\n     *         Min and max colors\n     *\n     * @type      {Highcharts.ColorString}\n     * @default   #003399\n     * @since     4.0\n     * @product   highcharts\n     * @apioption yAxis.maxColor\n     */\n\n    /**\n     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color\n     * to represent the minimum value of the Y axis.\n     *\n     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/\n     *         Min and max color\n     *\n     * @type      {Highcharts.ColorString}\n     * @default   #e6ebf5\n     * @since     4.0\n     * @product   highcharts\n     * @apioption yAxis.minColor\n     */\n\n    /**\n     * Whether to reverse the axis so that the highest number is closest\n     * to the origin.\n     *\n     * @sample {highcharts} highcharts/yaxis/reversed/\n     *         Reversed Y axis\n     * @sample {highstock} stock/xaxis/reversed/\n     *         Reversed Y axis\n     *\n     * @type      {boolean}\n     * @default   {highcharts} false\n     * @default   {highstock} false\n     * @default   {highmaps} true\n     * @apioption yAxis.reversed\n     */\n\n    /**\n     * If `true`, the first series in a stack will be drawn on top in a\n     * positive, non-reversed Y axis. If `false`, the first series is in\n     * the base of the stack.\n     *\n     * @sample {highcharts} highcharts/yaxis/reversedstacks-false/\n     *         Non-reversed stacks\n     * @sample {highstock} highcharts/yaxis/reversedstacks-false/\n     *         Non-reversed stacks\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     3.0.10\n     * @product   highcharts highstock\n     * @apioption yAxis.reversedStacks\n     */\n\n    /**\n     * Solid gauge series only. Color stops for the solid gauge. Use this\n     * in cases where a linear gradient between a `minColor` and `maxColor`\n     * is not sufficient. The stops is an array of tuples, where the first\n     * item is a float between 0 and 1 assigning the relative position in\n     * the gradient, and the second item is the color.\n     *\n     * For solid gauges, the Y axis also inherits the concept of [data classes](http://api.\n     * highcharts.com/highmaps#colorAxis.dataClasses) from the Highmaps\n     * color axis.\n     *\n     * @see [minColor](#yAxis.minColor)\n     * @see [maxColor](#yAxis.maxColor)\n     *\n     * @sample {highcharts} highcharts/demo/gauge-solid/\n     *         True by default\n     *\n     * @type      {Array<Array<number, Highcharts.ColorString>>}\n     * @since     4.0\n     * @product   highcharts\n     * @apioption yAxis.stops\n     */\n\n    /**\n     * The pixel width of the major tick marks.\n     *\n     * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width\n     * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis\n     *\n     * @type      {number}\n     * @default   0\n     * @product   highcharts highstock\n     * @apioption yAxis.tickWidth\n     */\n\n    /**\n     * Angular gauges and solid gauges only. The label's pixel distance\n     * from the perimeter of the plot area.\n     *\n     * @type      {number}\n     * @default   -25\n     * @product   highcharts\n     * @apioption yAxis.labels.distance\n     */\n\n    /**\n     * The y position offset of the label relative to the tick position\n     * on the axis.\n     *\n     * @sample {highcharts} highcharts/xaxis/labels-x/\n     *         Y axis labels placed on grid lines\n     *\n     * @type      {number}\n     * @default   {highcharts} 3\n     * @default   {highstock} -2\n     * @default   {highmaps} 3\n     * @apioption yAxis.labels.y\n     */\n\n    /**\n     * @productdesc {highstock}\n     * In Highstock, `endOnTick` is always false when the navigator is\n     * enabled, to prevent jumpy scrolling.\n     */\n    endOnTick: true,\n\n    /**\n     * Padding of the max value relative to the length of the axis. A\n     * padding of 0.05 will make a 100px axis 5px longer. This is useful\n     * when you don't want the highest data value to appear on the edge\n     * of the plot area. When the axis' `max` option is set or a max extreme\n     * is set using `axis.setExtremes()`, the maxPadding will be ignored.\n     *\n     * @sample {highcharts} highcharts/yaxis/maxpadding-02/\n     *         Max padding of 0.2\n     * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n     *         Greater min- and maxPadding\n     *\n     * @since   1.2.0\n     * @product highcharts highstock\n     */\n    maxPadding: 0.05,\n\n    /**\n     * Padding of the min value relative to the length of the axis. A\n     * padding of 0.05 will make a 100px axis 5px longer. This is useful\n     * when you don't want the lowest data value to appear on the edge\n     * of the plot area. When the axis' `min` option is set or a max extreme\n     * is set using `axis.setExtremes()`, the maxPadding will be ignored.\n     *\n     * @sample {highcharts} highcharts/yaxis/minpadding/\n     *         Min padding of 0.2\n     * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n     *         Greater min- and maxPadding\n     *\n     * @since   1.2.0\n     * @product highcharts highstock\n     */\n    minPadding: 0.05,\n\n    /**\n     * @productdesc {highstock}\n     * In Highstock 1.x, the Y axis was placed on the left side by default.\n     *\n     * @sample {highcharts} highcharts/yaxis/opposite/\n     *         Secondary Y axis opposite\n     * @sample {highstock} stock/xaxis/opposite/\n     *         Y axis on left side\n     *\n     * @type      {boolean}\n     * @default   {highstock} true\n     * @default   {highcharts} false\n     * @product   highstock highcharts\n     * @apioption yAxis.opposite\n     */\n\n    /**\n     * @see [tickInterval](#xAxis.tickInterval)\n     * @see [tickPositioner](#xAxis.tickPositioner)\n     * @see [tickPositions](#xAxis.tickPositions)\n     */\n    tickPixelInterval: 72,\n    showLastLabel: true,\n\n    /**\n     * @extends    xAxis.labels\n     */\n    labels: {\n      /**\n       * What part of the string the given position is anchored to. Can\n       * be one of `\"left\"`, `\"center\"` or `\"right\"`. The exact position\n       * also depends on the `labels.x` setting.\n       *\n       * Angular gauges and solid gauges defaults to `center`.\n       *\n       * @sample {highcharts} highcharts/yaxis/labels-align-left/\n       *         Left\n       *\n       * @type       {string}\n       * @default    {highcharts|highmaps} right\n       * @default    {highstock} left\n       * @validvalue [\"left\", \"center\", \"right\"]\n       * @apioption  yAxis.labels.align\n       */\n\n      /**\n       * The x position offset of the label relative to the tick position\n       * on the axis. Defaults to -15 for left axis, 15 for right axis.\n       *\n       * @sample {highcharts} highcharts/xaxis/labels-x/\n       *         Y axis labels placed on grid lines\n       */\n      x: -8\n    },\n\n    /**\n     * @productdesc {highmaps}\n     * In Highmaps, the axis line is hidden by default, because the axis is\n     * not visible by default.\n     *\n     * @type      {Highcharts.ColorString}\n     * @apioption yAxis.lineColor\n     */\n\n    /**\n     * @sample {highcharts} highcharts/yaxis/max-200/\n     *         Y axis max of 200\n     * @sample {highcharts} highcharts/yaxis/max-logarithmic/\n     *         Y axis max on logarithmic axis\n     * @sample {highstock} stock/yaxis/min-max/\n     *         Fixed min and max on Y axis\n     * @sample {highmaps} maps/axis/min-max/\n     *         Pre-zoomed to a specific area\n     *\n     * @type      {number}\n     * @apioption yAxis.max\n     */\n\n    /**\n     * @sample {highcharts} highcharts/yaxis/min-startontick-false/\n     *         -50 with startOnTick to false\n     * @sample {highcharts} highcharts/yaxis/min-startontick-true/\n     *         -50 with startOnTick true by default\n     * @sample {highstock} stock/yaxis/min-max/\n     *         Fixed min and max on Y axis\n     * @sample {highmaps} maps/axis/min-max/\n     *         Pre-zoomed to a specific area\n     *\n     * @type      {number}\n     * @apioption yAxis.min\n     */\n\n    /**\n     * An optional scrollbar to display on the Y axis in response to\n     * limiting the minimum an maximum of the axis values.\n     *\n     * In styled mode, all the presentational options for the scrollbar\n     * are replaced by the classes `.highcharts-scrollbar-thumb`,\n     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,\n     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.\n     *\n     * @sample {highstock} stock/yaxis/scrollbar/\n     *         Scrollbar on the Y axis\n     *\n     * @extends   scrollbar\n     * @excluding height\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar\n     */\n\n    /**\n     * Enable the scrollbar on the Y axis.\n     *\n     * @sample {highstock} stock/yaxis/scrollbar/\n     *         Enabled on Y axis\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.enabled\n     */\n\n    /**\n     * Pixel margin between the scrollbar and the axis elements.\n     *\n     * @type      {number}\n     * @default   10\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.margin\n     */\n\n    /**\n     * Whether to show the scrollbar when it is fully zoomed out at max\n     * range. Setting it to `false` on the Y axis makes the scrollbar stay\n     * hidden until the user zooms in, like common in browsers.\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.showFull\n     */\n\n    /**\n     * The width of a vertical scrollbar or height of a horizontal\n     * scrollbar. Defaults to 20 on touch devices.\n     *\n     * @type      {number}\n     * @default   14\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.size\n     */\n\n    /**\n     * Z index of the scrollbar elements.\n     *\n     * @type      {number}\n     * @default   3\n     * @since     4.2.6\n     * @product   highstock\n     * @apioption yAxis.scrollbar.zIndex\n     */\n\n    /**\n     * A soft maximum for the axis. If the series data maximum is less\n     * than this, the axis will stay at this maximum, but if the series\n     * data maximum is higher, the axis will flex to show all data.\n     *\n     * **Note**: The [series.softThreshold](\n     * #plotOptions.series.softThreshold) option takes precedence over this\n     * option.\n     *\n     * @sample highcharts/yaxis/softmin-softmax/\n     *         Soft min and max\n     *\n     * @type      {number}\n     * @since     5.0.1\n     * @product   highcharts highstock\n     * @apioption yAxis.softMax\n     */\n\n    /**\n     * A soft minimum for the axis. If the series data minimum is greater\n     * than this, the axis will stay at this minimum, but if the series\n     * data minimum is lower, the axis will flex to show all data.\n     *\n     * **Note**: The [series.softThreshold](\n     * #plotOptions.series.softThreshold) option takes precedence over this\n     * option.\n     *\n     * @sample highcharts/yaxis/softmin-softmax/\n     *         Soft min and max\n     *\n     * @type      {number}\n     * @since     5.0.1\n     * @product   highcharts highstock\n     * @apioption yAxis.softMin\n     */\n\n    /**\n     * Defines the horizontal alignment of the stack total label. Can be one\n     * of `\"left\"`, `\"center\"` or `\"right\"`. The default value is calculated\n     * at runtime and depends on orientation and whether the stack is\n     * positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/\n     *         Aligned to the left\n     * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/\n     *         Aligned in center\n     * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/\n     *         Aligned to the right\n     *\n     * @type       {string}\n     * @since      2.1.5\n     * @product    highcharts\n     * @validvalue [\"left\", \"center\", \"right\"]\n     * @apioption  yAxis.stackLabels.align\n     */\n\n    /**\n     * A [format string](http://docs.highcharts.com/#formatting) for the\n     * data label. Available variables are the same as for `formatter`.\n     *\n     * @type      {string}\n     * @default   {total}\n     * @since     3.0.2\n     * @product   highcharts highstock\n     * @apioption yAxis.stackLabels.format\n     */\n\n    /**\n     * Rotation of the labels in degrees.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/\n     *         Labels rotated 45\n     *\n     * @type      {number}\n     * @default   0\n     * @since     2.1.5\n     * @product   highcharts\n     * @apioption yAxis.stackLabels.rotation\n     */\n\n    /**\n     * The text alignment for the label. While `align` determines where the\n     * texts anchor point is placed with regards to the stack, `textAlign`\n     * determines how the text is aligned against its anchor point. Possible\n     * values are `\"left\"`, `\"center\"` and `\"right\"`. The default value is\n     * calculated at runtime and depends on orientation and whether the\n     * stack is positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/\n     *         Label in center position but text-aligned left\n     *\n     * @type       {string}\n     * @since      2.1.5\n     * @product    highcharts\n     * @validvalue [\"left\", \"center\", \"right\"]\n     * @apioption  yAxis.stackLabels.textAlign\n     */\n\n    /**\n     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/\n     * labels-and-string-formatting#html) to render the labels.\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     3.0\n     * @product   highcharts highstock\n     * @apioption yAxis.stackLabels.useHTML\n     */\n\n    /**\n     * Defines the vertical alignment of the stack total label. Can be one\n     * of `\"top\"`, `\"middle\"` or `\"bottom\"`. The default value is calculated\n     * at runtime and depends on orientation and whether the stack is\n     * positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/\n     *         Vertically aligned top\n     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/\n     *         Vertically aligned middle\n     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/\n     *         Vertically aligned bottom\n     *\n     * @type       {string}\n     * @since      2.1.5\n     * @product    highcharts\n     * @validvalue [\"top\", \"middle\", \"bottom\"]\n     * @apioption  yAxis.stackLabels.verticalAlign\n     */\n\n    /**\n     * The x position offset of the label relative to the left of the\n     * stacked bar. The default value is calculated at runtime and depends\n     * on orientation and whether the stack is positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-x/\n     *         Stack total labels with x offset\n     *\n     * @type      {number}\n     * @since     2.1.5\n     * @product   highcharts\n     * @apioption yAxis.stackLabels.x\n     */\n\n    /**\n     * The y position offset of the label relative to the tick position\n     * on the axis. The default value is calculated at runtime and depends\n     * on orientation and whether the stack is positive or negative.\n     *\n     * @sample {highcharts} highcharts/yaxis/stacklabels-y/\n     *         Stack total labels with y offset\n     *\n     * @type      {number}\n     * @since     2.1.5\n     * @product   highcharts\n     * @apioption yAxis.stackLabels.y\n     */\n\n    /**\n     * Whether to force the axis to start on a tick. Use this option with\n     * the `maxPadding` option to control the axis start.\n     *\n     * @sample  {highcharts} highcharts/xaxis/startontick-false/\n     *          False by default\n     * @sample  {highcharts} highcharts/xaxis/startontick-true/\n     *          True\n     * @sample  {highstock} stock/xaxis/endontick/\n     *          False for Y axis\n     *\n     * @since   1.2.0\n     * @product highcharts highstock\n     */\n    startOnTick: true,\n    title: {\n      /**\n       * The pixel distance between the axis labels and the title.\n       * Positive values are outside the axis line, negative are inside.\n       *\n       * @sample {highcharts} highcharts/xaxis/title-margin/\n       *         Y axis title margin of 60\n       *\n       * @type      {number}\n       * @default   40\n       * @apioption yAxis.title.margin\n       */\n\n      /**\n       * The rotation of the text in degrees. 0 is horizontal, 270 is\n       * vertical reading from bottom to top.\n       *\n       * @sample {highcharts} highcharts/yaxis/title-offset/\n       *         Horizontal\n       */\n      rotation: 270,\n\n      /**\n       * The actual text of the axis title. Horizontal texts can contain\n       * HTML, but rotated texts are painted using vector techniques and\n       * must be clean text. The Y axis title is disabled by setting the\n       * `text` option to `undefined`.\n       *\n       * @sample  {highcharts} highcharts/xaxis/title-text/\n       *          Custom HTML\n       *\n       * @default {highcharts} Values\n       * @default {highstock} undefined\n       * @product highcharts highstock\n       */\n      text: 'Values'\n    },\n\n    /**\n     * The top position of the Y axis. If it's a number, it is interpreted\n     * as pixel position relative to the chart.\n     *\n     * Since Highstock 2: If it's a percentage string, it is interpreted\n     * as percentages of the plot height, offset from plot area top.\n     *\n     * @see [yAxis.height](#yAxis.height)\n     *\n     * @sample {highstock} stock/demo/candlestick-and-volume/\n     *         Percentage height panes\n     *\n     * @type      {number|string}\n     * @product   highstock\n     * @apioption yAxis.top\n     */\n\n    /**\n     * The stack labels show the total value for each bar in a stacked\n     * column or bar chart. The label will be placed on top of positive\n     * columns and below negative columns. In case of an inverted column\n     * chart or a bar chart the label is placed to the right of positive\n     * bars and to the left of negative bars.\n     *\n     * @product highcharts\n     */\n    stackLabels: {\n      /**\n       * Allow the stack labels to overlap.\n       *\n       * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/\n       *         Default false\n       *\n       * @since   5.0.13\n       * @product highcharts\n       */\n      allowOverlap: false,\n\n      /**\n       * Enable or disable the stack total labels.\n       *\n       * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/\n       *         Enabled stack total labels\n       *\n       * @since   2.1.5\n       * @product highcharts\n       */\n      enabled: false,\n\n      /**\n       * Callback JavaScript function to format the label. The value is\n       * given by `this.total`.\n       *\n       * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/\n       *         Added units to stack total value\n       *\n       * @type    {Highcharts.FormatterCallbackFunction}\n       * @since   2.1.5\n       * @product highcharts\n       */\n      formatter: function () {\n        return H.numberFormat(this.total, -1);\n      }\n    }\n  },\n\n  /**\n   * The Z axis or depth axis for 3D plots.\n   *\n   * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic\n   * access to the axis.\n   *\n   * @sample {highcharts} highcharts/3d/scatter-zaxis-categories/\n   *         Z-Axis with Categories\n   * @sample {highcharts} highcharts/3d/scatter-zaxis-grid/\n   *         Z-Axis with styling\n   *\n   * @extends   xAxis\n   * @since     5.0.0\n   * @product   highcharts\n   * @excluding breaks, crosshair, lineColor, lineWidth, nameToX, showEmpty\n   * @apioption zAxis\n   */\n\n  /**\n   * These options extend the defaultOptions for left axes.\n   *\n   * @private\n   * @name Highcharts.Axis#defaultLeftAxisOptions\n   * @type {*}\n   */\n  defaultLeftAxisOptions: {\n    labels: {\n      x: -15\n    },\n    title: {\n      rotation: 270\n    }\n  },\n\n  /**\n   * These options extend the defaultOptions for right axes.\n   *\n   * @private\n   * @name Highcharts.Axis#defaultRightAxisOptions\n   * @type {*}\n   */\n  defaultRightAxisOptions: {\n    labels: {\n      x: 15\n    },\n    title: {\n      rotation: 90\n    }\n  },\n\n  /**\n   * These options extend the defaultOptions for bottom axes.\n   *\n   * @private\n   * @name Highcharts.Axis#defaultBottomAxisOptions\n   * @type {*}\n   */\n  defaultBottomAxisOptions: {\n    labels: {\n      autoRotation: [-45],\n      x: 0 // overflow: undefined,\n      // staggerLines: null\n\n    },\n    title: {\n      rotation: 0\n    }\n  },\n\n  /**\n   * These options extend the defaultOptions for top axes.\n   *\n   * @private\n   * @name Highcharts.Axis#defaultTopAxisOptions\n   * @type {*}\n   */\n  defaultTopAxisOptions: {\n    labels: {\n      autoRotation: [-45],\n      x: 0 // overflow: undefined\n      // staggerLines: null\n\n    },\n    title: {\n      rotation: 0\n    }\n  },\n\n  /**\n   * Overrideable function to initialize the axis.\n   *\n   * @see {@link Axis}\n   *\n   * @function Highcharts.Axis#init\n   *\n   * @param {Highcharts.Chart} chart\n   *\n   * @param {Highcharts.Options} userOptions\n   *\n   * @fires Highcharts.Axis#event:afterInit\n   * @fires Highcharts.Axis#event:init\n   */\n  init: function (chart, userOptions) {\n    var isXAxis = userOptions.isX,\n        axis = this;\n    /**\n     * The Chart that the axis belongs to.\n     *\n     * @name Highcharts.Axis#chart\n     * @type {Highcharts.Chart}\n     */\n\n    axis.chart = chart;\n    /**\n     * Whether the axis is horizontal.\n     *\n     * @name Highcharts.Axis#horiz\n     * @type {boolean}\n     */\n\n    axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis; // Flag, isXAxis\n\n    axis.isXAxis = isXAxis;\n    /**\n     * The collection where the axis belongs, for example `xAxis`, `yAxis`\n     * or `colorAxis`. Corresponds to properties on Chart, for example\n     * {@link Chart.xAxis}.\n     *\n     * @name Highcharts.Axis#coll\n     * @type {string}\n     */\n\n    axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');\n    fireEvent(this, 'init', {\n      userOptions: userOptions\n    });\n    axis.opposite = userOptions.opposite; // needed in setOptions\n\n    /**\n     * The side on which the axis is rendered. 0 is top, 1 is right, 2 is\n     * bottom and 3 is left.\n     *\n     * @name Highcharts.Axis#side\n     * @type {number}\n     */\n\n    axis.side = userOptions.side || (axis.horiz ? axis.opposite ? 0 : 2 : // top : bottom\n    axis.opposite ? 1 : 3); // right : left\n\n    axis.setOptions(userOptions);\n    var options = this.options,\n        type = options.type,\n        isDatetimeAxis = type === 'datetime';\n    axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n    // Flag, stagger lines or not\n\n    axis.userOptions = userOptions;\n    axis.minPixelPadding = 0;\n    /**\n     * Whether the axis is reversed. Based on the `axis.reversed`,\n     * option, but inverted charts have reversed xAxis by default.\n     *\n     * @name Highcharts.Axis#reversed\n     * @type {boolean}\n     */\n\n    axis.reversed = options.reversed;\n    axis.visible = options.visible !== false;\n    axis.zoomEnabled = options.zoomEnabled !== false; // Initial categories\n\n    axis.hasNames = type === 'category' || options.categories === true;\n    axis.categories = options.categories || axis.hasNames;\n\n    if (!axis.names) {\n      // Preserve on update (#3830)\n      axis.names = [];\n      axis.names.keys = {};\n    } // Placeholder for plotlines and plotbands groups\n\n\n    axis.plotLinesAndBandsGroups = {}; // Shorthand types\n\n    axis.isLog = type === 'logarithmic';\n    axis.isDatetimeAxis = isDatetimeAxis;\n    axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog; // Flag, if axis is linked to another axis\n\n    axis.isLinked = defined(options.linkedTo); // Major ticks\n\n    axis.ticks = {};\n    axis.labelEdge = []; // Minor ticks\n\n    axis.minorTicks = {}; // List of plotLines/Bands\n\n    axis.plotLinesAndBands = []; // Alternate bands\n\n    axis.alternateBands = {}; // Axis metrics\n\n    axis.len = 0;\n    axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n    axis.range = options.range;\n    axis.offset = options.offset || 0; // Dictionary for stacks\n\n    axis.stacks = {};\n    axis.oldStacks = {};\n    axis.stacksTouched = 0;\n    /**\n     * The maximum value of the axis. In a logarithmic axis, this is the\n     * logarithm of the real value, and the real value can be obtained from\n     * {@link Axis#getExtremes}.\n     *\n     * @name Highcharts.Axis#max\n     * @type {number}\n     */\n\n    axis.max = null;\n    /**\n     * The minimum value of the axis. In a logarithmic axis, this is the\n     * logarithm of the real value, and the real value can be obtained from\n     * {@link Axis#getExtremes}.\n     *\n     * @name Highcharts.Axis#min\n     * @type {number}\n     */\n\n    axis.min = null;\n    /**\n     * The processed crosshair options.\n     *\n     * @name Highcharts.Axis#crosshair\n     * @type {false|Highcharts.AxisCrosshairOptions}\n     */\n\n    axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n    var events = axis.options.events; // Register. Don't add it again on Axis.update().\n\n    if (inArray(axis, chart.axes) === -1) {\n      //\n      if (isXAxis) {\n        // #2713\n        chart.axes.splice(chart.xAxis.length, 0, axis);\n      } else {\n        chart.axes.push(axis);\n      }\n\n      chart[axis.coll].push(axis);\n    }\n    /**\n     * All series associated to the axis.\n     *\n     * @name Highcharts.Axis#series\n     * @type {Array<Highcharts.Series>}\n     */\n\n\n    axis.series = axis.series || []; // populated by Series\n    // Reversed axis\n\n    if (chart.inverted && !axis.isZAxis && isXAxis && axis.reversed === undefined) {\n      axis.reversed = true;\n    } // register event listeners\n\n\n    objectEach(events, function (event, eventType) {\n      addEvent(axis, eventType, event);\n    }); // extend logarithmic axis\n\n    axis.lin2log = options.linearToLogConverter || axis.lin2log;\n\n    if (axis.isLog) {\n      axis.val2lin = axis.log2lin;\n      axis.lin2val = axis.lin2log;\n    }\n\n    fireEvent(this, 'afterInit');\n  },\n\n  /**\n   * Merge and set options.\n   *\n   * @private\n   * @function Highcharts.Axis#setOptions\n   *\n   * @param {Highcharts.AxisOptions} userOptions\n   *\n   * @fires Highcharts.Axis#event:afterSetOptions\n   */\n  setOptions: function (userOptions) {\n    this.options = merge(this.defaultOptions, this.coll === 'yAxis' && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], merge(defaultOptions[this.coll], // if set in setOptions (#1053)\n    userOptions));\n    fireEvent(this, 'afterSetOptions', {\n      userOptions: userOptions\n    });\n  },\n\n  /**\n   * The default label formatter. The context is a special config object for\n   * the label. In apps, use the {@link\n   * https://api.highcharts.com/highcharts/xAxis.labels.formatter|\n   * labels.formatter} instead except when a modification is needed.\n   *\n   * @private\n   * @function Highcharts.Axis#defaultLabelFormatter\n   *\n   * @return {string}\n   */\n  defaultLabelFormatter: function () {\n    var axis = this.axis,\n        value = this.value,\n        time = axis.chart.time,\n        categories = axis.categories,\n        dateTimeLabelFormat = this.dateTimeLabelFormat,\n        lang = defaultOptions.lang,\n        numericSymbols = lang.numericSymbols,\n        numSymMagnitude = lang.numericSymbolMagnitude || 1000,\n        i = numericSymbols && numericSymbols.length,\n        multi,\n        ret,\n        formatOption = axis.options.labels.format,\n        // make sure the same symbol is added for all labels on a linear\n    // axis\n    numericSymbolDetector = axis.isLog ? Math.abs(value) : axis.tickInterval;\n\n    if (formatOption) {\n      ret = format(formatOption, this, time);\n    } else if (categories) {\n      ret = value;\n    } else if (dateTimeLabelFormat) {\n      // datetime axis\n      ret = time.dateFormat(dateTimeLabelFormat, value);\n    } else if (i && numericSymbolDetector >= 1000) {\n      // Decide whether we should add a numeric symbol like k (thousands)\n      // or M (millions). If we are to enable this in tooltip or other\n      // places as well, we can move this logic to the numberFormatter and\n      // enable it by a parameter.\n      while (i-- && ret === undefined) {\n        multi = Math.pow(numSymMagnitude, i + 1);\n\n        if ( // Only accept a numeric symbol when the distance is more\n        // than a full unit. So for example if the symbol is k, we\n        // don't accept numbers like 0.5k.\n        numericSymbolDetector >= multi && // Accept one decimal before the symbol. Accepts 0.5k but\n        // not 0.25k. How does this work with the previous?\n        value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0) {\n          // #5480\n          ret = H.numberFormat(value / multi, -1) + numericSymbols[i];\n        }\n      }\n    }\n\n    if (ret === undefined) {\n      if (Math.abs(value) >= 10000) {\n        // add thousands separators\n        ret = H.numberFormat(value, -1);\n      } else {\n        // small numbers\n        ret = H.numberFormat(value, -1, undefined, ''); // #2466\n      }\n    }\n\n    return ret;\n  },\n\n  /**\n   * Get the minimum and maximum for the series of each axis. The function\n   * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.\n   *\n   * @private\n   * @function Highcharts.Axis#getSeriesExtremes\n   *\n   * @fires Highcharts.Axis#event:afterGetSeriesExtremes\n   * @fires Highcharts.Axis#event:getSeriesExtremes\n   */\n  getSeriesExtremes: function () {\n    var axis = this,\n        chart = axis.chart;\n    fireEvent(this, 'getSeriesExtremes', null, function () {\n      axis.hasVisibleSeries = false; // Reset properties in case we're redrawing (#3353)\n\n      axis.dataMin = axis.dataMax = axis.threshold = null;\n      axis.softThreshold = !axis.isXAxis;\n\n      if (axis.buildStacks) {\n        axis.buildStacks();\n      } // loop through this axis' series\n\n\n      each(axis.series, function (series) {\n        if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n          var seriesOptions = series.options,\n              xData,\n              threshold = seriesOptions.threshold,\n              seriesDataMin,\n              seriesDataMax;\n          axis.hasVisibleSeries = true; // Validate threshold in logarithmic axes\n\n          if (axis.positiveValuesOnly && threshold <= 0) {\n            threshold = null;\n          } // Get dataMin and dataMax for X axes\n\n\n          if (axis.isXAxis) {\n            xData = series.xData;\n\n            if (xData.length) {\n              // If xData contains values which is not numbers,\n              // then filter them out. To prevent performance hit,\n              // we only do this after we have already found\n              // seriesDataMin because in most cases all data is\n              // valid. #5234.\n              seriesDataMin = arrayMin(xData);\n              seriesDataMax = arrayMax(xData);\n\n              if (!isNumber(seriesDataMin) && !(seriesDataMin instanceof Date) // #5010\n              ) {\n                  xData = grep(xData, isNumber); // Do it again with valid data\n\n                  seriesDataMin = arrayMin(xData);\n                  seriesDataMax = arrayMax(xData);\n                }\n\n              if (xData.length) {\n                axis.dataMin = Math.min(pick(axis.dataMin, xData[0], seriesDataMin), seriesDataMin);\n                axis.dataMax = Math.max(pick(axis.dataMax, xData[0], seriesDataMax), seriesDataMax);\n              }\n            } // Get dataMin and dataMax for Y axes, as well as handle\n            // stacking and processed data\n\n          } else {\n            // Get this particular series extremes\n            series.getExtremes();\n            seriesDataMax = series.dataMax;\n            seriesDataMin = series.dataMin; // Get the dataMin and dataMax so far. If percentage is\n            // used, the min and max are always 0 and 100. If\n            // seriesDataMin and seriesDataMax is null, then series\n            // doesn't have active y data, we continue with nulls\n\n            if (defined(seriesDataMin) && defined(seriesDataMax)) {\n              axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n              axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n            } // Adjust to threshold\n\n\n            if (defined(threshold)) {\n              axis.threshold = threshold;\n            } // If any series has a hard threshold, it takes\n            // precedence\n\n\n            if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {\n              axis.softThreshold = false;\n            }\n          }\n        }\n      });\n    });\n    fireEvent(this, 'afterGetSeriesExtremes');\n  },\n\n  /**\n   * Translate from axis value to pixel position on the chart, or back. Use\n   * the `toPixels` and `toValue` functions in applications.\n   *\n   * @private\n   * @function Highcharts.Axis#translate\n   *\n   * @param {number} val\n   *\n   * @param {boolean} [backwards]\n   *\n   * @param {boolean} [cvsCoord]\n   *\n   * @param {boolean} [old]\n   *\n   * @param {boolean} [handleLog]\n   *\n   * @param {number} [pointPlacement=0]\n   *\n   * @return {number|undefined}\n   */\n  translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n    var axis = this.linkedParent || this,\n        // #1417\n    sign = 1,\n        cvsOffset = 0,\n        localA = old ? axis.oldTransA : axis.transA,\n        localMin = old ? axis.oldMin : axis.min,\n        returnValue,\n        minPixelPadding = axis.minPixelPadding,\n        doPostTranslate = (axis.isOrdinal || axis.isBroken || axis.isLog && handleLog) && axis.lin2val;\n\n    if (!localA) {\n      localA = axis.transA;\n    } // In vertical axes, the canvas coordinates start from 0 at the top like\n    // in SVG.\n\n\n    if (cvsCoord) {\n      sign *= -1; // canvas coordinates inverts the value\n\n      cvsOffset = axis.len;\n    } // Handle reversed axis\n\n\n    if (axis.reversed) {\n      sign *= -1;\n      cvsOffset -= sign * (axis.sector || axis.len);\n    } // From pixels to value\n\n\n    if (backwards) {\n      // reverse translation\n      val = val * sign + cvsOffset;\n      val -= minPixelPadding;\n      returnValue = val / localA + localMin; // from chart pixel to value\n\n      if (doPostTranslate) {\n        // log and ordinal axes\n        returnValue = axis.lin2val(returnValue);\n      } // From value to pixels\n\n    } else {\n      if (doPostTranslate) {\n        // log and ordinal axes\n        val = axis.val2lin(val);\n      }\n\n      returnValue = isNumber(localMin) ? sign * (val - localMin) * localA + cvsOffset + sign * minPixelPadding + (isNumber(pointPlacement) ? localA * pointPlacement : 0) : undefined;\n    }\n\n    return returnValue;\n  },\n\n  /**\n   * Translate a value in terms of axis units into pixels within the chart.\n   *\n   * @function Highcharts.Axis#toPixels\n   *\n   * @param {number} value\n   *        A value in terms of axis units.\n   *\n   * @param {boolean} paneCoordinates\n   *        Whether to return the pixel coordinate relative to the chart or\n   *        just the axis/pane itself.\n   *\n   * @return {number}\n   *         Pixel position of the value on the chart or axis.\n   */\n  toPixels: function (value, paneCoordinates) {\n    return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);\n  },\n\n  /**\n   * Translate a pixel position along the axis to a value in terms of axis\n   * units.\n   *\n   * @function Highcharts.Axis#toValue\n   *\n   * @param {number} pixel\n   *        The pixel value coordinate.\n   *\n   * @param {boolean} paneCoordiantes\n   *        Whether the input pixel is relative to the chart or just the\n   *        axis/pane itself.\n   *\n   * @return {number}\n   *         The axis value.\n   */\n  toValue: function (pixel, paneCoordinates) {\n    return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);\n  },\n\n  /**\n   * Create the path for a plot line that goes from the given value on\n   * this axis, across the plot to the opposite side. Also used internally for\n   * grid lines and crosshairs.\n   *\n   * @function Highcharts.Axis#getPlotLinePath\n   *\n   * @param {number} value\n   *        Axis value.\n   *\n   * @param {number} [lineWidth=1]\n   *        Used for calculation crisp line coordinates.\n   *\n   * @param {boolean} [old=false]\n   *        Use old coordinates (for resizing and rescaling).\n   *\n   * @param {boolean} [force=false]\n   *        If `false`, the function will return null when it falls outside\n   *        the axis bounds.\n   *\n   * @param {number} [translatedValue]\n   *        If given, return the plot line path of a pixel position on the\n   *        axis.\n   *\n   * @return {Array<string|number>}\n   *         The SVG path definition for the plot line.\n   */\n  getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {\n    var axis = this,\n        chart = axis.chart,\n        axisLeft = axis.left,\n        axisTop = axis.top,\n        x1,\n        y1,\n        x2,\n        y2,\n        cHeight = old && chart.oldChartHeight || chart.chartHeight,\n        cWidth = old && chart.oldChartWidth || chart.chartWidth,\n        skip,\n        transB = axis.transB,\n\n    /**\n     * Check if x is between a and b. If not, either move to a/b\n     * or skip, depending on the force parameter.\n     */\n    between = function (x, a, b) {\n      if (x < a || x > b) {\n        if (force) {\n          x = Math.min(Math.max(a, x), b);\n        } else {\n          skip = true;\n        }\n      }\n\n      return x;\n    };\n\n    translatedValue = pick(translatedValue, axis.translate(value, null, null, old)); // Keep the translated value within sane bounds, and avoid Infinity to\n    // fail the isNumber test (#7709).\n\n    translatedValue = Math.min(Math.max(-1e5, translatedValue), 1e5);\n    x1 = x2 = Math.round(translatedValue + transB);\n    y1 = y2 = Math.round(cHeight - translatedValue - transB);\n\n    if (!isNumber(translatedValue)) {\n      // no min or max\n      skip = true;\n      force = false; // #7175, don't force it when path is invalid\n    } else if (axis.horiz) {\n      y1 = axisTop;\n      y2 = cHeight - axis.bottom;\n      x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n    } else {\n      x1 = axisLeft;\n      x2 = cWidth - axis.right;\n      y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n    }\n\n    return skip && !force ? null : chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);\n  },\n\n  /**\n   * Internal function to et the tick positions of a linear axis to round\n   * values like whole tens or every five.\n   *\n   * @function Highcharts.Axis#getLinearTickPositions\n   *\n   * @param {number} tickInterval\n   *        The normalized tick interval.\n   *\n   * @param {number} min\n   *        Axis minimum.\n   *\n   * @param {number} max\n   *        Axis maximum.\n   *\n   * @return {Array<number>}\n   *         An array of axis values where ticks should be placed.\n   */\n  getLinearTickPositions: function (tickInterval, min, max) {\n    var pos,\n        lastPos,\n        roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),\n        roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),\n        tickPositions = [],\n        precision; // When the precision is higher than what we filter out in\n    // correctFloat, skip it (#6183).\n\n    if (correctFloat(roundedMin + tickInterval) === roundedMin) {\n      precision = 20;\n    } // For single points, add a tick regardless of the relative position\n    // (#2662, #6274)\n\n\n    if (this.single) {\n      return [min];\n    } // Populate the intermediate values\n\n\n    pos = roundedMin;\n\n    while (pos <= roundedMax) {\n      // Place the tick on the rounded value\n      tickPositions.push(pos); // Always add the raw tickInterval, not the corrected one.\n\n      pos = correctFloat(pos + tickInterval, precision); // If the interval is not big enough in the current min - max range\n      // to actually increase the loop variable, we need to break out to\n      // prevent endless loop. Issue #619\n\n      if (pos === lastPos) {\n        break;\n      } // Record the last value\n\n\n      lastPos = pos;\n    }\n\n    return tickPositions;\n  },\n\n  /**\n   * Resolve the new minorTicks/minorTickInterval options into the legacy\n   * loosely typed minorTickInterval option.\n   *\n   * @function Highcharts.Axis#getMinorTickInterval\n   *\n   * @return {number|'auto'|null}\n   */\n  getMinorTickInterval: function () {\n    var options = this.options;\n\n    if (options.minorTicks === true) {\n      return pick(options.minorTickInterval, 'auto');\n    }\n\n    if (options.minorTicks === false) {\n      return null;\n    }\n\n    return options.minorTickInterval;\n  },\n\n  /**\n   * Internal function to return the minor tick positions. For logarithmic\n   * axes, the same logic as for major ticks is reused.\n   *\n   * @function Highcharts.Axis#getMinorTickPositions\n   *\n   * @return {Array<number>}\n   *         An array of axis values where ticks should be placed.\n   */\n  getMinorTickPositions: function () {\n    var axis = this,\n        options = axis.options,\n        tickPositions = axis.tickPositions,\n        minorTickInterval = axis.minorTickInterval,\n        minorTickPositions = [],\n        pos,\n        pointRangePadding = axis.pointRangePadding || 0,\n        min = axis.min - pointRangePadding,\n        // #1498\n    max = axis.max + pointRangePadding,\n        // #1498\n    range = max - min; // If minor ticks get too dense, they are hard to read, and may cause\n    // long running script. So we don't draw them.\n\n    if (range && range / minorTickInterval < axis.len / 3) {\n      // #3875\n      if (axis.isLog) {\n        // For each interval in the major ticks, compute the minor ticks\n        // separately.\n        each(this.paddedTicks, function (pos, i, paddedTicks) {\n          if (i) {\n            minorTickPositions.push.apply(minorTickPositions, axis.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));\n          }\n        });\n      } else if (axis.isDatetimeAxis && this.getMinorTickInterval() === 'auto') {\n        // #1314\n        minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));\n      } else {\n        for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n          // Very, very, tight grid lines (#5771)\n          if (pos === minorTickPositions[0]) {\n            break;\n          }\n\n          minorTickPositions.push(pos);\n        }\n      }\n    }\n\n    if (minorTickPositions.length !== 0) {\n      axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330\n    }\n\n    return minorTickPositions;\n  },\n\n  /**\n   * Adjust the min and max for the minimum range. Keep in mind that the\n   * series data is not yet processed, so we don't have information on data\n   * cropping and grouping, or updated axis.pointRange or series.pointRange.\n   * The data can't be processed until we have finally established min and\n   * max.\n   *\n   * @private\n   * @function Highcharts.Axis#adjustForMinRange\n   */\n  adjustForMinRange: function () {\n    var axis = this,\n        options = axis.options,\n        min = axis.min,\n        max = axis.max,\n        zoomOffset,\n        spaceAvailable,\n        closestDataRange,\n        i,\n        distance,\n        xData,\n        loopLength,\n        minArgs,\n        maxArgs,\n        minRange; // Set the automatic minimum range based on the closest point distance\n\n    if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {\n      if (defined(options.min) || defined(options.max)) {\n        axis.minRange = null; // don't do this again\n      } else {\n        // Find the closest distance between raw data points, as opposed\n        // to closestPointRange that applies to processed points\n        // (cropped and grouped)\n        each(axis.series, function (series) {\n          xData = series.xData;\n          loopLength = series.xIncrement ? 1 : xData.length - 1;\n\n          for (i = loopLength; i > 0; i--) {\n            distance = xData[i] - xData[i - 1];\n\n            if (closestDataRange === undefined || distance < closestDataRange) {\n              closestDataRange = distance;\n            }\n          }\n        });\n        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);\n      }\n    } // if minRange is exceeded, adjust\n\n\n    if (max - min < axis.minRange) {\n      spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;\n      minRange = axis.minRange;\n      zoomOffset = (minRange - max + min) / 2; // if min and max options have been set, don't go beyond it\n\n      minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)]; // If space is available, stay within the data range\n\n      if (spaceAvailable) {\n        minArgs[2] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;\n      }\n\n      min = arrayMax(minArgs);\n      maxArgs = [min + minRange, pick(options.max, min + minRange)]; // If space is availabe, stay within the data range\n\n      if (spaceAvailable) {\n        maxArgs[2] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;\n      }\n\n      max = arrayMin(maxArgs); // now if the max is adjusted, adjust the min back\n\n      if (max - min < minRange) {\n        minArgs[0] = max - minRange;\n        minArgs[1] = pick(options.min, max - minRange);\n        min = arrayMax(minArgs);\n      }\n    } // Record modified extremes\n\n\n    axis.min = min;\n    axis.max = max;\n  },\n\n  /**\n   * Find the closestPointRange across all series.\n   *\n   * @private\n   * @function Highcharts.Axis#getClosest\n   *\n   * @return {number}\n   */\n  getClosest: function () {\n    var ret;\n\n    if (this.categories) {\n      ret = 1;\n    } else {\n      each(this.series, function (series) {\n        var seriesClosest = series.closestPointRange,\n            visible = series.visible || !series.chart.options.chart.ignoreHiddenSeries;\n\n        if (!series.noSharedTooltip && defined(seriesClosest) && visible) {\n          ret = defined(ret) ? Math.min(ret, seriesClosest) : seriesClosest;\n        }\n      });\n    }\n\n    return ret;\n  },\n\n  /**\n   * When a point name is given and no x, search for the name in the existing\n   * categories, or if categories aren't provided, search names or create a\n   * new category (#2522).\n   *\n   * @private\n   * @function Highcharts.Axis#nameToX\n   *\n   * @param {Highcharts.Point} point\n   *        The point to inspect.\n   *\n   * @return {number}\n   *         The X value that the point is given.\n   */\n  nameToX: function (point) {\n    var explicitCategories = isArray(this.categories),\n        names = explicitCategories ? this.categories : this.names,\n        nameX = point.options.x,\n        x;\n    point.series.requireSorting = false;\n\n    if (!defined(nameX)) {\n      nameX = this.options.uniqueNames === false ? point.series.autoIncrement() : explicitCategories ? inArray(point.name, names) : pick(names.keys[point.name], -1);\n    }\n\n    if (nameX === -1) {\n      // Not found in currenct categories\n      if (!explicitCategories) {\n        x = names.length;\n      }\n    } else {\n      x = nameX;\n    } // Write the last point's name to the names array\n\n\n    if (x !== undefined) {\n      this.names[x] = point.name; // Backwards mapping is much faster than array searching (#7725)\n\n      this.names.keys[point.name] = x;\n    }\n\n    return x;\n  },\n\n  /**\n   * When changes have been done to series data, update the axis.names.\n   *\n   * @private\n   * @function Highcharts.Axis#updateNames\n   */\n  updateNames: function () {\n    var axis = this,\n        names = this.names,\n        i = names.length;\n\n    if (i > 0) {\n      each(H.keys(names.keys), function (key) {\n        delete names.keys[key];\n      });\n      names.length = 0;\n      this.minRange = this.userMinRange; // Reset\n\n      each(this.series || [], function (series) {\n        // Reset incrementer (#5928)\n        series.xIncrement = null; // When adding a series, points are not yet generated\n\n        if (!series.points || series.isDirtyData) {\n          series.processData();\n          series.generatePoints();\n        }\n\n        each(series.points, function (point, i) {\n          var x;\n\n          if (point.options) {\n            x = axis.nameToX(point);\n\n            if (x !== undefined && x !== point.x) {\n              point.x = x;\n              series.xData[i] = x;\n            }\n          }\n        });\n      });\n    }\n  },\n\n  /**\n   * Update translation information.\n   *\n   * @private\n   * @function Highcharts.Axis#setAxisTranslation\n   *\n   * @param {boolean} saveOld\n   *\n   * @fires Highcharts.Axis#event:afterSetAxisTranslation\n   */\n  setAxisTranslation: function (saveOld) {\n    var axis = this,\n        range = axis.max - axis.min,\n        pointRange = axis.axisPointRange || 0,\n        closestPointRange,\n        minPointOffset = 0,\n        pointRangePadding = 0,\n        linkedParent = axis.linkedParent,\n        ordinalCorrection,\n        hasCategories = !!axis.categories,\n        transA = axis.transA,\n        isXAxis = axis.isXAxis; // Adjust translation for padding. Y axis with categories need to go\n    // through the same (#1784).\n\n    if (isXAxis || hasCategories || pointRange) {\n      // Get the closest points\n      closestPointRange = axis.getClosest();\n\n      if (linkedParent) {\n        minPointOffset = linkedParent.minPointOffset;\n        pointRangePadding = linkedParent.pointRangePadding;\n      } else {\n        each(axis.series, function (series) {\n          var seriesPointRange = hasCategories ? 1 : isXAxis ? pick(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0,\n              // #2806\n          pointPlacement = series.options.pointPlacement;\n          pointRange = Math.max(pointRange, seriesPointRange);\n\n          if (!axis.single) {\n            // minPointOffset is the value padding to the left of\n            // the axis in order to make room for points with a\n            // pointRange, typically columns. When the\n            // pointPlacement option is 'between' or 'on', this\n            // padding does not apply.\n            minPointOffset = Math.max(minPointOffset, isString(pointPlacement) ? 0 : seriesPointRange / 2); // Determine the total padding needed to the length of\n            // the axis to make room for the pointRange. If the\n            // series' pointPlacement is 'on', no padding is added.\n\n            pointRangePadding = Math.max(pointRangePadding, pointPlacement === 'on' ? 0 : seriesPointRange);\n          }\n        });\n      } // Record minPointOffset and pointRangePadding\n\n\n      ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n\n      axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n      axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection; // pointRange means the width reserved for each point, like in a\n      // column chart\n\n      axis.pointRange = Math.min(pointRange, range); // closestPointRange means the closest distance between points. In\n      // columns it is mostly equal to pointRange, but in lines pointRange\n      // is 0 while closestPointRange is some other value\n\n      if (isXAxis) {\n        axis.closestPointRange = closestPointRange;\n      }\n    } // Secondary values\n\n\n    if (saveOld) {\n      axis.oldTransA = transA;\n    }\n\n    axis.translationSlope = axis.transA = transA = axis.options.staticScale || axis.len / (range + pointRangePadding || 1); // Translation addend\n\n    axis.transB = axis.horiz ? axis.left : axis.bottom;\n    axis.minPixelPadding = transA * minPointOffset;\n    fireEvent(this, 'afterSetAxisTranslation');\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Axis#minFromRange\n   *\n   * @return {number}\n   */\n  minFromRange: function () {\n    return this.max - this.range;\n  },\n\n  /**\n   * Set the tick positions to round values and optionally extend the extremes\n   * to the nearest tick.\n   *\n   * @private\n   * @function Highcharts.Axis#setTickInterval\n   *\n   * @param {boolean} secondPass\n   *\n   * @fires Highcharts.Axis#event:foundExtremes\n   */\n  setTickInterval: function (secondPass) {\n    var axis = this,\n        chart = axis.chart,\n        options = axis.options,\n        isLog = axis.isLog,\n        isDatetimeAxis = axis.isDatetimeAxis,\n        isXAxis = axis.isXAxis,\n        isLinked = axis.isLinked,\n        maxPadding = options.maxPadding,\n        minPadding = options.minPadding,\n        length,\n        linkedParentExtremes,\n        tickIntervalOption = options.tickInterval,\n        minTickInterval,\n        tickPixelIntervalOption = options.tickPixelInterval,\n        categories = axis.categories,\n        threshold = isNumber(axis.threshold) ? axis.threshold : null,\n        softThreshold = axis.softThreshold,\n        thresholdMin,\n        thresholdMax,\n        hardMin,\n        hardMax;\n\n    if (!isDatetimeAxis && !categories && !isLinked) {\n      this.getTickAmount();\n    } // Min or max set either by zooming/setExtremes or initial options\n\n\n    hardMin = pick(axis.userMin, options.min);\n    hardMax = pick(axis.userMax, options.max); // Linked axis gets the extremes from the parent axis\n\n    if (isLinked) {\n      axis.linkedParent = chart[axis.coll][options.linkedTo];\n      linkedParentExtremes = axis.linkedParent.getExtremes();\n      axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n      axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n\n      if (options.type !== axis.linkedParent.options.type) {\n        H.error(11, 1); // Can't link axes of different type\n      } // Initial min and max from the extreme data values\n\n    } else {\n      // Adjust to hard threshold\n      if (!softThreshold && defined(threshold)) {\n        if (axis.dataMin >= threshold) {\n          thresholdMin = threshold;\n          minPadding = 0;\n        } else if (axis.dataMax <= threshold) {\n          thresholdMax = threshold;\n          maxPadding = 0;\n        }\n      }\n\n      axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n      axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n    }\n\n    if (isLog) {\n      if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0) {\n        // #978\n        H.error(10, 1); // Can't plot negative values on log axis\n      } // The correctFloat cures #934, float errors on full tens. But it\n      // was too aggressive for #4360 because of conversion back to lin,\n      // therefore use precision 15.\n\n\n      axis.min = correctFloat(axis.log2lin(axis.min), 15);\n      axis.max = correctFloat(axis.log2lin(axis.max), 15);\n    } // handle zoomed range\n\n\n    if (axis.range && defined(axis.max)) {\n      axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange()); // #618, #6773\n\n      axis.userMax = hardMax = axis.max;\n      axis.range = null; // don't use it when running setExtremes\n    } // Hook for Highstock Scroller. Consider combining with beforePadding.\n\n\n    fireEvent(axis, 'foundExtremes'); // Hook for adjusting this.min and this.max. Used by bubble series.\n\n    if (axis.beforePadding) {\n      axis.beforePadding();\n    } // adjust min and max for the minimum range\n\n\n    axis.adjustForMinRange(); // Pad the values to get clear of the chart's edges. To avoid\n    // tickInterval taking the padding into account, we do this after\n    // computing tick interval (#1337).\n\n    if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n      length = axis.max - axis.min;\n\n      if (length) {\n        if (!defined(hardMin) && minPadding) {\n          axis.min -= length * minPadding;\n        }\n\n        if (!defined(hardMax) && maxPadding) {\n          axis.max += length * maxPadding;\n        }\n      }\n    } // Handle options for floor, ceiling, softMin and softMax (#6359)\n\n\n    if (isNumber(options.softMin) && !isNumber(axis.userMin)) {\n      axis.min = Math.min(axis.min, options.softMin);\n    }\n\n    if (isNumber(options.softMax) && !isNumber(axis.userMax)) {\n      axis.max = Math.max(axis.max, options.softMax);\n    }\n\n    if (isNumber(options.floor)) {\n      axis.min = Math.max(axis.min, options.floor);\n    }\n\n    if (isNumber(options.ceiling)) {\n      axis.max = Math.min(axis.max, options.ceiling);\n    } // When the threshold is soft, adjust the extreme value only if the data\n    // extreme and the padded extreme land on either side of the threshold.\n    // For example, a series of [0, 1, 2, 3] would make the yAxis add a tick\n    // for -1 because of the default minPadding and startOnTick options.\n    // This is prevented by the softThreshold option.\n\n\n    if (softThreshold && defined(axis.dataMin)) {\n      threshold = threshold || 0;\n\n      if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {\n        axis.min = threshold;\n      } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {\n        axis.max = threshold;\n      }\n    } // get tickInterval\n\n\n    if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n      axis.tickInterval = 1;\n    } else if (isLinked && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n      axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;\n    } else {\n      axis.tickInterval = pick(tickIntervalOption, this.tickAmount ? (axis.max - axis.min) / Math.max(this.tickAmount - 1, 1) : undefined, // For categoried axis, 1 is default, for linear axis use\n      // tickPix\n      categories ? 1 : // don't let it be more than the data range\n      (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption));\n    }\n    /**\n     * Now we're finished detecting min and max, crop and group series data.\n     * This is in turn needed in order to find tick positions in\n     * ordinal axes.\n     */\n\n\n    if (isXAxis && !secondPass) {\n      each(axis.series, function (series) {\n        series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n      });\n    } // set the translation factor used in translate function\n\n\n    axis.setAxisTranslation(true); // hook for ordinal axes and radial axes\n\n    if (axis.beforeSetTickPositions) {\n      axis.beforeSetTickPositions();\n    } // hook for extensions, used in Highstock ordinal axes\n\n\n    if (axis.postProcessTickInterval) {\n      axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n    } // In column-like charts, don't cramp in more ticks than there are\n    // points (#1943, #4184)\n\n\n    if (axis.pointRange && !tickIntervalOption) {\n      axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);\n    } // Before normalizing the tick interval, handle minimum tick interval.\n    // This applies only if tickInterval is not defined.\n\n\n    minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n\n    if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n      axis.tickInterval = minTickInterval;\n    } // for linear axes, get magnitude and normalize the interval\n\n\n    if (!isDatetimeAxis && !isLog && !tickIntervalOption) {\n      axis.tickInterval = normalizeTickInterval(axis.tickInterval, null, getMagnitude(axis.tickInterval), // If the tick interval is between 0.5 and 5 and the axis max is\n      // in the order of thousands, chances are we are dealing with\n      // years. Don't allow decimals. #3363.\n      pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)), !!this.tickAmount);\n    } // Prevent ticks from getting so close that we can't draw the labels\n\n\n    if (!this.tickAmount) {\n      axis.tickInterval = axis.unsquish();\n    }\n\n    this.setTickPositions();\n  },\n\n  /**\n   * Now we have computed the normalized tickInterval, get the tick positions\n   *\n   * @function Highcharts.Axis#setTickPositions\n   *\n   * @fires Highcharts.Axis#event:afterSetTickPositions\n   */\n  setTickPositions: function () {\n    var options = this.options,\n        tickPositions,\n        tickPositionsOption = options.tickPositions,\n        minorTickIntervalOption = this.getMinorTickInterval(),\n        tickPositioner = options.tickPositioner,\n        startOnTick = options.startOnTick,\n        endOnTick = options.endOnTick; // Set the tickmarkOffset\n\n    this.tickmarkOffset = this.categories && options.tickmarkPlacement === 'between' && this.tickInterval === 1 ? 0.5 : 0; // #3202\n    // get minorTickInterval\n\n    this.minorTickInterval = minorTickIntervalOption === 'auto' && this.tickInterval ? this.tickInterval / 5 : minorTickIntervalOption; // When there is only one point, or all points have the same value on\n    // this axis, then min and max are equal and tickPositions.length is 0\n    // or 1. In this case, add some padding in order to center the point,\n    // but leave it with one tick. #1337.\n\n    this.single = this.min === this.max && defined(this.min) && !this.tickAmount && ( // Data is on integer (#6563)\n    parseInt(this.min, 10) === this.min || // Between integers and decimals are not allowed (#6274)\n    options.allowDecimals !== false); // Find the tick positions. Work on a copy (#1565)\n\n    this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice();\n\n    if (!tickPositions) {\n      // Too many ticks (#6405). Create a friendly warning and provide two\n      // ticks so at least we can show the data series.\n      if (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {\n        tickPositions = [this.min, this.max];\n        H.error(19);\n      } else if (this.isDatetimeAxis) {\n        tickPositions = this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, this.ordinalPositions, this.closestPointRange, true);\n      } else if (this.isLog) {\n        tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);\n      } else {\n        tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n      } // Too dense ticks, keep only the first and last (#4477)\n\n\n      if (tickPositions.length > this.len) {\n        tickPositions = [tickPositions[0], tickPositions.pop()]; // Reduce doubled value (#7339)\n\n        if (tickPositions[0] === tickPositions[1]) {\n          tickPositions.length = 1;\n        }\n      }\n\n      this.tickPositions = tickPositions; // Run the tick positioner callback, that allows modifying auto tick\n      // positions.\n\n      if (tickPositioner) {\n        tickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n\n        if (tickPositioner) {\n          this.tickPositions = tickPositions = tickPositioner;\n        }\n      }\n    } // Reset min/max or remove extremes based on start/end on tick\n\n\n    this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor\n\n    this.trimTicks(tickPositions, startOnTick, endOnTick);\n\n    if (!this.isLinked) {\n      // Substract half a unit (#2619, #2846, #2515, #3390),\n      // but not in case of multiple ticks (#6897)\n      if (this.single && tickPositions.length < 2) {\n        this.min -= 0.5;\n        this.max += 0.5;\n      }\n\n      if (!tickPositionsOption && !tickPositioner) {\n        this.adjustTickAmount();\n      }\n    }\n\n    fireEvent(this, 'afterSetTickPositions');\n  },\n\n  /**\n   * Handle startOnTick and endOnTick by either adapting to padding min/max or\n   * rounded min/max. Also handle single data points.\n   *\n   * @private\n   * @function Highcharts.Axis#trimTicks\n   *\n   * @param {Array<number>} tickPositions\n   *\n   * @param {boolean} startOnTicl\n   *\n   * @param {boolean} endOnTick\n   */\n  trimTicks: function (tickPositions, startOnTick, endOnTick) {\n    var roundedMin = tickPositions[0],\n        roundedMax = tickPositions[tickPositions.length - 1],\n        minPointOffset = this.minPointOffset || 0;\n\n    if (!this.isLinked) {\n      if (startOnTick && roundedMin !== -Infinity) {\n        // #6502\n        this.min = roundedMin;\n      } else {\n        while (this.min - minPointOffset > tickPositions[0]) {\n          tickPositions.shift();\n        }\n      }\n\n      if (endOnTick) {\n        this.max = roundedMax;\n      } else {\n        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {\n          tickPositions.pop();\n        }\n      } // If no tick are left, set one tick in the middle (#3195)\n\n\n      if (tickPositions.length === 0 && defined(roundedMin) && !this.options.tickPositions) {\n        tickPositions.push((roundedMax + roundedMin) / 2);\n      }\n    }\n  },\n\n  /**\n   * Check if there are multiple axes in the same pane.\n   *\n   * @private\n   * @function Highcharts.Axis#alignToOthers\n   *\n   * @return {boolean}\n   *         True if there are other axes.\n   */\n  alignToOthers: function () {\n    var others = {},\n        // Whether there is another axis to pair with this one\n    hasOther,\n        options = this.options;\n\n    if ( // Only if alignTicks is true\n    this.chart.options.chart.alignTicks !== false && options.alignTicks !== false && // Disabled when startOnTick or endOnTick are false (#7604)\n    options.startOnTick !== false && options.endOnTick !== false && // Don't try to align ticks on a log axis, they are not evenly\n    // spaced (#6021)\n    !this.isLog) {\n      each(this.chart[this.coll], function (axis) {\n        var otherOptions = axis.options,\n            horiz = axis.horiz,\n            key = [horiz ? otherOptions.left : otherOptions.top, otherOptions.width, otherOptions.height, otherOptions.pane].join(',');\n\n        if (axis.series.length) {\n          // #4442\n          if (others[key]) {\n            hasOther = true; // #4201\n          } else {\n            others[key] = 1;\n          }\n        }\n      });\n    }\n\n    return hasOther;\n  },\n\n  /**\n   * Find the max ticks of either the x and y axis collection, and record it\n   * in `this.tickAmount`.\n   *\n   * @private\n   * @function Highcharts.Axis#getTickAmount\n   */\n  getTickAmount: function () {\n    var options = this.options,\n        tickAmount = options.tickAmount,\n        tickPixelInterval = options.tickPixelInterval;\n\n    if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial && !this.isLog && options.startOnTick && options.endOnTick) {\n      tickAmount = 2;\n    }\n\n    if (!tickAmount && this.alignToOthers()) {\n      // Add 1 because 4 tick intervals require 5 ticks (including first\n      // and last)\n      tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;\n    } // For tick amounts of 2 and 3, compute five ticks and remove the\n    // intermediate ones. This prevents the axis from adding ticks that are\n    // too far away from the data extremes.\n\n\n    if (tickAmount < 4) {\n      this.finalTickAmt = tickAmount;\n      tickAmount = 5;\n    }\n\n    this.tickAmount = tickAmount;\n  },\n\n  /**\n   * When using multiple axes, adjust the number of ticks to match the highest\n   * number of ticks in that group.\n   *\n   * @private\n   * @function Highcharts.Axis#adjustTickAmount\n   */\n  adjustTickAmount: function () {\n    var tickInterval = this.tickInterval,\n        tickPositions = this.tickPositions,\n        tickAmount = this.tickAmount,\n        finalTickAmt = this.finalTickAmt,\n        currentTickAmount = tickPositions && tickPositions.length,\n        threshold = pick(this.threshold, this.softThreshold ? 0 : null),\n        i,\n        len;\n\n    if (this.hasData()) {\n      if (currentTickAmount < tickAmount) {\n        while (tickPositions.length < tickAmount) {\n          // Extend evenly for both sides unless we're on the\n          // threshold (#3965)\n          if (tickPositions.length % 2 || this.min === threshold) {\n            // to the end\n            tickPositions.push(correctFloat(tickPositions[tickPositions.length - 1] + tickInterval));\n          } else {\n            // to the start\n            tickPositions.unshift(correctFloat(tickPositions[0] - tickInterval));\n          }\n        }\n\n        this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n        this.min = tickPositions[0];\n        this.max = tickPositions[tickPositions.length - 1]; // We have too many ticks, run second pass to try to reduce ticks\n      } else if (currentTickAmount > tickAmount) {\n        this.tickInterval *= 2;\n        this.setTickPositions();\n      } // The finalTickAmt property is set in getTickAmount\n\n\n      if (defined(finalTickAmt)) {\n        i = len = tickPositions.length;\n\n        while (i--) {\n          if ( // Remove every other tick\n          finalTickAmt === 3 && i % 2 === 1 || // Remove all but first and last\n          finalTickAmt <= 2 && i > 0 && i < len - 1) {\n            tickPositions.splice(i, 1);\n          }\n        }\n\n        this.finalTickAmt = undefined;\n      }\n    }\n  },\n\n  /**\n   * Set the scale based on data min and max, user set min and max or options.\n   *\n   * @private\n   * @function Highcharts.Axis#setScale\n   *\n   * @fires Highcharts.Axis#event:afterSetScale\n   */\n  setScale: function () {\n    var axis = this,\n        isDirtyData,\n        isDirtyAxisLength;\n    axis.oldMin = axis.min;\n    axis.oldMax = axis.max;\n    axis.oldAxisLength = axis.len; // set the new axisLength\n\n    axis.setAxisSize();\n    isDirtyAxisLength = axis.len !== axis.oldAxisLength; // is there new data?\n\n    each(axis.series, function (series) {\n      if (series.isDirtyData || series.isDirty || // When x axis is dirty, we need new data extremes for y as well\n      series.xAxis.isDirty) {\n        isDirtyData = true;\n      }\n    }); // do we really need to go through all this?\n\n    if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw || axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {\n      if (axis.resetStacks) {\n        axis.resetStacks();\n      }\n\n      axis.forceRedraw = false; // get data extremes if needed\n\n      axis.getSeriesExtremes(); // get fixed positions based on tickInterval\n\n      axis.setTickInterval(); // record old values to decide whether a rescale is necessary later\n      // on (#540)\n\n      axis.oldUserMin = axis.userMin;\n      axis.oldUserMax = axis.userMax; // Mark as dirty if it is not already set to dirty and extremes have\n      // changed. #595.\n\n      if (!axis.isDirty) {\n        axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n      }\n    } else if (axis.cleanStacks) {\n      axis.cleanStacks();\n    }\n\n    fireEvent(this, 'afterSetScale');\n  },\n\n  /**\n   * Set the minimum and maximum of the axes after render time. If the\n   * `startOnTick` and `endOnTick` options are true, the minimum and maximum\n   * values are rounded off to the nearest tick. To prevent this, these\n   * options can be set to false before calling setExtremes. Also, setExtremes\n   * will not allow a range lower than the `minRange` option, which by default\n   * is the range of five points.\n   *\n   * @sample highcharts/members/axis-setextremes/\n   *         Set extremes from a button\n   * @sample highcharts/members/axis-setextremes-datetime/\n   *         Set extremes on a datetime axis\n   * @sample highcharts/members/axis-setextremes-off-ticks/\n   *         Set extremes off ticks\n   * @sample stock/members/axis-setextremes/\n   *         Set extremes in Highstock\n   * @sample maps/members/axis-setextremes/\n   *         Set extremes in Highmaps\n   *\n   * @function Highcharts.Axis#setExtremes\n   *\n   * @param {number} [newMin]\n   *        The new minimum value.\n   *\n   * @param {number} [newMax]\n   *        The new maximum value.\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart or wait for an explicit call to\n   *        {@link Highcharts.Chart#redraw}\n   *\n   * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]\n   *        Enable or modify animations.\n   *\n   * @param {*} [eventArguments]\n   *        Arguments to be accessed in event handler.\n   *\n   * @fires Highcharts.Axis#event:setExtremes\n   */\n  setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n    var axis = this,\n        chart = axis.chart;\n    redraw = pick(redraw, true); // defaults to true\n\n    each(axis.series, function (serie) {\n      delete serie.kdTree;\n    }); // Extend the arguments with min and max\n\n    eventArguments = extend(eventArguments, {\n      min: newMin,\n      max: newMax\n    }); // Fire the event\n\n    fireEvent(axis, 'setExtremes', eventArguments, function () {\n      axis.userMin = newMin;\n      axis.userMax = newMax;\n      axis.eventArgs = eventArguments;\n\n      if (redraw) {\n        chart.redraw(animation);\n      }\n    });\n  },\n\n  /**\n   * Overridable method for zooming chart. Pulled out in a separate method to\n   * allow overriding in stock charts.\n   *\n   * @private\n   * @function Highcharts.Axis#zoom\n   *\n   * @param {number} newMin\n   *\n   * @param {number} newMax\n   *\n   * @return {boolean}\n   */\n  zoom: function (newMin, newMax) {\n    var dataMin = this.dataMin,\n        dataMax = this.dataMax,\n        options = this.options,\n        min = Math.min(dataMin, pick(options.min, dataMin)),\n        max = Math.max(dataMax, pick(options.max, dataMax));\n\n    if (newMin !== this.min || newMax !== this.max) {\n      // #5790\n      // Prevent pinch zooming out of range. Check for defined is for\n      // #1946. #1734.\n      if (!this.allowZoomOutside) {\n        // #6014, sometimes newMax will be smaller than min (or newMin\n        // will be larger than max).\n        if (defined(dataMin)) {\n          if (newMin < min) {\n            newMin = min;\n          }\n\n          if (newMin > max) {\n            newMin = max;\n          }\n        }\n\n        if (defined(dataMax)) {\n          if (newMax < min) {\n            newMax = min;\n          }\n\n          if (newMax > max) {\n            newMax = max;\n          }\n        }\n      } // In full view, displaying the reset zoom button is not required\n\n\n      this.displayBtn = newMin !== undefined || newMax !== undefined; // Do it\n\n      this.setExtremes(newMin, newMax, false, undefined, {\n        trigger: 'zoom'\n      });\n    }\n\n    return true;\n  },\n\n  /**\n   * Update the axis metrics.\n   *\n   * @private\n   * @function Highcharts.Axis#setAxisSize\n   */\n  setAxisSize: function () {\n    var chart = this.chart,\n        options = this.options,\n        // [top, right, bottom, left]\n    offsets = options.offsets || [0, 0, 0, 0],\n        horiz = this.horiz,\n        // Check for percentage based input values. Rounding fixes problems\n    // with column overflow and plot line filtering (#4898, #4899)\n    width = this.width = Math.round(H.relativeLength(pick(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)),\n        height = this.height = Math.round(H.relativeLength(pick(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)),\n        top = this.top = Math.round(H.relativeLength(pick(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)),\n        left = this.left = Math.round(H.relativeLength(pick(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft)); // Expose basic values to use in Series object and navigator\n\n    this.bottom = chart.chartHeight - height - top;\n    this.right = chart.chartWidth - width - left; // Direction agnostic properties\n\n    this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905\n\n    this.pos = horiz ? left : top; // distance from SVG origin\n  },\n\n  /**\n   * Get the current extremes for the axis.\n   *\n   * @sample highcharts/members/axis-getextremes/\n   *         Report extremes by click on a button\n   * @sample maps/members/axis-getextremes/\n   *         Get extremes in Highmaps\n   *\n   * @function Highcharts.Axis#getExtremes\n   *\n   * @returns {Highcharts.ExtremesObject}\n   *          An object containing extremes information.\n   */\n  getExtremes: function () {\n    var axis = this,\n        isLog = axis.isLog;\n    return {\n      min: isLog ? correctFloat(axis.lin2log(axis.min)) : axis.min,\n      max: isLog ? correctFloat(axis.lin2log(axis.max)) : axis.max,\n      dataMin: axis.dataMin,\n      dataMax: axis.dataMax,\n      userMin: axis.userMin,\n      userMax: axis.userMax\n    };\n  },\n\n  /**\n   * Get the zero plane either based on zero or on the min or max value.\n   * Used in bar and area plots.\n   *\n   * @function Highcharts.Axis#getThreshold\n   *\n   * @param {number} threshold\n   *        The threshold in axis values.\n   *\n   * @return {number}\n   *         The translated threshold position in terms of pixels, and\n   *         corrected to stay within the axis bounds.\n   */\n  getThreshold: function (threshold) {\n    var axis = this,\n        isLog = axis.isLog,\n        realMin = isLog ? axis.lin2log(axis.min) : axis.min,\n        realMax = isLog ? axis.lin2log(axis.max) : axis.max;\n\n    if (threshold === null || threshold === -Infinity) {\n      threshold = realMin;\n    } else if (threshold === Infinity) {\n      threshold = realMax;\n    } else if (realMin > threshold) {\n      threshold = realMin;\n    } else if (realMax < threshold) {\n      threshold = realMax;\n    }\n\n    return axis.translate(threshold, 0, 1, 0, 1);\n  },\n\n  /**\n   * Compute auto alignment for the axis label based on which side the axis is\n   * on and the given rotation for the label.\n   *\n   * @private\n   * @function Highcharts.Axis#autoLabelAlign\n   *\n   * @param {number} rotation\n   *        The rotation in degrees as set by either the `rotation` or\n   *        `autoRotation` options.\n   *\n   * @return {string}\n   *         Can be `center`, `left` or `right`.\n   */\n  autoLabelAlign: function (rotation) {\n    var ret,\n        angle = (pick(rotation, 0) - this.side * 90 + 720) % 360;\n\n    if (angle > 15 && angle < 165) {\n      ret = 'right';\n    } else if (angle > 195 && angle < 345) {\n      ret = 'left';\n    } else {\n      ret = 'center';\n    }\n\n    return ret;\n  },\n\n  /**\n   * Get the tick length and width for the axis based on axis options.\n   *\n   * @private\n   * @function Highcharts.Axis#tickSize\n   *\n   * @param {string} prefix\n   *        'tick' or 'minorTick'\n   *\n   * @return {Array<number>}\n   *         An array of tickLength and tickWidth\n   */\n  tickSize: function (prefix) {\n    var options = this.options,\n        tickLength = options[prefix + 'Length'],\n        tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0 // X axis default 1\n    );\n\n    if (tickWidth && tickLength) {\n      // Negate the length\n      if (options[prefix + 'Position'] === 'inside') {\n        tickLength = -tickLength;\n      }\n\n      return [tickLength, tickWidth];\n    }\n  },\n\n  /**\n   * Return the size of the labels.\n   *\n   * @private\n   * @function Highcharts.Axis#labelMetrics\n   *\n   * @return {Highcharts.FontMetricsObject}\n   */\n  labelMetrics: function () {\n    var index = this.tickPositions && this.tickPositions[0] || 0;\n    return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[index] && this.ticks[index].label);\n  },\n\n  /**\n   * Prevent the ticks from getting so close we can't draw the labels. On a\n   * horizontal axis, this is handled by rotating the labels, removing ticks\n   * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.\n   *\n   * @private\n   * @function Highcharts.Axis#unsquish\n   *\n   * @return {number}\n   */\n  unsquish: function () {\n    var labelOptions = this.options.labels,\n        horiz = this.horiz,\n        tickInterval = this.tickInterval,\n        newTickInterval = tickInterval,\n        slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n        rotation,\n        rotationOption = labelOptions.rotation,\n        labelMetrics = this.labelMetrics(),\n        step,\n        bestScore = Number.MAX_VALUE,\n        autoRotation,\n        // Return the multiple of tickInterval that is needed to avoid\n    // collision\n    getStep = function (spaceNeeded) {\n      var step = spaceNeeded / (slotSize || 1);\n      step = step > 1 ? Math.ceil(step) : 1;\n      return correctFloat(step * tickInterval);\n    };\n\n    if (horiz) {\n      autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971\n      defined(rotationOption) ? [rotationOption] : slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation);\n\n      if (autoRotation) {\n        // Loop over the given autoRotation options, and determine\n        // which gives the best score. The best score is that with\n        // the lowest number of steps and a rotation closest\n        // to horizontal.\n        each(autoRotation, function (rot) {\n          var score;\n\n          if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {\n            // #3891\n            step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));\n            score = step + Math.abs(rot / 360);\n\n            if (score < bestScore) {\n              bestScore = score;\n              rotation = rot;\n              newTickInterval = step;\n            }\n          }\n        });\n      }\n    } else if (!labelOptions.step) {\n      // #4411\n      newTickInterval = getStep(labelMetrics.h);\n    }\n\n    this.autoRotation = autoRotation;\n    this.labelRotation = pick(rotation, rotationOption);\n    return newTickInterval;\n  },\n\n  /**\n   * Get the general slot width for labels/categories on this axis. This may\n   * change between the pre-render (from Axis.getOffset) and the final tick\n   * rendering and placement.\n   *\n   * @private\n   * @function Highcharts.Axis#getSlotWidth\n   *\n   * @param {*} [tick]\n   *        Optionally, calculate the slot width basing on tick label. It is\n   *        used in highcharts-3d module, where the slots has different widths\n   *        depending on perspective angles.\n   *\n   * @return {number}\n   *         The pixel width allocated to each axis label.\n   */\n  getSlotWidth: function () {\n    // #5086, #1580, #1931\n    var chart = this.chart,\n        horiz = this.horiz,\n        labelOptions = this.options.labels,\n        slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n        marginLeft = chart.margin[3];\n    return horiz && (labelOptions.step || 0) < 2 && !labelOptions.rotation && // #4415\n    (this.staggerLines || 1) * this.len / slotCount || !horiz && ( // #7028\n    labelOptions.style && parseInt(labelOptions.style.width, 10) || marginLeft && marginLeft - chart.spacing[3] || chart.chartWidth * 0.33);\n  },\n\n  /**\n   * Render the axis labels and determine whether ellipsis or rotation need\n   * to be applied.\n   *\n   * @private\n   * @function Highcharts.Axis#renderUnsquish\n   */\n  renderUnsquish: function () {\n    var chart = this.chart,\n        renderer = chart.renderer,\n        tickPositions = this.tickPositions,\n        ticks = this.ticks,\n        labelOptions = this.options.labels,\n        labelStyleOptions = labelOptions && labelOptions.style || {},\n        horiz = this.horiz,\n        slotWidth = this.getSlotWidth(),\n        innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),\n        attr = {},\n        labelMetrics = this.labelMetrics(),\n        textOverflowOption = labelOptions.style && labelOptions.style.textOverflow,\n        commonWidth,\n        commonTextOverflow,\n        maxLabelLength = 0,\n        label,\n        i,\n        pos; // Set rotation option unless it is \"auto\", like in gauges\n\n    if (!isString(labelOptions.rotation)) {\n      attr.rotation = labelOptions.rotation || 0; // #4443\n    } // Get the longest label length\n\n\n    each(tickPositions, function (tick) {\n      tick = ticks[tick];\n\n      if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {\n        maxLabelLength = tick.label.textPxLength;\n      }\n    });\n    this.maxLabelLength = maxLabelLength; // Handle auto rotation on horizontal axis\n\n    if (this.autoRotation) {\n      // Apply rotation only if the label is too wide for the slot, and\n      // the label is wider than its height.\n      if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {\n        attr.rotation = this.labelRotation;\n      } else {\n        this.labelRotation = 0;\n      } // Handle word-wrap or ellipsis on vertical axis\n\n    } else if (slotWidth) {\n      // For word-wrap or ellipsis\n      commonWidth = innerWidth;\n\n      if (!textOverflowOption) {\n        commonTextOverflow = 'clip'; // On vertical axis, only allow word wrap if there is room\n        // for more lines.\n\n        i = tickPositions.length;\n\n        while (!horiz && i--) {\n          pos = tickPositions[i];\n          label = ticks[pos].label;\n\n          if (label) {\n            // Reset ellipsis in order to get the correct\n            // bounding box (#4070)\n            if (label.styles && label.styles.textOverflow === 'ellipsis') {\n              label.css({\n                textOverflow: 'clip'\n              }); // Set the correct width in order to read\n              // the bounding box height (#4678, #5034)\n            } else if (label.textPxLength > slotWidth) {\n              label.css({\n                width: slotWidth + 'px'\n              });\n            }\n\n            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {\n              label.specificTextOverflow = 'ellipsis';\n            }\n          }\n        }\n      }\n    } // Add ellipsis if the label length is significantly longer than ideal\n\n\n    if (attr.rotation) {\n      commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;\n\n      if (!textOverflowOption) {\n        commonTextOverflow = 'ellipsis';\n      }\n    } // Set the explicit or automatic label alignment\n\n\n    this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n\n    if (this.labelAlign) {\n      attr.align = this.labelAlign;\n    } // Apply general and specific CSS\n\n\n    each(tickPositions, function (pos) {\n      var tick = ticks[pos],\n          label = tick && tick.label,\n          widthOption = labelStyleOptions.width,\n          css = {};\n\n      if (label) {\n        // This needs to go before the CSS in old IE (#4502)\n        label.attr(attr);\n\n        if (commonWidth && !widthOption && // Setting width in this case messes with the bounding box\n        // (#7975)\n        labelStyleOptions.whiteSpace !== 'nowrap' && ( // Speed optimizing, #7656\n        commonWidth < label.textPxLength || // Resetting CSS, #4928\n        label.element.tagName === 'SPAN')) {\n          css.width = commonWidth;\n\n          if (!textOverflowOption) {\n            css.textOverflow = label.specificTextOverflow || commonTextOverflow;\n          }\n\n          label.css(css); // Reset previously shortened label (#8210)\n        } else if (label.styles && label.styles.width && !css.width && !widthOption) {\n          label.css({\n            width: null\n          });\n        }\n\n        delete label.specificTextOverflow;\n        tick.rotation = attr.rotation;\n      }\n    }); // Note: Why is this not part of getLabelPosition?\n\n    this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n  },\n\n  /**\n   * Return true if the axis has associated data.\n   *\n   * @function Highcharts.Axis#hasData\n   *\n   * @return {boolean}\n   *         True if the axis has associated visible series and those series\n   *         have either valid data points or explicit `min` and `max`\n   *         settings.\n   */\n  hasData: function () {\n    return this.hasVisibleSeries || defined(this.min) && defined(this.max) && this.tickPositions && this.tickPositions.length > 0;\n  },\n\n  /**\n   * Adds the title defined in axis.options.title.\n   *\n   * @function Highcharts.Axis#addTitle\n   *\n   * @param {boolean} display\n   *        Whether or not to display the title.\n   */\n  addTitle: function (display) {\n    var axis = this,\n        renderer = axis.chart.renderer,\n        horiz = axis.horiz,\n        opposite = axis.opposite,\n        options = axis.options,\n        axisTitleOptions = options.title,\n        textAlign;\n\n    if (!axis.axisTitle) {\n      textAlign = axisTitleOptions.textAlign;\n\n      if (!textAlign) {\n        textAlign = (horiz ? {\n          low: 'left',\n          middle: 'center',\n          high: 'right'\n        } : {\n          low: opposite ? 'right' : 'left',\n          middle: 'center',\n          high: opposite ? 'left' : 'right'\n        })[axisTitleOptions.align];\n      }\n\n      axis.axisTitle = renderer.text(axisTitleOptions.text, 0, 0, axisTitleOptions.useHTML).attr({\n        zIndex: 7,\n        rotation: axisTitleOptions.rotation || 0,\n        align: textAlign\n      }).addClass('highcharts-axis-title').add(axis.axisGroup);\n      axis.axisTitle.isNew = true;\n    } // Max width defaults to the length of the axis\n\n\n    axis.axisTitle.css({\n      width: axis.len\n    }); // hide or show the title depending on whether showEmpty is set\n\n    axis.axisTitle[display ? 'show' : 'hide'](true);\n  },\n\n  /**\n   * Generates a tick for initial positioning.\n   *\n   * @private\n   * @function Highcharts.Axis#generateTick\n   *\n   * @param {number} pos\n   *        The tick position in axis values.\n   *\n   * @param {number} i\n   *        The index of the tick in {@link Axis.tickPositions}.\n   */\n  generateTick: function (pos) {\n    var ticks = this.ticks;\n\n    if (!ticks[pos]) {\n      ticks[pos] = new Tick(this, pos);\n    } else {\n      ticks[pos].addLabel(); // update labels depending on tick interval\n    }\n  },\n\n  /**\n   * Render the tick labels to a preliminary position to get their sizes.\n   *\n   * @private\n   * @function Highcharts.Axis#getOffset\n   *\n   * @fires Highcharts.Axis#event:afterGetOffset\n   */\n  getOffset: function () {\n    var axis = this,\n        chart = axis.chart,\n        renderer = chart.renderer,\n        options = axis.options,\n        tickPositions = axis.tickPositions,\n        ticks = axis.ticks,\n        horiz = axis.horiz,\n        side = axis.side,\n        invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side,\n        hasData,\n        showAxis,\n        titleOffset = 0,\n        titleOffsetOption,\n        titleMargin = 0,\n        axisTitleOptions = options.title,\n        labelOptions = options.labels,\n        labelOffset = 0,\n        // reset\n    labelOffsetPadded,\n        axisOffset = chart.axisOffset,\n        clipOffset = chart.clipOffset,\n        clip,\n        directionFactor = [-1, 1, 1, -1][side],\n        className = options.className,\n        axisParent = axis.axisParent,\n        // Used in color axis\n    lineHeightCorrection,\n        tickSize = this.tickSize('tick'); // For reuse in Axis.render\n\n    hasData = axis.hasData();\n    axis.showAxis = showAxis = hasData || pick(options.showEmpty, true); // Set/reset staggerLines\n\n    axis.staggerLines = axis.horiz && labelOptions.staggerLines; // Create the axisGroup and gridGroup elements on first iteration\n\n    if (!axis.axisGroup) {\n      axis.gridGroup = renderer.g('grid').attr({\n        zIndex: options.gridZIndex || 1\n      }).addClass('highcharts-' + this.coll.toLowerCase() + '-grid ' + (className || '')).add(axisParent);\n      axis.axisGroup = renderer.g('axis').attr({\n        zIndex: options.zIndex || 2\n      }).addClass('highcharts-' + this.coll.toLowerCase() + ' ' + (className || '')).add(axisParent);\n      axis.labelGroup = renderer.g('axis-labels').attr({\n        zIndex: labelOptions.zIndex || 7\n      }).addClass('highcharts-' + axis.coll.toLowerCase() + '-labels ' + (className || '')).add(axisParent);\n    }\n\n    if (hasData || axis.isLinked) {\n      // Generate ticks\n      each(tickPositions, function (pos, i) {\n        // i is not used here, but may be used in overrides\n        axis.generateTick(pos, i);\n      });\n      axis.renderUnsquish(); // Left side must be align: right and right side must\n      // have align: left for labels\n\n      axis.reserveSpaceDefault = side === 0 || side === 2 || {\n        1: 'left',\n        3: 'right'\n      }[side] === axis.labelAlign;\n\n      if (pick(labelOptions.reserveSpace, axis.labelAlign === 'center' ? true : null, axis.reserveSpaceDefault)) {\n        each(tickPositions, function (pos) {\n          // get the highest offset\n          labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);\n        });\n      }\n\n      if (axis.staggerLines) {\n        labelOffset *= axis.staggerLines;\n      }\n\n      axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n    } else {\n      // doesn't have data\n      objectEach(ticks, function (tick, n) {\n        tick.destroy();\n        delete ticks[n];\n      });\n    }\n\n    if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n      axis.addTitle(showAxis);\n\n      if (showAxis && axisTitleOptions.reserveSpace !== false) {\n        axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n        titleOffsetOption = axisTitleOptions.offset;\n        titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n      }\n    } // Render the axis line\n\n\n    axis.renderLine(); // handle automatic or user set offset\n\n    axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n    axis.tickRotCorr = axis.tickRotCorr || {\n      x: 0,\n      y: 0\n    }; // polar\n\n    if (side === 0) {\n      lineHeightCorrection = -axis.labelMetrics().h;\n    } else if (side === 2) {\n      lineHeightCorrection = axis.tickRotCorr.y;\n    } else {\n      lineHeightCorrection = 0;\n    } // Find the padded label offset\n\n\n    labelOffsetPadded = Math.abs(labelOffset) + titleMargin;\n\n    if (labelOffset) {\n      labelOffsetPadded -= lineHeightCorrection;\n      labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);\n    }\n\n    axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n    axisOffset[side] = Math.max(axisOffset[side], axis.axisTitleMargin + titleOffset + directionFactor * axis.offset, labelOffsetPadded, // #3027\n    hasData && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0 // #4866\n    ); // Decide the clipping needed to keep the graph inside\n    // the plot area and axis lines\n\n    clip = options.offset ? 0 : Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371\n\n    clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);\n    fireEvent(this, 'afterGetOffset');\n  },\n\n  /**\n   * Internal function to get the path for the axis line. Extended for polar\n   * charts.\n   *\n   * @function Highcharts.Axis#getLinePath\n   *\n   * @param {number} lineWidth\n   *        The line width in pixels.\n   *\n   * @return {Highcharts.SVGPathArray}\n   *         The SVG path definition in array form.\n   */\n  getLinePath: function (lineWidth) {\n    var chart = this.chart,\n        opposite = this.opposite,\n        offset = this.offset,\n        horiz = this.horiz,\n        lineLeft = this.left + (opposite ? this.width : 0) + offset,\n        lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n\n    if (opposite) {\n      lineWidth *= -1; // crispify the other way - #1480, #1687\n    }\n\n    return chart.renderer.crispLine(['M', horiz ? this.left : lineLeft, horiz ? lineTop : this.top, 'L', horiz ? chart.chartWidth - this.right : lineLeft, horiz ? lineTop : chart.chartHeight - this.bottom], lineWidth);\n  },\n\n  /**\n   * Render the axis line. Called internally when rendering and redrawing the\n   * axis.\n   *\n   * @function Highcharts.Axis#renderLine\n   */\n  renderLine: function () {\n    if (!this.axisLine) {\n      this.axisLine = this.chart.renderer.path().addClass('highcharts-axis-line').add(this.axisGroup);\n    }\n  },\n\n  /**\n   * Position the axis title.\n   *\n   * @private\n   * @function Highcharts.Axis#getTitlePosition\n   *\n   * @return {Highcharts.AxisTitlePositionObject}\n   *         X and Y positions for the title.\n   */\n  getTitlePosition: function () {\n    // compute anchor points for each of the title align options\n    var horiz = this.horiz,\n        axisLeft = this.left,\n        axisTop = this.top,\n        axisLength = this.len,\n        axisTitleOptions = this.options.title,\n        margin = horiz ? axisLeft : axisTop,\n        opposite = this.opposite,\n        offset = this.offset,\n        xOption = axisTitleOptions.x || 0,\n        yOption = axisTitleOptions.y || 0,\n        axisTitle = this.axisTitle,\n        fontMetrics = this.chart.renderer.fontMetrics(axisTitleOptions.style && axisTitleOptions.style.fontSize, axisTitle),\n        // The part of a multiline text that is below the baseline of the\n    // first line. Subtract 1 to preserve pixel-perfectness from the\n    // old behaviour (v5.0.12), where only one line was allowed.\n    textHeightOvershoot = Math.max(axisTitle.getBBox(null, 0).height - fontMetrics.h - 1, 0),\n        // the position in the length direction of the axis\n    alongAxis = {\n      low: margin + (horiz ? 0 : axisLength),\n      middle: margin + axisLength / 2,\n      high: margin + (horiz ? axisLength : 0)\n    }[axisTitleOptions.align],\n        // the position in the perpendicular direction of the axis\n    offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * ( // horizontal axis reverses the margin\n    opposite ? -1 : 1) * // so does opposite axes\n    this.axisTitleMargin + [-textHeightOvershoot, // top\n    textHeightOvershoot, // right\n    fontMetrics.f, // bottom\n    -textHeightOvershoot // left\n    ][this.side];\n    return {\n      x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,\n      y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption\n    };\n  },\n\n  /**\n   * Render a minor tick into the given position. If a minor tick already\n   * exists in this position, move it.\n   *\n   * @function Highcharts.Axis#renderMinorTick\n   *\n   * @param {number} pos\n   *        The position in axis values.\n   */\n  renderMinorTick: function (pos) {\n    var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),\n        minorTicks = this.minorTicks;\n\n    if (!minorTicks[pos]) {\n      minorTicks[pos] = new Tick(this, pos, 'minor');\n    } // Render new ticks in old position\n\n\n    if (slideInTicks && minorTicks[pos].isNew) {\n      minorTicks[pos].render(null, true);\n    }\n\n    minorTicks[pos].render(null, false, 1);\n  },\n\n  /**\n   * Render a major tick into the given position. If a tick already exists\n   * in this position, move it.\n   *\n   * @function Highcharts.Axis#renderTick\n   *\n   * @param {number} pos\n   *        The position in axis values.\n   *\n   * @param {number} i\n   *        The tick index.\n   */\n  renderTick: function (pos, i) {\n    var isLinked = this.isLinked,\n        ticks = this.ticks,\n        slideInTicks = this.chart.hasRendered && isNumber(this.oldMin); // Linked axes need an extra check to find out if\n\n    if (!isLinked || pos >= this.min && pos <= this.max) {\n      if (!ticks[pos]) {\n        ticks[pos] = new Tick(this, pos);\n      } // render new ticks in old position\n\n\n      if (slideInTicks && ticks[pos].isNew) {\n        ticks[pos].render(i, true, 0.1);\n      }\n\n      ticks[pos].render(i);\n    }\n  },\n\n  /**\n   * Render the axis.\n   *\n   * @private\n   * @function Highcharts.Axis#render\n   *\n   * @fires Highcharts.Axis#event:afterRender\n   */\n  render: function () {\n    var axis = this,\n        chart = axis.chart,\n        renderer = chart.renderer,\n        options = axis.options,\n        isLog = axis.isLog,\n        isLinked = axis.isLinked,\n        tickPositions = axis.tickPositions,\n        axisTitle = axis.axisTitle,\n        ticks = axis.ticks,\n        minorTicks = axis.minorTicks,\n        alternateBands = axis.alternateBands,\n        stackLabelOptions = options.stackLabels,\n        alternateGridColor = options.alternateGridColor,\n        tickmarkOffset = axis.tickmarkOffset,\n        axisLine = axis.axisLine,\n        showAxis = axis.showAxis,\n        animation = animObject(renderer.globalAnimation),\n        from,\n        to; // Reset\n\n    axis.labelEdge.length = 0;\n    axis.overlap = false; // Mark all elements inActive before we go over and mark the active ones\n\n    each([ticks, minorTicks, alternateBands], function (coll) {\n      objectEach(coll, function (tick) {\n        tick.isActive = false;\n      });\n    }); // If the series has data draw the ticks. Else only the line and title\n\n    if (axis.hasData() || isLinked) {\n      // minor ticks\n      if (axis.minorTickInterval && !axis.categories) {\n        each(axis.getMinorTickPositions(), function (pos) {\n          axis.renderMinorTick(pos);\n        });\n      } // Major ticks. Pull out the first item and render it last so that\n      // we can get the position of the neighbour label. #808.\n\n\n      if (tickPositions.length) {\n        // #1300\n        each(tickPositions, function (pos, i) {\n          axis.renderTick(pos, i);\n        }); // In a categorized axis, the tick marks are displayed\n        // between labels. So we need to add a tick mark and\n        // grid line at the left edge of the X axis.\n\n        if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n          if (!ticks[-1]) {\n            ticks[-1] = new Tick(axis, -1, null, true);\n          }\n\n          ticks[-1].render(-1);\n        }\n      } // alternate grid color\n\n\n      if (alternateGridColor) {\n        each(tickPositions, function (pos, i) {\n          to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;\n\n          if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {\n            // #2248, #4660\n            if (!alternateBands[pos]) {\n              alternateBands[pos] = new H.PlotLineOrBand(axis);\n            }\n\n            from = pos + tickmarkOffset; // #949\n\n            alternateBands[pos].options = {\n              from: isLog ? axis.lin2log(from) : from,\n              to: isLog ? axis.lin2log(to) : to,\n              color: alternateGridColor\n            };\n            alternateBands[pos].render();\n            alternateBands[pos].isActive = true;\n          }\n        });\n      } // custom plot lines and bands\n\n\n      if (!axis._addedPlotLB) {\n        // only first time\n        each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n          axis.addPlotBandOrLine(plotLineOptions);\n        });\n        axis._addedPlotLB = true;\n      }\n    } // end if hasData\n    // Remove inactive ticks\n\n\n    each([ticks, minorTicks, alternateBands], function (coll) {\n      var i,\n          forDestruction = [],\n          delay = animation.duration,\n          destroyInactiveItems = function () {\n        i = forDestruction.length;\n\n        while (i--) {\n          // When resizing rapidly, the same items\n          // may be destroyed in different timeouts,\n          // or the may be reactivated\n          if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n            coll[forDestruction[i]].destroy();\n            delete coll[forDestruction[i]];\n          }\n        }\n      };\n\n      objectEach(coll, function (tick, pos) {\n        if (!tick.isActive) {\n          // Render to zero opacity\n          tick.render(pos, false, 0);\n          tick.isActive = false;\n          forDestruction.push(pos);\n        }\n      }); // When the objects are finished fading out, destroy them\n\n      syncTimeout(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);\n    }); // Set the axis line path\n\n    if (axisLine) {\n      axisLine[axisLine.isPlaced ? 'animate' : 'attr']({\n        d: this.getLinePath(axisLine.strokeWidth())\n      });\n      axisLine.isPlaced = true; // Show or hide the line depending on options.showEmpty\n\n      axisLine[showAxis ? 'show' : 'hide'](true);\n    }\n\n    if (axisTitle && showAxis) {\n      var titleXy = axis.getTitlePosition();\n\n      if (isNumber(titleXy.y)) {\n        axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);\n        axisTitle.isNew = false;\n      } else {\n        axisTitle.attr('y', -9999);\n        axisTitle.isNew = true;\n      }\n    } // Stacked totals:\n\n\n    if (stackLabelOptions && stackLabelOptions.enabled) {\n      axis.renderStackTotals();\n    } // End stacked totals\n\n\n    axis.isDirty = false;\n    fireEvent(this, 'afterRender');\n  },\n\n  /**\n   * Redraw the axis to reflect changes in the data or axis extremes. Called\n   * internally from {@link Chart#redraw}.\n   *\n   * @private\n   * @function Highcharts.Axis#redraw\n   */\n  redraw: function () {\n    if (this.visible) {\n      // render the axis\n      this.render(); // move plot lines and bands\n\n      each(this.plotLinesAndBands, function (plotLine) {\n        plotLine.render();\n      });\n    } // mark associated series as dirty and ready for redraw\n\n\n    each(this.series, function (series) {\n      series.isDirty = true;\n    });\n  },\n  // Properties to survive after destroy, needed for Axis.update (#4317,\n  // #5773, #5881).\n  keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],\n\n  /**\n   * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint\n   * to fully remove the axis.\n   *\n   * @private\n   * @function Highcharts.Axis#destroy\n   *\n   * @param {boolean} keepEvents\n   *        Whether to preserve events, used internally in Axis.update.\n   */\n  destroy: function (keepEvents) {\n    var axis = this,\n        stacks = axis.stacks,\n        plotLinesAndBands = axis.plotLinesAndBands,\n        plotGroup,\n        i;\n    fireEvent(this, 'destroy', {\n      keepEvents: keepEvents\n    }); // Remove the events\n\n    if (!keepEvents) {\n      removeEvent(axis);\n    } // Destroy each stack total\n\n\n    objectEach(stacks, function (stack, stackKey) {\n      destroyObjectProperties(stack);\n      stacks[stackKey] = null;\n    }); // Destroy collections\n\n    each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {\n      destroyObjectProperties(coll);\n    });\n\n    if (plotLinesAndBands) {\n      i = plotLinesAndBands.length;\n\n      while (i--) {\n        // #1975\n        plotLinesAndBands[i].destroy();\n      }\n    } // Destroy elements\n\n\n    each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross', 'scrollbar'], function (prop) {\n      if (axis[prop]) {\n        axis[prop] = axis[prop].destroy();\n      }\n    }); // Destroy each generated group for plotlines and plotbands\n\n    for (plotGroup in axis.plotLinesAndBandsGroups) {\n      axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();\n    } // Delete all properties and fall back to the prototype.\n\n\n    objectEach(axis, function (val, key) {\n      if (inArray(key, axis.keepProps) === -1) {\n        delete axis[key];\n      }\n    });\n  },\n\n  /**\n   * Internal function to draw a crosshair.\n   *\n   * @function Highcharts.Axis#drawCrosshair\n   *\n   * @param {Highcharts.PointerEventObject} [e]\n   *        The event arguments from the modified pointer event, extended with\n   *        `chartX` and `chartY`\n   *\n   * @param {Highcharts.Point} [point]\n   *        The Point object if the crosshair snaps to points.\n   *\n   * @fires Highcharts.Axis#event:afterDrawCrosshair\n   * @fires Highcharts.Axis#event:drawCrosshair\n   */\n  drawCrosshair: function (e, point) {\n    var path,\n        options = this.crosshair,\n        snap = pick(options.snap, true),\n        pos,\n        categorized,\n        graphic = this.cross;\n    fireEvent(this, 'drawCrosshair', {\n      e: e,\n      point: point\n    }); // Use last available event when updating non-snapped crosshairs without\n    // mouse interaction (#5287)\n\n    if (!e) {\n      e = this.cross && this.cross.e;\n    }\n\n    if ( // Disabled in options\n    !this.crosshair || // Snap\n    (defined(point) || !snap) === false) {\n      this.hideCrosshair();\n    } else {\n      // Get the path\n      if (!snap) {\n        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n      } else if (defined(point)) {\n        // #3834\n        pos = pick(point.crosshairPos, // 3D axis extension\n        this.isXAxis ? point.plotX : this.len - point.plotY);\n      }\n\n      if (defined(pos)) {\n        path = this.getPlotLinePath( // First argument, value, only used on radial\n        point && (this.isXAxis ? point.x : pick(point.stackY, point.y)), null, null, null, pos // Translated position\n        ) || null; // #3189\n      }\n\n      if (!defined(path)) {\n        this.hideCrosshair();\n        return;\n      }\n\n      categorized = this.categories && !this.isRadial; // Draw the cross\n\n      if (!graphic) {\n        this.cross = graphic = this.chart.renderer.path().addClass('highcharts-crosshair highcharts-crosshair-' + (categorized ? 'category ' : 'thin ') + options.className).attr({\n          zIndex: pick(options.zIndex, 2)\n        }).add();\n      }\n\n      graphic.show().attr({\n        d: path\n      });\n\n      if (categorized && !options.width) {\n        graphic.attr({\n          'stroke-width': this.transA\n        });\n      }\n\n      this.cross.e = e;\n    }\n\n    fireEvent(this, 'afterDrawCrosshair', {\n      e: e,\n      point: point\n    });\n  },\n\n  /**\n   * Hide the crosshair if visible.\n   *\n   * @function Highcharts.Axis#hideCrosshair\n   */\n  hideCrosshair: function () {\n    if (this.cross) {\n      this.cross.hide();\n    }\n  }\n}); // end Axis\n\nH.Axis = Axis;\nexport default Axis;"
    },
    {
     "id": 246,
     "name": "../node_modules/highcharts/js/es-modules/parts/Point.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Configuration hash for the data label and tooltip formatters.\n *\n * @typedef Highcharts.PointLabelObject\n *\n * @property {number|string} x\n *           For categorized axes this property holds the category name for the\n *           point. For other axes it holds the X value.\n *\n * @property {number} [y]\n *           The y value of the point.\n *\n * @property {Highcharts.ColorString} color\n *           The point's current color.\n *\n * @property {number} colorIndex\n *           The point's current color index, used in styled mode instead of\n *           `color`. The color index is inserted in class names used for\n *           styling.\n *\n * @property {number|string} key\n *           The name of the related point.\n *\n * @property {Highcharts.Series} series\n *           The related series.\n *\n * @property {Highcharts.Point} point\n *           The related point.\n *\n * @property {number} percentage\n *           The percentage for related points in a stacked series or pies.\n *\n * @property {number} total\n *           The total of values in either a stack for stacked series, or a pie\n *           in a pie series.\n */\n'use strict';\n\nimport Highcharts from './Globals.js';\nimport './Utilities.js';\nvar Point,\n    H = Highcharts,\n    each = H.each,\n    extend = H.extend,\n    erase = H.erase,\n    fireEvent = H.fireEvent,\n    format = H.format,\n    isArray = H.isArray,\n    isNumber = H.isNumber,\n    pick = H.pick,\n    removeEvent = H.removeEvent;\n/**\n * The Point object. The point objects are generated from the `series.data`\n * configuration objects or raw numbers. They can be accessed from the\n * `Series.points` array. Other ways to instantiate points are through {@link\n * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.\n *\n * @class\n * @name Highcharts.Point\n */\n\nHighcharts.Point = Point = function () {};\n\nHighcharts.Point.prototype = {\n  /**\n   * Initialize the point. Called internally based on the `series.data`\n   * option.\n   *\n   * @function Highcharts.Point#init\n   *\n   * @param {Highcharts.Series} series\n   *        The series object containing this point.\n   *\n   * @param {number|Array<number>|*} options\n   *        The data in either number, array or object format.\n   *\n   * @param {number} x\n   *        Optionally, the X value of the point.\n   *\n   * @return {Highcharts.Point}\n   *         The Point instance.\n   *\n   * @fires Highcharts.Point#event:afterInit\n   */\n  init: function (series, options, x) {\n    var point = this,\n        colors,\n        colorCount = series.chart.options.chart.colorCount,\n        colorIndex;\n    /**\n     * The series object associated with the point.\n     *\n     * @name Highcharts.Point#series\n     * @type {Highcharts.Series}\n     */\n\n    point.series = series;\n    point.applyOptions(options, x);\n\n    if (series.options.colorByPoint) {\n      colorIndex = series.colorCounter;\n      series.colorCounter++; // loop back to zero\n\n      if (series.colorCounter === colorCount) {\n        series.colorCounter = 0;\n      }\n    } else {\n      colorIndex = series.colorIndex;\n    }\n    /**\n     * The point's current color index, used in styled mode instead of\n     * `color`. The color index is inserted in class names used for styling.\n     *\n     * @name Highcharts.Point#colorIndex\n     * @type {number}\n     */\n\n\n    point.colorIndex = pick(point.colorIndex, colorIndex);\n    series.chart.pointCount++;\n    fireEvent(point, 'afterInit');\n    return point;\n  },\n\n  /**\n   * Apply the options containing the x and y data and possible some extra\n   * properties. Called on point init or from point.update.\n   *\n   * @private\n   * @function Highcharts.Point#applyOptions\n   *\n   * @param {*} options\n   *        The point options as defined in series.data.\n   *\n   * @param {number} x\n   *        Optionally, the x value.\n   *\n   * @return {Highcharts.Point}\n   *         The Point instance.\n   */\n  applyOptions: function (options, x) {\n    var point = this,\n        series = point.series,\n        pointValKey = series.options.pointValKey || series.pointValKey;\n    options = Point.prototype.optionsToObject.call(this, options); // copy options directly to point\n\n    extend(point, options);\n    /**\n     * The point's options as applied in the initial configuration, or\n     * extended through `Point.update`.\n     *\n     * @name Highcharts.Point#options\n     * @type {*}\n     */\n\n    point.options = point.options ? extend(point.options, options) : options; // Since options are copied into the Point instance, some accidental\n    // options must be shielded (#5681)\n\n    if (options.group) {\n      delete point.group;\n    }\n    /**\n     * The y value of the point.\n     *\n     * @name Highcharts.Point#y\n     * @type {number|undefined}\n     */\n    // For higher dimension series types. For instance, for ranges, point.y\n    // is mapped to point.low.\n\n\n    if (pointValKey) {\n      point.y = point[pointValKey];\n    }\n\n    point.isNull = pick(point.isValid && !point.isValid(), point.x === null || !isNumber(point.y, true)); // #3571, check for NaN\n    // The point is initially selected by options (#5777)\n\n    if (point.selected) {\n      point.state = 'select';\n    }\n    /**\n     * The x value of the point.\n     *\n     * @name Highcharts.Point#x\n     * @type {number}\n     */\n    // If no x is set by now, get auto incremented value. All points must\n    // have an x value, however the y value can be null to create a gap in\n    // the series\n\n\n    if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {\n      point.x = series.xAxis.nameToX(point);\n    }\n\n    if (point.x === undefined && series) {\n      if (x === undefined) {\n        point.x = series.autoIncrement(point);\n      } else {\n        point.x = x;\n      }\n    }\n\n    return point;\n  },\n\n  /**\n   * Set a value in an object, on the property defined by key. The key\n   * supports nested properties using dot notation. The function modifies the\n   * input object and does not make a copy.\n   *\n   * @function Highcharts.Point#setNestedProperty\n   *\n   * @param {*} object\n   *        The object to set the value on.\n   *\n   * @param {*} value\n   *        The value to set.\n   *\n   * @param {string} key\n   *        Key to the property to set.\n   *\n   * @return {*}\n   *         The modified object.\n   */\n  setNestedProperty: function (object, value, key) {\n    var nestedKeys = key.split('.');\n    H.reduce(nestedKeys, function (result, key, i, arr) {\n      var isLastKey = arr.length - 1 === i;\n      result[key] = isLastKey ? value : H.isObject(result[key], true) ? result[key] : {};\n      return result[key];\n    }, object);\n    return object;\n  },\n\n  /**\n   * Transform number or array configs into objects. Used internally to unify\n   * the different configuration formats for points. For example, a simple\n   * number `10` in a line series will be transformed to `{ y: 10 }`, and an\n   * array config like `[1, 10]` in a scatter series will be transformed to\n   * `{ x: 1, y: 10 }`.\n   *\n   * @function Highcharts.Point#optionsToObject\n   *\n   * @param {number|Array<number>|*} options\n   *        The input option.\n   *\n   * @return {*}\n   *         Transformed options.\n   */\n  optionsToObject: function (options) {\n    var ret = {},\n        series = this.series,\n        keys = series.options.keys,\n        pointArrayMap = keys || series.pointArrayMap || ['y'],\n        valueCount = pointArrayMap.length,\n        firstItemType,\n        i = 0,\n        j = 0;\n\n    if (isNumber(options) || options === null) {\n      ret[pointArrayMap[0]] = options;\n    } else if (isArray(options)) {\n      // with leading x value\n      if (!keys && options.length > valueCount) {\n        firstItemType = typeof options[0];\n\n        if (firstItemType === 'string') {\n          ret.name = options[0];\n        } else if (firstItemType === 'number') {\n          ret.x = options[0];\n        }\n\n        i++;\n      }\n\n      while (j < valueCount) {\n        // Skip undefined positions for keys\n        if (!keys || options[i] !== undefined) {\n          if (pointArrayMap[j].indexOf('.') > 0) {\n            // Handle nested keys, e.g. ['color.pattern.image']\n            // Avoid function call unless necessary.\n            H.Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);\n          } else {\n            ret[pointArrayMap[j]] = options[i];\n          }\n        }\n\n        i++;\n        j++;\n      }\n    } else if (typeof options === 'object') {\n      ret = options; // This is the fastest way to detect if there are individual point\n      // dataLabels that need to be considered in drawDataLabels. These\n      // can only occur in object configs.\n\n      if (options.dataLabels) {\n        series._hasPointLabels = true;\n      } // Same approach as above for markers\n\n\n      if (options.marker) {\n        series._hasPointMarkers = true;\n      }\n    }\n\n    return ret;\n  },\n\n  /**\n   * Get the CSS class names for individual points. Used internally where the\n   * returned value is set on every point.\n   *\n   * @function Highcharts.Point#getClassName\n   *\n   * @return {string}\n   *         The class names.\n   */\n  getClassName: function () {\n    return 'highcharts-point' + (this.selected ? ' highcharts-point-select' : '') + (this.negative ? ' highcharts-negative' : '') + (this.isNull ? ' highcharts-null-point' : '') + (this.colorIndex !== undefined ? ' highcharts-color-' + this.colorIndex : '') + (this.options.className ? ' ' + this.options.className : '') + (this.zone && this.zone.className ? ' ' + this.zone.className.replace('highcharts-negative', '') : '');\n  },\n\n  /**\n   * In a series with `zones`, return the zone that the point belongs to.\n   *\n   * @function Highcharts.Point#getZone\n   *\n   * @return {Highcharts.PlotSeriesZonesOptions}\n   *         The zone item.\n   */\n  getZone: function () {\n    var series = this.series,\n        zones = series.zones,\n        zoneAxis = series.zoneAxis || 'y',\n        i = 0,\n        zone;\n    zone = zones[i];\n\n    while (this[zoneAxis] >= zone.value) {\n      zone = zones[++i];\n    } // For resetting or reusing the point (#8100)\n\n\n    if (!this.nonZonedColor) {\n      this.nonZonedColor = this.color;\n    }\n\n    if (zone && zone.color && !this.options.color) {\n      this.color = zone.color;\n    } else {\n      this.color = this.nonZonedColor;\n    }\n\n    return zone;\n  },\n\n  /**\n   * Destroy a point to clear memory. Its reference still stays in\n   * `series.data`.\n   *\n   * @private\n   * @function Highcharts.Point#destroy\n   */\n  destroy: function () {\n    var point = this,\n        series = point.series,\n        chart = series.chart,\n        hoverPoints = chart.hoverPoints,\n        prop;\n    chart.pointCount--;\n\n    if (hoverPoints) {\n      point.setState();\n      erase(hoverPoints, point);\n\n      if (!hoverPoints.length) {\n        chart.hoverPoints = null;\n      }\n    }\n\n    if (point === chart.hoverPoint) {\n      point.onMouseOut();\n    } // Remove all events\n\n\n    if (point.graphic || point.dataLabel) {\n      removeEvent(point);\n      point.destroyElements();\n    }\n\n    if (point.legendItem) {\n      // pies have legend items\n      chart.legend.destroyItem(point);\n    }\n\n    for (prop in point) {\n      point[prop] = null;\n    }\n  },\n\n  /**\n   * Destroy SVG elements associated with the point.\n   *\n   * @private\n   * @function Highcharts.Point#destroyElements\n   */\n  destroyElements: function () {\n    var point = this,\n        props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],\n        prop,\n        i = 6;\n\n    while (i--) {\n      prop = props[i];\n\n      if (point[prop]) {\n        point[prop] = point[prop].destroy();\n      }\n    }\n  },\n\n  /**\n   * Return the configuration hash needed for the data label and tooltip\n   * formatters.\n   *\n   * @function Highcharts.Point#getLabelConfig\n   *\n   * @return {Highcharts.PointLabelObject}\n   *         Abstract object used in formatters and formats.\n   */\n  getLabelConfig: function () {\n    return {\n      x: this.category,\n      y: this.y,\n      color: this.color,\n      colorIndex: this.colorIndex,\n      key: this.name || this.category,\n      series: this.series,\n      point: this,\n      percentage: this.percentage,\n      total: this.total || this.stackTotal\n    };\n  },\n\n  /**\n   * Extendable method for formatting each point's tooltip line.\n   *\n   * @function Highcharts.Point#tooltipFormatter\n   *\n   * @param {string} pointFormat\n   *        The point format.\n   *\n   * @return {string}\n   *         A string to be concatenated in to the common tooltip text.\n   */\n  tooltipFormatter: function (pointFormat) {\n    // Insert options for valueDecimals, valuePrefix, and valueSuffix\n    var series = this.series,\n        seriesTooltipOptions = series.tooltipOptions,\n        valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n        valuePrefix = seriesTooltipOptions.valuePrefix || '',\n        valueSuffix = seriesTooltipOptions.valueSuffix || ''; // Loop over the point array map and replace unformatted values with\n    // sprintf formatting markup\n\n    each(series.pointArrayMap || ['y'], function (key) {\n      key = '{point.' + key; // without the closing bracket\n\n      if (valuePrefix || valueSuffix) {\n        pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), valuePrefix + key + '}' + valueSuffix);\n      }\n\n      pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), key + ':,.' + valueDecimals + 'f}');\n    });\n    return format(pointFormat, {\n      point: this,\n      series: this.series\n    }, series.chart.time);\n  },\n\n  /**\n   * Fire an event on the Point object.\n   *\n   * @private\n   * @function Highcharts.Point#firePointEvent\n   *\n   * @param {string} eventType\n   *        Type of the event.\n   *\n   * @param {*} eventArgs\n   *        Additional event arguments.\n   *\n   * @param {Function} defaultFunction\n   *        Default event handler.\n   *\n   * @fires Highcharts.Point#event:*\n   */\n  firePointEvent: function (eventType, eventArgs, defaultFunction) {\n    var point = this,\n        series = this.series,\n        seriesOptions = series.options; // load event handlers on demand to save time on mouseover/out\n\n    if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {\n      this.importEvents();\n    } // add default handler if in selection mode\n\n\n    if (eventType === 'click' && seriesOptions.allowPointSelect) {\n      defaultFunction = function (event) {\n        // Control key is for Windows, meta (= Cmd key) for Mac, Shift\n        // for Opera.\n        if (point.select) {\n          // #2911\n          point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n        }\n      };\n    }\n\n    fireEvent(this, eventType, eventArgs, defaultFunction);\n  },\n\n  /**\n   * For certain series types, like pie charts, where individual points can\n   * be shown or hidden.\n   *\n   * @name Highcharts.Point#visible\n   * @type {boolean}\n   */\n  visible: true\n};\n/**\n * For categorized axes this property holds the category name for the\n * point. For other axes it holds the X value.\n *\n * @name Highcharts.Point#category\n * @type {number|string}\n */\n\n/**\n * The name of the point. The name can be given as the first position of the\n * point configuration array, or as a `name` property in the configuration:\n *\n * @example\n * // Array config\n * data: [\n *     ['John', 1],\n *     ['Jane', 2]\n * ]\n *\n * // Object config\n * data: [{\n *        name: 'John',\n *        y: 1\n * }, {\n *     name: 'Jane',\n *     y: 2\n * }]\n *\n * @name Highcharts.Point#name\n * @type {string}\n */\n\n/**\n * The percentage for points in a stacked series or pies.\n *\n * @name Highcharts.Point#percentage\n * @type {number}\n */\n\n/**\n * The total of values in either a stack for stacked series, or a pie in a pie\n * series.\n *\n * @name Highcharts.Point#total\n * @type {number}\n */"
    },
    {
     "id": 248,
     "name": "../node_modules/highcharts/js/es-modules/parts/Color.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * A valid color to be parsed and handled by Highcharts. Highcharts internally\n * supports hex colors like `#ffffff`, rgb colors like `rgb(255,255,255)` and\n * rgba colors like `rgba(255,255,255,1)`. Other colors may be supported by the\n * browsers and displayed correctly, but Highcharts is not able to process them\n * and apply concepts like opacity and brightening.\n *\n * @typedef {string} Highcharts.ColorString\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nvar each = H.each,\n    isNumber = H.isNumber,\n    map = H.map,\n    merge = H.merge,\n    pInt = H.pInt;\n/**\n * Handle color operations. The object methods are chainable.\n *\n * @ignore\n * @class Highcharts.Color\n *\n * @param {Highcharts.ColorString} input\n *        The input color in either rbga or hex format\n */\n\nH.Color = function (input) {\n  // Backwards compatibility, allow instanciation without new\n  if (!(this instanceof H.Color)) {\n    return new H.Color(input);\n  } // Initialize\n\n\n  this.init(input);\n};\n\nH.Color.prototype = {\n  // Collection of parsers. This can be extended from the outside by pushing\n  // parsers to Highcharts.Color.prototype.parsers.\n  parsers: [{\n    // RGBA color\n    regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n    // eslint-disable-line security/detect-unsafe-regex\n    parse: function (result) {\n      return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n    }\n  }, {\n    // RGB color\n    regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n    parse: function (result) {\n      return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n    }\n  }],\n  // Collection of named colors. Can be extended from the outside by adding\n  // colors to Highcharts.Color.prototype.names.\n  names: {\n    white: '#ffffff',\n    black: '#000000'\n  },\n\n  /**\n   * Parse the input color to rgba array\n   *\n   * @private\n   * @function Highcharts.Color#init\n   *\n   * @param  {Highcharts.ColorString} input\n   *         The input color in either rbga or hex format\n   *\n   * @return {void}\n   */\n  init: function (input) {\n    var result, rgba, i, parser, len;\n    this.input = input = this.names[input && input.toLowerCase ? input.toLowerCase() : ''] || input; // Gradients\n\n    if (input && input.stops) {\n      this.stops = map(input.stops, function (stop) {\n        return new H.Color(stop[1]);\n      }); // Solid colors\n    } else {\n      // Bitmasking as input[0] is not working for legacy IE.\n      if (input && input.charAt && input.charAt() === '#') {\n        len = input.length;\n        input = parseInt(input.substr(1), 16); // Handle long-form, e.g. #AABBCC\n\n        if (len === 7) {\n          rgba = [(input & 0xFF0000) >> 16, (input & 0xFF00) >> 8, input & 0xFF, 1]; // Handle short-form, e.g. #ABC\n          // In short form, the value is assumed to be the same\n          // for both nibbles for each component. e.g. #ABC = #AABBCC\n        } else if (len === 4) {\n          rgba = [(input & 0xF00) >> 4 | (input & 0xF00) >> 8, (input & 0xF0) >> 4 | input & 0xF0, (input & 0xF) << 4 | input & 0xF, 1];\n        }\n      } // Otherwise, check regex parsers\n\n\n      if (!rgba) {\n        i = this.parsers.length;\n\n        while (i-- && !rgba) {\n          parser = this.parsers[i];\n          result = parser.regex.exec(input);\n\n          if (result) {\n            rgba = parser.parse(result);\n          }\n        }\n      }\n    }\n\n    this.rgba = rgba || [];\n  },\n\n  /**\n   * Return the color in the specified format\n   *\n   * @function Highcharts.Color#get\n   *\n   * @param  {string} format\n   *         Possible values are 'a', 'rgb', undefined\n   *\n   * @return {Highcharts.ColorString}\n   *         This color as a string.\n   */\n  get: function (format) {\n    var input = this.input,\n        rgba = this.rgba,\n        ret;\n\n    if (this.stops) {\n      ret = merge(input);\n      ret.stops = [].concat(ret.stops);\n      each(this.stops, function (stop, i) {\n        ret.stops[i] = [ret.stops[i][0], stop.get(format)];\n      }); // it's NaN if gradient colors on a column chart\n    } else if (rgba && isNumber(rgba[0])) {\n      if (format === 'rgb' || !format && rgba[3] === 1) {\n        ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n      } else if (format === 'a') {\n        ret = rgba[3];\n      } else {\n        ret = 'rgba(' + rgba.join(',') + ')';\n      }\n    } else {\n      ret = input;\n    }\n\n    return ret;\n  },\n\n  /**\n   * Brighten the color instance.\n   *\n   * @function Highcharts.Color#brighten\n   *\n   * @param  {number} alpha\n   *         The alpha value.\n   *\n   * @return {Highcharts.ColorString}\n   *         This color with modifications.\n   */\n  brighten: function (alpha) {\n    var i,\n        rgba = this.rgba;\n\n    if (this.stops) {\n      each(this.stops, function (stop) {\n        stop.brighten(alpha);\n      });\n    } else if (isNumber(alpha) && alpha !== 0) {\n      for (i = 0; i < 3; i++) {\n        rgba[i] += pInt(alpha * 255);\n\n        if (rgba[i] < 0) {\n          rgba[i] = 0;\n        }\n\n        if (rgba[i] > 255) {\n          rgba[i] = 255;\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Set the color's opacity to a given alpha value.\n   *\n   * @function Highcharts.Color#setOpacity\n   *\n   * @param  {number} alpha\n   *         Opacity between 0 and 1.\n   *\n   * @return {Highcharts.ColorString}\n   *         Color with modifications.\n   */\n  setOpacity: function (alpha) {\n    this.rgba[3] = alpha;\n    return this;\n  },\n\n  /**\n   * Return an intermediate color between two colors.\n   *\n   * @function Highcharts.Color#tweenTo\n   *\n   * @param  {Highcharts.Color} to\n   *         The color object to tween to.\n   *\n   * @param  {number} pos\n   *         The intermediate position, where 0 is the from color (current\n   *         color item), and 1 is the `to` color.\n   *\n   * @return {Highcharts.ColorString}\n   *         The intermediate color in rgba notation.\n   */\n  tweenTo: function (to, pos) {\n    // Check for has alpha, because rgba colors perform worse due to lack of\n    // support in WebKit.\n    var fromRgba = this.rgba,\n        toRgba = to.rgba,\n        hasAlpha,\n        ret; // Unsupported color, return to-color (#3920, #7034)\n\n    if (!toRgba.length || !fromRgba || !fromRgba.length) {\n      ret = to.input || 'none'; // Interpolate\n    } else {\n      hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1;\n      ret = (hasAlpha ? 'rgba(' : 'rgb(') + Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) + ',' + Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) + ',' + Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) + (hasAlpha ? ',' + (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos)) : '') + ')';\n    }\n\n    return ret;\n  }\n};\n\nH.color = function (input) {\n  return new H.Color(input);\n};"
    },
    {
     "id": 249,
     "name": "../node_modules/highcharts/js/es-modules/parts/Legend.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport Highcharts from './Globals.js';\nimport './Utilities.js';\nvar H = Highcharts,\n    addEvent = H.addEvent,\n    css = H.css,\n    discardElement = H.discardElement,\n    defined = H.defined,\n    each = H.each,\n    fireEvent = H.fireEvent,\n    isFirefox = H.isFirefox,\n    marginNames = H.marginNames,\n    merge = H.merge,\n    pick = H.pick,\n    setAnimation = H.setAnimation,\n    stableSort = H.stableSort,\n    win = H.win,\n    wrap = H.wrap;\n/**\n * The overview of the chart's series. The legend object is instanciated\n * internally in the chart constructor, and is available from the `chart.legend`\n * property. Each chart has only one legend.\n *\n * @class\n * @name Highcharts.Legend\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @param {Highcharts.LegendOptions} options\n *        Legend options.\n */\n\nHighcharts.Legend = function (chart, options) {\n  this.init(chart, options);\n};\n\nHighcharts.Legend.prototype = {\n  /**\n   * Initialize the legend.\n   *\n   * @private\n   * @function Highcharts.Legend#init\n   *\n   * @param {Highcharts.Chart} chart\n   *        The chart instance.\n   *\n   * @param {Highcharts.LegendOptions} options\n   *        Legend options.\n   */\n  init: function (chart, options) {\n    /**\n     * Chart of this legend.\n     *\n     * @readonly\n     * @name Highcharts.Legend#chart\n     * @type {Highcharts.Chart}\n     */\n    this.chart = chart;\n    this.setOptions(options);\n\n    if (options.enabled) {\n      // Render it\n      this.render(); // move checkboxes\n\n      addEvent(this.chart, 'endResize', function () {\n        this.legend.positionCheckboxes();\n      });\n\n      if (this.proximate) {\n        this.unchartrender = addEvent(this.chart, 'render', function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        });\n      } else if (this.unchartrender) {\n        this.unchartrender();\n      }\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Legend#setOptions\n   *\n   * @param {Highcharts.LegendOptions} options\n   */\n  setOptions: function (options) {\n    var padding = pick(options.padding, 8);\n    /**\n     * Legend options.\n     *\n     * @readonly\n     * @name Highcharts.Legend#options\n     * @type {Highcharts.LegendOptions}\n     */\n\n    this.options = options;\n    this.itemMarginTop = options.itemMarginTop || 0;\n    this.padding = padding;\n    this.initialItemY = padding - 5; // 5 is pixels above the text\n\n    this.symbolWidth = pick(options.symbolWidth, 16);\n    this.pages = [];\n    this.proximate = options.layout === 'proximate' && !this.chart.inverted;\n  },\n\n  /**\n   * Update the legend with new options. Equivalent to running `chart.update`\n   * with a legend configuration option.\n   *\n   * @sample highcharts/legend/legend-update/\n   *         Legend update\n   *\n   * @function Highcharts.Legend#update\n   *\n   * @param {Highcharts.LegendOptions} options\n   *        Legend options.\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart.\n   *\n   * @todo\n   * Make events official: Fires the event `afterUpdate`.\n   */\n  update: function (options, redraw) {\n    var chart = this.chart;\n    this.setOptions(merge(true, this.options, options));\n    this.destroy();\n    chart.isDirtyLegend = chart.isDirtyBox = true;\n\n    if (pick(redraw, true)) {\n      chart.redraw();\n    }\n\n    fireEvent(this, 'afterUpdate');\n  },\n\n  /**\n   * Set the colors for the legend item.\n   *\n   * @private\n   * @function Highcharts.Legend#colorizeItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        A Series or Point instance\n   *\n   * @param {boolean} [visible=false]\n   *        Dimmed or colored\n   *\n   * @todo\n   * Make events official: Fires the event `afterColorizeItem`.\n   */\n  colorizeItem: function (item, visible) {\n    item.legendGroup[visible ? 'removeClass' : 'addClass']('highcharts-legend-item-hidden');\n    fireEvent(this, 'afterColorizeItem', {\n      item: item,\n      visible: visible\n    });\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Legend#positionItems\n   */\n  positionItems: function () {\n    // Now that the legend width and height are established, put the items\n    // in the final position\n    each(this.allItems, this.positionItem, this);\n\n    if (!this.chart.isResizing) {\n      this.positionCheckboxes();\n    }\n  },\n\n  /**\n   * Position the legend item.\n   *\n   * @private\n   * @function Highcharts.Legend#positionItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The item to position\n   */\n  positionItem: function (item) {\n    var legend = this,\n        options = legend.options,\n        symbolPadding = options.symbolPadding,\n        ltr = !options.rtl,\n        legendItemPos = item._legendItemPos,\n        itemX = legendItemPos[0],\n        itemY = legendItemPos[1],\n        checkbox = item.checkbox,\n        legendGroup = item.legendGroup;\n\n    if (legendGroup && legendGroup.element) {\n      legendGroup[defined(legendGroup.translateY) ? 'animate' : 'attr']({\n        translateX: ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n        translateY: itemY\n      });\n    }\n\n    if (checkbox) {\n      checkbox.x = itemX;\n      checkbox.y = itemY;\n    }\n  },\n\n  /**\n   * Destroy a single legend item, used internally on removing series items.\n   *\n   * @private\n   * @function Highcharts.Legend#destroyItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The item to remove\n   */\n  destroyItem: function (item) {\n    var checkbox = item.checkbox; // destroy SVG elements\n\n    each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n      if (item[key]) {\n        item[key] = item[key].destroy();\n      }\n    });\n\n    if (checkbox) {\n      discardElement(item.checkbox);\n    }\n  },\n\n  /**\n   * Destroy the legend. Used internally. To reflow objects, `chart.redraw`\n   * must be called after destruction.\n   *\n   * @private\n   * @function Highcharts.Legend#destroy\n   */\n  destroy: function () {\n    function destroyItems(key) {\n      if (this[key]) {\n        this[key] = this[key].destroy();\n      }\n    } // Destroy items\n\n\n    each(this.getAllItems(), function (item) {\n      each(['legendItem', 'legendGroup'], destroyItems, item);\n    }); // Destroy legend elements\n\n    each(['clipRect', 'up', 'down', 'pager', 'nav', 'box', 'title', 'group'], destroyItems, this);\n    this.display = null; // Reset in .render on update.\n  },\n\n  /**\n   * Position the checkboxes after the width is determined.\n   *\n   * @private\n   * @function Highcharts.Legend#positionCheckboxes\n   */\n  positionCheckboxes: function () {\n    var alignAttr = this.group && this.group.alignAttr,\n        translateY,\n        clipHeight = this.clipHeight || this.legendHeight,\n        titleHeight = this.titleHeight;\n\n    if (alignAttr) {\n      translateY = alignAttr.translateY;\n      each(this.allItems, function (item) {\n        var checkbox = item.checkbox,\n            top;\n\n        if (checkbox) {\n          top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;\n          css(checkbox, {\n            left: alignAttr.translateX + item.checkboxOffset + checkbox.x - 20 + 'px',\n            top: top + 'px',\n            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : 'none'\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * Render the legend title on top of the legend.\n   *\n   * @private\n   * @function Highcharts.Legend#renderTitle\n   */\n  renderTitle: function () {\n    var options = this.options,\n        padding = this.padding,\n        titleOptions = options.title,\n        titleHeight = 0,\n        bBox;\n\n    if (titleOptions.text) {\n      if (!this.title) {\n        /**\n         * SVG element of the legend title.\n         *\n         * @readonly\n         * @name Highcharts.Legend#title\n         * @type {Highcharts.SVGElement}\n         */\n        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, options.useHTML, null, 'legend-title').attr({\n          zIndex: 1\n        }).add(this.group);\n      }\n\n      bBox = this.title.getBBox();\n      titleHeight = bBox.height;\n      this.offsetWidth = bBox.width; // #1717\n\n      this.contentGroup.attr({\n        translateY: titleHeight\n      });\n    }\n\n    this.titleHeight = titleHeight;\n  },\n\n  /**\n   * Set the legend item text.\n   *\n   * @function Highcharts.Legend#setText\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The item for which to update the text in the legend.\n   */\n  setText: function (item) {\n    var options = this.options;\n    item.legendItem.attr({\n      text: options.labelFormat ? H.format(options.labelFormat, item, this.chart.time) : options.labelFormatter.call(item)\n    });\n  },\n\n  /**\n   * Render a single specific legend item. Called internally from the `render`\n   * function.\n   *\n   * @private\n   * @function Highcharts.Legend#renderItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The item to render.\n   */\n  renderItem: function (item) {\n    var legend = this,\n        chart = legend.chart,\n        renderer = chart.renderer,\n        options = legend.options,\n        horizontal = options.layout === 'horizontal',\n        symbolWidth = legend.symbolWidth,\n        symbolPadding = options.symbolPadding,\n        itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n        ltr = !options.rtl,\n        bBox,\n        li = item.legendItem,\n        isSeries = !item.series,\n        series = !isSeries && item.series.drawLegendSymbol ? item.series : item,\n        seriesOptions = series.options,\n        showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n        // full width minus text width\n    itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0),\n        useHTML = options.useHTML,\n        fontSize = 12,\n        itemClassName = item.options.className;\n\n    if (!li) {\n      // generate it once, later move it\n      // Generate the group box, a group to hold the symbol and text. Text\n      // is to be appended in Legend class.\n      item.legendGroup = renderer.g('legend-item').addClass('highcharts-' + series.type + '-series ' + 'highcharts-color-' + item.colorIndex + (itemClassName ? ' ' + itemClassName : '') + (isSeries ? ' highcharts-series-' + item.index : '')).attr({\n        zIndex: 1\n      }).add(legend.scrollGroup); // Generate the list item text and add it to the group\n\n      item.legendItem = li = renderer.text('', ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML).attr({\n        align: ltr ? 'left' : 'right',\n        zIndex: 2\n      }).add(item.legendGroup); // Get the baseline for the first item - the font size is equal for\n      // all\n\n      if (!legend.baseline) {\n        legend.fontMetrics = renderer.fontMetrics(fontSize, li);\n        legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;\n        li.attr('y', legend.baseline);\n      } // Draw the legend symbol inside the group box\n\n\n      legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;\n      series.drawLegendSymbol(legend, item);\n\n      if (legend.setItemEvents) {\n        legend.setItemEvents(item, li, useHTML);\n      } // add the HTML checkbox on top\n\n\n      if (showCheckbox) {\n        legend.createCheckboxForItem(item);\n      }\n    } // Colorize the items\n\n\n    legend.colorizeItem(item, item.visible); // Take care of max width and text overflow (#6659)\n\n    li.css({\n      width: (options.itemWidth || options.width || chart.spacingBox.width) - itemExtraWidth\n    }); // Always update the text\n\n    legend.setText(item); // calculate the positions for the next line\n\n    bBox = li.getBBox();\n    item.itemWidth = item.checkboxOffset = options.itemWidth || item.legendItemWidth || bBox.width + itemExtraWidth;\n    legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);\n    legend.totalItemWidth += item.itemWidth;\n    legend.itemHeight = item.itemHeight = Math.round(item.legendItemHeight || bBox.height || legend.symbolHeight);\n  },\n\n  /**\n   * Get the position of the item in the layout. We now know the\n   * maxItemWidth from the previous loop.\n   *\n   * @private\n   * @function Highcharts.Legend#layoutItem\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   */\n  layoutItem: function (item) {\n    var options = this.options,\n        padding = this.padding,\n        horizontal = options.layout === 'horizontal',\n        itemHeight = item.itemHeight,\n        itemMarginBottom = options.itemMarginBottom || 0,\n        itemMarginTop = this.itemMarginTop,\n        itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n        widthOption = options.width,\n        maxLegendWidth = widthOption || this.chart.spacingBox.width - 2 * padding - options.x,\n        itemWidth = options.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item.itemWidth; // If the item exceeds the width, start a new line\n\n    if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {\n      this.itemX = padding;\n      this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;\n      this.lastLineHeight = 0; // reset for next line (#915, #3976)\n    } // Set the edge positions\n\n\n    this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;\n    this.lastLineHeight = Math.max( // #915\n    itemHeight, this.lastLineHeight); // cache the position of the newly generated or reordered items\n\n    item._legendItemPos = [this.itemX, this.itemY]; // advance\n\n    if (horizontal) {\n      this.itemX += itemWidth;\n    } else {\n      this.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n      this.lastLineHeight = itemHeight;\n    } // the width of the widest item\n\n\n    this.offsetWidth = widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ? // decrease by itemDistance only when no checkbox #4853\n    0 : itemDistance) : itemWidth) + padding, this.offsetWidth);\n  },\n\n  /**\n   * Get all items, which is one item per series for most series and one\n   * item per point for pie series and its derivatives.\n   *\n   * @private\n   * @function Highcharts.Legend#getAllItems\n   *\n   * @return {Array<Highcharts.Point|Highcharts.Series>}\n   *         The current items in the legend.\n   *\n   * @fires Highcharts.Legend#event:afterGetAllItems\n   *\n   * @todo\n   * Make events official: Fires the event `afterGetAllItems`.\n   */\n  getAllItems: function () {\n    var allItems = [];\n    each(this.chart.series, function (series) {\n      var seriesOptions = series && series.options; // Handle showInLegend. If the series is linked to another series,\n      // defaults to false.\n\n      if (series && pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? undefined : false, true)) {\n        // Use points or series for the legend item depending on\n        // legendType\n        allItems = allItems.concat(series.legendItems || (seriesOptions.legendType === 'point' ? series.data : series));\n      }\n    });\n    fireEvent(this, 'afterGetAllItems', {\n      allItems: allItems\n    });\n    return allItems;\n  },\n\n  /**\n   * Get a short, three letter string reflecting the alignment and layout.\n   *\n   * @private\n   * @function Highcharts.Legend#getAlignment\n   *\n   * @return {string}\n   *         The alignment, empty string if floating\n   */\n  getAlignment: function () {\n    var options = this.options; // Use the first letter of each alignment option in order to detect\n    // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)\n\n    if (this.proximate) {\n      return options.align.charAt(0) + 'tv';\n    }\n\n    return options.floating ? '' : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);\n  },\n\n  /**\n   * Adjust the chart margins by reserving space for the legend on only one\n   * side of the chart. If the position is set to a corner, top or bottom is\n   * reserved for horizontal legends and left or right for vertical ones.\n   *\n   * @private\n   * @function Highcharts.Legend#adjustMargins\n   *\n   * @param {Array<number>} margin\n   *\n   * @param {number} spacing\n   */\n  adjustMargins: function (margin, spacing) {\n    var chart = this.chart,\n        options = this.options,\n        alignment = this.getAlignment();\n\n    if (alignment) {\n      each([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (alignments, side) {\n        if (alignments.test(alignment) && !defined(margin[side])) {\n          // Now we have detected on which side of the chart we should\n          // reserve space for the legend\n          chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + [1, -1, -1, 1][side] * options[side % 2 ? 'x' : 'y'] + pick(options.margin, 12) + spacing[side] + (side === 0 && chart.options.title.margin !== undefined ? chart.titleOffset + chart.options.title.margin : 0) // #7428, #7894\n          );\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Legend#proximatePositions\n   */\n  proximatePositions: function () {\n    var chart = this.chart,\n        boxes = [],\n        alignLeft = this.options.align === 'left';\n    each(this.allItems, function (item) {\n      var lastPoint,\n          height,\n          useFirstPoint = alignLeft;\n\n      if (item.xAxis && item.points) {\n        if (item.xAxis.options.reversed) {\n          useFirstPoint = !useFirstPoint;\n        }\n\n        lastPoint = H.find(useFirstPoint ? item.points : item.points.slice(0).reverse(), function (item) {\n          return H.isNumber(item.plotY);\n        });\n        height = item.legendGroup.getBBox().height;\n        boxes.push({\n          target: item.visible ? (lastPoint ? lastPoint.plotY : item.xAxis.height) - 0.3 * height : chart.plotHeight,\n          size: height,\n          item: item\n        });\n      }\n    }, this);\n    H.distribute(boxes, chart.plotHeight);\n    each(boxes, function (box) {\n      box.item._legendItemPos[1] = chart.plotTop - chart.spacing[0] + box.pos;\n    });\n  },\n\n  /**\n   * Render the legend. This method can be called both before and after\n   * `chart.render`. If called after, it will only rearrange items instead\n   * of creating new ones. Called internally on initial render and after\n   * redraws.\n   *\n   * @private\n   * @function Highcharts.Legend#render\n   */\n  render: function () {\n    var legend = this,\n        chart = legend.chart,\n        renderer = chart.renderer,\n        legendGroup = legend.group,\n        allItems,\n        display,\n        legendWidth,\n        legendHeight,\n        box = legend.box,\n        options = legend.options,\n        padding = legend.padding,\n        alignTo;\n    legend.itemX = padding;\n    legend.itemY = legend.initialItemY;\n    legend.offsetWidth = 0;\n    legend.lastItemY = 0;\n\n    if (!legendGroup) {\n      /**\n       * SVG group of the legend.\n       *\n       * @readonly\n       * @name Highcharts.Legend#group\n       * @type {Highcharts.SVGElement}\n       */\n      legend.group = legendGroup = renderer.g('legend').attr({\n        zIndex: 7\n      }).add();\n      legend.contentGroup = renderer.g().attr({\n        zIndex: 1\n      }) // above background\n      .add(legendGroup);\n      legend.scrollGroup = renderer.g().add(legend.contentGroup);\n    }\n\n    legend.renderTitle(); // add each series or point\n\n    allItems = legend.getAllItems(); // sort by legendIndex\n\n    stableSort(allItems, function (a, b) {\n      return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n    }); // reversed legend\n\n    if (options.reversed) {\n      allItems.reverse();\n    }\n    /**\n     * All items for the legend, which is an array of series for most series\n     * and an array of points for pie series and its derivatives.\n     *\n     * @readonly\n     * @name Highcharts.Legend#allItems\n     * @type {Array<Highcharts.Point|Highcharts.Series>}\n     */\n\n\n    legend.allItems = allItems;\n    legend.display = display = !!allItems.length; // Render the items. First we run a loop to set the text and properties\n    // and read all the bounding boxes. The next loop computes the item\n    // positions based on the bounding boxes.\n\n    legend.lastLineHeight = 0;\n    legend.maxItemWidth = 0;\n    legend.totalItemWidth = 0;\n    legend.itemHeight = 0;\n    each(allItems, legend.renderItem, legend);\n    each(allItems, legend.layoutItem, legend); // Get the box\n\n    legendWidth = (options.width || legend.offsetWidth) + padding;\n    legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n    legendHeight = legend.handleOverflow(legendHeight);\n    legendHeight += padding; // Draw the border and/or background\n\n    if (!box) {\n      /**\n       * SVG element of the legend box.\n       *\n       * @readonly\n       * @name Highcharts.Legend#box\n       * @type {Highcharts.SVGElement}\n       */\n      legend.box = box = renderer.rect().addClass('highcharts-legend-box').attr({\n        r: options.borderRadius\n      }).add(legendGroup);\n      box.isNew = true;\n    }\n\n    if (legendWidth > 0 && legendHeight > 0) {\n      box[box.isNew ? 'attr' : 'animate'](box.crisp.call({}, {\n        // #7260\n        x: 0,\n        y: 0,\n        width: legendWidth,\n        height: legendHeight\n      }, box.strokeWidth()));\n      box.isNew = false;\n    } // hide the border if no items\n\n\n    box[display ? 'show' : 'hide'](); // Open for responsiveness\n\n    if (legendGroup.getStyle('display') === 'none') {\n      legendWidth = legendHeight = 0;\n    }\n\n    legend.legendWidth = legendWidth;\n    legend.legendHeight = legendHeight;\n\n    if (display) {\n      // If aligning to the top and the layout is horizontal, adjust for\n      // the title (#7428)\n      alignTo = chart.spacingBox;\n\n      if (/(lth|ct|rth)/.test(legend.getAlignment())) {\n        alignTo = merge(alignTo, {\n          y: alignTo.y + chart.titleOffset + chart.options.title.margin\n        });\n      }\n\n      legendGroup.align(merge(options, {\n        width: legendWidth,\n        height: legendHeight,\n        verticalAlign: this.proximate ? 'top' : options.verticalAlign\n      }), true, alignTo);\n    }\n\n    if (!this.proximate) {\n      this.positionItems();\n    }\n  },\n\n  /**\n   * Set up the overflow handling by adding navigation with up and down arrows\n   * below the legend.\n   *\n   * @private\n   * @function Highcharts.Legend#handleOverflow\n   *\n   * @param {number} legendHeight\n   *\n   * @return {number}\n   */\n  handleOverflow: function (legendHeight) {\n    var legend = this,\n        chart = this.chart,\n        renderer = chart.renderer,\n        options = this.options,\n        optionsY = options.y,\n        alignTop = options.verticalAlign === 'top',\n        padding = this.padding,\n        spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding,\n        maxHeight = options.maxHeight,\n        clipHeight,\n        clipRect = this.clipRect,\n        navOptions = options.navigation,\n        animation = pick(navOptions.animation, true),\n        arrowSize = navOptions.arrowSize || 12,\n        nav = this.nav,\n        pages = this.pages,\n        lastY,\n        allItems = this.allItems,\n        clipToHeight = function (height) {\n      if (typeof height === 'number') {\n        clipRect.attr({\n          height: height\n        });\n      } else if (clipRect) {\n        // Reset (#5912)\n        legend.clipRect = clipRect.destroy();\n        legend.contentGroup.clip();\n      } // useHTML\n\n\n      if (legend.contentGroup.div) {\n        legend.contentGroup.div.style.clip = height ? 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)' : 'auto';\n      }\n    }; // Adjust the height\n\n\n    if (options.layout === 'horizontal' && options.verticalAlign !== 'middle' && !options.floating) {\n      spaceHeight /= 2;\n    }\n\n    if (maxHeight) {\n      spaceHeight = Math.min(spaceHeight, maxHeight);\n    } // Reset the legend height and adjust the clipping rectangle\n\n\n    pages.length = 0;\n\n    if (legendHeight > spaceHeight && navOptions.enabled !== false) {\n      this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);\n      this.currentPage = pick(this.currentPage, 1);\n      this.fullHeight = legendHeight; // Fill pages with Y positions so that the top of each a legend item\n      // defines the scroll top for each page (#2098)\n\n      each(allItems, function (item, i) {\n        var y = item._legendItemPos[1],\n            h = Math.round(item.legendItem.getBBox().height),\n            len = pages.length;\n\n        if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {\n          pages.push(lastY || y);\n          len++;\n        } // Keep track of which page each item is on\n\n\n        item.pageIx = len - 1;\n\n        if (lastY) {\n          allItems[i - 1].pageIx = len - 1;\n        }\n\n        if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {\n          pages.push(y);\n          item.pageIx = len;\n        }\n\n        if (y !== lastY) {\n          lastY = y;\n        }\n      }); // Only apply clipping if needed. Clipping causes blurred legend in\n      // PDF export (#1787)\n\n      if (!clipRect) {\n        clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);\n        legend.contentGroup.clip(clipRect);\n      }\n\n      clipToHeight(clipHeight); // Add navigation elements\n\n      if (!nav) {\n        this.nav = nav = renderer.g().attr({\n          zIndex: 1\n        }).add(this.group);\n        this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize).on('click', function () {\n          legend.scroll(-1, animation);\n        }).add(nav);\n        this.pager = renderer.text('', 15, 10).addClass('highcharts-legend-navigation').add(nav);\n        this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize).on('click', function () {\n          legend.scroll(1, animation);\n        }).add(nav);\n      } // Set initial position\n\n\n      legend.scroll(0);\n      legendHeight = spaceHeight; // Reset\n    } else if (nav) {\n      clipToHeight();\n      this.nav = nav.destroy(); // #6322\n\n      this.scrollGroup.attr({\n        translateY: 1\n      });\n      this.clipHeight = 0; // #1379\n    }\n\n    return legendHeight;\n  },\n\n  /**\n   * Scroll the legend by a number of pages.\n   *\n   * @private\n   * @function Highcharts.Legend#scroll\n   *\n   * @param {number} scrollBy\n   *        The number of pages to scroll.\n   *\n   * @param {Highcharts.AnimationOptionsObject} animation\n   *        Whether and how to apply animation.\n   */\n  scroll: function (scrollBy, animation) {\n    var pages = this.pages,\n        pageCount = pages.length,\n        currentPage = this.currentPage + scrollBy,\n        clipHeight = this.clipHeight,\n        navOptions = this.options.navigation,\n        pager = this.pager,\n        padding = this.padding; // When resizing while looking at the last page\n\n    if (currentPage > pageCount) {\n      currentPage = pageCount;\n    }\n\n    if (currentPage > 0) {\n      if (animation !== undefined) {\n        setAnimation(animation, this.chart);\n      }\n\n      this.nav.attr({\n        translateX: padding,\n        translateY: clipHeight + this.padding + 7 + this.titleHeight,\n        visibility: 'visible'\n      });\n      this.up.attr({\n        'class': currentPage === 1 ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n      });\n      pager.attr({\n        text: currentPage + '/' + pageCount\n      });\n      this.down.attr({\n        'x': 18 + this.pager.getBBox().width,\n        // adjust to text width\n        'class': currentPage === pageCount ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n      });\n      this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n      this.scrollGroup.animate({\n        translateY: this.scrollOffset\n      });\n      this.currentPage = currentPage;\n      this.positionCheckboxes();\n    }\n  }\n};\n/**\n * Legend symbol mixin.\n *\n * @private\n * @mixin Highcharts.LegendSymbolMixin\n */\n\nH.LegendSymbolMixin = {\n  /**\n   * Get the series' symbol in the legend\n   *\n   * @private\n   * @function Highcharts.LegendSymbolMixin.drawRectangle\n   *\n   * @param {Highcharts.Legend} legend\n   *        The legend object\n   *\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The series (this) or point\n   */\n  drawRectangle: function (legend, item) {\n    var options = legend.options,\n        symbolHeight = legend.symbolHeight,\n        square = options.squareSymbol,\n        symbolWidth = square ? symbolHeight : legend.symbolWidth;\n    item.legendSymbol = this.chart.renderer.rect(square ? (legend.symbolWidth - symbolHeight) / 2 : 0, legend.baseline - symbolHeight + 1, // #3988\n    symbolWidth, symbolHeight, pick(legend.options.symbolRadius, symbolHeight / 2)).addClass('highcharts-point').attr({\n      zIndex: 3\n    }).add(item.legendGroup);\n  },\n\n  /**\n   * Get the series' symbol in the legend. This method should be overridable\n   * to create custom symbols through\n   * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n   *\n   * @private\n   * @function Highcharts.LegendSymbolMixin.drawLineMarker\n   *\n   * @param {Highcharts.Legend} legend\n   *        The legend object.\n   */\n  drawLineMarker: function (legend) {\n    var options = this.options,\n        markerOptions = options.marker,\n        radius,\n        legendSymbol,\n        symbolWidth = legend.symbolWidth,\n        symbolHeight = legend.symbolHeight,\n        generalRadius = symbolHeight / 2,\n        renderer = this.chart.renderer,\n        legendItemGroup = this.legendGroup,\n        verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3),\n        attr = {}; // Draw the line\n\n    this.legendLine = renderer.path(['M', 0, verticalCenter, 'L', symbolWidth, verticalCenter]).addClass('highcharts-graph').attr(attr).add(legendItemGroup); // Draw the marker\n\n    if (markerOptions && markerOptions.enabled !== false && symbolWidth) {\n      // Do not allow the marker to be larger than the symbolHeight\n      radius = Math.min(pick(markerOptions.radius, generalRadius), generalRadius); // Restrict symbol markers size\n\n      if (this.symbol.indexOf('url') === 0) {\n        markerOptions = merge(markerOptions, {\n          width: symbolHeight,\n          height: symbolHeight\n        });\n        radius = 0;\n      }\n\n      this.legendSymbol = legendSymbol = renderer.symbol(this.symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius, markerOptions).addClass('highcharts-point').add(legendItemGroup);\n      legendSymbol.isMarker = true;\n    }\n  }\n}; // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n// and for #2580, a similar drawing flaw in Firefox 26.\n// Explore if there's a general cause for this. The problem may be related\n// to nested group elements, as the legend item texts are within 4 group\n// elements.\n\nif (/Trident\\/7\\.0/.test(win.navigator.userAgent) || isFirefox) {\n  wrap(Highcharts.Legend.prototype, 'positionItem', function (proceed, item) {\n    var legend = this,\n        // If chart destroyed in sync, this is undefined (#2030)\n    runPositionItem = function () {\n      if (item._legendItemPos) {\n        proceed.call(legend, item);\n      }\n    }; // Do it now, for export and to get checkbox placement\n\n\n    runPositionItem(); // Do it after to work around the core issue\n\n    setTimeout(runPositionItem);\n  });\n}"
    },
    {
     "id": 252,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-column.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2018 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { DirMixin } from '@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js';\nimport { Templatizer } from './vaadin-grid-templatizer.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { animationFrame } from '@polymer/polymer/lib/utils/async.js';\n/**\n * @polymerMixin\n */\n\nexport var ColumnBaseMixin = superClass => class ColumnBaseMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * When set to true, the column is user-resizable.\n       * @default false\n       */\n      resizable: {\n        type: Boolean,\n        value: function () {\n          if (this.localName === 'vaadin-grid-column-group') {\n            return;\n          }\n\n          var parent = this.parentNode;\n\n          if (parent && parent.localName === 'vaadin-grid-column-group') {\n            return parent.resizable || false;\n          } else {\n            return false;\n          }\n        }\n      },\n\n      /**\n       * @type {HTMLTemplateElement}\n       * @protected\n       */\n      _headerTemplate: {\n        type: Object\n      },\n\n      /**\n       * @type {HTMLTemplateElement}\n       * @protected\n       */\n      _footerTemplate: {\n        type: Object\n      },\n\n      /**\n       * When true, the column is frozen. When a column inside of a column group is frozen,\n       * all of the sibling columns inside the group will get frozen also.\n       * @type {boolean}\n       */\n      frozen: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * When set to true, the cells for this column are hidden.\n       */\n      hidden: {\n        type: Boolean\n      },\n\n      /**\n       * Text content to display in the header cell of the column.\n       */\n      header: {\n        type: String\n      },\n\n      /**\n       * Aligns the columns cell content horizontally.\n       * Supported values: \"start\", \"center\" and \"end\".\n       * @attr {start|center|end} text-align\n       * @type {GridColumnTextAlign | null | undefined}\n       */\n      textAlign: {\n        type: String\n      },\n\n      /**\n       * @type {boolean}\n       * @protected\n       */\n      _lastFrozen: {\n        type: Boolean,\n        value: false\n      },\n\n      /** @protected */\n      _order: Number,\n\n      /** @private */\n      _reorderStatus: Boolean,\n\n      /**\n       * @type {Array<!HTMLElement>}\n       * @protected\n       */\n      _emptyCells: Array,\n\n      /** @private */\n      _headerCell: Object,\n\n      /** @private */\n      _footerCell: Object,\n\n      /** @protected */\n      _grid: Object,\n\n      /**\n       * Custom function for rendering the header content.\n       * Receives two arguments:\n       *\n       * - `root` The header cell content DOM element. Append your content to it.\n       * - `column` The `<vaadin-grid-column>` element.\n       *\n       * @type {GridHeaderFooterRenderer | null | undefined}\n       */\n      headerRenderer: Function,\n\n      /**\n       * Custom function for rendering the footer content.\n       * Receives two arguments:\n       *\n       * - `root` The footer cell content DOM element. Append your content to it.\n       * - `column` The `<vaadin-grid-column>` element.\n       *\n       * @type {GridHeaderFooterRenderer | null | undefined}\n       */\n      footerRenderer: Function\n    };\n  }\n\n  static get observers() {\n    return ['_widthChanged(width, _headerCell, _footerCell, _cells.*)', '_frozenChanged(frozen, _headerCell, _footerCell, _cells.*)', '_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells.*)', '_pathOrHeaderChanged(path, header, _headerCell, _footerCell, _cells.*, renderer, headerRenderer, _bodyTemplate, _headerTemplate)', '_textAlignChanged(textAlign, _cells.*, _headerCell, _footerCell)', '_orderChanged(_order, _headerCell, _footerCell, _cells.*)', '_lastFrozenChanged(_lastFrozen)', '_setBodyTemplateOrRenderer(_bodyTemplate, renderer, _cells, _cells.*)', '_setHeaderTemplateOrRenderer(_headerTemplate, headerRenderer, _headerCell)', '_setFooterTemplateOrRenderer(_footerTemplate, footerRenderer, _footerCell)', '_resizableChanged(resizable, _headerCell)', '_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells.*)', '_hiddenChanged(hidden, _headerCell, _footerCell, _cells.*)'];\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    this._bodyTemplate && (this._bodyTemplate.templatizer._grid = this._grid);\n    this._headerTemplate && (this._headerTemplate.templatizer._grid = this._grid);\n    this._footerTemplate && (this._footerTemplate.templatizer._grid = this._grid);\n\n    this._templateObserver.flush();\n\n    if (!this._bodyTemplate) {\n      // The observer might not have triggered if the tag is empty. Run manually.\n      this._templateObserver.callback();\n    }\n\n    requestAnimationFrame(() => {\n      this._allCells.forEach(cell => {\n        if (!cell._content.parentNode) {\n          this._grid && this._grid.appendChild(cell._content);\n        }\n      });\n    });\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    requestAnimationFrame(() => {\n      if (!this._findHostGrid()) {\n        this._allCells.forEach(cell => {\n          if (cell._content.parentNode) {\n            cell._content.parentNode.removeChild(cell._content);\n          }\n        });\n      }\n    });\n    this._gridValue = undefined;\n  }\n  /**\n   * @return {!GridElement | undefined}\n   * @protected\n   */\n\n\n  _findHostGrid() {\n    var el = this; // Custom elements extending grid must have a specific localName\n\n    while (el && !/^vaadin.*grid(-pro)?$/.test(el.localName)) {\n      el = el.assignedSlot ? el.assignedSlot.parentNode : el.parentNode;\n    }\n\n    return el || undefined;\n  }\n  /**\n   * @return {!GridElement | undefined}\n   * @protected\n   */\n\n\n  get _grid() {\n    if (!this._gridValue) {\n      this._gridValue = this._findHostGrid();\n    }\n\n    return this._gridValue;\n  }\n  /**\n   * @return {!Array<!HTMLElement>}\n   * @protected\n   */\n\n\n  get _allCells() {\n    return [].concat(this._cells || []).concat(this._emptyCells || []).concat(this._headerCell).concat(this._footerCell).filter(cell => cell);\n  }\n\n  constructor() {\n    super();\n    this._templateObserver = new FlattenedNodesObserver(this, info => {\n      this._headerTemplate = this._prepareHeaderTemplate();\n      this._footerTemplate = this._prepareFooterTemplate();\n      this._bodyTemplate = this._prepareBodyTemplate();\n    });\n  }\n  /**\n   * @return {HTMLTemplateElement}\n   * @protected\n   */\n\n\n  _prepareHeaderTemplate() {\n    return this._prepareTemplatizer(this._findTemplate(true) || null, {});\n  }\n  /**\n   * @return {HTMLTemplateElement}\n   * @protected\n   */\n\n\n  _prepareFooterTemplate() {\n    return this._prepareTemplatizer(this._findTemplate(false, true) || null, {});\n  }\n  /**\n   * @return {HTMLTemplateElement}\n   * @protected\n   */\n\n\n  _prepareBodyTemplate() {\n    return this._prepareTemplatizer(this._findTemplate() || null);\n  }\n  /**\n   * @param {HTMLTemplateElement} template\n   * @param {object} instanceProps\n   * @return {HTMLTemplateElement}\n   * @protected\n   */\n\n\n  _prepareTemplatizer(template, instanceProps) {\n    if (template && !template.templatizer) {\n      var templatizer = new Templatizer();\n      templatizer._grid = this._grid;\n      templatizer.dataHost = this.dataHost;\n      templatizer._instanceProps = instanceProps || templatizer._instanceProps;\n      templatizer.template = template;\n      template.templatizer = templatizer;\n    }\n\n    return template;\n  }\n  /** @protected */\n\n\n  _renderHeaderAndFooter() {\n    if (this.headerRenderer && this._headerCell) {\n      this.__runRenderer(this.headerRenderer, this._headerCell);\n    }\n\n    if (this.footerRenderer && this._footerCell) {\n      this.__runRenderer(this.footerRenderer, this._footerCell);\n    }\n  }\n  /** @private */\n\n\n  __runRenderer(renderer, cell, model) {\n    var args = [cell._content, this];\n\n    if (model && model.item) {\n      args.push(model);\n    }\n\n    renderer.apply(this, args);\n  }\n  /** @private */\n\n\n  __setColumnTemplateOrRenderer(template, renderer, cells) {\n    if (template && renderer) {\n      throw new Error('You should only use either a renderer or a template');\n    }\n\n    cells.forEach(cell => {\n      var model = this._grid.__getRowModel(cell.parentElement);\n\n      if (renderer) {\n        cell._renderer = renderer;\n\n        if (model.item || renderer === this.headerRenderer || renderer === this.footerRenderer) {\n          this.__runRenderer(renderer, cell, model);\n        }\n      } else if (cell._template !== template) {\n        cell._template = template;\n        cell._content.innerHTML = '';\n        template.templatizer._grid = template.templatizer._grid || this._grid;\n        var inst = template.templatizer.createInstance();\n\n        cell._content.appendChild(inst.root);\n\n        cell._instance = inst;\n\n        if (model.item) {\n          cell._instance.setProperties(model);\n        }\n      }\n    });\n  }\n  /** @private */\n\n\n  _setBodyTemplateOrRenderer(template, renderer, cells, splices) {\n    if ((template || renderer) && cells) {\n      this.__setColumnTemplateOrRenderer(template, renderer, cells);\n    }\n  }\n  /** @private */\n\n\n  _setHeaderTemplateOrRenderer(headerTemplate, headerRenderer, headerCell) {\n    if ((headerTemplate || headerRenderer) && headerCell) {\n      this.__setColumnTemplateOrRenderer(headerTemplate, headerRenderer, [headerCell]);\n    }\n  }\n  /** @private */\n\n\n  _setFooterTemplateOrRenderer(footerTemplate, footerRenderer, footerCell) {\n    if ((footerTemplate || footerRenderer) && footerCell) {\n      this.__setColumnTemplateOrRenderer(footerTemplate, footerRenderer, [footerCell]);\n\n      this._grid.__updateHeaderFooterRowVisibility(footerCell.parentElement);\n    }\n  }\n  /**\n   * @param {boolean} header\n   * @param {boolean} footer\n   * @return {HTMLTemplateElement}\n   * @protected\n   */\n\n\n  _selectFirstTemplate(header = false, footer = false) {\n    return FlattenedNodesObserver.getFlattenedNodes(this).filter(node => node.localName === 'template' && node.classList.contains('header') === header && node.classList.contains('footer') === footer)[0];\n  }\n  /**\n   * @param {boolean} header\n   * @param {boolean} footer\n   * @return {HTMLTemplateElement}\n   * @protected\n   */\n\n\n  _findTemplate(header, footer) {\n    var template = this._selectFirstTemplate(header, footer);\n\n    if (template) {\n      if (this.dataHost) {\n        // set dataHost to the context where template has been defined\n        template._rootDataHost = this.dataHost._rootDataHost || this.dataHost;\n      }\n    }\n\n    return template;\n  }\n  /** @private */\n\n\n  _flexGrowChanged(flexGrow, headerCell, footerCell, cells) {\n    if (this.parentElement && this.parentElement._columnPropChanged) {\n      this.parentElement._columnPropChanged('flexGrow');\n    }\n\n    this._allCells.forEach(cell => cell.style.flexGrow = flexGrow);\n  }\n  /** @private */\n\n\n  _orderChanged(order, headerCell, footerCell, cells) {\n    this._allCells.forEach(cell => cell.style.order = order);\n  }\n  /** @private */\n\n\n  _widthChanged(width, headerCell, footerCell, cells) {\n    if (this.parentElement && this.parentElement._columnPropChanged) {\n      this.parentElement._columnPropChanged('width');\n    }\n\n    this._allCells.forEach(cell => cell.style.width = width); // Force a reflow to workaround browser issues causing double scrollbars to grid\n    // https://github.com/vaadin/vaadin-grid/issues/1586\n\n\n    if (this._grid && this._grid.__forceReflow) {\n      this._grid.__forceReflow();\n    }\n  }\n  /** @private */\n\n\n  _frozenChanged(frozen, headerCell, footerCell, cells) {\n    if (this.parentElement && this.parentElement._columnPropChanged) {\n      this.parentElement._columnPropChanged('frozen', frozen);\n    }\n\n    this._allCells.forEach(cell => this._toggleAttribute('frozen', frozen, cell));\n\n    this._grid && this._grid._frozenCellsChanged && this._grid._frozenCellsChanged();\n  }\n  /** @private */\n\n\n  _lastFrozenChanged(lastFrozen) {\n    this._allCells.forEach(cell => this._toggleAttribute('last-frozen', lastFrozen, cell));\n\n    if (this.parentElement && this.parentElement._columnPropChanged) {\n      this.parentElement._lastFrozen = lastFrozen;\n    }\n  }\n  /**\n   * @param {string | undefined} path\n   * @param {string | undefined} header\n   * @param {!HTMLTableCellElement | undefined} headerCell\n   * @param {!HTMLTableCellElement | undefined} footerCell\n   * @param {!object | undefined} cells\n   * @param {GridBodyRenderer | undefined} renderer\n   * @param {GridHeaderFooterRenderer | undefined} headerRenderer\n   * @param {HTMLTemplateElement | undefined} bodyTemplate\n   * @param {HTMLTemplateElement | undefined} headerTemplate\n   * @protected\n   */\n\n\n  _pathOrHeaderChanged(path, header, headerCell, footerCell, cells, renderer, headerRenderer, bodyTemplate, headerTemplate) {\n    var hasHeaderText = header !== undefined;\n\n    if (!headerRenderer && !headerTemplate && hasHeaderText && headerCell) {\n      this.__setTextContent(headerCell._content, header);\n    }\n\n    if (path && cells.value) {\n      if (!renderer && !bodyTemplate) {\n        var pathRenderer = (root, owner, {\n          item\n        }) => this.__setTextContent(root, this.get(path, item));\n\n        this.__setColumnTemplateOrRenderer(undefined, pathRenderer, cells.value);\n      }\n\n      if (!headerRenderer && !headerTemplate && !hasHeaderText && headerCell && header !== null) {\n        this.__setTextContent(headerCell._content, this._generateHeader(path));\n      }\n    }\n\n    if (headerCell) {\n      this._grid.__updateHeaderFooterRowVisibility(headerCell.parentElement);\n    }\n  }\n  /** @private */\n\n\n  __setTextContent(node, textContent) {\n    node.textContent !== textContent && (node.textContent = textContent);\n  }\n  /**\n   * @param {string} path\n   * @return {string}\n   * @protected\n   */\n\n\n  _generateHeader(path) {\n    return path.substr(path.lastIndexOf('.') + 1).replace(/([A-Z])/g, '-$1').toLowerCase().replace(/-/g, ' ').replace(/^./, match => match.toUpperCase());\n  }\n  /**\n   * @param {string} name\n   * @param {boolean} bool\n   * @param {!Element} node\n   * @protected\n   */\n\n\n  _toggleAttribute(name, bool, node) {\n    if (node.hasAttribute(name) === !bool) {\n      if (bool) {\n        node.setAttribute(name, '');\n      } else {\n        node.removeAttribute(name);\n      }\n    }\n  }\n  /** @private */\n\n\n  _reorderStatusChanged(reorderStatus, headerCell, footerCell, cells) {\n    this._allCells.forEach(cell => cell.setAttribute('reorder-status', reorderStatus));\n  }\n  /** @private */\n\n\n  _resizableChanged(resizable, headerCell) {\n    if (resizable === undefined || headerCell === undefined) {\n      return;\n    }\n\n    if (headerCell) {\n      [headerCell].concat(this._emptyCells).forEach(cell => {\n        if (cell) {\n          var existingHandle = cell.querySelector('[part~=\"resize-handle\"]');\n\n          if (existingHandle) {\n            cell.removeChild(existingHandle);\n          }\n\n          if (resizable) {\n            var handle = document.createElement('div');\n            handle.setAttribute('part', 'resize-handle');\n            cell.appendChild(handle);\n          }\n        }\n      });\n    }\n  }\n  /** @private */\n\n\n  _textAlignChanged(textAlign, _cells, _headerCell, _footerCell) {\n    if (textAlign === undefined) {\n      return;\n    }\n\n    if (['start', 'end', 'center'].indexOf(textAlign) === -1) {\n      console.warn('textAlign can only be set as \"start\", \"end\" or \"center\"');\n      return;\n    }\n\n    var textAlignFallback;\n\n    if (getComputedStyle(this._grid).direction === 'ltr') {\n      if (textAlign === 'start') {\n        textAlignFallback = 'left';\n      } else if (textAlign === 'end') {\n        textAlignFallback = 'right';\n      }\n    } else {\n      if (textAlign === 'start') {\n        textAlignFallback = 'right';\n      } else if (textAlign === 'end') {\n        textAlignFallback = 'left';\n      }\n    }\n\n    this._allCells.forEach(cell => {\n      cell._content.style.textAlign = textAlign;\n\n      if (getComputedStyle(cell._content).textAlign !== textAlign) {\n        cell._content.style.textAlign = textAlignFallback;\n      }\n    });\n  }\n  /** @private */\n\n\n  _hiddenChanged(hidden, headerCell, footerCell, cells) {\n    if (this.parentElement && this.parentElement._columnPropChanged) {\n      this.parentElement._columnPropChanged('hidden', hidden);\n    }\n\n    if (!!hidden !== !!this._previousHidden && this._grid) {\n      if (hidden === true) {\n        this._allCells.forEach(cell => {\n          if (cell._content.parentNode) {\n            cell._content.parentNode.removeChild(cell._content);\n          }\n        });\n      }\n\n      this._grid._debouncerHiddenChanged = Debouncer.debounce(this._grid._debouncerHiddenChanged, animationFrame, () => {\n        if (this._grid && this._grid._renderColumnTree) {\n          this._grid._renderColumnTree(this._grid._columnTree);\n        }\n      });\n      this._grid._updateLastFrozen && this._grid._updateLastFrozen();\n      this._grid.notifyResize && this._grid.notifyResize();\n      this._grid._resetKeyboardNavigation && this._grid._resetKeyboardNavigation();\n    }\n\n    this._previousHidden = hidden;\n  }\n\n};\n/**\n * A `<vaadin-grid-column>` is used to configure how a column in `<vaadin-grid>`\n * should look like.\n *\n * See `<vaadin-grid>` documentation and demos for instructions and examples on how\n * to configure the `<vaadin-grid-column>`.\n * ```\n *\n * @extends PolymerElement\n * @mixes ColumnBaseMixin\n */\n\nclass GridColumnElement extends ColumnBaseMixin(DirMixin(PolymerElement)) {\n  static get is() {\n    return 'vaadin-grid-column';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Width of the cells for this column.\n       */\n      width: {\n        type: String,\n        value: '100px'\n      },\n\n      /**\n       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.\n       * @attr {number} flex-grow\n       * @type {number}\n       */\n      flexGrow: {\n        type: Number,\n        value: 1\n      },\n\n      /**\n       * Custom function for rendering the cell content.\n       * Receives three arguments:\n       *\n       * - `root` The cell content DOM element. Append your content to it.\n       * - `column` The `<vaadin-grid-column>` element.\n       * - `model` The object with the properties related with\n       *   the rendered item, contains:\n       *   - `model.index` The index of the item.\n       *   - `model.item` The item.\n       *   - `model.expanded` Sublevel toggle state.\n       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.\n       *   - `model.selected` Selected state.\n       *\n       * @type {GridBodyRenderer | null | undefined}\n       */\n      renderer: Function,\n\n      /**\n       * Path to an item sub-property whose value gets displayed in the column body cells.\n       * The property name is also shown in the column header if an explicit header or renderer isn't defined.\n       */\n      path: {\n        type: String\n      },\n\n      /**\n       * Automatically sets the width of the column based on the column contents when this is set to `true`.\n       *\n       * For performance reasons the column width is calculated automatically only once when the grid items\n       * are rendered for the first time and the calculation only considers the rows which are currently\n       * rendered in DOM (a bit more than what is currently visible). If the grid is scrolled, or the cell\n       * content changes, the column width might not match the contents anymore.\n       *\n       * Hidden columns are ignored in the calculation and their widths are not automatically updated when\n       * you show a column that was initially hidden.\n       *\n       * You can manually trigger the auto sizing behavior again by calling `grid.recalculateColumnWidths()`.\n       *\n       * The column width may still grow larger when `flexGrow` is not 0.\n       * @attr {boolean} auto-width\n       * @type {boolean}\n       */\n      autoWidth: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * @type {HTMLTemplateElement}\n       * @protected\n       */\n      _bodyTemplate: {\n        type: Object\n      },\n\n      /**\n       * @type {Array<!HTMLElement>}\n       * @protected\n       */\n      _cells: Array\n    };\n  }\n\n}\n\ncustomElements.define(GridColumnElement.is, GridColumnElement);\nexport { GridColumnElement };"
    },
    {
     "id": 254,
     "name": "../node_modules/highcharts/js/es-modules/parts/SvgRenderer.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Options to align the element relative to the chart or another box.\n *\n * @typedef Highcharts.AlignObject\n *\n * @property {string} [align='left']\n *           Horizontal alignment. Can be one of `left`, `center` and\n *           `right`.\n *\n * @property {string} [verticalAlign='top']\n *           Vertical alignment. Can be one of `top`, `middle` and `bottom`.\n *\n * @property {number} [x=0]\n *           Horizontal pixel offset from alignment.\n *\n * @property {number} [y=0]\n *           Vertical pixel offset from alignment.\n *\n * @property {boolean} [alignByTranslate=false]\n *           Use the `transform` attribute with translateX and translateY\n *           custom attributes to align this elements rather than `x` and\n *           `y` attributes.\n */\n\n/**\n * Bounding box of an element.\n *\n * @typedef Highcharts.BBoxObject\n *\n * @property {number} height\n *           Height of the bounding box.\n *\n * @property {number} width\n *           Width of the bounding box.\n *\n * @property {number} x\n *           Horizontal position of the bounding box.\n *\n * @property {number} y\n *           Vertical position of the bounding box.\n */\n\n/**\n * A clipping rectangle that can be applied to one or more\n * {@link SVGElement} instances. It is instanciated with the\n * {@link SVGRenderer#clipRect} function and applied with the\n * {@link SVGElement#clip} function.\n *\n * @example\n * var circle = renderer.circle(100, 100, 100)\n *     .attr({ fill: 'red' })\n *     .add();\n * var clipRect = renderer.clipRect(100, 100, 100, 100);\n *\n * // Leave only the lower right quarter visible\n * circle.clip(clipRect);\n *\n * @typedef {Highcharts.SVGElement} Highcharts.ClipRectElement\n */\n\n/**\n * The font metrics.\n *\n * @typedef Highcharts.FontMetricsObject\n *\n * @property {number} b\n *           The baseline relative to the top of the box.\n *\n * @property {number} h\n *           The line height.\n *\n * @property {number} f\n *           The font size.\n */\n\n/**\n * Gradient options instead of a solid color.\n *\n * @example\n * // Linear gradient used as a color option\n * color: {\n *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },\n *         stops: [\n *             [0, '#003399'], // start\n *             [0.5, '#ffffff'], // middle\n *             [1, '#3366AA'] // end\n *         ]\n *     }\n * }\n *\n * @private\n * @typedef Highcharts.GradientColorObject\n *\n * @property {Highcharts.LinearGradientColorObject} linearGradient\n *           Holds an object that defines the start position and the end\n *           position relative to the shape.\n *\n * @property {Highcharts.RadialGradientColorObject} radialGradient\n *           Holds an object that defines the center position and the\n *           radius.\n *\n * @property {Array<Array<number|string>>} stops\n *           The first item in each tuple is the position in the gradient,\n *           where 0 is the start of the gradient and 1 is the end of the\n *           gradient. Multiple stops can be applied. The second item is the\n *           color for each stop. This color can also be given in the rgba\n *           format.\n */\n\n/**\n * Defines the start position and the end position for a gradient relative\n * to the shape.\n *\n * @private\n * @typedef Highcharts.LinearGradientColorObject\n *\n * @property {number} x1\n *           Start horizontal position of the gradient. Ranges 0-1.\n *\n * @property {number} x2\n *           End horizontal position of the gradient. Ranges 0-1.\n *\n * @property {number} y1\n *           Start vertical position of the gradient. Ranges 0-1.\n *\n * @property {number} y2\n *           End vertical position of the gradient. Ranges 0-1.\n */\n\n/**\n * Defines the center position and the radius for a gradient.\n *\n * @private\n * @typedef Highcharts.RadialGradientColorObject\n *\n * @property {number} cx\n *           Center horizontal position relative to the shape. Ranges 0-1.\n *\n * @property {number} cy\n *           Center vertical position relative to the shape. Ranges 0-1.\n *\n * @property {number} r\n *           Radius relative to the shape. Ranges 0-1.\n */\n\n/**\n * A rectangle.\n *\n * @typedef Highcharts.RectangleObject\n *\n * @property {number} height\n *           Height of the rectangle.\n *\n * @property {number} width\n *           Width of the rectangle.\n *\n * @property {number} x\n *           Horizontal position of the rectangle.\n *\n * @property {number} y\n *           Vertical position of the rectangle.\n */\n\n/**\n * The shadow options.\n *\n * @typedef Highcharts.ShadowOptionsObject\n *\n * @property {string} [color=#000000]\n *           The shadow color.\n *\n * @property {number} [offsetX=1]\n *           The horizontal offset from the element.\n *\n * @property {number} [offsetY=1]\n *           The vertical offset from the element.\n *\n * @property {number} [opacity=0.15]\n *           The shadow opacity.\n *\n * @property {number} [width=3]\n *           The shadow width or distance from the element.\n */\n\n/**\n * Serialized form of an SVG definition, including children. Some key\n * property names are reserved: tagName, textContent, and children.\n *\n * @typedef Highcharts.SVGDefinitionObject\n *\n * @property {number|string|Array<Highcharts.SVGDefinitionObject>|undefined} [key:string]\n *\n * @property {Array<Highcharts.SVGDefinitionObject>} [children]\n *\n * @property {string} [tagName]\n *\n * @property {string} [textContent]\n */\n\n/**\n * An extendable collection of functions for defining symbol paths.\n *\n * @typedef Highcharts.SymbolDictionary\n *\n * @property {Function} [key:Highcharts.SymbolKey]\n */\n\n/**\n * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,\n * `triangle`, `triangle-down`. Symbols are used internally for point\n * markers, button and label borders and backgrounds, or custom shapes.\n * Extendable by adding to {@link SVGRenderer#symbols}.\n *\n * @typedef {string} Highcharts.SymbolKey\n *\n * @validvalue [\"arc\", \"callout\", \"circle\", \"diamond\", \"square\", \"triangle\",\n *             \"triangle-down\"]\n */\n\n/**\n * Additional options, depending on the actual symbol drawn.\n *\n * @typedef Highcharts.SymbolOptionsObject\n *\n * @property {number} anchorX\n *           The anchor X position for the `callout` symbol. This is where\n *           the chevron points to.\n *\n * @property {number} anchorY\n *           The anchor Y position for the `callout` symbol. This is where\n *           the chevron points to.\n *\n * @property {number} end\n *           The end angle of an `arc` symbol.\n *\n * @property {boolean} open\n *           Whether to draw `arc` symbol open or closed.\n *\n * @property {number} r\n *           The radius of an `arc` symbol, or the border radius for the\n *           `callout` symbol.\n *\n * @property {number} start\n *           The start angle of an `arc` symbol.\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Color.js';\nvar SVGElement,\n    SVGRenderer,\n    addEvent = H.addEvent,\n    animate = H.animate,\n    attr = H.attr,\n    charts = H.charts,\n    color = H.color,\n    css = H.css,\n    createElement = H.createElement,\n    defined = H.defined,\n    deg2rad = H.deg2rad,\n    destroyObjectProperties = H.destroyObjectProperties,\n    doc = H.doc,\n    each = H.each,\n    extend = H.extend,\n    erase = H.erase,\n    grep = H.grep,\n    hasTouch = H.hasTouch,\n    inArray = H.inArray,\n    isArray = H.isArray,\n    isFirefox = H.isFirefox,\n    isMS = H.isMS,\n    isObject = H.isObject,\n    isString = H.isString,\n    isWebKit = H.isWebKit,\n    merge = H.merge,\n    noop = H.noop,\n    objectEach = H.objectEach,\n    pick = H.pick,\n    pInt = H.pInt,\n    removeEvent = H.removeEvent,\n    splat = H.splat,\n    stop = H.stop,\n    svg = H.svg,\n    SVG_NS = H.SVG_NS,\n    symbolSizes = H.symbolSizes,\n    win = H.win;\n/**\n * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the\n * rendering layer of Highcharts. Combined with the {@link\n * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation\n * in the charts or even in HTML pages without instanciating a chart. The\n * SVGElement can also wrap HTML labels, when `text` or `label` elements are\n * created with the `useHTML` parameter.\n *\n * The SVGElement instances are created through factory functions on the\n * {@link Highcharts.SVGRenderer} object, like\n * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link\n * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},\n * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link\n * Highcharts.SVGRenderer#g} and more.\n *\n * @class\n * @name Highcharts.SVGElement\n */\n\nSVGElement = H.SVGElement = function () {\n  return this;\n};\n\nextend(SVGElement.prototype,\n/** @lends Highcharts.SVGElement.prototype */\n{\n  // Default base for animation\n  opacity: 1,\n  SVG_NS: SVG_NS,\n\n  /**\n   * For labels, these CSS properties are applied to the `text` node directly.\n   *\n   * @private\n   * @name Highcharts.SVGElement#textProps\n   * @type {Array<string>}\n   */\n  textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color', 'lineHeight', 'width', 'textAlign', 'textDecoration', 'textOverflow', 'textOutline', 'cursor'],\n\n  /**\n   * Initialize the SVG element. This function only exists to make the\n   * initiation process overridable. It should not be called directly.\n   *\n   * @function Highcharts.SVGElement#init\n   *\n   * @param {Highcharts.SVGRenderer} renderer\n   *        The SVGRenderer instance to initialize to.\n   *\n   * @param {string} nodeName\n   *        The SVG node name.\n   */\n  init: function (renderer, nodeName) {\n    /**\n     * The primary DOM node. Each `SVGElement` instance wraps a main DOM\n     * node, but may also represent more nodes.\n     *\n     * @name Highcharts.SVGElement#element\n     * @type {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}\n     */\n    this.element = nodeName === 'span' ? createElement(nodeName) : doc.createElementNS(this.SVG_NS, nodeName);\n    /**\n     * The renderer that the SVGElement belongs to.\n     *\n     * @name Highcharts.SVGElement#renderer\n     * @type {Highcharts.SVGRenderer}\n     */\n\n    this.renderer = renderer;\n  },\n\n  /**\n   * Animate to given attributes or CSS properties.\n   *\n   * @sample highcharts/members/element-on/\n   *         Setting some attributes by animation\n   *\n   * @function Highcharts.SVGElement#animate\n   *\n   * @param {Highcharts.SVGAttributes} params\n   *        SVG attributes or CSS to animate.\n   *\n   * @param {Highcharts.AnimationOptionsObject} [options]\n   *        Animation options.\n   *\n   * @param {Function} [complete]\n   *        Function to perform at the end of animation.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  animate: function (params, options, complete) {\n    var animOptions = H.animObject(pick(options, this.renderer.globalAnimation, true));\n\n    if (animOptions.duration !== 0) {\n      // allows using a callback with the global animation without\n      // overwriting it\n      if (complete) {\n        animOptions.complete = complete;\n      }\n\n      animate(this, params, animOptions);\n    } else {\n      this.attr(params, null, complete);\n\n      if (animOptions.step) {\n        animOptions.step.call(this);\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Build and apply an SVG gradient out of a common JavaScript configuration\n   * object. This function is called from the attribute setters. An event\n   * hook is added for supporting other complex color types.\n   *\n   * @private\n   * @function Highcharts.SVGElement#complexColor\n   *\n   * @param {Highcharts.GradientColorObject} color\n   *        The gradient options structure.\n   *\n   * @param {string} prop\n   *        The property to apply, can either be `fill` or `stroke`.\n   *\n   * @param {Highcharts.SVGDOMElement} elem\n   *        SVG DOM element to apply the gradient on.\n   */\n  complexColor: function (color, prop, elem) {\n    var renderer = this.renderer,\n        colorObject,\n        gradName,\n        gradAttr,\n        radAttr,\n        gradients,\n        gradientObject,\n        stops,\n        stopColor,\n        stopOpacity,\n        radialReference,\n        id,\n        key = [],\n        value;\n    H.fireEvent(this.renderer, 'complexColor', {\n      args: arguments\n    }, function () {\n      // Apply linear or radial gradients\n      if (color.radialGradient) {\n        gradName = 'radialGradient';\n      } else if (color.linearGradient) {\n        gradName = 'linearGradient';\n      }\n\n      if (gradName) {\n        gradAttr = color[gradName];\n        gradients = renderer.gradients;\n        stops = color.stops;\n        radialReference = elem.radialReference; // Keep < 2.2 kompatibility\n\n        if (isArray(gradAttr)) {\n          color[gradName] = gradAttr = {\n            x1: gradAttr[0],\n            y1: gradAttr[1],\n            x2: gradAttr[2],\n            y2: gradAttr[3],\n            gradientUnits: 'userSpaceOnUse'\n          };\n        } // Correct the radial gradient for the radial reference system\n\n\n        if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n          // Save the radial attributes for updating\n          radAttr = gradAttr;\n          gradAttr = merge(gradAttr, renderer.getRadialAttr(radialReference, radAttr), {\n            gradientUnits: 'userSpaceOnUse'\n          });\n        } // Build the unique key to detect whether we need to create a\n        // new element (#1282)\n\n\n        objectEach(gradAttr, function (val, n) {\n          if (n !== 'id') {\n            key.push(n, val);\n          }\n        });\n        objectEach(stops, function (val) {\n          key.push(val);\n        });\n        key = key.join(','); // Check if a gradient object with the same config object is\n        // created within this renderer\n\n        if (gradients[key]) {\n          id = gradients[key].attr('id');\n        } else {\n          // Set the id and create the element\n          gradAttr.id = id = H.uniqueKey();\n          gradients[key] = gradientObject = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);\n          gradientObject.radAttr = radAttr; // The gradient needs to keep a list of stops to be able to\n          // destroy them\n\n          gradientObject.stops = [];\n          each(stops, function (stop) {\n            var stopObject;\n\n            if (stop[1].indexOf('rgba') === 0) {\n              colorObject = H.color(stop[1]);\n              stopColor = colorObject.get('rgb');\n              stopOpacity = colorObject.get('a');\n            } else {\n              stopColor = stop[1];\n              stopOpacity = 1;\n            }\n\n            stopObject = renderer.createElement('stop').attr({\n              offset: stop[0],\n              'stop-color': stopColor,\n              'stop-opacity': stopOpacity\n            }).add(gradientObject); // Add the stop element to the gradient\n\n            gradientObject.stops.push(stopObject);\n          });\n        } // Set the reference to the gradient object\n\n\n        value = 'url(' + renderer.url + '#' + id + ')';\n        elem.setAttribute(prop, value);\n        elem.gradient = key; // Allow the color to be concatenated into tooltips formatters\n        // etc. (#2995)\n\n        color.toString = function () {\n          return value;\n        };\n      }\n    });\n  },\n\n  /**\n   * Apply a text outline through a custom CSS property, by copying the text\n   * element and apply stroke to the copy. Used internally. Contrast checks at\n   * {@link https://jsfiddle.net/highcharts/43soe9m1/2/}.\n   *\n   * @example\n   * // Specific color\n   * text.css({\n   *    textOutline: '1px black'\n   * });\n   * // Automatic contrast\n   * text.css({\n   *    color: '#000000', // black text\n   *    textOutline: '1px contrast' // => white outline\n   * });\n   *\n   * @private\n   * @function Highcharts.SVGElement#applyTextOutline\n   *\n   * @param {string} textOutline\n   *        A custom CSS `text-outline` setting, defined by `width color`.\n   */\n  applyTextOutline: function (textOutline) {\n    var elem = this.element,\n        tspans,\n        tspan,\n        hasContrast = textOutline.indexOf('contrast') !== -1,\n        styles = {},\n        color,\n        strokeWidth,\n        firstRealChild,\n        i; // When the text shadow is set to contrast, use dark stroke for light\n    // text and vice versa.\n\n    if (hasContrast) {\n      styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n    } // Extract the stroke width and color\n\n\n    textOutline = textOutline.split(' ');\n    color = textOutline[textOutline.length - 1];\n    strokeWidth = textOutline[0];\n\n    if (strokeWidth && strokeWidth !== 'none' && H.svg) {\n      this.fakeTS = true; // Fake text shadow\n\n      tspans = [].slice.call(elem.getElementsByTagName('tspan')); // In order to get the right y position of the clone,\n      // copy over the y setter\n\n      this.ySetter = this.xSetter; // Since the stroke is applied on center of the actual outline, we\n      // need to double it to get the correct stroke-width outside the\n      // glyphs.\n\n      strokeWidth = strokeWidth.replace(/(^[\\d\\.]+)(.*?)$/g, function (match, digit, unit) {\n        return 2 * digit + unit;\n      }); // Remove shadows from previous runs. Iterate from the end to\n      // support removing items inside the cycle (#6472).\n\n      i = tspans.length;\n\n      while (i--) {\n        tspan = tspans[i];\n\n        if (tspan.getAttribute('class') === 'highcharts-text-outline') {\n          // Remove then erase\n          erase(tspans, elem.removeChild(tspan));\n        }\n      } // For each of the tspans, create a stroked copy behind it.\n\n\n      firstRealChild = elem.firstChild;\n      each(tspans, function (tspan, y) {\n        var clone; // Let the first line start at the correct X position\n\n        if (y === 0) {\n          tspan.setAttribute('x', elem.getAttribute('x'));\n          y = elem.getAttribute('y');\n          tspan.setAttribute('y', y || 0);\n\n          if (y === null) {\n            elem.setAttribute('y', 0);\n          }\n        } // Create the clone and apply outline properties\n\n\n        clone = tspan.cloneNode(1);\n        attr(clone, {\n          'class': 'highcharts-text-outline',\n          'fill': color,\n          'stroke': color,\n          'stroke-width': strokeWidth,\n          'stroke-linejoin': 'round'\n        });\n        elem.insertBefore(clone, firstRealChild);\n      });\n    }\n  },\n\n  /**\n   * Apply native and custom attributes to the SVG elements.\n   *\n   * In order to set the rotation center for rotation, set x and y to 0 and\n   * use `translateX` and `translateY` attributes to position the element\n   * instead.\n   *\n   * Attributes frequently used in Highcharts are `fill`, `stroke`,\n   * `stroke-width`.\n   *\n   * @sample highcharts/members/renderer-rect/\n   *         Setting some attributes\n   *\n   * @example\n   * // Set multiple attributes\n   * element.attr({\n   *     stroke: 'red',\n   *     fill: 'blue',\n   *     x: 10,\n   *     y: 10\n   * });\n   *\n   * // Set a single attribute\n   * element.attr('stroke', 'red');\n   *\n   * // Get an attribute\n   * element.attr('stroke'); // => 'red'\n   *\n   * @function Highcharts.SVGElement#attr\n   *\n   * @param {string|Highcharts.SVGAttributes} [hash]\n   *        The native and custom SVG attributes.\n   *\n   * @param {string} [val]\n   *        If the type of the first argument is `string`, the second can be a\n   *        value, which will serve as a single attribute setter. If the first\n   *        argument is a string and the second is undefined, the function\n   *        serves as a getter and the current value of the property is\n   *        returned.\n   *\n   * @param {Function} [complete]\n   *        A callback function to execute after setting the attributes. This\n   *        makes the function compliant and interchangeable with the\n   *        {@link SVGElement#animate} function.\n   *\n   * @param {boolean} [continueAnimation=true]\n   *        Used internally when `.attr` is called as part of an animation\n   *        step. Otherwise, calling `.attr` for an attribute will stop\n   *        animation for that attribute.\n   *\n   * @return {number|string|Highcharts.SVGElement}\n   *         If used as a setter, it returns the current\n   *         {@link Highcharts.SVGElement} so the calls can be chained. If\n   *         used as a getter, the current value of the attribute is returned.\n   */\n  attr: function (hash, val, complete, continueAnimation) {\n    var key,\n        element = this.element,\n        hasSetSymbolSize,\n        ret = this,\n        skipAttr,\n        setter; // single key-value pair\n\n    if (typeof hash === 'string' && val !== undefined) {\n      key = hash;\n      hash = {};\n      hash[key] = val;\n    } // used as a getter: first argument is a string, second is undefined\n\n\n    if (typeof hash === 'string') {\n      ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element); // setter\n    } else {\n      objectEach(hash, function eachAttribute(val, key) {\n        skipAttr = false; // Unless .attr is from the animator update, stop current\n        // running animation of this property\n\n        if (!continueAnimation) {\n          stop(this, key);\n        } // Special handling of symbol attributes\n\n\n        if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(key)) {\n          if (!hasSetSymbolSize) {\n            this.symbolAttr(hash);\n            hasSetSymbolSize = true;\n          }\n\n          skipAttr = true;\n        }\n\n        if (this.rotation && (key === 'x' || key === 'y')) {\n          this.doTransform = true;\n        }\n\n        if (!skipAttr) {\n          setter = this[key + 'Setter'] || this._defaultSetter;\n          setter.call(this, val, key, element);\n        }\n      }, this);\n      this.afterSetters();\n    } // In accordance with animate, run a complete callback\n\n\n    if (complete) {\n      complete.call(this);\n    }\n\n    return ret;\n  },\n\n  /**\n   * This method is executed in the end of `attr()`, after setting all\n   * attributes in the hash. In can be used to efficiently consolidate\n   * multiple attributes in one SVG property -- e.g., translate, rotate and\n   * scale are merged in one \"transform\" attribute in the SVG node.\n   *\n   * @private\n   * @function Highcharts.SVGElement#afterSetters\n   */\n  afterSetters: function () {\n    // Update transform. Do this outside the loop to prevent redundant\n    // updating for batch setting of attributes.\n    if (this.doTransform) {\n      this.updateTransform();\n      this.doTransform = false;\n    }\n  },\n\n  /**\n   * Add a class name to an element.\n   *\n   * @function Highcharts.SVGElement#addClass\n   *\n   * @param {string} className\n   *        The new class name to add.\n   *\n   * @param {boolean} [replace=false]\n   *        When true, the existing class name(s) will be overwritten with\n   *        the new one. When false, the new one is added.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Return the SVG element for chainability.\n   */\n  addClass: function (className, replace) {\n    var currentClassName = this.attr('class') || '';\n\n    if (currentClassName.indexOf(className) === -1) {\n      if (!replace) {\n        className = (currentClassName + (currentClassName ? ' ' : '') + className).replace('  ', ' ');\n      }\n\n      this.attr('class', className);\n    }\n\n    return this;\n  },\n\n  /**\n   * Check if an element has the given class name.\n   *\n   * @function Highcharts.SVGElement#hasClass\n   *\n   * @param {string} className\n   *        The class name to check for.\n   *\n   * @return {boolean}\n   *         Whether the class name is found.\n   */\n  hasClass: function (className) {\n    return inArray(className, (this.attr('class') || '').split(' ')) !== -1;\n  },\n\n  /**\n   * Remove a class name from the element.\n   *\n   * @function Highcharts.SVGElement#removeClass\n   *\n   * @param {string|RegExp} className\n   *        The class name to remove.\n   *\n   * @return {Highcharts.SVGElement} Returns the SVG element for chainability.\n   */\n  removeClass: function (className) {\n    return this.attr('class', (this.attr('class') || '').replace(className, ''));\n  },\n\n  /**\n   * If one of the symbol size affecting parameters are changed,\n   * check all the others only once for each call to an element's\n   * .attr() method\n   *\n   * @private\n   * @function Highcharts.SVGElement#symbolAttr\n   *\n   * @param {Highcharts.Dictionary<number|string>} hash\n   *        The attributes to set.\n   */\n  symbolAttr: function (hash) {\n    var wrapper = this;\n    each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {\n      wrapper[key] = pick(hash[key], wrapper[key]);\n    });\n    wrapper.attr({\n      d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)\n    });\n  },\n\n  /**\n   * Apply a clipping rectangle to this element.\n   *\n   * @function Highcharts.SVGElement#clip\n   *\n   * @param {Highcharts.ClipRectElement} [clipRect]\n   *        The clipping rectangle. If skipped, the current clip is removed.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVG element to allow chaining.\n   */\n  clip: function (clipRect) {\n    return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : 'none');\n  },\n\n  /**\n   * Calculate the coordinates needed for drawing a rectangle crisply and\n   * return the calculated attributes.\n   *\n   * @function Highcharts.SVGElement#crisp\n   *\n   * @param {Highcharts.RectangleObject} rect\n   *        Rectangle to crisp.\n   *\n   * @param {number} [strokeWidth]\n   *        The stroke width to consider when computing crisp positioning. It\n   *        can also be set directly on the rect parameter.\n   *\n   * @return {Highcharts.RectangleObject}\n   *         The modified rectangle arguments.\n   */\n  crisp: function (rect, strokeWidth) {\n    var wrapper = this,\n        normalizer;\n    strokeWidth = strokeWidth || rect.strokeWidth || 0; // Math.round because strokeWidth can sometimes have roundoff errors\n\n    normalizer = Math.round(strokeWidth) % 2 / 2; // normalize for crisp edges\n\n    rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n    rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n    rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);\n    rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);\n\n    if (defined(rect.strokeWidth)) {\n      rect.strokeWidth = strokeWidth;\n    }\n\n    return rect;\n  },\n\n  /**\n   * Set styles for the element. In addition to CSS styles supported by\n   * native SVG and HTML elements, there are also some custom made for\n   * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text\n   * elements.\n   *\n   * @sample highcharts/members/renderer-text-on-chart/\n   *         Styled text\n   *\n   * @function Highcharts.SVGElement#css\n   *\n   * @param {Highcharts.CSSObject} styles\n   *        The new CSS styles.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Return the SVG element for chaining.\n   */\n  css: function (styles) {\n    var oldStyles = this.styles,\n        newStyles = {},\n        elem = this.element,\n        textWidth,\n        serializedCss = '',\n        hyphenate,\n        hasNew = !oldStyles,\n        // These CSS properties are interpreted internally by the SVG\n    // renderer, but are not supported by SVG and should not be added to\n    // the DOM. In styled mode, no CSS should find its way to the DOM\n    // whatsoever (#6173, #6474).\n    svgPseudoProps = ['textOutline', 'textOverflow', 'width']; // convert legacy\n\n    if (styles && styles.color) {\n      styles.fill = styles.color;\n    } // Filter out existing styles to increase performance (#2640)\n\n\n    if (oldStyles) {\n      objectEach(styles, function (style, n) {\n        if (style !== oldStyles[n]) {\n          newStyles[n] = style;\n          hasNew = true;\n        }\n      });\n    }\n\n    if (hasNew) {\n      // Merge the new styles with the old ones\n      if (oldStyles) {\n        styles = extend(oldStyles, newStyles);\n      } // Get the text width from style\n\n\n      if (styles) {\n        // Previously set, unset it (#8234)\n        if (styles.width === null || styles.width === 'auto') {\n          delete this.textWidth; // Apply new\n        } else if (elem.nodeName.toLowerCase() === 'text' && styles.width) {\n          textWidth = this.textWidth = pInt(styles.width);\n        }\n      } // store object\n\n\n      this.styles = styles;\n\n      if (textWidth && !svg && this.renderer.forExport) {\n        delete styles.width;\n      } // Serialize and set style attribute\n\n\n      if (elem.namespaceURI === this.SVG_NS) {\n        // #7633\n        hyphenate = function (a, b) {\n          return '-' + b.toLowerCase();\n        };\n\n        objectEach(styles, function (style, n) {\n          if (inArray(n, svgPseudoProps) === -1) {\n            serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + style + ';';\n          }\n        });\n\n        if (serializedCss) {\n          attr(elem, 'style', serializedCss); // #1881\n        }\n      } else {\n        css(elem, styles);\n      }\n\n      if (this.added) {\n        // Rebuild text after added. Cache mechanisms in the buildText\n        // will prevent building if there are no significant changes.\n        if (this.element.nodeName === 'text') {\n          this.renderer.buildText(this);\n        } // Apply text outline after added\n\n\n        if (styles && styles.textOutline) {\n          this.applyTextOutline(styles.textOutline);\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Get the computed style. Only in styled mode.\n   *\n   * @example\n   * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'\n   *\n   * @function Highcharts.SVGElement#getStyle\n   *\n   * @param {string} prop\n   *        The property name to check for.\n   *\n   * @return {string}\n   *         The current computed value.\n   */\n  getStyle: function (prop) {\n    return win.getComputedStyle(this.element || this, '').getPropertyValue(prop);\n  },\n\n  /**\n   * Get the computed stroke width in pixel values. This is used extensively\n   * when drawing shapes to ensure the shapes are rendered crisp and\n   * positioned correctly relative to each other. Using\n   * `shape-rendering: crispEdges` leaves us less control over positioning,\n   * for example when we want to stack columns next to each other, or position\n   * things pixel-perfectly within the plot box.\n   *\n   * The common pattern when placing a shape is:\n   * - Create the SVGElement and add it to the DOM. In styled mode, it will\n   *   now receive a stroke width from the style sheet. In classic mode we\n   *   will add the `stroke-width` attribute.\n   * - Read the computed `elem.strokeWidth()`.\n   * - Place it based on the stroke width.\n   *\n   * @function Highcharts.SVGElement#strokeWidth\n   *\n   * @return {number}\n   *         The stroke width in pixels. Even if the given stroke widtch (in\n   *         CSS or by attributes) is based on `em` or other units, the pixel\n   *         size is returned.\n   */\n  strokeWidth: function () {\n    var val = this.getStyle('stroke-width'),\n        ret,\n        dummy; // Read pixel values directly\n\n    if (val.indexOf('px') === val.length - 2) {\n      ret = pInt(val); // Other values like em, pt etc need to be measured\n    } else {\n      dummy = doc.createElementNS(SVG_NS, 'rect');\n      attr(dummy, {\n        'width': val,\n        'stroke-width': 0\n      });\n      this.element.parentNode.appendChild(dummy);\n      ret = dummy.getBBox().width;\n      dummy.parentNode.removeChild(dummy);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Add an event listener. This is a simple setter that replaces all other\n   * events of the same type, opposed to the {@link Highcharts#addEvent}\n   * function.\n   *\n   * @sample highcharts/members/element-on/\n   *         A clickable rectangle\n   *\n   * @function Highcharts.SVGElement#on\n   *\n   * @param {string} eventType\n   *        The event type. If the type is `click`, Highcharts will internally\n   *        translate it to a `touchstart` event on touch devices, to prevent\n   *        the browser from waiting for a click event from firing.\n   *\n   * @param {Function} handler\n   *        The handler callback.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The SVGElement for chaining.\n   */\n  on: function (eventType, handler) {\n    var svgElement = this,\n        element = svgElement.element; // touch\n\n    if (hasTouch && eventType === 'click') {\n      element.ontouchstart = function (e) {\n        svgElement.touchEventFired = Date.now(); // #2269\n\n        e.preventDefault();\n        handler.call(element, e);\n      };\n\n      element.onclick = function (e) {\n        if (win.navigator.userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) {\n          handler.call(element, e);\n        }\n      };\n    } else {\n      // simplest possible event model for internal use\n      element['on' + eventType] = handler;\n    }\n\n    return this;\n  },\n\n  /**\n   * Set the coordinates needed to draw a consistent radial gradient across\n   * a shape regardless of positioning inside the chart. Used on pie slices\n   * to make all the slices have the same radial reference point.\n   *\n   * @function Highcharts.SVGElement#setRadialReference\n   *\n   * @param {Array<number>} coordinates\n   *        The center reference. The format is `[centerX, centerY, diameter]`\n   *        in pixels.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  setRadialReference: function (coordinates) {\n    var existingGradient = this.renderer.gradients[this.element.gradient];\n    this.element.radialReference = coordinates; // On redrawing objects with an existing gradient, the gradient needs\n    // to be repositioned (#3801)\n\n    if (existingGradient && existingGradient.radAttr) {\n      existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));\n    }\n\n    return this;\n  },\n\n  /**\n   * Move an object and its children by x and y values.\n   *\n   * @function Highcharts.SVGElement#translate\n   *\n   * @param {number} x\n   *        The x value.\n   *\n   * @param {number} y\n   *        The y value.\n   */\n  translate: function (x, y) {\n    return this.attr({\n      translateX: x,\n      translateY: y\n    });\n  },\n\n  /**\n   * Invert a group, rotate and flip. This is used internally on inverted\n   * charts, where the points and graphs are drawn as if not inverted, then\n   * the series group elements are inverted.\n   *\n   * @function Highcharts.SVGElement#invert\n   *\n   * @param {boolean} inverted\n   *        Whether to invert or not. An inverted shape can be un-inverted by\n   *        setting it to false.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Return the SVGElement for chaining.\n   */\n  invert: function (inverted) {\n    var wrapper = this;\n    wrapper.inverted = inverted;\n    wrapper.updateTransform();\n    return wrapper;\n  },\n\n  /**\n   * Update the transform attribute based on internal properties. Deals with\n   * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`\n   * attributes and updates the SVG `transform` attribute.\n   *\n   * @private\n   * @function Highcharts.SVGElement#updateTransform\n   */\n  updateTransform: function () {\n    var wrapper = this,\n        translateX = wrapper.translateX || 0,\n        translateY = wrapper.translateY || 0,\n        scaleX = wrapper.scaleX,\n        scaleY = wrapper.scaleY,\n        inverted = wrapper.inverted,\n        rotation = wrapper.rotation,\n        matrix = wrapper.matrix,\n        element = wrapper.element,\n        transform; // Flipping affects translate as adjustment for flipping around the\n    // group's axis\n\n    if (inverted) {\n      translateX += wrapper.width;\n      translateY += wrapper.height;\n    } // Apply translate. Nearly all transformed elements have translation,\n    // so instead of checking for translate = 0, do it always (#1767,\n    // #1846).\n\n\n    transform = ['translate(' + translateX + ',' + translateY + ')']; // apply matrix\n\n    if (defined(matrix)) {\n      transform.push('matrix(' + matrix.join(',') + ')');\n    } // apply rotation\n\n\n    if (inverted) {\n      transform.push('rotate(90) scale(-1,1)');\n    } else if (rotation) {\n      // text rotation\n      transform.push('rotate(' + rotation + ' ' + pick(this.rotationOriginX, element.getAttribute('x'), 0) + ' ' + pick(this.rotationOriginY, element.getAttribute('y') || 0) + ')');\n    } // apply scale\n\n\n    if (defined(scaleX) || defined(scaleY)) {\n      transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n    }\n\n    if (transform.length) {\n      element.setAttribute('transform', transform.join(' '));\n    }\n  },\n\n  /**\n   * Bring the element to the front. Alternatively, a new zIndex can be set.\n   *\n   * @sample highcharts/members/element-tofront/\n   *         Click an element to bring it to front\n   *\n   * @function Highcharts.SVGElement#toFront\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  toFront: function () {\n    var element = this.element;\n    element.parentNode.appendChild(element);\n    return this;\n  },\n\n  /**\n   * Align the element relative to the chart or another box.\n   *\n   * @function Highcharts.SVGElement#align\n   *\n   * @param {Highcharts.AlignObject} [alignOptions]\n   *        The alignment options. The function can be called without this\n   *        parameter in order to re-align an element after the box has been\n   *        updated.\n   *\n   * @param {boolean} [alignByTranslate]\n   *        Align element by translation.\n   *\n   * @param {string|Highcharts.BBoxObject} [box]\n   *        The box to align to, needs a width and height. When the box is a\n   *        string, it refers to an object in the Renderer. For example, when\n   *        box is `spacingBox`, it refers to `Renderer.spacingBox` which\n   *        holds `width`, `height`, `x` and `y` properties.\n   *\n   * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n   */\n  align: function (alignOptions, alignByTranslate, box) {\n    var align,\n        vAlign,\n        x,\n        y,\n        attribs = {},\n        alignTo,\n        renderer = this.renderer,\n        alignedObjects = renderer.alignedObjects,\n        alignFactor,\n        vAlignFactor; // First call on instanciate\n\n    if (alignOptions) {\n      this.alignOptions = alignOptions;\n      this.alignByTranslate = alignByTranslate;\n\n      if (!box || isString(box)) {\n        this.alignTo = alignTo = box || 'renderer'; // prevent duplicates, like legendGroup after resize\n\n        erase(alignedObjects, this);\n        alignedObjects.push(this);\n        box = null; // reassign it below\n      } // When called on resize, no arguments are supplied\n\n    } else {\n      alignOptions = this.alignOptions;\n      alignByTranslate = this.alignByTranslate;\n      alignTo = this.alignTo;\n    }\n\n    box = pick(box, renderer[alignTo], renderer); // Assign variables\n\n    align = alignOptions.align;\n    vAlign = alignOptions.verticalAlign;\n    x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n\n    y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n    // Align\n\n    if (align === 'right') {\n      alignFactor = 1;\n    } else if (align === 'center') {\n      alignFactor = 2;\n    }\n\n    if (alignFactor) {\n      x += (box.width - (alignOptions.width || 0)) / alignFactor;\n    }\n\n    attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x); // Vertical align\n\n    if (vAlign === 'bottom') {\n      vAlignFactor = 1;\n    } else if (vAlign === 'middle') {\n      vAlignFactor = 2;\n    }\n\n    if (vAlignFactor) {\n      y += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n    }\n\n    attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y); // Animate only if already placed\n\n    this[this.placed ? 'animate' : 'attr'](attribs);\n    this.placed = true;\n    this.alignAttr = attribs;\n    return this;\n  },\n\n  /**\n   * Get the bounding box (width, height, x and y) for the element. Generally\n   * used to get rendered text size. Since this is called a lot in charts,\n   * the results are cached based on text properties, in order to save DOM\n   * traffic. The returned bounding box includes the rotation, so for example\n   * a single text line of rotation 90 will report a greater height, and a\n   * width corresponding to the line-height.\n   *\n   * @sample highcharts/members/renderer-on-chart/\n   *         Draw a rectangle based on a text's bounding box\n   *\n   * @function Highcharts.SVGElement#getBBox\n   *\n   * @param {boolean} [reload]\n   *        Skip the cache and get the updated DOM bouding box.\n   *\n   * @param {number} [rot]\n   *        Override the element's rotation. This is internally used on axis\n   *        labels with a value of 0 to find out what the bounding box would\n   *        be have been if it were not rotated.\n   *\n   * @return {Highcharts.BBoxObject}\n   *         The bounding box with `x`, `y`, `width` and `height` properties.\n   */\n  getBBox: function (reload, rot) {\n    var wrapper = this,\n        bBox,\n        // = wrapper.bBox,\n    renderer = wrapper.renderer,\n        width,\n        height,\n        rotation,\n        rad,\n        element = wrapper.element,\n        styles = wrapper.styles,\n        fontSize,\n        textStr = wrapper.textStr,\n        toggleTextShadowShim,\n        cache = renderer.cache,\n        cacheKeys = renderer.cacheKeys,\n        cacheKey;\n    rotation = pick(rot, wrapper.rotation);\n    rad = rotation * deg2rad;\n    fontSize = element && SVGElement.prototype.getStyle.call(element, 'font-size'); // Avoid undefined and null (#7316)\n\n    if (defined(textStr)) {\n      cacheKey = textStr.toString(); // Since numbers are monospaced, and numerical labels appear a lot\n      // in a chart, we assume that a label of n characters has the same\n      // bounding box as others of the same length. Unless there is inner\n      // HTML in the label. In that case, leave the numbers as is (#5899).\n\n      if (cacheKey.indexOf('<') === -1) {\n        cacheKey = cacheKey.replace(/[0-9]/g, '0');\n      } // Properties that affect bounding box\n\n\n      cacheKey += ['', rotation || 0, fontSize, wrapper.textWidth, // #7874, also useHTML\n      styles && styles.textOverflow // #5968\n      ].join(',');\n    }\n\n    if (cacheKey && !reload) {\n      bBox = cache[cacheKey];\n    } // No cache found\n\n\n    if (!bBox) {\n      // SVG elements\n      if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {\n        try {\n          // Fails in Firefox if the container has display: none.\n          // When the text shadow shim is used, we need to hide the\n          // fake shadows to get the correct bounding box (#3872)\n          toggleTextShadowShim = this.fakeTS && function (display) {\n            each(element.querySelectorAll('.highcharts-text-outline'), function (tspan) {\n              tspan.style.display = display;\n            });\n          }; // Workaround for #3842, Firefox reporting wrong bounding\n          // box for shadows\n\n\n          if (toggleTextShadowShim) {\n            toggleTextShadowShim('none');\n          }\n\n          bBox = element.getBBox ? // SVG: use extend because IE9 is not allowed to change\n          // width and height in case of rotation (below)\n          extend({}, element.getBBox()) : {\n            // Legacy IE in export mode\n            width: element.offsetWidth,\n            height: element.offsetHeight\n          }; // #3842\n\n          if (toggleTextShadowShim) {\n            toggleTextShadowShim('');\n          }\n        } catch (e) {} // If the bBox is not set, the try-catch block above failed. The\n        // other condition is for Opera that returns a width of\n        // -Infinity on hidden elements.\n\n\n        if (!bBox || bBox.width < 0) {\n          bBox = {\n            width: 0,\n            height: 0\n          };\n        } // VML Renderer or useHTML within SVG\n\n      } else {\n        bBox = wrapper.htmlGetBBox();\n      } // True SVG elements as well as HTML elements in modern browsers\n      // using the .useHTML option need to compensated for rotation\n\n\n      if (renderer.isSVG) {\n        width = bBox.width;\n        height = bBox.height; // Workaround for wrong bounding box in IE, Edge and Chrome on\n        // Windows. With Highcharts' default font, IE and Edge report\n        // a box height of 16.899 and Chrome rounds it to 17. If this\n        // stands uncorrected, it results in more padding added below\n        // the text than above when adding a label border or background.\n        // Also vertical positioning is affected.\n        // https://jsfiddle.net/highcharts/em37nvuj/\n        // (#1101, #1505, #1669, #2568, #6213).\n\n        if (styles && styles.fontSize === '11px' && Math.round(height) === 17) {\n          bBox.height = height = 14;\n        } // Adjust for rotated text\n\n\n        if (rotation) {\n          bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));\n          bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));\n        }\n      } // Cache it. When loading a chart in a hidden iframe in Firefox and\n      // IE/Edge, the bounding box height is 0, so don't cache it (#5620).\n\n\n      if (cacheKey && bBox.height > 0) {\n        // Rotate (#4681)\n        while (cacheKeys.length > 250) {\n          delete cache[cacheKeys.shift()];\n        }\n\n        if (!cache[cacheKey]) {\n          cacheKeys.push(cacheKey);\n        }\n\n        cache[cacheKey] = bBox;\n      }\n    }\n\n    return bBox;\n  },\n\n  /**\n   * Show the element after it has been hidden.\n   *\n   * @function Highcharts.SVGElement#show\n   *\n   * @param {boolean} [inherit=false]\n   *        Set the visibility attribute to `inherit` rather than `visible`.\n   *        The difference is that an element with `visibility=\"visible\"`\n   *        will be visible even if the parent is hidden.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  show: function (inherit) {\n    return this.attr({\n      visibility: inherit ? 'inherit' : 'visible'\n    });\n  },\n\n  /**\n   * Hide the element, equivalent to setting the `visibility` attribute to\n   * `hidden`.\n   *\n   * @function Highcharts.SVGElement#hide\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  hide: function () {\n    return this.attr({\n      visibility: 'hidden'\n    });\n  },\n\n  /**\n   * Fade out an element by animating its opacity down to 0, and hide it on\n   * complete. Used internally for the tooltip.\n   *\n   * @function Highcharts.SVGElement#fadeOut\n   *\n   * @param {number} [duration=150]\n   *        The fade duration in milliseconds.\n   */\n  fadeOut: function (duration) {\n    var elemWrapper = this;\n    elemWrapper.animate({\n      opacity: 0\n    }, {\n      duration: duration || 150,\n      complete: function () {\n        // #3088, assuming we're only using this for tooltips\n        elemWrapper.attr({\n          y: -9999\n        });\n      }\n    });\n  },\n\n  /**\n   * Add the element to the DOM. All elements must be added this way.\n   *\n   * @sample highcharts/members/renderer-g\n   *         Elements added to a group\n   *\n   * @function Highcharts.SVGElement#add\n   *\n   * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [parent]\n   *        The parent item to add it to. If undefined, the element is added\n   *        to the {@link Highcharts.SVGRenderer.box}.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  add: function (parent) {\n    var renderer = this.renderer,\n        element = this.element,\n        inserted;\n\n    if (parent) {\n      this.parentGroup = parent;\n    } // mark as inverted\n\n\n    this.parentInverted = parent && parent.inverted; // build formatted text\n\n    if (this.textStr !== undefined) {\n      renderer.buildText(this);\n    } // Mark as added\n\n\n    this.added = true; // If we're adding to renderer root, or other elements in the group\n    // have a z index, we need to handle it\n\n    if (!parent || parent.handleZ || this.zIndex) {\n      inserted = this.zIndexSetter();\n    } // If zIndex is not handled, append at the end\n\n\n    if (!inserted) {\n      (parent ? parent.element : renderer.box).appendChild(element);\n    } // fire an event for internal hooks\n\n\n    if (this.onAdd) {\n      this.onAdd();\n    }\n\n    return this;\n  },\n\n  /**\n   * Removes an element from the DOM.\n   *\n   * @private\n   * @function Highcharts.SVGElement#safeRemoveChild\n   *\n   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n   *        The DOM node to remove.\n   */\n  safeRemoveChild: function (element) {\n    var parentNode = element.parentNode;\n\n    if (parentNode) {\n      parentNode.removeChild(element);\n    }\n  },\n\n  /**\n   * Destroy the element and element wrapper and clear up the DOM and event\n   * hooks.\n   *\n   * @function Highcharts.SVGElement#destroy\n   */\n  destroy: function () {\n    var wrapper = this,\n        element = wrapper.element || {},\n        parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,\n        grandParent,\n        ownerSVGElement = element.ownerSVGElement,\n        i,\n        clipPath = wrapper.clipPath; // remove events\n\n    element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n    stop(wrapper); // stop running animations\n\n    if (clipPath && ownerSVGElement) {\n      // Look for existing references to this clipPath and remove them\n      // before destroying the element (#6196).\n      each( // The upper case version is for Edge\n      ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'), function (el) {\n        var clipPathAttr = el.getAttribute('clip-path'),\n            clipPathId = clipPath.element.id; // Include the closing paranthesis in the test to rule out\n        // id's from 10 and above (#6550). Edge puts quotes inside\n        // the url, others not.\n\n        if (clipPathAttr.indexOf('(#' + clipPathId + ')') > -1 || clipPathAttr.indexOf('(\"#' + clipPathId + '\")') > -1) {\n          el.removeAttribute('clip-path');\n        }\n      });\n      wrapper.clipPath = clipPath.destroy();\n    } // Destroy stops in case this is a gradient object\n\n\n    if (wrapper.stops) {\n      for (i = 0; i < wrapper.stops.length; i++) {\n        wrapper.stops[i] = wrapper.stops[i].destroy();\n      }\n\n      wrapper.stops = null;\n    } // remove element\n\n\n    wrapper.safeRemoveChild(element); // In case of useHTML, clean up empty containers emulating SVG groups\n    // (#1960, #2393, #2697).\n\n    while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n      grandParent = parentToClean.parentGroup;\n      wrapper.safeRemoveChild(parentToClean.div);\n      delete parentToClean.div;\n      parentToClean = grandParent;\n    } // remove from alignObjects\n\n\n    if (wrapper.alignTo) {\n      erase(wrapper.renderer.alignedObjects, wrapper);\n    }\n\n    objectEach(wrapper, function (val, key) {\n      delete wrapper[key];\n    });\n    return null;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#xGetter\n   *\n   * @param {string} key\n   *\n   * @return {number|string|null}\n   */\n  xGetter: function (key) {\n    if (this.element.nodeName === 'circle') {\n      if (key === 'x') {\n        key = 'cx';\n      } else if (key === 'y') {\n        key = 'cy';\n      }\n    }\n\n    return this._defaultGetter(key);\n  },\n\n  /**\n   * Get the current value of an attribute or pseudo attribute,\n   * used mainly for animation. Called internally from\n   * the {@link Highcharts.SVGRenderer#attr} function.\n   *\n   * @private\n   * @function Highcharts.SVGElement#_defaultGetter\n   *\n   * @param {string} key\n   *        Property key.\n   *\n   * @return {number|string|null}\n   *         Property value.\n   */\n  _defaultGetter: function (key) {\n    var ret = pick(this[key + 'Value'], // align getter\n    this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n    if (/^[\\-0-9\\.]+$/.test(ret)) {\n      // is numerical\n      ret = parseFloat(ret);\n    }\n\n    return ret;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#dSettter\n   *\n   * @param {number|string|Highcharts.SVGPathArray} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  dSetter: function (value, key, element) {\n    if (value && value.join) {\n      // join path\n      value = value.join(' ');\n    }\n\n    if (/(NaN| {2}|^$)/.test(value)) {\n      value = 'M 0 0';\n    } // Check for cache before resetting. Resetting causes disturbance in the\n    // DOM, causing flickering in some cases in Edge/IE (#6747). Also\n    // possible performance gain.\n\n\n    if (this[key] !== value) {\n      element.setAttribute(key, value);\n      this[key] = value;\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#alignSetter\n   *\n   * @param {\"start\"|\"middle\"|\"end\"} value\n   */\n  alignSetter: function (value) {\n    var convert = {\n      left: 'start',\n      center: 'middle',\n      right: 'end'\n    };\n    this.alignValue = value;\n    this.element.setAttribute('text-anchor', convert[value]);\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#opacitySetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  opacitySetter: function (value, key, element) {\n    this[key] = value;\n    element.setAttribute(key, value);\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#titleSetter\n   *\n   * @param {string} value\n   */\n  titleSetter: function (value) {\n    var titleNode = this.element.getElementsByTagName('title')[0];\n\n    if (!titleNode) {\n      titleNode = doc.createElementNS(this.SVG_NS, 'title');\n      this.element.appendChild(titleNode);\n    } // Remove text content if it exists\n\n\n    if (titleNode.firstChild) {\n      titleNode.removeChild(titleNode.firstChild);\n    }\n\n    titleNode.appendChild(doc.createTextNode( // #3276, #3895\n    String(pick(value), '').replace(/<[^>]*>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>')));\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#textSetter\n   *\n   * @param {string} value\n   */\n  textSetter: function (value) {\n    if (value !== this.textStr) {\n      // Delete bBox memo when the text changes\n      delete this.bBox;\n      this.textStr = value;\n\n      if (this.added) {\n        this.renderer.buildText(this);\n      }\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#fillSetter\n   *\n   * @param {Highcharts.Color|Highcharts.ColorString} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  fillSetter: function (value, key, element) {\n    if (typeof value === 'string') {\n      element.setAttribute(key, value);\n    } else if (value) {\n      this.complexColor(value, key, element);\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#visibilitySetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  visibilitySetter: function (value, key, element) {\n    // IE9-11 doesn't handle visibilty:inherit well, so we remove the\n    // attribute instead (#2881, #3909)\n    if (value === 'inherit') {\n      element.removeAttribute(key);\n    } else if (this[key] !== value) {\n      // #6747\n      element.setAttribute(key, value);\n    }\n\n    this[key] = value;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#zIndexSetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @return {boolean}\n   */\n  zIndexSetter: function (value, key) {\n    var renderer = this.renderer,\n        parentGroup = this.parentGroup,\n        parentWrapper = parentGroup || renderer,\n        parentNode = parentWrapper.element || renderer.box,\n        childNodes,\n        otherElement,\n        otherZIndex,\n        element = this.element,\n        inserted,\n        undefinedOtherZIndex,\n        svgParent = parentNode === renderer.box,\n        run = this.added,\n        i;\n\n    if (defined(value)) {\n      // So we can read it for other elements in the group\n      element.setAttribute('data-z-index', value);\n      value = +value;\n\n      if (this[key] === value) {\n        // Only update when needed (#3865)\n        run = false;\n      }\n    } else if (defined(this[key])) {\n      element.removeAttribute('data-z-index');\n    }\n\n    this[key] = value; // Insert according to this and other elements' zIndex. Before .add() is\n    // called, nothing is done. Then on add, or by later calls to\n    // zIndexSetter, the node is placed on the right place in the DOM.\n\n    if (run) {\n      value = this.zIndex;\n\n      if (value && parentGroup) {\n        parentGroup.handleZ = true;\n      }\n\n      childNodes = parentNode.childNodes;\n\n      for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {\n        otherElement = childNodes[i];\n        otherZIndex = otherElement.getAttribute('data-z-index');\n        undefinedOtherZIndex = !defined(otherZIndex);\n\n        if (otherElement !== element) {\n          if ( // Negative zIndex versus no zIndex:\n          // On all levels except the highest. If the parent is\n          // <svg>, then we don't want to put items before <desc>\n          // or <defs>\n          value < 0 && undefinedOtherZIndex && !svgParent && !i) {\n            parentNode.insertBefore(element, childNodes[i]);\n            inserted = true;\n          } else if ( // Insert after the first element with a lower zIndex\n          pInt(otherZIndex) <= value || // If negative zIndex, add this before first undefined\n          // zIndex element\n          undefinedOtherZIndex && (!defined(value) || value >= 0)) {\n            parentNode.insertBefore(element, childNodes[i + 1] || null // null for oldIE export\n            );\n            inserted = true;\n          }\n        }\n      }\n\n      if (!inserted) {\n        parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0] || null // null for oldIE\n        );\n        inserted = true;\n      }\n    }\n\n    return inserted;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.SVGElement#_defaultSetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  _defaultSetter: function (value, key, element) {\n    element.setAttribute(key, value);\n  }\n}); // Some shared setters and getters\n\nSVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\n\nSVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.matrixSetter = function (value, key) {\n  this[key] = value;\n  this.doTransform = true;\n};\n/**\n * Allows direct access to the Highcharts rendering layer in order to draw\n * primitive shapes like circles, rectangles, paths or text directly on a chart,\n * or independent from any chart. The SVGRenderer represents a wrapper object\n * for SVG in modern browsers. Through the VMLRenderer, part of the `oldie.js`\n * module, it also brings vector graphics to IE <= 8.\n *\n * An existing chart's renderer can be accessed through {@link Chart.renderer}.\n * The renderer can also be used completely decoupled from a chart.\n *\n * @sample highcharts/members/renderer-on-chart\n *         Annotating a chart programmatically.\n * @sample highcharts/members/renderer-basic\n *         Independent SVG drawing.\n *\n * @example\n * // Use directly without a chart object.\n * var renderer = new Highcharts.Renderer(parentNode, 600, 400);\n *\n * @class\n * @name Highcharts.SVGRenderer\n *\n * @param {Highcharts.HTMLDOMElement} container\n *        Where to put the SVG in the web page.\n *\n * @param {number} width\n *        The width of the SVG.\n *\n * @param {number} height\n *        The height of the SVG.\n *\n * @param {boolean} [forExport=false]\n *        Whether the rendered content is intended for export.\n *\n * @param {boolean} [allowHTML=true]\n *        Whether the renderer is allowed to include HTML text, which will be\n *        projected on top of the SVG.\n */\n\n\nSVGRenderer = H.SVGRenderer = function () {\n  this.init.apply(this, arguments);\n};\n\nextend(SVGRenderer.prototype,\n/** @lends Highcharts.SVGRenderer.prototype */\n{\n  /**\n   * A pointer to the renderer's associated Element class. The VMLRenderer\n   * will have a pointer to VMLElement here.\n   *\n   * @name Highcharts.SVGRenderer#Element\n   * @type {Highcharts.SVGElement}\n   */\n  Element: SVGElement,\n  SVG_NS: SVG_NS,\n\n  /**\n   * Initialize the SVGRenderer. Overridable initiator function that takes\n   * the same parameters as the constructor.\n   *\n   * @function Highcharts.SVGRenderer#init\n   *\n   * @param {Highcharts.HTMLDOMElement} container\n   *        Where to put the SVG in the web page.\n   *\n   * @param {number} width\n   *        The width of the SVG.\n   *\n   * @param {number} height\n   *        The height of the SVG.\n   *\n   * @param {boolean} [forExport=false]\n   *        Whether the rendered content is intended for export.\n   *\n   * @param {boolean} [allowHTML=true]\n   *        Whether the renderer is allowed to include HTML text, which will\n   *        be projected on top of the SVG.\n   */\n  init: function (container, width, height, style, forExport, allowHTML) {\n    var renderer = this,\n        boxWrapper,\n        element,\n        desc;\n    boxWrapper = renderer.createElement('svg').attr({\n      'version': '1.1',\n      'class': 'highcharts-root'\n    });\n    element = boxWrapper.element;\n    container.appendChild(element); // Always use ltr on the container, otherwise text-anchor will be\n    // flipped and text appear outside labels, buttons, tooltip etc (#3482)\n\n    attr(container, 'dir', 'ltr'); // For browsers other than IE, add the namespace attribute (#1978)\n\n    if (container.innerHTML.indexOf('xmlns') === -1) {\n      attr(element, 'xmlns', this.SVG_NS);\n    } // object properties\n\n\n    renderer.isSVG = true;\n    /**\n     * The root `svg` node of the renderer.\n     *\n     * @name Highcharts.SVGRenderer#box\n     * @type {Highcharts.SVGDOMElement}\n     */\n\n    this.box = element;\n    /**\n     * The wrapper for the root `svg` node of the renderer.\n     *\n     * @name Highcharts.SVGRenderer#boxWrapper\n     * @type {Highcharts.SVGElement}\n     */\n\n    this.boxWrapper = boxWrapper;\n    renderer.alignedObjects = [];\n    /**\n     * Page url used for internal references.\n     *\n     * @private\n     * @name Highcharts.SVGRenderer#url\n     * @type {string}\n     */\n    // #24, #672, #1070\n\n    this.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ? win.location.href.split('#')[0] // remove the hash\n    .replace(/<[^>]*>/g, '') // wing cut HTML\n    // escape parantheses and quotes\n    .replace(/([\\('\\)])/g, '\\\\$1') // replace spaces (needed for Safari only)\n    .replace(/ /g, '%20') : ''; // Add description\n\n    desc = this.createElement('desc').add();\n    desc.element.appendChild(doc.createTextNode('Created with @product.name@ @product.version@'));\n    /**\n     * A pointer to the `defs` node of the root SVG.\n     *\n     * @name Highcharts.SVGRenderer#defs\n     * @type {Highcharts.SVGElement}\n     */\n\n    renderer.defs = this.createElement('defs').add();\n    renderer.allowHTML = allowHTML;\n    renderer.forExport = forExport;\n    renderer.gradients = {}; // Object where gradient SvgElements are stored\n\n    renderer.cache = {}; // Cache for numerical bounding boxes\n\n    renderer.cacheKeys = [];\n    renderer.imgCount = 0;\n    renderer.setSize(width, height, false); // Issue 110 workaround:\n    // In Firefox, if a div is positioned by percentage, its pixel position\n    // may land between pixels. The container itself doesn't display this,\n    // but an SVG element inside this container will be drawn at subpixel\n    // precision. In order to draw sharp lines, this must be compensated\n    // for. This doesn't seem to work inside iframes though (like in\n    // jsFiddle).\n\n    var subPixelFix, rect;\n\n    if (isFirefox && container.getBoundingClientRect) {\n      subPixelFix = function () {\n        css(container, {\n          left: 0,\n          top: 0\n        });\n        rect = container.getBoundingClientRect();\n        css(container, {\n          left: Math.ceil(rect.left) - rect.left + 'px',\n          top: Math.ceil(rect.top) - rect.top + 'px'\n        });\n      }; // run the fix now\n\n\n      subPixelFix(); // run it on resize\n\n      renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);\n    }\n  },\n\n  /**\n   * General method for adding a definition to the SVG `defs` tag. Can be used\n   * for gradients, fills, filters etc. Styled mode only. A hook for adding\n   * general definitions to the SVG's defs tag. Definitions can be referenced\n   * from the CSS by its `id`. Read more in\n   * {@link https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns|gradients, shadows and patterns}.\n   * Styled mode only.\n   *\n   * @function Highcharts.SVGRenderer#definition\n   *\n   * @param {Highcharts.SVGDefinitionObject} def\n   *        A serialized form of an SVG definition, including children.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The inserted node.\n   */\n  definition: function (def) {\n    var ren = this;\n\n    function recurse(config, parent) {\n      var ret;\n      each(splat(config), function (item) {\n        var node = ren.createElement(item.tagName),\n            attr = {}; // Set attributes\n\n        objectEach(item, function (val, key) {\n          if (key !== 'tagName' && key !== 'children' && key !== 'textContent') {\n            attr[key] = val;\n          }\n        });\n        node.attr(attr); // Add to the tree\n\n        node.add(parent || ren.defs); // Add text content\n\n        if (item.textContent) {\n          node.element.appendChild(doc.createTextNode(item.textContent));\n        } // Recurse\n\n\n        recurse(item.children || [], node);\n        ret = node;\n      }); // Return last node added (on top level it's the only one)\n\n      return ret;\n    }\n\n    return recurse(def);\n  },\n\n  /**\n   * Detect whether the renderer is hidden. This happens when one of the\n   * parent elements has `display: none`. Used internally to detect when we\n   * needto render preliminarily in another div to get the text bounding boxes\n   * right.\n   *\n   * @function Highcharts.SVGRenderer#isHidden\n   *\n   * @return {boolean}\n   *         True if it is hidden.\n   */\n  isHidden: function () {\n    // #608\n    return !this.boxWrapper.getBBox().width;\n  },\n\n  /**\n   * Destroys the renderer and its allocated members.\n   *\n   * @function Highcharts.SVGRenderer#destroy\n   */\n  destroy: function () {\n    var renderer = this,\n        rendererDefs = renderer.defs;\n    renderer.box = null;\n    renderer.boxWrapper = renderer.boxWrapper.destroy(); // Call destroy on all gradient elements\n\n    destroyObjectProperties(renderer.gradients || {});\n    renderer.gradients = null; // Defs are null in VMLRenderer\n    // Otherwise, destroy them here.\n\n    if (rendererDefs) {\n      renderer.defs = rendererDefs.destroy();\n    } // Remove sub pixel fix handler (#982)\n\n\n    if (renderer.unSubPixelFix) {\n      renderer.unSubPixelFix();\n    }\n\n    renderer.alignedObjects = null;\n    return null;\n  },\n\n  /**\n   * Create a wrapper for an SVG element. Serves as a factory for\n   * {@link SVGElement}, but this function is itself mostly called from\n   * primitive factories like {@link SVGRenderer#path}, {@link\n   * SVGRenderer#rect} or {@link SVGRenderer#text}.\n   *\n   * @function Highcharts.SVGRenderer#createElement\n   *\n   * @param {string} nodeName\n   *        The node name, for example `rect`, `g` etc.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated SVGElement.\n   */\n  createElement: function (nodeName) {\n    var wrapper = new this.Element();\n    wrapper.init(this, nodeName);\n    return wrapper;\n  },\n\n  /**\n   * Dummy function for plugins, called every time the renderer is updated.\n   * Prior to Highcharts 5, this was used for the canvg renderer.\n   *\n   * @deprecated\n   * @function Highcharts.SVGRenderer#draw\n   */\n  draw: noop,\n\n  /**\n   * Get converted radial gradient attributes according to the radial\n   * reference. Used internally from the {@link SVGElement#colorGradient}\n   * function.\n   *\n   * @private\n   * @function Highcharts.SVGRenderer#getRadialAttr\n   *\n   * @param {Array<number>} radialReference\n   *\n   * @param {Highcharts.SVGAttributes} gradAttr\n   *\n   * @return {Highcharts.SVGAttributes}\n   */\n  getRadialAttr: function (radialReference, gradAttr) {\n    return {\n      cx: radialReference[0] - radialReference[2] / 2 + gradAttr.cx * radialReference[2],\n      cy: radialReference[1] - radialReference[2] / 2 + gradAttr.cy * radialReference[2],\n      r: gradAttr.r * radialReference[2]\n    };\n  },\n\n  /**\n   * Truncate the text node contents to a given length. Used when the css\n   * width is set. If the `textOverflow` is `ellipsis`, the text is truncated\n   * character by character to the given length. If not, the text is\n   * word-wrapped line by line.\n   *\n   * @private\n   * @function Highcharts.SVGRenderer#truncate\n   *\n   * @param {Highcharts.SVGElement} wrapper\n   *\n   * @param {Highcharts.SVGDOMElement} tspan\n   *\n   * @param {string} text\n   *\n   * @param {Array.<string>} words\n   *\n   * @param {number} width\n   *\n   * @param {Function} getString\n   *\n   * @return {boolean}\n   *         True if tspan is too long.\n   */\n  truncate: function (wrapper, tspan, text, words, startAt, width, getString) {\n    var renderer = this,\n        rotation = wrapper.rotation,\n        str,\n        // Word wrap can not be truncated to shorter than one word, ellipsis\n    // text can be completely blank.\n    minIndex = words ? 1 : 0,\n        maxIndex = (text || words).length,\n        currentIndex = maxIndex,\n        // Cache the lengths to avoid checking the same twice\n    lengths = [],\n        updateTSpan = function (s) {\n      if (tspan.firstChild) {\n        tspan.removeChild(tspan.firstChild);\n      }\n\n      if (s) {\n        tspan.appendChild(doc.createTextNode(s));\n      }\n    },\n        getSubStringLength = function (charEnd, concatenatedEnd) {\n      // charEnd is useed when finding the character-by-character\n      // break for ellipsis, concatenatedEnd is used for word-by-word\n      // break for word wrapping.\n      var end = concatenatedEnd || charEnd;\n\n      if (lengths[end] === undefined) {\n        // Modern browsers\n        if (tspan.getSubStringLength) {\n          // Fails with DOM exception on unit-tests/legend/members\n          // of unknown reason. Desired width is 0, text content\n          // is \"5\" and end is 1.\n          try {\n            lengths[end] = startAt + tspan.getSubStringLength(0, words ? end + 1 : end);\n          } catch (e) {} // Legacy\n\n        } else {\n          updateTSpan(getString(text || words, charEnd));\n          lengths[end] = startAt + renderer.getSpanWidth(wrapper, tspan);\n        }\n      }\n\n      return lengths[end];\n    },\n        actualWidth,\n        truncated;\n\n    wrapper.rotation = 0; // discard rotation when computing box\n\n    actualWidth = getSubStringLength(tspan.textContent.length);\n    truncated = startAt + actualWidth > width;\n\n    if (truncated) {\n      // Do a binary search for the index where to truncate the text\n      while (minIndex <= maxIndex) {\n        currentIndex = Math.ceil((minIndex + maxIndex) / 2); // When checking words for word-wrap, we need to build the\n        // string and measure the subStringLength at the concatenated\n        // word length.\n\n        if (words) {\n          str = getString(words, currentIndex);\n        }\n\n        actualWidth = getSubStringLength(currentIndex, str && str.length - 1);\n\n        if (minIndex === maxIndex) {\n          // Complete\n          minIndex = maxIndex + 1;\n        } else if (actualWidth > width) {\n          // Too large. Set max index to current.\n          maxIndex = currentIndex - 1;\n        } else {\n          // Within width. Set min index to current.\n          minIndex = currentIndex;\n        }\n      } // If max index was 0 it means the shortest possible text was also\n      // too large. For ellipsis that means only the ellipsis, while for\n      // word wrap it means the whole first word.\n\n\n      if (maxIndex === 0) {\n        // Remove ellipsis\n        updateTSpan(''); // If the new text length is one less than the original, we don't\n        // need the ellipsis\n      } else if (!(text && maxIndex === text.length - 1)) {\n        updateTSpan(str || getString(text || words, currentIndex));\n      }\n    } // When doing line wrapping, prepare for the next line by removing the\n    // items from this line.\n\n\n    if (words) {\n      words.splice(0, currentIndex);\n    }\n\n    wrapper.actualWidth = actualWidth;\n    wrapper.rotation = rotation; // Apply rotation again.\n\n    return truncated;\n  },\n\n  /**\n   * A collection of characters mapped to HTML entities. When `useHTML` on an\n   * element is true, these entities will be rendered correctly by HTML. In\n   * the SVG pseudo-HTML, they need to be unescaped back to simple characters,\n   * so for example `&lt;` will render as `<`.\n   *\n   * @example\n   * // Add support for unescaping quotes\n   * Highcharts.SVGRenderer.prototype.escapes['\"'] = '&quot;';\n   *\n   * @name Highcharts.SVGRenderer#escapes\n   * @type {Highcharts.Dictionary<string>}\n   */\n  escapes: {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    \"'\": '&#39;',\n    // eslint-disable-line quotes\n    '\"': '&quot;'\n  },\n\n  /**\n   * Parse a simple HTML string into SVG tspans. Called internally when text\n   * is set on an SVGElement. The function supports a subset of HTML tags, CSS\n   * text features like `width`, `text-overflow`, `white-space`, and also\n   * attributes like `href` and `style`.\n   *\n   * @private\n   * @function Highcharts.SVGRenderer#buildText\n   *\n   * @param {Highcharts.SVGElement} wrapper\n   *        The parent SVGElement.\n   */\n  buildText: function (wrapper) {\n    var textNode = wrapper.element,\n        renderer = this,\n        forExport = renderer.forExport,\n        textStr = pick(wrapper.textStr, '').toString(),\n        hasMarkup = textStr.indexOf('<') !== -1,\n        lines,\n        childNodes = textNode.childNodes,\n        truncated,\n        parentX = attr(textNode, 'x'),\n        textStyles = wrapper.styles,\n        width = wrapper.textWidth,\n        textLineHeight = textStyles && textStyles.lineHeight,\n        textOutline = textStyles && textStyles.textOutline,\n        ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n        noWrap = textStyles && textStyles.whiteSpace === 'nowrap',\n        fontSize = textStyles && textStyles.fontSize,\n        textCache,\n        isSubsequentLine,\n        i = childNodes.length,\n        tempParent = width && !wrapper.added && this.box,\n        getLineHeight = function (tspan) {\n      var fontSizeStyle;\n      return textLineHeight ? pInt(textLineHeight) : renderer.fontMetrics(fontSizeStyle, // Get the computed size from parent if not explicit\n      tspan.getAttribute('style') ? tspan : textNode).h;\n    },\n        unescapeEntities = function (inputStr, except) {\n      objectEach(renderer.escapes, function (value, key) {\n        if (!except || inArray(value, except) === -1) {\n          inputStr = inputStr.toString().replace(new RegExp(value, 'g'), // eslint-disable-line security/detect-non-literal-regexp\n          key);\n        }\n      });\n      return inputStr;\n    },\n        parseAttribute = function (s, attr) {\n      var start, delimiter;\n      start = s.indexOf('<');\n      s = s.substring(start, s.indexOf('>') - start);\n      start = s.indexOf(attr + '=');\n\n      if (start !== -1) {\n        start = start + attr.length + 1;\n        delimiter = s.charAt(start);\n\n        if (delimiter === '\"' || delimiter === \"'\") {\n          // eslint-disable-line quotes\n          s = s.substring(start + 1);\n          return s.substring(0, s.indexOf(delimiter));\n        }\n      }\n    }; // The buildText code is quite heavy, so if we're not changing something\n    // that affects the text, skip it (#6113).\n\n\n    textCache = [textStr, ellipsis, noWrap, textLineHeight, textOutline, fontSize, width].join(',');\n\n    if (textCache === wrapper.textCache) {\n      return;\n    }\n\n    wrapper.textCache = textCache; // Remove old text\n\n    while (i--) {\n      textNode.removeChild(childNodes[i]);\n    } // Skip tspans, add text directly to text node. The forceTSpan is a hook\n    // used in text outline hack.\n\n\n    if (!hasMarkup && !textOutline && !ellipsis && !width && textStr.indexOf(' ') === -1) {\n      textNode.appendChild(doc.createTextNode(unescapeEntities(textStr))); // Complex strings, add more logic\n    } else {\n      if (tempParent) {\n        // attach it to the DOM to read offset width\n        tempParent.appendChild(textNode);\n      }\n\n      if (hasMarkup) {\n        lines = textStr.replace(/<(b|strong)>/g, '<span class=\"highcharts-strong\">').replace(/<(i|em)>/g, '<span class=\"highcharts-emphasized\">').replace(/<a/g, '<span').replace(/<\\/(b|strong|i|em|a)>/g, '</span>').split(/<br.*?>/g);\n      } else {\n        lines = [textStr];\n      } // Trim empty lines (#5261)\n\n\n      lines = grep(lines, function (line) {\n        return line !== '';\n      }); // build the lines\n\n      each(lines, function buildTextLines(line, lineNo) {\n        var spans,\n            spanNo = 0,\n            lineLength = 0;\n        line = line // Trim to prevent useless/costly process on the spaces\n        // (#5258)\n        .replace(/^\\s+|\\s+$/g, '').replace(/<span/g, '|||<span').replace(/<\\/span>/g, '</span>|||');\n        spans = line.split('|||');\n        each(spans, function buildTextSpans(span) {\n          if (span !== '' || spans.length === 1) {\n            var attributes = {},\n                tspan = doc.createElementNS(renderer.SVG_NS, 'tspan'),\n                classAttribute,\n                styleAttribute,\n                // #390\n            hrefAttribute;\n            classAttribute = parseAttribute(span, 'class');\n\n            if (classAttribute) {\n              attr(tspan, 'class', classAttribute);\n            }\n\n            styleAttribute = parseAttribute(span, 'style');\n\n            if (styleAttribute) {\n              styleAttribute = styleAttribute.replace(/(;| |^)color([ :])/, '$1fill$2');\n              attr(tspan, 'style', styleAttribute);\n            } // Not for export - #1529\n\n\n            hrefAttribute = parseAttribute(span, 'href');\n\n            if (hrefAttribute && !forExport) {\n              attr(tspan, 'onclick', 'location.href=\\\"' + hrefAttribute + '\\\"');\n              attr(tspan, 'class', 'highcharts-anchor');\n            } // Strip away unsupported HTML tags (#7126)\n\n\n            span = unescapeEntities(span.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, '') || ' '); // Nested tags aren't supported, and cause crash in\n            // Safari (#1596)\n\n            if (span !== ' ') {\n              // add the text node\n              tspan.appendChild(doc.createTextNode(span)); // First span in a line, align it to the left\n\n              if (!spanNo) {\n                if (lineNo && parentX !== null) {\n                  attributes.x = parentX;\n                }\n              } else {\n                attributes.dx = 0; // #16\n              } // add attributes\n\n\n              attr(tspan, attributes); // Append it\n\n              textNode.appendChild(tspan); // first span on subsequent line, add the line\n              // height\n\n              if (!spanNo && isSubsequentLine) {\n                // allow getting the right offset height in\n                // exporting in IE\n                if (!svg && forExport) {\n                  css(tspan, {\n                    display: 'block'\n                  });\n                } // Set the line height based on the font size of\n                // either the text element or the tspan element\n\n\n                attr(tspan, 'dy', getLineHeight(tspan));\n              } // Check width and apply soft breaks or ellipsis\n\n\n              if (width) {\n                var words = span.replace(/([^\\^])-/g, '$1- ').split(' '),\n                    // #1273\n                hasWhiteSpace = !noWrap && (spans.length > 1 || lineNo || words.length > 1),\n                    wrapLineNo = 0,\n                    dy = getLineHeight(tspan);\n\n                if (ellipsis) {\n                  truncated = renderer.truncate(wrapper, tspan, span, undefined, 0, // Target width\n                  Math.max(0, // Substract the font face to make\n                  // room for the ellipsis itself\n                  width - parseInt(fontSize || 12, 10)), // Build the text to test for\n                  function (text, currentIndex) {\n                    return text.substring(0, currentIndex) + '\\u2026';\n                  });\n                } else if (hasWhiteSpace) {\n                  while (words.length) {\n                    // For subsequent lines, create tspans\n                    // with the same style attributes as the\n                    // parent text node.\n                    if (words.length && !noWrap && wrapLineNo > 0) {\n                      tspan = doc.createElementNS(SVG_NS, 'tspan');\n                      attr(tspan, {\n                        dy: dy,\n                        x: parentX\n                      });\n\n                      if (styleAttribute) {\n                        // #390\n                        attr(tspan, 'style', styleAttribute);\n                      } // Start by appending the full\n                      // remaining text\n\n\n                      tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n                      textNode.appendChild(tspan);\n                    } // For each line, truncate the remaining\n                    // words into the line length.\n\n\n                    renderer.truncate(wrapper, tspan, null, words, wrapLineNo === 0 ? lineLength : 0, width, // Build the text to test for\n                    function (text, currentIndex) {\n                      return words.slice(0, currentIndex).join(' ').replace(/- /g, '-');\n                    });\n                    lineLength = wrapper.actualWidth;\n                    wrapLineNo++;\n                  }\n                }\n              }\n\n              spanNo++;\n            }\n          }\n        }); // To avoid beginning lines that doesn't add to the textNode\n        // (#6144)\n\n        isSubsequentLine = isSubsequentLine || textNode.childNodes.length;\n      });\n\n      if (ellipsis && truncated) {\n        wrapper.attr('title', unescapeEntities(wrapper.textStr, ['&lt;', '&gt;']) // #7179\n        );\n      }\n\n      if (tempParent) {\n        tempParent.removeChild(textNode);\n      } // Apply the text outline\n\n\n      if (textOutline && wrapper.applyTextOutline) {\n        wrapper.applyTextOutline(textOutline);\n      }\n    }\n  },\n\n  /**\n   * Returns white for dark colors and black for bright colors.\n   *\n   * @function Highcharts.SVGRenderer#getContrast\n   *\n   * @param {Highcharts.ColorString} rgba\n   *        The color to get the contrast for.\n   *\n   * @return {string}\n   *         The contrast color, either `#000000` or `#FFFFFF`.\n   */\n  getContrast: function (rgba) {\n    rgba = color(rgba).rgba; // The threshold may be discussed. Here's a proposal for adding\n    // different weight to the color channels (#6216)\n\n    rgba[0] *= 1; // red\n\n    rgba[1] *= 1.2; // green\n\n    rgba[2] *= 0.5; // blue\n\n    return rgba[0] + rgba[1] + rgba[2] > 1.8 * 255 ? '#000000' : '#FFFFFF';\n  },\n\n  /**\n   * Create a button with preset states.\n   *\n   * @function Highcharts.SVGRenderer#button\n   *\n   * @param {string} text\n   *        The text or HTML to draw.\n   *\n   * @param {number} x\n   *        The x position of the button's left side.\n   *\n   * @param {number} y\n   *        The y position of the button's top side.\n   *\n   * @param {Function} callback\n   *        The function to execute on button click or touch.\n   *\n   * @param {Highcharts.SVGAttributes} [normalState]\n   *        SVG attributes for the normal state.\n   *\n   * @param {Highcharts.SVGAttributes} [hoverState]\n   *        SVG attributes for the hover state.\n   *\n   * @param {Highcharts.SVGAttributes} [pressedState]\n   *        SVG attributes for the pressed state.\n   *\n   * @param {Highcharts.SVGAttributes} [disabledState]\n   *        SVG attributes for the disabled state.\n   *\n   * @param {Highcharts.SymbolKey} [shape=rect]\n   *        The shape type.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The button element.\n   */\n  button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n    var label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n        curState = 0; // Default, non-stylable attributes\n\n    label.attr(merge({\n      'padding': 8,\n      'r': 2\n    }, normalState)); // Add the events. IE9 and IE10 need mouseover and mouseout to funciton\n    // (#667).\n\n    addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {\n      if (curState !== 3) {\n        label.setState(1);\n      }\n    });\n    addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {\n      if (curState !== 3) {\n        label.setState(curState);\n      }\n    });\n\n    label.setState = function (state) {\n      // Hover state is temporary, don't record it\n      if (state !== 1) {\n        label.state = curState = state;\n      } // Update visuals\n\n\n      label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);\n    };\n\n    return label.on('click', function (e) {\n      if (curState !== 3) {\n        callback.call(label, e);\n      }\n    });\n  },\n\n  /**\n   * Make a straight line crisper by not spilling out to neighbour pixels.\n   *\n   * @function Highcharts.SVGRenderer#crispLine\n   *\n   * @param {Highcharts.SVGPathArray} points\n   *        The original points on the format `['M', 0, 0, 'L', 100, 0]`.\n   *\n   * @param {number} width\n   *        The width of the line.\n   *\n   * @return {Highcharts.SVGPathArray}\n   *         The original points array, but modified to render crisply.\n   */\n  crispLine: function (points, width) {\n    // normalize to a crisp line\n    if (points[1] === points[4]) {\n      // Substract due to #1129. Now bottom and left axis gridlines behave\n      // the same.\n      points[1] = points[4] = Math.round(points[1]) - width % 2 / 2;\n    }\n\n    if (points[2] === points[5]) {\n      points[2] = points[5] = Math.round(points[2]) + width % 2 / 2;\n    }\n\n    return points;\n  },\n\n  /**\n   * Draw a path, wraps the SVG `path` element.\n   *\n   * @sample highcharts/members/renderer-path-on-chart/\n   *         Draw a path in a chart\n   * @sample highcharts/members/renderer-path/\n   *         Draw a path independent from a chart\n   *\n   * @example\n   * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])\n   *     .attr({ stroke: '#ff00ff' })\n   *     .add();\n   *\n   * @function Highcharts.SVGRenderer#path\n   *\n   * @param {Highcharts.SVGPathArray} [path]\n   *        An SVG path definition in array form.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   *\n   */\n\n  /**\n  * Draw a path, wraps the SVG `path` element.\n  *\n  * @function Highcharts.SVGRenderer#path\n  *\n  * @param {Highcharts.SVGAttributes} [attribs]\n  *        The initial attributes.\n  *\n  * @return {Highcharts.SVGElement}\n  *         The generated wrapper element.\n  */\n  path: function (path) {\n    var attribs = {};\n\n    if (isArray(path)) {\n      attribs.d = path;\n    } else if (isObject(path)) {\n      // attributes\n      extend(attribs, path);\n    }\n\n    return this.createElement('path').attr(attribs);\n  },\n\n  /**\n   * Draw a circle, wraps the SVG `circle` element.\n   *\n   * @sample highcharts/members/renderer-circle/\n   *         Drawing a circle\n   *\n   * @function Highcharts.SVGRenderer#circle\n   *\n   * @param {number} [x]\n   *        The center x position.\n   *\n   * @param {number} [y]\n   *        The center y position.\n   *\n   * @param {number} [r]\n   *        The radius.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n\n  /**\n  * Draw a circle, wraps the SVG `circle` element.\n  *\n  * @function Highcharts.SVGRenderer#circle\n  *\n  * @param {Highcharts.SVGAttributes} [attribs]\n  *        The initial attributes.\n  *\n  * @return {Highcharts.SVGElement}\n  *         The generated wrapper element.\n  */\n  circle: function (x, y, r) {\n    var attribs = isObject(x) ? x : {\n      x: x,\n      y: y,\n      r: r\n    },\n        wrapper = this.createElement('circle'); // Setting x or y translates to cx and cy\n\n    wrapper.xSetter = wrapper.ySetter = function (value, key, element) {\n      element.setAttribute('c' + key, value);\n    };\n\n    return wrapper.attr(attribs);\n  },\n\n  /**\n   * Draw and return an arc.\n   *\n   * @sample highcharts/members/renderer-arc/\n   *         Drawing an arc\n   *\n   * @function Highcharts.SVGRenderer#arc\n   *\n   * @param {number} [x=0]\n   *        Center X position.\n   *\n   * @param {number} [y=0]\n   *        Center Y position.\n   *\n   * @param {number} [r=0]\n   *        The outer radius of the arc.\n   *\n   * @param {number} [innerR=0]\n   *        Inner radius like used in donut charts.\n   *\n   * @param {number} [start=0]\n   *        The starting angle of the arc in radians, where 0 is to the right\n   *         and `-Math.PI/2` is up.\n   *\n   * @param {number} [end=0]\n   *        The ending angle of the arc in radians, where 0 is to the right\n   *        and `-Math.PI/2` is up.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n\n  /**\n  * Draw and return an arc. Overloaded function that takes arguments object.\n  *\n  * @function Highcharts.SVGRenderer#arc\n  *\n  * @param {Highcharts.SVGAttributes} attribs\n  *        Initial SVG attributes.\n  *\n  * @return {Highcharts.SVGElement}\n  *         The generated wrapper element.\n  */\n  arc: function (x, y, r, innerR, start, end) {\n    var arc, options;\n\n    if (isObject(x)) {\n      options = x;\n      y = options.y;\n      r = options.r;\n      innerR = options.innerR;\n      start = options.start;\n      end = options.end;\n      x = options.x;\n    } else {\n      options = {\n        innerR: innerR,\n        start: start,\n        end: end\n      };\n    } // Arcs are defined as symbols for the ability to set\n    // attributes in attr and animate\n\n\n    arc = this.symbol('arc', x, y, r, r, options);\n    arc.r = r; // #959\n\n    return arc;\n  },\n\n  /**\n   * Draw and return a rectangle.\n   *\n   * @function Highcharts.SVGRenderer#rect\n   *\n   * @param {number} [x]\n   *        Left position.\n   *\n   * @param {number} [y]\n   *        Top position.\n   *\n   * @param {number} [width]\n   *        Width of the rectangle.\n   *\n   * @param {number} [height]\n   *        Height of the rectangle.\n   *\n   * @param {number} [r]\n   *        Border corner radius.\n   *\n   * @param {number} [strokeWidth]\n   *        A stroke width can be supplied to allow crisp drawing.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n\n  /**\n  * Draw and return a rectangle.\n  *\n  * @sample highcharts/members/renderer-rect-on-chart/\n  *         Draw a rectangle in a chart\n  * @sample highcharts/members/renderer-rect/\n  *         Draw a rectangle independent from a chart\n  *\n  * @function Highcharts.SVGRenderer#rect\n  *\n  * @param {Highcharts.SVGAttributes} [attributes]\n  *        General SVG attributes for the rectangle.\n  *\n  * @return {Highcharts.SVGElement}\n  *         The generated wrapper element.\n  */\n  rect: function (x, y, width, height, r, strokeWidth) {\n    r = isObject(x) ? x.r : r;\n    var wrapper = this.createElement('rect'),\n        attribs = isObject(x) ? x : x === undefined ? {} : {\n      x: x,\n      y: y,\n      width: Math.max(width, 0),\n      height: Math.max(height, 0)\n    };\n\n    if (r) {\n      attribs.r = r;\n    }\n\n    wrapper.rSetter = function (value, key, element) {\n      attr(element, {\n        rx: value,\n        ry: value\n      });\n    };\n\n    return wrapper.attr(attribs);\n  },\n\n  /**\n   * Resize the {@link SVGRenderer#box} and re-align all aligned child\n   * elements.\n   *\n   * @sample highcharts/members/renderer-g/\n   *         Show and hide grouped objects\n   *\n   * @function Highcharts.SVGRenderer#setSize\n   *\n   * @param {number} width\n   *        The new pixel width.\n   *\n   * @param {number} height\n   *        The new pixel height.\n   *\n   * @param {boolean|Highcharts.AnimationOptionsObject} [animate=true]\n   *        Whether and how to animate.\n   */\n  setSize: function (width, height, animate) {\n    var renderer = this,\n        alignedObjects = renderer.alignedObjects,\n        i = alignedObjects.length;\n    renderer.width = width;\n    renderer.height = height;\n    renderer.boxWrapper.animate({\n      width: width,\n      height: height\n    }, {\n      step: function () {\n        this.attr({\n          viewBox: '0 0 ' + this.attr('width') + ' ' + this.attr('height')\n        });\n      },\n      duration: pick(animate, true) ? undefined : 0\n    });\n\n    while (i--) {\n      alignedObjects[i].align();\n    }\n  },\n\n  /**\n   * Create and return an svg group element. Child\n   * {@link Highcharts.SVGElement} objects are added to the group by using the\n   * group as the first parameter in {@link Highcharts.SVGElement#add|add()}.\n   *\n   * @function Highcharts.SVGRenderer#g\n   *\n   * @param {string} [name]\n   *        The group will be given a class name of `highcharts-{name}`. This\n   *        can be used for styling and scripting.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n  g: function (name) {\n    var elem = this.createElement('g');\n    return name ? elem.attr({\n      'class': 'highcharts-' + name\n    }) : elem;\n  },\n\n  /**\n   * Display an image.\n   *\n   * @sample highcharts/members/renderer-image-on-chart/\n   *         Add an image in a chart\n   * @sample highcharts/members/renderer-image/\n   *         Add an image independent of a chart\n   *\n   * @function Highcharts.SVGRenderer#image\n   *\n   * @param {string} src\n   *        The image source.\n   *\n   * @param {number} [x]\n   *        The X position.\n   *\n   * @param {number} [y]\n   *        The Y position.\n   *\n   * @param {number} [width]\n   *        The image width. If omitted, it defaults to the image file width.\n   *\n   * @param {number} [height]\n   *        The image height. If omitted it defaults to the image file\n   *        height.\n   *\n   * @param {Function} [onload]\n   *        Event handler for image load.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated wrapper element.\n   */\n  image: function (src, x, y, width, height, onload) {\n    var attribs = {\n      preserveAspectRatio: 'none'\n    },\n        elemWrapper,\n        dummy,\n        setSVGImageSource = function (el, src) {\n      // Set the href in the xlink namespace\n      if (el.setAttributeNS) {\n        el.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src);\n      } else {\n        // could be exporting in IE\n        // using href throws \"not supported\" in ie7 and under,\n        // requries regex shim to fix later\n        el.setAttribute('hc-svg-href', src);\n      }\n    },\n        onDummyLoad = function (e) {\n      setSVGImageSource(elemWrapper.element, src);\n      onload.call(elemWrapper, e);\n    }; // optional properties\n\n\n    if (arguments.length > 1) {\n      extend(attribs, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n\n    elemWrapper = this.createElement('image').attr(attribs); // Add load event if supplied\n\n    if (onload) {\n      // We have to use a dummy HTML image since IE support for SVG image\n      // load events is very buggy. First set a transparent src, wait for\n      // dummy to load, and then add the real src to the SVG image.\n      setSVGImageSource(elemWrapper.element, 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='\n      /* eslint-disable-line */\n      );\n      dummy = new win.Image();\n      addEvent(dummy, 'load', onDummyLoad);\n      dummy.src = src;\n\n      if (dummy.complete) {\n        onDummyLoad({});\n      }\n    } else {\n      setSVGImageSource(elemWrapper.element, src);\n    }\n\n    return elemWrapper;\n  },\n\n  /**\n   * Draw a symbol out of pre-defined shape paths from\n   * {@link SVGRenderer#symbols}.\n   * It is used in Highcharts for point makers, which cake a `symbol` option,\n   * and label and button backgrounds like in the tooltip and stock flags.\n   *\n   * @function Highcharts.SVGRenderer#symbol\n   *\n   * @param {symbol} symbol\n   *        The symbol name.\n   *\n   * @param {number} x\n   *        The X coordinate for the top left position.\n   *\n   * @param {number} y\n   *        The Y coordinate for the top left position.\n   *\n   * @param {number} width\n   *        The pixel width.\n   *\n   * @param {number} height\n   *        The pixel height.\n   *\n   * @param {Highcharts.SymbolOptionsObject} [options]\n   *        Additional options, depending on the actual symbol drawn.\n   *\n   * @return {Highcharts.SVGElement}\n   */\n  symbol: function (symbol, x, y, width, height, options) {\n    var ren = this,\n        obj,\n        imageRegex = /^url\\((.*?)\\)$/,\n        isImage = imageRegex.test(symbol),\n        sym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),\n        // get the symbol definition function\n    symbolFn = sym && this.symbols[sym],\n        // check if there's a path defined for this symbol\n    path = defined(x) && symbolFn && symbolFn.call(this.symbols, Math.round(x), Math.round(y), width, height, options),\n        imageSrc,\n        centerImage;\n\n    if (symbolFn) {\n      obj = this.path(path); // expando properties for use in animate and attr\n\n      extend(obj, {\n        symbolName: sym,\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n\n      if (options) {\n        extend(obj, options);\n      } // Image symbols\n\n    } else if (isImage) {\n      imageSrc = symbol.match(imageRegex)[1]; // Create the image synchronously, add attribs async\n\n      obj = this.image(imageSrc); // The image width is not always the same as the symbol width. The\n      // image may be centered within the symbol, as is the case when\n      // image shapes are used as label backgrounds, for example in flags.\n\n      obj.imgwidth = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);\n      obj.imgheight = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);\n      /**\n       * Set the size and position\n       */\n\n      centerImage = function () {\n        obj.attr({\n          width: obj.width,\n          height: obj.height\n        });\n      };\n      /**\n       * Width and height setters that take both the image's physical size\n       * and the label size into consideration, and translates the image\n       * to center within the label.\n       */\n\n\n      each(['width', 'height'], function (key) {\n        obj[key + 'Setter'] = function (value, key) {\n          var attribs = {},\n              imgSize = this['img' + key],\n              trans = key === 'width' ? 'translateX' : 'translateY';\n          this[key] = value;\n\n          if (defined(imgSize)) {\n            if (this.element) {\n              this.element.setAttribute(key, imgSize);\n            }\n\n            if (!this.alignByTranslate) {\n              attribs[trans] = ((this[key] || 0) - imgSize) / 2;\n              this.attr(attribs);\n            }\n          }\n        };\n      });\n\n      if (defined(x)) {\n        obj.attr({\n          x: x,\n          y: y\n        });\n      }\n\n      obj.isImg = true;\n\n      if (defined(obj.imgwidth) && defined(obj.imgheight)) {\n        centerImage();\n      } else {\n        // Initialize image to be 0 size so export will still function\n        // if there's no cached sizes.\n        obj.attr({\n          width: 0,\n          height: 0\n        }); // Create a dummy JavaScript image to get the width and height.\n\n        createElement('img', {\n          onload: function () {\n            var chart = charts[ren.chartIndex]; // Special case for SVGs on IE11, the width is not\n            // accessible until the image is part of the DOM\n            // (#2854).\n\n            if (this.width === 0) {\n              css(this, {\n                position: 'absolute',\n                top: '-999em'\n              });\n              doc.body.appendChild(this);\n            } // Center the image\n\n\n            symbolSizes[imageSrc] = {\n              // Cache for next\n              width: this.width,\n              height: this.height\n            };\n            obj.imgwidth = this.width;\n            obj.imgheight = this.height;\n\n            if (obj.element) {\n              centerImage();\n            } // Clean up after #2854 workaround.\n\n\n            if (this.parentNode) {\n              this.parentNode.removeChild(this);\n            } // Fire the load event when all external images are\n            // loaded\n\n\n            ren.imgCount--;\n\n            if (!ren.imgCount && chart && chart.onload) {\n              chart.onload();\n            }\n          },\n          src: imageSrc\n        });\n        this.imgCount++;\n      }\n    }\n\n    return obj;\n  },\n\n  /**\n   * An extendable collection of functions for defining symbol paths.\n   *\n   * @name Highcharts.SVGRenderer#symbols\n   * @type {Highcharts.SymbolDictionary}\n   */\n  symbols: {\n    'circle': function (x, y, w, h) {\n      // Return a full arc\n      return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {\n        start: 0,\n        end: Math.PI * 2,\n        open: false\n      });\n    },\n    'square': function (x, y, w, h) {\n      return ['M', x, y, 'L', x + w, y, x + w, y + h, x, y + h, 'Z'];\n    },\n    'triangle': function (x, y, w, h) {\n      return ['M', x + w / 2, y, 'L', x + w, y + h, x, y + h, 'Z'];\n    },\n    'triangle-down': function (x, y, w, h) {\n      return ['M', x, y, 'L', x + w, y, x + w / 2, y + h, 'Z'];\n    },\n    'diamond': function (x, y, w, h) {\n      return ['M', x + w / 2, y, 'L', x + w, y + h / 2, x + w / 2, y + h, x, y + h / 2, 'Z'];\n    },\n    'arc': function (x, y, w, h, options) {\n      var start = options.start,\n          rx = options.r || w,\n          ry = options.r || h || w,\n          proximity = 0.001,\n          fullCircle = Math.abs(options.end - options.start - 2 * Math.PI) < proximity,\n          // Substract a small number to prevent cos and sin of start and\n      // end from becoming equal on 360 arcs (related: #1561)\n      end = options.end - proximity,\n          innerRadius = options.innerR,\n          open = pick(options.open, fullCircle),\n          cosStart = Math.cos(start),\n          sinStart = Math.sin(start),\n          cosEnd = Math.cos(end),\n          sinEnd = Math.sin(end),\n          // Proximity takes care of rounding errors around PI (#6971)\n      longArc = options.end - start - Math.PI < proximity ? 0 : 1,\n          arc;\n      arc = ['M', x + rx * cosStart, y + ry * sinStart, 'A', // arcTo\n      rx, // x radius\n      ry, // y radius\n      0, // slanting\n      longArc, // long or short arc\n      1, // clockwise\n      x + rx * cosEnd, y + ry * sinEnd];\n\n      if (defined(innerRadius)) {\n        arc.push(open ? 'M' : 'L', x + innerRadius * cosEnd, y + innerRadius * sinEnd, 'A', // arcTo\n        innerRadius, // x radius\n        innerRadius, // y radius\n        0, // slanting\n        longArc, // long or short arc\n        0, // clockwise\n        x + innerRadius * cosStart, y + innerRadius * sinStart);\n      }\n\n      arc.push(open ? '' : 'Z'); // close\n\n      return arc;\n    },\n\n    /**\n     * Callout shape used for default tooltips, also used for rounded\n     * rectangles in VML\n     */\n    'callout': function (x, y, w, h, options) {\n      var arrowLength = 6,\n          halfDistance = 6,\n          r = Math.min(options && options.r || 0, w, h),\n          safeDistance = r + halfDistance,\n          anchorX = options && options.anchorX,\n          anchorY = options && options.anchorY,\n          path;\n      path = ['M', x + r, y, 'L', x + w - r, y, // top side\n      'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n      'L', x + w, y + h - r, // right side\n      'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-rgt\n      'L', x + r, y + h, // bottom side\n      'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n      'L', x, y + r, // left side\n      'C', x, y, x, y, x + r, y // top-left corner\n      ]; // Anchor on right side\n\n      if (anchorX && anchorX > w) {\n        // Chevron\n        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {\n          path.splice(13, 3, 'L', x + w, anchorY - halfDistance, x + w + arrowLength, anchorY, x + w, anchorY + halfDistance, x + w, y + h - r); // Simple connector\n        } else {\n          path.splice(13, 3, 'L', x + w, h / 2, anchorX, anchorY, x + w, h / 2, x + w, y + h - r);\n        } // Anchor on left side\n\n      } else if (anchorX && anchorX < 0) {\n        // Chevron\n        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {\n          path.splice(33, 3, 'L', x, anchorY + halfDistance, x - arrowLength, anchorY, x, anchorY - halfDistance, x, y + r); // Simple connector\n        } else {\n          path.splice(33, 3, 'L', x, h / 2, anchorX, anchorY, x, h / 2, x, y + r);\n        }\n      } else if ( // replace bottom\n      anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {\n        path.splice(23, 3, 'L', anchorX + halfDistance, y + h, anchorX, y + h + arrowLength, anchorX - halfDistance, y + h, x + r, y + h);\n      } else if ( // replace top\n      anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {\n        path.splice(3, 3, 'L', anchorX - halfDistance, y, anchorX, y - arrowLength, anchorX + halfDistance, y, w - r, y);\n      }\n\n      return path;\n    }\n  },\n\n  /**\n   * Define a clipping rectangle. The clipping rectangle is later applied\n   * to {@link SVGElement} objects through the {@link SVGElement#clip}\n   * function.\n   *\n   * @example\n   * var circle = renderer.circle(100, 100, 100)\n   *     .attr({ fill: 'red' })\n   *     .add();\n   * var clipRect = renderer.clipRect(100, 100, 100, 100);\n   *\n   * // Leave only the lower right quarter visible\n   * circle.clip(clipRect);\n   *\n   * @function Highcharts.SVGRenderer#clipRect\n   *\n   * @param {string} id\n   *\n   * @param {number} x\n   *\n   * @param {number} y\n   *\n   * @param {number} width\n   *\n   * @param {number} height\n   *\n   * @return {Highcharts.ClipRectElement}\n   *         A clipping rectangle.\n   */\n  clipRect: function (x, y, width, height) {\n    var wrapper,\n        id = H.uniqueKey(),\n        clipPath = this.createElement('clipPath').attr({\n      id: id\n    }).add(this.defs);\n    wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n    wrapper.id = id;\n    wrapper.clipPath = clipPath;\n    wrapper.count = 0;\n    return wrapper;\n  },\n\n  /**\n   * Draw text. The text can contain a subset of HTML, like spans and anchors\n   * and some basic text styling of these. For more advanced features like\n   * border and background, use {@link Highcharts.SVGRenderer#label} instead.\n   * To update the text after render, run `text.attr({ text: 'New text' })`.\n   *\n   * @sample highcharts/members/renderer-text-on-chart/\n   *         Annotate the chart freely\n   * @sample highcharts/members/renderer-on-chart/\n   *         Annotate with a border and in response to the data\n   * @sample highcharts/members/renderer-text/\n   *         Formatted text\n   *\n   * @function Highcharts.SVGRenderer#text\n   *\n   * @param {string} str\n   *        The text of (subset) HTML to draw.\n   *\n   * @param {number} x\n   *        The x position of the text's lower left corner.\n   *\n   * @param {number} y\n   *        The y position of the text's lower left corner.\n   *\n   * @param {boolean} [useHTML=false]\n   *        Use HTML to render the text.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The text object.\n   */\n  text: function (str, x, y, useHTML) {\n    // declare variables\n    var renderer = this,\n        wrapper,\n        attribs = {};\n\n    if (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n      return renderer.html(str, x, y);\n    }\n\n    attribs.x = Math.round(x || 0); // X always needed for line-wrap logic\n\n    if (y) {\n      attribs.y = Math.round(y);\n    }\n\n    if (str || str === 0) {\n      attribs.text = str;\n    }\n\n    wrapper = renderer.createElement('text').attr(attribs);\n\n    if (!useHTML) {\n      wrapper.xSetter = function (value, key, element) {\n        var tspans = element.getElementsByTagName('tspan'),\n            tspan,\n            parentVal = element.getAttribute(key),\n            i;\n\n        for (i = 0; i < tspans.length; i++) {\n          tspan = tspans[i]; // If the x values are equal, the tspan represents a\n          // linebreak\n\n          if (tspan.getAttribute(key) === parentVal) {\n            tspan.setAttribute(key, value);\n          }\n        }\n\n        element.setAttribute(key, value);\n      };\n    }\n\n    return wrapper;\n  },\n\n  /**\n   * Utility to return the baseline offset and total line height from the font\n   * size.\n   *\n   * @function Highcharts.SVGRenderer#fontMetrics\n   *\n   * @param {string} [fontSize]\n   *        The current font size to inspect. If not given, the font size\n   *        will be found from the DOM element.\n   *\n   * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [elem]\n   *        The element to inspect for a current font size.\n   *\n   * @return {Highcharts.FontMetricsObject}\n   *         The font metrics.\n   */\n  fontMetrics: function (fontSize, elem) {\n    var lineHeight, baseline;\n    fontSize = elem && SVGElement.prototype.getStyle.call(elem, 'font-size'); // Handle different units\n\n    if (/px/.test(fontSize)) {\n      fontSize = pInt(fontSize);\n    } else if (/em/.test(fontSize)) {\n      // The em unit depends on parent items\n      fontSize = parseFloat(fontSize) * (elem ? this.fontMetrics(null, elem.parentNode).f : 16);\n    } else {\n      fontSize = 12;\n    } // Empirical values found by comparing font size and bounding box\n    // height. Applies to the default font family.\n    // https://jsfiddle.net/highcharts/7xvn7/\n\n\n    lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);\n    baseline = Math.round(lineHeight * 0.8);\n    return {\n      h: lineHeight,\n      b: baseline,\n      f: fontSize\n    };\n  },\n\n  /**\n   * Correct X and Y positioning of a label for rotation (#1764).\n   *\n   * @private\n   * @function Highcharts.SVGRenderer#rotCorr\n   *\n   * @param {number} baseline\n   *\n   * @param {number} rotation\n   *\n   * @param {boolean} alterY\n   */\n  rotCorr: function (baseline, rotation, alterY) {\n    var y = baseline;\n\n    if (rotation && alterY) {\n      y = Math.max(y * Math.cos(rotation * deg2rad), 4);\n    }\n\n    return {\n      x: -baseline / 3 * Math.sin(rotation * deg2rad),\n      y: y\n    };\n  },\n\n  /**\n   * Draw a label, which is an extended text element with support for border\n   * and background. Highcharts creates a `g` element with a text and a `path`\n   * or `rect` inside, to make it behave somewhat like a HTML div. Border and\n   * background are set through `stroke`, `stroke-width` and `fill` attributes\n   * using the {@link Highcharts.SVGElement#attr|attr} method. To update the\n   * text after render, run `label.attr({ text: 'New text' })`.\n   *\n   * @sample highcharts/members/renderer-label-on-chart/\n   *         A label on the chart\n   *\n   * @function Highcharts.SVGRenderer#label\n   *\n   * @param {string} str\n   *        The initial text string or (subset) HTML to render.\n   *\n   * @param {number} x\n   *        The x position of the label's left side.\n   *\n   * @param {number} y\n   *        The y position of the label's top side or baseline, depending on\n   *        the `baseline` parameter.\n   *\n   * @param {string} [shape='rect']\n   *        The shape of the label's border/background, if any. Defaults to\n   *        `rect`. Other possible values are `callout` or other shapes\n   *        defined in {@link Highcharts.SVGRenderer#symbols}.\n   *\n   * @param {string} [shape='rect']\n   *        The shape of the label's border/background, if any. Defaults to\n   *        `rect`. Other possible values are `callout` or other shapes\n   *        defined in {@link Highcharts.SVGRenderer#symbols}.\n   *\n   * @param {number} [anchorX]\n   *        In case the `shape` has a pointer, like a flag, this is the\n   *        coordinates it should be pinned to.\n   *\n   * @param {number} [anchorY]\n   *        In case the `shape` has a pointer, like a flag, this is the\n   *        coordinates it should be pinned to.\n   *\n   * @param {boolean} [useHTML=false]\n   *        Wether to use HTML to render the label.\n   *\n   * @param {boolean} [baseline=false]\n   *        Whether to position the label relative to the text baseline,\n   *        like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the\n   *        upper border of the rectangle.\n   *\n   * @param {string} [className]\n   *        Class name for the group.\n   *\n   * @return {Highcharts.SVGElement}\n   *         The generated label.\n   */\n  label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n    var renderer = this,\n        wrapper = renderer.g(className !== 'button' && 'label'),\n        text = wrapper.text = renderer.text('', 0, 0, useHTML).attr({\n      zIndex: 1\n    }),\n        box,\n        bBox,\n        alignFactor = 0,\n        padding = 3,\n        paddingLeft = 0,\n        width,\n        height,\n        wrapperX,\n        wrapperY,\n        textAlign,\n        deferredAttr = {},\n        strokeWidth,\n        baselineOffset,\n        hasBGImage = /^url\\((.*?)\\)$/.test(shape),\n        needsBox = hasBGImage,\n        getCrispAdjust,\n        updateBoxSize,\n        updateTextPadding,\n        boxAttr;\n\n    if (className) {\n      wrapper.addClass('highcharts-' + className);\n    }\n\n    needsBox = true; // for styling\n\n    getCrispAdjust = function () {\n      return box.strokeWidth() % 2 / 2;\n    };\n    /*\n     * This function runs after the label is added to the DOM (when the\n     * bounding box is available), and after the text of the label is\n     * updated to detect the new bounding box and reflect it in the border\n     * box.\n     */\n\n\n    updateBoxSize = function () {\n      var style = text.element.style,\n          crispAdjust,\n          attribs = {};\n      bBox = (width === undefined || height === undefined || textAlign) && defined(text.textStr) && text.getBBox(); // #3295 && 3514 box failure when string equals 0\n\n      wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n      wrapper.height = (height || bBox.height || 0) + 2 * padding; // Update the label-scoped y offset\n\n      baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n      if (needsBox) {\n        // Create the border box if it is not already present\n        if (!box) {\n          // Symbol definition exists (#5324)\n          wrapper.box = box = renderer.symbols[shape] || hasBGImage ? renderer.symbol(shape) : renderer.rect();\n          box.addClass( // Don't use label className for buttons\n          (className === 'button' ? '' : 'highcharts-label-box') + (className ? ' highcharts-' + className + '-box' : ''));\n          box.add(wrapper);\n          crispAdjust = getCrispAdjust();\n          attribs.x = crispAdjust;\n          attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;\n        } // Apply the box attributes\n\n\n        attribs.width = Math.round(wrapper.width);\n        attribs.height = Math.round(wrapper.height);\n        box.attr(extend(attribs, deferredAttr));\n        deferredAttr = {};\n      }\n    };\n    /*\n     * This function runs after setting text or padding, but only if padding\n     * is changed.\n     */\n\n\n    updateTextPadding = function () {\n      var textX = paddingLeft + padding,\n          textY; // determin y based on the baseline\n\n      textY = baseline ? 0 : baselineOffset; // compensate for alignment\n\n      if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n        textX += {\n          center: 0.5,\n          right: 1\n        }[textAlign] * (width - bBox.width);\n      } // update if anything changed\n\n\n      if (textX !== text.x || textY !== text.y) {\n        text.attr('x', textX); // #8159 - prevent misplaced data labels in treemap\n        // (useHTML: true)\n\n        if (text.hasBoxWidthChanged) {\n          bBox = text.getBBox(true);\n          updateBoxSize();\n        }\n\n        if (textY !== undefined) {\n          text.attr('y', textY);\n        }\n      } // record current values\n\n\n      text.x = textX;\n      text.y = textY;\n    };\n    /*\n     * Set a box attribute, or defer it if the box is not yet created\n     */\n\n\n    boxAttr = function (key, value) {\n      if (box) {\n        box.attr(key, value);\n      } else {\n        deferredAttr[key] = value;\n      }\n    };\n    /*\n     * After the text element is added, get the desired size of the border\n     * box and add it before the text in the DOM.\n     */\n\n\n    wrapper.onAdd = function () {\n      text.add(wrapper);\n      wrapper.attr({\n        // Alignment is available now  (#3295, 0 not rendered if given\n        // as a value)\n        text: str || str === 0 ? str : '',\n        x: x,\n        y: y\n      });\n\n      if (box && defined(anchorX)) {\n        wrapper.attr({\n          anchorX: anchorX,\n          anchorY: anchorY\n        });\n      }\n    };\n    /*\n     * Add specific attribute setters.\n     */\n    // only change local variables\n\n\n    wrapper.widthSetter = function (value) {\n      width = H.isNumber(value) ? value : null; // width:auto => null\n    };\n\n    wrapper.heightSetter = function (value) {\n      height = value;\n    };\n\n    wrapper['text-alignSetter'] = function (value) {\n      textAlign = value;\n    };\n\n    wrapper.paddingSetter = function (value) {\n      if (defined(value) && value !== padding) {\n        padding = wrapper.padding = value;\n        updateTextPadding();\n      }\n    };\n\n    wrapper.paddingLeftSetter = function (value) {\n      if (defined(value) && value !== paddingLeft) {\n        paddingLeft = value;\n        updateTextPadding();\n      }\n    }; // change local variable and prevent setting attribute on the group\n\n\n    wrapper.alignSetter = function (value) {\n      value = {\n        left: 0,\n        center: 0.5,\n        right: 1\n      }[value];\n\n      if (value !== alignFactor) {\n        alignFactor = value; // Bounding box exists, means we're dynamically changing\n\n        if (bBox) {\n          wrapper.attr({\n            x: wrapperX\n          }); // #5134\n        }\n      }\n    }; // apply these to the box and the text alike\n\n\n    wrapper.textSetter = function (value) {\n      if (value !== undefined) {\n        text.textSetter(value);\n      }\n\n      updateBoxSize();\n      updateTextPadding();\n    }; // apply these to the box but not to the text\n\n\n    wrapper['stroke-widthSetter'] = function (value, key) {\n      if (value) {\n        needsBox = true;\n      }\n\n      strokeWidth = this['stroke-width'] = value;\n      boxAttr(key, value);\n    };\n\n    wrapper.rSetter = function (value, key) {\n      boxAttr(key, value);\n    };\n\n    wrapper.anchorXSetter = function (value, key) {\n      anchorX = wrapper.anchorX = value;\n      boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);\n    };\n\n    wrapper.anchorYSetter = function (value, key) {\n      anchorY = wrapper.anchorY = value;\n      boxAttr(key, value - wrapperY);\n    }; // rename attributes\n\n\n    wrapper.xSetter = function (value) {\n      wrapper.x = value; // for animation getter\n\n      if (alignFactor) {\n        value -= alignFactor * ((width || bBox.width) + 2 * padding); // Force animation even when setting to the same value (#7898)\n\n        wrapper['forceAnimate:x'] = true;\n      }\n\n      wrapperX = Math.round(value);\n      wrapper.attr('translateX', wrapperX);\n    };\n\n    wrapper.ySetter = function (value) {\n      wrapperY = wrapper.y = Math.round(value);\n      wrapper.attr('translateY', wrapperY);\n    }; // Redirect certain methods to either the box or the text\n\n\n    var baseCss = wrapper.css;\n    return extend(wrapper, {\n      /*\n       * Pick up some properties and apply them to the text instead of the\n       * wrapper.\n       */\n      css: function (styles) {\n        if (styles) {\n          var textStyles = {}; // Create a copy to avoid altering the original object\n          // (#537)\n\n          styles = merge(styles);\n          each(wrapper.textProps, function (prop) {\n            if (styles[prop] !== undefined) {\n              textStyles[prop] = styles[prop];\n              delete styles[prop];\n            }\n          });\n          text.css(textStyles);\n\n          if ('width' in textStyles) {\n            updateBoxSize();\n          }\n        }\n\n        return baseCss.call(wrapper, styles);\n      },\n\n      /*\n       * Return the bounding box of the box, not the group.\n       */\n      getBBox: function () {\n        return {\n          width: bBox.width + 2 * padding,\n          height: bBox.height + 2 * padding,\n          x: bBox.x - padding,\n          y: bBox.y - padding\n        };\n      },\n\n      /*\n       * Destroy and release memory.\n       */\n      destroy: function () {\n        // Added by button implementation\n        removeEvent(wrapper.element, 'mouseenter');\n        removeEvent(wrapper.element, 'mouseleave');\n\n        if (text) {\n          text = text.destroy();\n        }\n\n        if (box) {\n          box = box.destroy();\n        } // Call base implementation to destroy the rest\n\n\n        SVGElement.prototype.destroy.call(wrapper); // Release local pointers (#1298)\n\n        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n      }\n    });\n  }\n}); // end SVGRenderer\n// general renderer\n\nH.Renderer = SVGRenderer;"
    },
    {
     "id": 256,
     "name": "../node_modules/@vaadin/vaadin-license-checker/vaadin-license-checker.js?babel-target=es6",
     "source": "/* This file is autogenerated from src/vaadin-license-checker.tpl.html */\n\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport { runIfDevelopmentMode } from '@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js';\n\nfunction maybeCheckLicenses() {\n  /** vaadin-dev-mode:start\n  (function () {\n  'use strict';\n  var classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n  };\n  var createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n   return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n  }();\n  var inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n   subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n  var possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n   return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n  function _CustomElement() {\n  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);\n  }\n  Object.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);\n  Object.setPrototypeOf(_CustomElement, HTMLElement);\n  var licenseBoxTemplate = document.createElement('template');\n  licenseBoxTemplate.innerHTML = '\\n  <style>\\n    :host {\\n      font: 16px/1.625 -apple-system, BlinkMacSystemFont, \"Roboto\", \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\\n      position: fixed;\\n      top: .5em;\\n      right: .5em;\\n      z-index: 10000;\\n      cursor: pointer;\\n      backface-visibility: hidden;\\n    }\\n\\n    #content {\\n      padding: 1em 1.5em;\\n      margin: 0;\\n      display: flex;\\n      flex-direction:row;\\n      align-items: center;\\n      text-align: left;\\n      font-size: inherit;\\n      line-height: inherit;\\n      font-weight: inherit;\\n      -webkit-font-smoothing: antialiased;\\n      -moz-osx-font-smoothin: grayscale;\\n      white-space: nowrap;\\n      letter-spacing: 0;\\n      border-radius: 5px;\\n    }\\n\\n    #content[type=\"needsvalidation\"] {\\n      background-color: #FFD5D8;\\n      color: #591217;\\n      box-shadow: 0 0 20px 1px rgba(242,51,51,0.10);\\n    }\\n\\n    #content[type=\"ok\"] {\\n      background-color: #B2F5C2;\\n      color: #1C562A;\\n      box-shadow: 0 0 20px 1px rgba(43,193,78,0.10);\\n    }\\n\\n    #content > svg {\\n      display: none;\\n      fill: currentColor;\\n      stroke: currentColor 1px;\\n      padding-left: 1.25em;\\n    }\\n\\n    #content[type=\"needsvalidation\"] > #link {\\n      display: inline;\\n    }\\n\\n    #content[type=\"ok\"] > #close {\\n      display: inline;\\n      vertical-align: -.125em;\\n    }\\n  </style>\\n\\n  <div id=\"content\">\\n    <div></div>\\n    <svg id=\"link\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\\n      <g id=\"external-link\"><path d=\"M8.6 3.5l3.5 3.5h-12.1v2h12.1l-3.5 3.5 1.4 1.4 6-5.9-6-5.9z\"></path></g>\\n    </svg>\\n    <svg id=\"close\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\\n      <g id=\"close-big\"><path d=\"M16 0l-1 0.010-7 6.99-7-6.99-1-0.010v1l7 7-7 7v1h1l7-7 7 7h1v-1l-7-7 7-7v-1z\"></path></g>\\n    </svg>\\n  </div>\\n';\n  window.ShadyCSS && window.ShadyCSS.prepareTemplate(licenseBoxTemplate, 'vaadin-license-box');\n  var LicenseBoxElement = function (_CustomElement2) {\n  inherits(LicenseBoxElement, _CustomElement2);\n   function LicenseBoxElement() {\n    classCallCheck(this, LicenseBoxElement);\n    return possibleConstructorReturn(this, (LicenseBoxElement.__proto__ || Object.getPrototypeOf(LicenseBoxElement)).apply(this, arguments));\n  }\n   createClass(LicenseBoxElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      window.ShadyCSS && window.ShadyCSS.styleElement(this);\n       if (!this.shadowRoot) {\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(document.importNode(licenseBoxTemplate.content, true));\n        this._contentElement = this.shadowRoot.querySelector('#content');\n        this._render();\n      }\n    }\n  }, {\n    key: '_render',\n    value: function _render() {\n      if (!this._contentElement) {\n        return;\n      }\n       if (this._type) {\n        this._contentElement.setAttribute('type', this._type);\n      } else {\n        this._contentElement.removeAttribute('type');\n      }\n       this._contentElement.firstElementChild.innerHTML = this._content;\n    }\n  }, {\n    key: 'type',\n    get: function () {\n      return this._type;\n    },\n    set: function (type) {\n      this._type = type;\n      this._render();\n    }\n  }, {\n    key: 'content',\n    get: function () {\n      return this._content;\n    },\n    set: function (content) {\n      this._content = content;\n      this._render();\n    }\n  }]);\n  return LicenseBoxElement;\n  }(_CustomElement);\n  customElements.define('vaadin-license-box', LicenseBoxElement);\n  var LicenseCheckerLogger = function () {\n  function LicenseCheckerLogger() {\n    classCallCheck(this, LicenseCheckerLogger);\n     this.id = \"vaadin-license-checker\";\n  }\n   createClass(LicenseCheckerLogger, [{\n    key: 'isDebug',\n    value: function isDebug() {\n      return localStorage.getItem(\"vaadin.licenses.debug\");\n    }\n  }, {\n    key: 'debug',\n    value: function debug(msg) {\n      if (this.isDebug()) {\n        console.info(this.id + \": \" + msg);\n      }\n    }\n  }]);\n  return LicenseCheckerLogger;\n  }();\n  var LicenseCheckerStorage = function () {\n  function LicenseCheckerStorage() {\n    classCallCheck(this, LicenseCheckerStorage);\n     this.logger = new LicenseCheckerLogger();\n  }\n   createClass(LicenseCheckerStorage, [{\n    key: 'getLastCheckKey',\n    value: function getLastCheckKey(productInfo) {\n      return \"vaadin.licenses.{product}.lastCheck\".replace(\"{product}\", productInfo.name);\n    }\n  }, {\n    key: 'getLastCheck',\n    value: function getLastCheck(productInfo) {\n      return Number(localStorage.getItem(this.getLastCheckKey(productInfo)));\n    }\n  }, {\n    key: 'setLastCheck',\n    value: function setLastCheck(productInfo, timestamp) {\n      this.logger.debug(\"Setting last check time to \" + new Date(timestamp));\n      localStorage.setItem(this.getLastCheckKey(productInfo), timestamp);\n    }\n  }]);\n  return LicenseCheckerStorage;\n  }();\n  var VaadinLicenseChecker = function () {\n  function VaadinLicenseChecker() {\n    classCallCheck(this, VaadinLicenseChecker);\n     this.okNotifier = new LicenseOkNotifier();\n    this.validationNeededNotifier = new LicenseValidationNeededNotifier();\n    this.storage = new LicenseCheckerStorage();\n    this.checkInterval = 1000 * 60 * 60 * 24;\n    this.firstCheckDelay = 1000 * 60 * 1;\n    this.logger = new LicenseCheckerLogger();\n    this.url = \"https://tools.vaadin.com/vaadin-license-server/licenses/pro\";\n  }\n   createClass(VaadinLicenseChecker, [{\n    key: 'getForcedResponseKey',\n    value: function getForcedResponseKey(productInfo) {\n      return 'vaadin.licenses.{product}.forcedResponse'.replace('{product}', productInfo.name);\n    }\n  }, {\n    key: 'getForcedResponse',\n    value: function getForcedResponse(productInfo) {\n      return localStorage.getItem(this.getForcedResponseKey(productInfo));\n    }\n  }, {\n    key: 'clearForcedResponse',\n    value: function clearForcedResponse(productInfo) {\n      return localStorage.removeItem(this.getForcedResponseKey(productInfo));\n    }\n  }, {\n    key: 'maybeCheck',\n    value: function maybeCheck(productInfo) {\n      this.logger.debug(\"maybeCheck(\" + JSON.stringify(productInfo) + \")\");\n      // Defer first check until interval has expired to avoid interfering with tests etc\n      var now = new Date().getTime();\n      var lastCheck = this.storage.getLastCheck(productInfo);\n      if (!lastCheck) {\n        this.logger.debug(\"Deferring first check until \" + new Date(now + this.firstCheckDelay));\n        this.storage.setLastCheck(productInfo, now - this.checkInterval + this.firstCheckDelay);\n        return;\n      } else {\n        var sinceLastCheck = Math.round((now - lastCheck) / 1000);\n        var nextCheck = Math.round(this.checkInterval / 1000 - sinceLastCheck);\n        if (nextCheck > 0) {\n          // Checked recently\n          var nextCheckDate = new Date(lastCheck + this.checkInterval);\n          this.logger.debug(\"Checked \" + sinceLastCheck + \"s ago. Next check in \" + nextCheck + \"s at \" + nextCheckDate + \".\");\n          return;\n        } else {\n          this.logger.debug(\"Last check was \" + sinceLastCheck + \"s ago.\");\n        }\n      }\n      this.check(productInfo);\n    }\n  }, {\n    key: 'check',\n    value: function check(productInfo) {\n      this.logger.debug(\"check(\" + JSON.stringify(productInfo) + \")\");\n       // Only show an ok notification if the \"validation needed\" notification was shown.\n      // For background checks, show no visual notification if all goes well\n      var showOkOnSuccess = this.validationNeededNotifier.isVisible(productInfo);\n       var checker = this;\n      var onerror = function () {\n        // Offline or blocked, just log to console and let people get work done\n        console.error(\"Unable to validate the license for \" + productInfo.name + \". Check your internet access.\");\n      };\n      var onresponse = function (responseText) {\n        var response = JSON.parse(responseText);\n        if (response.result == \"ok\") {\n          // Everything is fine, stop\n          checker.logger.debug(\"License check ok for \" + JSON.stringify(productInfo));\n          checker.storage.setLastCheck(productInfo, new Date().getTime());\n          if (showOkOnSuccess) {\n            checker.logger.debug(\"Showing validation-ok dialog\");\n            checker.okNotifier.show(productInfo);\n          }\n        } else {\n          checker.logger.debug(\"License check failed for \" + JSON.stringify(productInfo));\n          checker.logger.debug(\"Showing validation-needed dialog\");\n          checker.validationNeededNotifier.show(productInfo);\n        }\n        if (response.message) {\n          console.log(response.message);\n        }\n      };\n       // This is typically hidden already but when receiving a window message it is not\n      this.logger.debug(\"Ensuring validation-needed dialog is hidden\");\n      this.validationNeededNotifier.hide(productInfo);\n       if (this.logger.isDebug() && this.getForcedResponse(productInfo)) {\n        var respJson = this.getForcedResponse(productInfo);\n        this.clearForcedResponse(productInfo);\n        if (JSON.parse(respJson).type == \"error\") {\n          this.logger.debug(\"Forced error for check\");\n          onerror();\n        } else {\n          this.logger.debug(\"Forced response for check: \" + respJson);\n          onresponse(respJson);\n        }\n      } else {\n        this.send(this.url, productInfo, onresponse, onerror);\n      }\n    }\n  }, {\n    key: 'send',\n    value: function send(url, productInfo, onsuccess, onerror) {\n      this.logger.debug(\"Sending request to \" + url);\n      var req = new XMLHttpRequest();\n      req.withCredentials = true;\n      req.addEventListener(\"readystatechange\", function () {\n        if (req.readyState === XMLHttpRequest.DONE && req.status === 200) {\n          onsuccess(req.responseText);\n        }\n      });\n      req.addEventListener(\"error\", function () {\n        onerror();\n      });\n      req.open(\"GET\", url);\n      req.setRequestHeader(\"check-source\", \"webcomponent\");\n      req.setRequestHeader(\"product-name\", productInfo.name);\n      req.setRequestHeader(\"product-version\", productInfo.version);\n       req.send();\n    }\n  }], [{\n    key: 'version',\n    get: function () {\n      return '2.1.2';\n    }\n  }]);\n  return VaadinLicenseChecker;\n  }();\n  var LicenseOkNotifier = function () {\n  function LicenseOkNotifier() {\n    classCallCheck(this, LicenseOkNotifier);\n  }\n   createClass(LicenseOkNotifier, [{\n    key: 'getInstance',\n    value: function getInstance() {\n      return document.getElementById(LicenseOkNotifier.id);\n    }\n  }, {\n    key: 'show',\n    value: function show(productInfo) {\n      // Only show one ok box even if multiple licenses were checked\n      if (this.getInstance()) {\n        // Already shown\n        return;\n      }\n      var instance = document.createElement(\"vaadin-license-box\");\n      instance.id = LicenseOkNotifier.id;\n      instance.type = \"ok\";\n      instance.content = \"Your license has been validated\";\n      document.body.appendChild(instance);\n      instance.addEventListener(\"click\", function () {\n        instance.parentElement.removeChild(instance);\n      });\n    }\n  }], [{\n    key: 'id',\n    get: function () {\n      return 'vaadin-license-validation-ok';\n    }\n  }]);\n  return LicenseOkNotifier;\n  }();\n  var LicenseValidationNeededNotifier = function () {\n  function LicenseValidationNeededNotifier() {\n    classCallCheck(this, LicenseValidationNeededNotifier);\n  }\n   createClass(LicenseValidationNeededNotifier, [{\n    key: 'id',\n    value: function id(productInfo) {\n      return \"vaadin-license-validation-notification-{product}\".replace(\"{product}\", productInfo.name);\n    }\n  }, {\n    key: 'getInstance',\n    value: function getInstance(productInfo) {\n      return document.getElementById(this.id(productInfo));\n    }\n  }, {\n    key: 'show',\n    value: function show(productInfo) {\n      if (this.getInstance(productInfo)) {\n        // Already shown\n        return;\n      }\n      var instance = document.createElement(\"vaadin-license-box\");\n      instance.id = this.id(productInfo);\n      instance.type = \"needsvalidation\";\n      instance.content = \"This application is using components which are part of a Vaadin subscription.<br>Click here to get a trial or validate your subscription\";\n      document.body.appendChild(instance);\n      instance.addEventListener(\"click\", function () {\n        window.open(\"https://vaadin.com/pro/validate-license\", \"_blank\");\n      });\n    }\n  }, {\n    key: 'hide',\n    value: function hide(productInfo) {\n      var instance = this.getInstance(productInfo);\n      if (instance) {\n        instance.parentElement.removeChild(instance);\n      }\n    }\n  }, {\n    key: 'isVisible',\n    value: function isVisible(productInfo) {\n      return !!this.getInstance(productInfo);\n    }\n  }]);\n  return LicenseValidationNeededNotifier;\n  }();\n  var proProducts = [];\n  window.Vaadin = window.Vaadin || {};\n  window.Vaadin.LicenseChecker = window.Vaadin.VaadinLicenseChecker || new VaadinLicenseChecker();\n  window.Vaadin.LicenseCheckerClass = window.Vaadin.LicenseCheckerClass || VaadinLicenseChecker;\n  window.Vaadin.developmentModeCallback = window.Vaadin.developmentModeCallback || {};\n  window.Vaadin.developmentModeCallback[\"vaadin-license-checker\"] = function (cls) {\n  var productInfo = { name: cls.is, version: cls.version };\n  proProducts.push(productInfo);\n  window.addEventListener(\"message\", function (e) {\n    if (e.data == \"validate-license\") {\n      window.Vaadin.LicenseChecker.check(productInfo);\n    }\n  }, false);\n   window.Vaadin.checkLicenses = function () {\n    // Force checking of all licenses to avoid e.g. popups during presentations when the grace period just has ended\n    proProducts.forEach(function (productInfo) {\n      window.Vaadin.LicenseChecker.check(productInfo);\n    });\n  };\n   window.Vaadin.LicenseChecker.maybeCheck(productInfo);\n  };\n  }());\n   vaadin-dev-mode:end **/\n}\n\nif (typeof runIfDevelopmentMode === 'function') {\n  runIfDevelopmentMode(maybeCheckLicenses);\n}"
    },
    {
     "id": 258,
     "name": "../node_modules/highcharts/js/es-modules/parts/Pointer.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * One position in relation to an axis.\n *\n * @typedef Highcharts.PointerAxisCoordinateObject\n *\n * @property {Highcharts.Axis} axis\n *           Related axis.\n *\n * @property {number} value\n *           Axis value.\n */\n\n/**\n * Positions in terms of axis values.\n *\n * @typedef Highcharts.PointerAxisCoordinatesObject\n *\n * @property {Array<Highcharts.PointerAxisCoordinateObject>} xAxis\n *           Positions on the x-axis.\n *\n * @property {Array<Highcharts.PointerAxisCoordinateObject>} yAxis\n *           Positions on the y-axis.\n */\n\n/**\n * Pointer coordinates.\n *\n * @typedef Highcharts.PointerCoordinatesObject\n *\n * @property {number} chartX\n *\n * @property {number} chartY\n */\n\n/**\n * A native browser mouse or touch event, extended with position information\n * relative to the {@link Chart.container}.\n *\n * @typedef {global.PointerEvent} Highcharts.PointerEventObject\n *\n * @property {number} chartX\n *           The X coordinate of the pointer interaction relative to the\n *           chart.\n *\n * @property {number} chartY\n *           The Y coordinate of the pointer interaction relative to the\n *           chart.\n */\n\n/**\n * Axis-specific data of a selection.\n *\n * @typedef Highcharts.SelectDataObject\n *\n * @property {Highcharts.Axis} axis\n *\n * @property {number} min\n *\n * @property {number} max\n */\n\n/**\n * Object for select events.\n *\n * @typedef Highcharts.SelectEventObject\n *\n * @property {global.Event} originalEvent\n *\n * @property {Array<Highcharts.SelectDataObject>} xAxis\n *\n * @property {Array<Highcharts.SelectDataObject>} yAxis\n */\n'use strict';\n\nimport Highcharts from './Globals.js';\nimport './Utilities.js';\nimport './Tooltip.js';\nimport './Color.js';\nvar H = Highcharts,\n    addEvent = H.addEvent,\n    attr = H.attr,\n    charts = H.charts,\n    color = H.color,\n    css = H.css,\n    defined = H.defined,\n    each = H.each,\n    extend = H.extend,\n    find = H.find,\n    fireEvent = H.fireEvent,\n    isNumber = H.isNumber,\n    isObject = H.isObject,\n    offset = H.offset,\n    pick = H.pick,\n    splat = H.splat,\n    Tooltip = H.Tooltip;\n/**\n * The mouse and touch tracker object. Each {@link Chart} item has one\n * assosiated Pointer item that can be accessed from the  {@link Chart.pointer}\n * property.\n *\n * @class\n * @name Highcharts.Pointer\n *\n * @param {Highcharts.Chart} chart\n *        The Chart instance.\n *\n * @param {Highcharts.Options} options\n *        The root options object. The pointer uses options from the chart and\n *        tooltip structures.\n */\n\nHighcharts.Pointer = function (chart, options) {\n  this.init(chart, options);\n};\n\nHighcharts.Pointer.prototype = {\n  /**\n   * Initialize the Pointer.\n   *\n   * @private\n   * @function Highcharts.Pointer#init\n   *\n   * @param {Highcharts.Chart} chart\n   *        The Chart instance.\n   *\n   * @param {Highcharts.Options} options\n   *        The root options object. The pointer uses options from the chart\n   *        and tooltip structures.\n   */\n  init: function (chart, options) {\n    // Store references\n    this.options = options;\n    this.chart = chart; // Do we need to handle click on a touch device?\n\n    this.runChartClick = options.chart.events && !!options.chart.events.click;\n    this.pinchDown = [];\n    this.lastValidTouch = {};\n\n    if (Tooltip) {\n      /**\n       * Tooltip object for points of series.\n       *\n       * @name Highcharts.Chart#tooltip\n       * @type {Highcharts.Tooltip}\n       */\n      chart.tooltip = new Tooltip(chart, options.tooltip);\n      this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n    }\n\n    this.setDOMEvents();\n  },\n\n  /**\n   * Resolve the zoomType option, this is reset on all touch start and mouse\n   * down events.\n   *\n   * @private\n   * @function Highcharts.Pointer#zoomOption\n   *\n   * @param {global.Event} e\n   *        Event object.\n   */\n  zoomOption: function (e) {\n    var chart = this.chart,\n        options = chart.options.chart,\n        zoomType = options.zoomType || '',\n        inverted = chart.inverted,\n        zoomX,\n        zoomY; // Look for the pinchType option\n\n    if (/touch/.test(e.type)) {\n      zoomType = pick(options.pinchType, zoomType);\n    }\n\n    this.zoomX = zoomX = /x/.test(zoomType);\n    this.zoomY = zoomY = /y/.test(zoomType);\n    this.zoomHor = zoomX && !inverted || zoomY && inverted;\n    this.zoomVert = zoomY && !inverted || zoomX && inverted;\n    this.hasZoom = zoomX || zoomY;\n  },\n\n  /**\n   * Takes a browser event object and extends it with custom Highcharts\n   * properties `chartX` and `chartY` in order to work on the internal\n   * coordinate system.\n   *\n   * @function Highcharts.Pointer#normalize\n   *\n   * @param {global.Event} e\n   *        Event object in standard browsers.\n   *\n   * @return {Highcharts.PointerEventObject}\n   *         A browser event with extended properties `chartX` and `chartY`.\n   */\n  normalize: function (e, chartPosition) {\n    var ePos; // iOS (#2757)\n\n    ePos = e.touches ? e.touches.length ? e.touches.item(0) : e.changedTouches[0] : e; // Get mouse position\n\n    if (!chartPosition) {\n      this.chartPosition = chartPosition = offset(this.chart.container);\n    }\n\n    return extend(e, {\n      chartX: Math.round(ePos.pageX - chartPosition.left),\n      chartY: Math.round(ePos.pageY - chartPosition.top)\n    });\n  },\n\n  /**\n   * Get the click position in terms of axis values.\n   *\n   * @function Highcharts.Pointer#getCoordinates\n   *\n   * @param {Highcharts.PointerEventObject} e\n   *        Pointer event, extended with `chartX` and `chartY` properties.\n   *\n   * @return {Highcharts.PointerAxisCoordinatesObject}\n   */\n  getCoordinates: function (e) {\n    var coordinates = {\n      xAxis: [],\n      yAxis: []\n    };\n    each(this.chart.axes, function (axis) {\n      coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n        axis: axis,\n        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n      });\n    });\n    return coordinates;\n  },\n\n  /**\n   * Finds the closest point to a set of coordinates, using the k-d-tree\n   * algorithm.\n   *\n   * @function Highcharts.Pointer#findNearestKDPoints\n   *\n   * @param {Array<Highcharts.Series>} series\n   *        All the series to search in.\n   *\n   * @param {boolean} shared\n   *        Whether it is a shared tooltip or not.\n   *\n   * @param {Highcharts.PointerCoordinatesObject} coordinates\n   *        Chart coordinates of the pointer.\n   *\n   * @return {Point|undefined}\n   *         The point closest to given coordinates.\n   */\n  findNearestKDPoint: function (series, shared, coordinates) {\n    var closest,\n        sort = function (p1, p2) {\n      var isCloserX = p1.distX - p2.distX,\n          isCloser = p1.dist - p2.dist,\n          isAbove = (p2.series.group && p2.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex),\n          result; // We have two points which are not in the same place on xAxis\n      // and shared tooltip:\n\n      if (isCloserX !== 0 && shared) {\n        // #5721\n        result = isCloserX; // Points are not exactly in the same place on x/yAxis:\n      } else if (isCloser !== 0) {\n        result = isCloser; // The same xAxis and yAxis position, sort by z-index:\n      } else if (isAbove !== 0) {\n        result = isAbove; // The same zIndex, sort by array index:\n      } else {\n        result = p1.series.index > p2.series.index ? -1 : 1;\n      }\n\n      return result;\n    };\n\n    each(series, function (s) {\n      var noSharedTooltip = s.noSharedTooltip && shared,\n          compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf('y') < 0,\n          point = s.searchPoint(coordinates, compareX);\n\n      if ( // Check that we actually found a point on the series.\n      isObject(point, true) && ( // Use the new point if it is closer.\n      !isObject(closest, true) || sort(closest, point) > 0)) {\n        closest = point;\n      }\n    });\n    return closest;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#getPointFromEvent\n   *\n   * @param {global.Event} e\n   *\n   * @return {Highcharts.Point|undefined}\n   */\n  getPointFromEvent: function (e) {\n    var target = e.target,\n        point;\n\n    while (target && !point) {\n      point = target.point;\n      target = target.parentNode;\n    }\n\n    return point;\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#getChartCoordinatesFromPoint\n   *\n   * @param {Highcharts.Point} point\n   *\n   * @param {boolean} inverted\n   *\n   * @return {Highcharts.PointerCoordinatesObject}\n   */\n  getChartCoordinatesFromPoint: function (point, inverted) {\n    var series = point.series,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis,\n        plotX = pick(point.clientX, point.plotX),\n        shapeArgs = point.shapeArgs;\n\n    if (xAxis && yAxis) {\n      return inverted ? {\n        chartX: xAxis.len + xAxis.pos - plotX,\n        chartY: yAxis.len + yAxis.pos - point.plotY\n      } : {\n        chartX: plotX + xAxis.pos,\n        chartY: point.plotY + yAxis.pos\n      };\n    } else if (shapeArgs && shapeArgs.x && shapeArgs.y) {\n      // E.g. pies do not have axes\n      return {\n        chartX: shapeArgs.x,\n        chartY: shapeArgs.y\n      };\n    }\n  },\n\n  /**\n   * Calculates what is the current hovered point/points and series.\n   *\n   * @private\n   * @function Highcharts.Pointer#getHoverData\n   *\n   * @param {Highcharts.Point|undefined} existingHoverPoint\n   *        The point currrently beeing hovered.\n   *\n   * @param {Highcharts.Series|undefined} existingHoverSeries\n   *        The series currently beeing hovered.\n   *\n   * @param {Array<Highcharts.Series>} series\n   *        All the series in the chart.\n   *\n   * @param {boolean} isDirectTouch\n   *        Is the pointer directly hovering the point.\n   *\n   * @param {boolean} shared\n   *        Whether it is a shared tooltip or not.\n   *\n   * @param {Highcharts.PointerCoordinatesObject} coordinates\n   *        Chart coordinates of the pointer.\n   *\n   * @return {*}\n   *         Object containing resulting hover data: hoverPoint, hoverSeries,\n   *         and hoverPoints.\n   */\n  getHoverData: function (existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, coordinates, params) {\n    var hoverPoint,\n        hoverPoints = [],\n        hoverSeries = existingHoverSeries,\n        isBoosting = params && params.isBoosting,\n        useExisting = !!(isDirectTouch && existingHoverPoint),\n        notSticky = hoverSeries && !hoverSeries.stickyTracking,\n        filter = function (s) {\n      return s.visible && !(!shared && s.directTouch) && // #3821\n      pick(s.options.enableMouseTracking, true);\n    },\n        // Which series to look in for the hover point\n    searchSeries = notSticky ? // Only search on hovered series if it has stickyTracking false\n    [hoverSeries] : // Filter what series to look in.\n    H.grep(series, function (s) {\n      return filter(s) && s.stickyTracking;\n    }); // Use existing hovered point or find the one closest to coordinates.\n\n\n    hoverPoint = useExisting ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, coordinates); // Assign hover series\n\n    hoverSeries = hoverPoint && hoverPoint.series; // If we have a hoverPoint, assign hoverPoints.\n\n    if (hoverPoint) {\n      // When tooltip is shared, it displays more than one point\n      if (shared && !hoverSeries.noSharedTooltip) {\n        searchSeries = H.grep(series, function (s) {\n          return filter(s) && !s.noSharedTooltip;\n        }); // Get all points with the same x value as the hoverPoint\n\n        each(searchSeries, function (s) {\n          var point = find(s.points, function (p) {\n            return p.x === hoverPoint.x && !p.isNull;\n          });\n\n          if (isObject(point)) {\n            /*\n            * Boost returns a minimal point. Convert it to a usable\n            * point for tooltip and states.\n            */\n            if (isBoosting) {\n              point = s.getPoint(point);\n            }\n\n            hoverPoints.push(point);\n          }\n        });\n      } else {\n        hoverPoints.push(hoverPoint);\n      }\n    }\n\n    return {\n      hoverPoint: hoverPoint,\n      hoverSeries: hoverSeries,\n      hoverPoints: hoverPoints\n    };\n  },\n\n  /**\n   * With line type charts with a single tracker, get the point closest to the\n   * mouse. Run Point.onMouseOver and display tooltip for the point or points.\n   *\n   * @private\n   * @function Highcharts.Pointer#runPointActions\n   *\n   * @param {global.Event} e\n   *\n   * @param {Highcharts.Point} p\n   *\n   * @fires Highcharts.Point#event:mouseOut\n   * @fires Highcharts.Point#event:mouseOver\n   */\n  runPointActions: function (e, p) {\n    var pointer = this,\n        chart = pointer.chart,\n        series = chart.series,\n        tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : undefined,\n        shared = tooltip ? tooltip.shared : false,\n        hoverPoint = p || chart.hoverPoint,\n        hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,\n        // onMouseOver or already hovering a series with directTouch\n    isDirectTouch = e.type !== 'touchmove' && (!!p || hoverSeries && hoverSeries.directTouch && pointer.isDirectTouch),\n        hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e, {\n      isBoosting: chart.isBoosting\n    }),\n        useSharedTooltip,\n        followPointer,\n        anchor,\n        points; // Update variables from hoverData.\n\n    hoverPoint = hoverData.hoverPoint;\n    points = hoverData.hoverPoints;\n    hoverSeries = hoverData.hoverSeries;\n    followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n    useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip; // Refresh tooltip for kdpoint if new hover point or tooltip was hidden\n    // #3926, #4200\n\n    if (hoverPoint && ( // !(hoverSeries && hoverSeries.directTouch) &&\n    hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {\n      each(chart.hoverPoints || [], function (p) {\n        if (H.inArray(p, points) === -1) {\n          p.setState();\n        }\n      }); // Do mouseover on all points (#3919, #3985, #4410, #5622)\n\n      each(points || [], function (p) {\n        p.setState('hover');\n      }); // set normal state to previous series\n\n      if (chart.hoverSeries !== hoverSeries) {\n        hoverSeries.onMouseOver();\n      } // If tracking is on series in stead of on each point,\n      // fire mouseOver on hover point. // #4448\n\n\n      if (chart.hoverPoint) {\n        chart.hoverPoint.firePointEvent('mouseOut');\n      } // Hover point may have been destroyed in the event handlers (#7127)\n\n\n      if (!hoverPoint.series) {\n        return;\n      }\n\n      hoverPoint.firePointEvent('mouseOver');\n      chart.hoverPoints = points;\n      chart.hoverPoint = hoverPoint; // Draw tooltip if necessary\n\n      if (tooltip) {\n        tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);\n      } // Update positions (regardless of kdpoint or hoverPoint)\n\n    } else if (followPointer && tooltip && !tooltip.isHidden) {\n      anchor = tooltip.getAnchor([{}], e);\n      tooltip.updatePosition({\n        plotX: anchor[0],\n        plotY: anchor[1]\n      });\n    } // Start the event listener to pick up the tooltip and crosshairs\n\n\n    if (!pointer.unDocMouseMove) {\n      pointer.unDocMouseMove = addEvent(chart.container.ownerDocument, 'mousemove', function (e) {\n        var chart = charts[H.hoverChartIndex];\n\n        if (chart) {\n          chart.pointer.onDocumentMouseMove(e);\n        }\n      });\n    } // Issues related to crosshair #4927, #5269 #5066, #5658\n\n\n    each(chart.axes, function drawAxisCrosshair(axis) {\n      var snap = pick(axis.crosshair.snap, true),\n          point = !snap ? undefined : H.find(points, function (p) {\n        return p.series[axis.coll] === axis;\n      }); // Axis has snapping crosshairs, and one of the hover points belongs\n      // to axis. Always call drawCrosshair when it is not snap.\n\n      if (point || !snap) {\n        axis.drawCrosshair(e, point); // Axis has snapping crosshairs, but no hover point belongs to axis\n      } else {\n        axis.hideCrosshair();\n      }\n    });\n  },\n\n  /**\n   * Reset the tracking by hiding the tooltip, the hover series state and the\n   * hover point\n   *\n   * @function Highcharts.Pointer#reset\n   *\n   * @param {boolean} allowMove\n   *        Instead of destroying the tooltip altogether, allow moving it if\n   *        possible.\n   *\n   * @param {number} delay\n   */\n  reset: function (allowMove, delay) {\n    var pointer = this,\n        chart = pointer.chart,\n        hoverSeries = chart.hoverSeries,\n        hoverPoint = chart.hoverPoint,\n        hoverPoints = chart.hoverPoints,\n        tooltip = chart.tooltip,\n        tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint; // Check if the points have moved outside the plot area (#1003, #4736,\n    // #5101)\n\n    if (allowMove && tooltipPoints) {\n      each(splat(tooltipPoints), function (point) {\n        if (point.series.isCartesian && point.plotX === undefined) {\n          allowMove = false;\n        }\n      });\n    } // Just move the tooltip, #349\n\n\n    if (allowMove) {\n      if (tooltip && tooltipPoints) {\n        tooltip.refresh(tooltipPoints);\n\n        if (tooltip.shared && hoverPoints) {\n          // #8284\n          each(hoverPoints, function (point) {\n            point.setState(point.state, true);\n\n            if (point.series.xAxis.crosshair) {\n              point.series.xAxis.drawCrosshair(null, point);\n            }\n\n            if (point.series.yAxis.crosshair) {\n              point.series.yAxis.drawCrosshair(null, point);\n            }\n          });\n        } else if (hoverPoint) {\n          // #2500\n          hoverPoint.setState(hoverPoint.state, true);\n          each(chart.axes, function (axis) {\n            if (axis.crosshair) {\n              axis.drawCrosshair(null, hoverPoint);\n            }\n          });\n        }\n      } // Full reset\n\n    } else {\n      if (hoverPoint) {\n        hoverPoint.onMouseOut();\n      }\n\n      if (hoverPoints) {\n        each(hoverPoints, function (point) {\n          point.setState();\n        });\n      }\n\n      if (hoverSeries) {\n        hoverSeries.onMouseOut();\n      }\n\n      if (tooltip) {\n        tooltip.hide(delay);\n      }\n\n      if (pointer.unDocMouseMove) {\n        pointer.unDocMouseMove = pointer.unDocMouseMove();\n      } // Remove crosshairs\n\n\n      each(chart.axes, function (axis) {\n        axis.hideCrosshair();\n      });\n      pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n    }\n  },\n\n  /**\n   * Scale series groups to a certain scale and translation.\n   *\n   * @private\n   * @function Highcharts.Pointer#scaleGroups\n   *\n   * @param {Highcharts.SeriesPlotBoxObject} attribs\n   *\n   * @param {boolean} clip\n   */\n  scaleGroups: function (attribs, clip) {\n    var chart = this.chart,\n        seriesAttribs; // Scale each series\n\n    each(chart.series, function (series) {\n      seriesAttribs = attribs || series.getPlotBox(); // #1701\n\n      if (series.xAxis && series.xAxis.zoomEnabled && series.group) {\n        series.group.attr(seriesAttribs);\n\n        if (series.markerGroup) {\n          series.markerGroup.attr(seriesAttribs);\n          series.markerGroup.clip(clip ? chart.clipRect : null);\n        }\n\n        if (series.dataLabelsGroup) {\n          series.dataLabelsGroup.attr(seriesAttribs);\n        }\n      }\n    }); // Clip\n\n    chart.clipRect.attr(clip || chart.clipBox);\n  },\n\n  /**\n   * Start a drag operation.\n   *\n   * @private\n   * @function Highcharts.Pointer#dragStart\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  dragStart: function (e) {\n    var chart = this.chart; // Record the start position\n\n    chart.mouseIsDown = e.type;\n    chart.cancelClick = false;\n    chart.mouseDownX = this.mouseDownX = e.chartX;\n    chart.mouseDownY = this.mouseDownY = e.chartY;\n  },\n\n  /**\n   * Perform a drag operation in response to a mousemove event while the mouse\n   * is down.\n   *\n   * @private\n   * @function Highcharts.Pointer#drag\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  drag: function (e) {\n    var chart = this.chart,\n        chartOptions = chart.options.chart,\n        chartX = e.chartX,\n        chartY = e.chartY,\n        zoomHor = this.zoomHor,\n        zoomVert = this.zoomVert,\n        plotLeft = chart.plotLeft,\n        plotTop = chart.plotTop,\n        plotWidth = chart.plotWidth,\n        plotHeight = chart.plotHeight,\n        clickedInside,\n        size,\n        selectionMarker = this.selectionMarker,\n        mouseDownX = this.mouseDownX,\n        mouseDownY = this.mouseDownY,\n        panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key']; // If the device supports both touch and mouse (like IE11), and we are\n    // touch-dragging inside the plot area, don't handle the mouse event.\n    // #4339.\n\n    if (selectionMarker && selectionMarker.touch) {\n      return;\n    } // If the mouse is outside the plot area, adjust to cooordinates\n    // inside to prevent the selection marker from going outside\n\n\n    if (chartX < plotLeft) {\n      chartX = plotLeft;\n    } else if (chartX > plotLeft + plotWidth) {\n      chartX = plotLeft + plotWidth;\n    }\n\n    if (chartY < plotTop) {\n      chartY = plotTop;\n    } else if (chartY > plotTop + plotHeight) {\n      chartY = plotTop + plotHeight;\n    } // determine if the mouse has moved more than 10px\n\n\n    this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));\n\n    if (this.hasDragged > 10) {\n      clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop); // make a selection\n\n      if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n        if (!selectionMarker) {\n          this.selectionMarker = selectionMarker = chart.renderer.rect(plotLeft, plotTop, zoomHor ? 1 : plotWidth, zoomVert ? 1 : plotHeight, 0).attr({\n            'class': 'highcharts-selection-marker',\n            'zIndex': 7\n          }).add();\n        }\n      } // adjust the width of the selection marker\n\n\n      if (selectionMarker && zoomHor) {\n        size = chartX - mouseDownX;\n        selectionMarker.attr({\n          width: Math.abs(size),\n          x: (size > 0 ? 0 : size) + mouseDownX\n        });\n      } // adjust the height of the selection marker\n\n\n      if (selectionMarker && zoomVert) {\n        size = chartY - mouseDownY;\n        selectionMarker.attr({\n          height: Math.abs(size),\n          y: (size > 0 ? 0 : size) + mouseDownY\n        });\n      } // panning\n\n\n      if (clickedInside && !selectionMarker && chartOptions.panning) {\n        chart.pan(e, chartOptions.panning);\n      }\n    }\n  },\n\n  /**\n   * On mouse up or touch end across the entire document, drop the selection.\n   *\n   * @private\n   * @function Highcharts.Pointer#drop\n   *\n   * @param {global.Event} e\n   */\n  drop: function (e) {\n    var pointer = this,\n        chart = this.chart,\n        hasPinched = this.hasPinched;\n\n    if (this.selectionMarker) {\n      var selectionData = {\n        originalEvent: e,\n        // #4890\n        xAxis: [],\n        yAxis: []\n      },\n          selectionBox = this.selectionMarker,\n          selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n          selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n          selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n          selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n          runZoom; // a selection has been made\n\n      if (this.hasDragged || hasPinched) {\n        // record each axis' min and max\n        each(chart.axes, function (axis) {\n          if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{\n            xAxis: 'zoomX',\n            yAxis: 'zoomY'\n          }[axis.coll]])) {\n            // #859, #3569\n            var horiz = axis.horiz,\n                minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0,\n                // #1207, #3075\n            selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n                selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n            selectionData[axis.coll].push({\n              axis: axis,\n              // Min/max for reversed axes\n              min: Math.min(selectionMin, selectionMax),\n              max: Math.max(selectionMin, selectionMax)\n            });\n            runZoom = true;\n          }\n        });\n\n        if (runZoom) {\n          fireEvent(chart, 'selection', selectionData, function (args) {\n            chart.zoom(extend(args, hasPinched ? {\n              animation: false\n            } : null));\n          });\n        }\n      }\n\n      if (isNumber(chart.index)) {\n        this.selectionMarker = this.selectionMarker.destroy();\n      } // Reset scaling preview\n\n\n      if (hasPinched) {\n        this.scaleGroups();\n      }\n    } // Reset all. Check isNumber because it may be destroyed on mouse up\n    // (#877)\n\n\n    if (chart && isNumber(chart.index)) {\n      css(chart.container, {\n        cursor: chart._cursor\n      });\n      chart.cancelClick = this.hasDragged > 10; // #370\n\n      chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n      this.pinchDown = [];\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseDown\n   *\n   * @param {global.Event} e\n   */\n  onContainerMouseDown: function (e) {\n    // Normalize before the 'if' for the legacy IE (#7850)\n    e = this.normalize(e);\n\n    if (e.button !== 2) {\n      this.zoomOption(e); // issue #295, dragging not always working in Firefox\n\n      if (e.preventDefault) {\n        e.preventDefault();\n      }\n\n      this.dragStart(e);\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#onDocumentMouseUp\n   *\n   * @param {global.Event} e\n   */\n  onDocumentMouseUp: function (e) {\n    if (charts[H.hoverChartIndex]) {\n      charts[H.hoverChartIndex].pointer.drop(e);\n    }\n  },\n\n  /**\n   * Special handler for mouse move that will hide the tooltip when the mouse\n   * leaves the plotarea. Issue #149 workaround. The mouseleave event does not\n   * always fire.\n   *\n   * @private\n   * @function Highcharts.Pointer#onDocumentMouseMove\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  onDocumentMouseMove: function (e) {\n    var chart = this.chart,\n        chartPosition = this.chartPosition;\n    e = this.normalize(e, chartPosition); // If we're outside, hide the tooltip\n\n    if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') && !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n      this.reset();\n    }\n  },\n\n  /**\n   * When mouse leaves the container, hide the tooltip.\n   *\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseLeave\n   *\n   * @param {global.Event} e\n   */\n  onContainerMouseLeave: function (e) {\n    var chart = charts[H.hoverChartIndex]; // #4886, MS Touch end fires mouseleave but with no related target\n\n    if (chart && (e.relatedTarget || e.toElement)) {\n      chart.pointer.reset(); // Also reset the chart position, used in #149 fix\n\n      chart.pointer.chartPosition = null;\n    }\n  },\n\n  /**\n   * The mousemove, touchmove and touchstart event handler\n   *\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseMove\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  onContainerMouseMove: function (e) {\n    var chart = this.chart;\n\n    if (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex] || !charts[H.hoverChartIndex].mouseIsDown) {\n      H.hoverChartIndex = chart.index;\n    }\n\n    e = this.normalize(e);\n    e.returnValue = false; // #2251, #3224\n\n    if (chart.mouseIsDown === 'mousedown') {\n      this.drag(e);\n    } // Show the tooltip and run mouse over events (#977)\n\n\n    if ((this.inClass(e.target, 'highcharts-tracker') || chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n      this.runPointActions(e);\n    }\n  },\n\n  /**\n   * Utility to detect whether an element has, or has a parent with, a\n   * specificclass name. Used on detection of tracker objects and on deciding\n   * whether hovering the tooltip should cause the active series to mouse out.\n   *\n   * @function Highcharts.Pointer#inClass\n   *\n   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n   *        The element to investigate.\n   *\n   * @param {string} className\n   *        The class name to look for.\n   *\n   * @return {boolean}\n   *         True if either the element or one of its parents has the given\n   *         class name.\n   */\n  inClass: function (element, className) {\n    var elemClassName;\n\n    while (element) {\n      elemClassName = attr(element, 'class');\n\n      if (elemClassName) {\n        if (elemClassName.indexOf(className) !== -1) {\n          return true;\n        }\n\n        if (elemClassName.indexOf('highcharts-container') !== -1) {\n          return false;\n        }\n      }\n\n      element = element.parentNode;\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#onTrackerMouseOut\n   *\n   * @param {global.Event} e\n   */\n  onTrackerMouseOut: function (e) {\n    var series = this.chart.hoverSeries,\n        relatedTarget = e.relatedTarget || e.toElement;\n    this.isDirectTouch = false;\n\n    if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, 'highcharts-tooltip') && (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) || // #2499, #4465\n    !this.inClass(relatedTarget, 'highcharts-tracker') // #5553\n    )) {\n      series.onMouseOut();\n    }\n  },\n\n  /**\n   * @private\n   * @function Highcharts.Pointer#onContainerClick\n   *\n   * @param {Highcharts.PointerEventObject} e\n   */\n  onContainerClick: function (e) {\n    var chart = this.chart,\n        hoverPoint = chart.hoverPoint,\n        plotLeft = chart.plotLeft,\n        plotTop = chart.plotTop;\n    e = this.normalize(e);\n\n    if (!chart.cancelClick) {\n      // On tracker click, fire the series and point events. #783, #1583\n      if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {\n        // the series click event\n        fireEvent(hoverPoint.series, 'click', extend(e, {\n          point: hoverPoint\n        })); // the point click event\n\n        if (chart.hoverPoint) {\n          // it may be destroyed (#1844)\n          hoverPoint.firePointEvent('click', e);\n        } // When clicking outside a tracker, fire a chart event\n\n      } else {\n        extend(e, this.getCoordinates(e)); // fire a click event in the chart\n\n        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n          fireEvent(chart, 'click', e);\n        }\n      }\n    }\n  },\n\n  /**\n   * Set the JS DOM events on the container and document. This method should\n   * contain a one-to-one assignment between methods and their handlers. Any\n   * advanced logic should be moved to the handler reflecting the event's\n   * name.\n   *\n   * @private\n   * @function Highcharts.Pointer#setDOMEvents\n   */\n  setDOMEvents: function () {\n    var pointer = this,\n        container = pointer.chart.container,\n        ownerDoc = container.ownerDocument;\n\n    container.onmousedown = function (e) {\n      pointer.onContainerMouseDown(e);\n    };\n\n    container.onmousemove = function (e) {\n      pointer.onContainerMouseMove(e);\n    };\n\n    container.onclick = function (e) {\n      pointer.onContainerClick(e);\n    };\n\n    this.unbindContainerMouseLeave = addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n\n    if (!H.unbindDocumentMouseUp) {\n      H.unbindDocumentMouseUp = addEvent(ownerDoc, 'mouseup', pointer.onDocumentMouseUp);\n    }\n\n    if (H.hasTouch) {\n      container.ontouchstart = function (e) {\n        pointer.onContainerTouchStart(e);\n      };\n\n      container.ontouchmove = function (e) {\n        pointer.onContainerTouchMove(e);\n      };\n\n      if (!H.unbindDocumentTouchEnd) {\n        H.unbindDocumentTouchEnd = addEvent(ownerDoc, 'touchend', pointer.onDocumentTouchEnd);\n      }\n    }\n  },\n\n  /**\n   * Destroys the Pointer object and disconnects DOM events.\n   *\n   * @function Highcharts.Pointer#destroy\n   */\n  destroy: function () {\n    var pointer = this;\n\n    if (pointer.unDocMouseMove) {\n      pointer.unDocMouseMove();\n    }\n\n    this.unbindContainerMouseLeave();\n\n    if (!H.chartCount) {\n      if (H.unbindDocumentMouseUp) {\n        H.unbindDocumentMouseUp = H.unbindDocumentMouseUp();\n      }\n\n      if (H.unbindDocumentTouchEnd) {\n        H.unbindDocumentTouchEnd = H.unbindDocumentTouchEnd();\n      }\n    } // memory and CPU leak\n\n\n    clearInterval(pointer.tooltipTimeout);\n    H.objectEach(pointer, function (val, prop) {\n      pointer[prop] = null;\n    });\n  }\n};"
    },
    {
     "id": 260,
     "name": "../node_modules/@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js?babel-target=es6",
     "source": "import './vaadin-checkbox-styles.js';\nimport '../../src/vaadin-checkbox.js';"
    },
    {
     "id": 262,
     "name": "../node_modules/@vaadin/vaadin-board/src/vaadin-board-row.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Commercial Vaadin Add-On License 3.0, available at http://vaadin.com/license/cval-3.\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { IronResizableBehavior } from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { DomRepeat } from '@polymer/polymer/lib/elements/dom-repeat.js';\nimport { DomIf } from '@polymer/polymer/lib/elements/dom-if.js';\nimport { mixinBehaviors } from '@polymer/polymer/lib/legacy/class.js';\n/**\n* `<vaadin-board-row>` is a Polymer element that together with `vaadin-board` element allows to create flexible responsive layouts and build nice looking dashboard.\n*\n* Each row can contain up to four elements (fewer if colspan is used) and is automatically responsive. The row changes between `large`, `medium` and `small` modes depending on the available width and the set breakpoints. In `large` mode, typically all content is shown side-by-side, in `medium` half of the content is side by side and in `small` mode, content is laid out vertically.\n*\n* The breakpoints can be set using custom CSS properties. By default the breakpoints are `small: <600px`, `medium: < 960px`, `large >= 960px`.\n*\n*\n* ```html\n* <vaadin-board>\n*   <vaadin-board-row>\n*     <div>This could be chart 1</div>\n*     <div>This could be chart 2</div>\n*     <div>This could be chart 3</div>\n*     <div>This could be chart 4</div>\n*   </vaadin-board-row>\n* </vaadin-board>\n* ```\n*\n* ### Styling\n*\n* The following custom properties are available for styling:\n*\n* Custom property | Description | Default\n* ----------------|-------------|-------------\n* `--vaadin-board-width-small` | Determines the width where mode changes from `small` to `medium` | `600px`\n* `--vaadin-board-width-medium` | Determines the width where mode changes from `medium` to `large` | `960px`\n*\n* @extends PolymerElement\n* @mixes ElementMixin\n* @demo demo/index.html\n*/\n\nclass BoardRowElement extends ElementMixin(mixinBehaviors([IronResizableBehavior], PolymerElement)) {\n  static get template() {\n    return html`\n    <style>\n       :host {\n        display: flex;\n        flex-flow: row wrap;\n        align-items: stretch;\n        --small-size: var(--vaadin-board-width-small, 600px);\n        --medium-size: var(--vaadin-board-width-medium, 960px);\n      }\n\n       :host ::slotted(*) {\n        box-sizing: border-box;\n        flex-grow: 1;\n        overflow: hidden;\n      }\n    </style>\n    <slot id=\"insertionPoint\"></slot>\n`;\n  }\n\n  static get is() {\n    return \"vaadin-board-row\";\n  }\n\n  constructor() {\n    super();\n    this._onIronResize = this._onIronResize.bind(this);\n    this._SMALL_VIEWPORT_CLASSNAME = \"small\";\n    this._MEDIUM_VIEWPORT_CLASSNAME = \"medium\";\n    this._LARGE_VIEWPORT_CLASSNAME = \"large\";\n    this._oldWidth = 0;\n    this._oldBreakpoints = {\n      'smallSize': 600,\n      'mediumSize': 960\n    };\n    this._oldFlexBasis = [];\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.addEventListener('iron-resize', this._onIronResize, true);\n    this.$.insertionPoint.addEventListener('slotchange', this.redraw.bind(this));\n    afterNextRender(this, function () {\n      //force this as an interested resizable of parent\n      this.dispatchEvent(new CustomEvent('iron-request-resize-notifications', {\n        node: this,\n        bubbles: true,\n        cancelable: true,\n        composed: true,\n        detail: {}\n      }));\n    });\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    afterNextRender(this, this._onIronResize);\n  }\n  /**\n   * Adds styles for board row based on width.\n   * @private\n   */\n\n\n  _addStyleNames(width, breakpoints) {\n    if (width < breakpoints.smallSize) {\n      this.classList.add(this._SMALL_VIEWPORT_CLASSNAME);\n      this.classList.remove(this._MEDIUM_VIEWPORT_CLASSNAME);\n      this.classList.remove(this._LARGE_VIEWPORT_CLASSNAME);\n    } else if (width < breakpoints.mediumSize) {\n      this.classList.remove(this._SMALL_VIEWPORT_CLASSNAME);\n      this.classList.add(this._MEDIUM_VIEWPORT_CLASSNAME);\n      this.classList.remove(this._LARGE_VIEWPORT_CLASSNAME);\n    } else {\n      this.classList.remove(this._SMALL_VIEWPORT_CLASSNAME);\n      this.classList.remove(this._MEDIUM_VIEWPORT_CLASSNAME);\n      this.classList.add(this._LARGE_VIEWPORT_CLASSNAME);\n    }\n  }\n  /**\n   * Calculates flex basis based on colSpan, width and breakpoints.\n   * @param {number} colSpan colspan value of the row\n   * @param {number} width width of the row in px\n   * @param {number} colsInRow number of columns in the row\n   * @param {object} breakpoints object with smallSize and mediumSize number properties, which tells\n   * where the row should switch rendering size in pixels.\n   * @private\n   */\n\n\n  _calculateFlexBasis(colSpan, width, colsInRow, breakpoints) {\n    if (width < breakpoints.smallSize) {\n      colsInRow = 1;\n    } else if (width < breakpoints.mediumSize && colsInRow == 4) {\n      colsInRow = 2;\n    }\n\n    var flexBasis = colSpan / colsInRow * 100;\n    flexBasis = flexBasis > 100 ? 100 : flexBasis;\n    return flexBasis + '%';\n  }\n  /** @private */\n\n\n  _reportError() {\n    var errorMessage = \"The column configuration is not valid; column count should add up to 3 or 4.\";\n    console.warn(errorMessage, \"check: \\r\\n\" + this.outerHTML);\n  }\n  /**\n   * Parses board-cols from DOM.\n   * If there is not enough space in the row drop board cols.\n   * @param {!Array<!Node>} nodes array of nodes\n   * @return {!Array<number>} array of boardCols\n   * @private\n   */\n\n\n  _parseBoardCols(nodes) {\n    var boardCols = nodes.map(node => {\n      if (node.getAttribute(\"board-cols\")) {\n        return parseInt(node.getAttribute(\"board-cols\"));\n      }\n\n      return 1;\n    });\n    var spaceLeft = 4;\n    var returnBoardCols = [];\n    nodes.forEach((node, i) => {\n      spaceLeft = spaceLeft - boardCols[i];\n    });\n\n    if (spaceLeft < 0) {\n      this._reportError();\n\n      boardCols.forEach((node, i) => {\n        returnBoardCols[i] = 1;\n      });\n    } else {\n      returnBoardCols = boardCols.slice(0);\n    }\n\n    return returnBoardCols;\n  }\n  /**\n   * If there is not enough space in the row.\n   * Extra items are dropped from DOM.\n   * @param {!Array<number>} boardCols array of board-cols for every node\n   * @param {!Array<!Node>} nodes array of nodes\n   * @return {!Array<!Node>} filtered array of nodes\n   * @private\n   */\n\n\n  _removeExtraNodesFromDOM(boardCols, nodes) {\n    var isErrorReported = false;\n    var spaceLeft = 4;\n    var returnNodes = [];\n    nodes.forEach((node, i) => {\n      spaceLeft = spaceLeft - boardCols[i];\n\n      if (spaceLeft < 0) {\n        if (!isErrorReported) {\n          isErrorReported = true;\n\n          this._reportError();\n        }\n\n        this.removeChild(node);\n      } else {\n        returnNodes[i] = node;\n      }\n    });\n    return returnNodes;\n  }\n  /**\n   * Redraws the row, if necessary.\n   *\n   * In most cases, a board row will redraw itself if your reconfigure it. If you dynamically change CSS which affects the row, then you need to call this method.\n   */\n\n\n  redraw() {\n    this._recalculateFlexBasis(true);\n  }\n  /** @private */\n\n\n  _onIronResize() {\n    this._recalculateFlexBasis(false);\n  }\n  /** @private */\n\n\n  _recalculateFlexBasis(forceResize) {\n    var width = this.getBoundingClientRect().width;\n\n    var breakpoints = this._measureBreakpointsInPx();\n\n    if (forceResize || width != this._oldWidth || breakpoints.smallSize != this._oldBreakpoints.smallSize || breakpoints.mediumSize != this._oldBreakpoints.mediumSize) {\n      var nodes = this.$.insertionPoint.assignedNodes({\n        flatten: true\n      });\n\n      var isElementNode = function (node) {\n        return !(node.nodeType === node.TEXT_NODE || node instanceof DomRepeat || node instanceof DomIf);\n      };\n\n      var filteredNodes = nodes.filter(isElementNode);\n\n      this._addStyleNames(width, breakpoints);\n\n      var boardCols = this._parseBoardCols(filteredNodes);\n\n      var colsInRow = boardCols.reduce((a, b) => a + b, 0);\n\n      this._removeExtraNodesFromDOM(boardCols, filteredNodes).forEach((e, i) => {\n        var newFlexBasis = this._calculateFlexBasis(boardCols[i], width, colsInRow, breakpoints);\n\n        if (forceResize || !this._oldFlexBasis[i] || this._oldFlexBasis[i] != newFlexBasis) {\n          this._oldFlexBasis[i] = newFlexBasis;\n          e.style.flexBasis = newFlexBasis;\n        }\n      });\n\n      this._oldWidth = width;\n      this._oldBreakpoints = breakpoints;\n    }\n  }\n  /**\n   * Measure the breakpoints in pixels.\n   *\n   * The breakpoints for `small` and `medium` can be given in any unit: `px`, `em`, `in` etc.\n   * We need to know them in `px` so that they are comparable with the actual size.\n   *\n   * @return {object} object with smallSize and mediumSize number properties, which tells\n   * where the row should switch rendering size in pixels.\n   * @private\n   */\n\n\n  _measureBreakpointsInPx() {\n    // Convert minWidth to px units for comparison\n    var breakpoints = {};\n    var tmpStyleProp = 'background-position';\n    var smallSize;\n    var mediumSize;\n\n    if (window.ShadyCSS) {\n      smallSize = window.ShadyCSS.getComputedStyleValue(this, '--small-size');\n      mediumSize = window.ShadyCSS.getComputedStyleValue(this, '--medium-size');\n    } else {\n      smallSize = getComputedStyle(this).getPropertyValue('--small-size');\n      mediumSize = getComputedStyle(this).getPropertyValue('--medium-size');\n    }\n\n    this.style.setProperty(tmpStyleProp, smallSize);\n    breakpoints.smallSize = parseFloat(getComputedStyle(this).getPropertyValue(tmpStyleProp));\n    this.style.setProperty(tmpStyleProp, mediumSize);\n    breakpoints.mediumSize = parseFloat(getComputedStyle(this).getPropertyValue(tmpStyleProp));\n    this.style.removeProperty(tmpStyleProp);\n    return breakpoints;\n  }\n\n}\n\ncustomElements.define(BoardRowElement.is, BoardRowElement);\nexport { BoardRowElement };"
    },
    {
     "id": 263,
     "name": "../node_modules/highcharts/js/es-modules/parts/Tick.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nvar correctFloat = H.correctFloat,\n    defined = H.defined,\n    destroyObjectProperties = H.destroyObjectProperties,\n    fireEvent = H.fireEvent,\n    isNumber = H.isNumber,\n    merge = H.merge,\n    pick = H.pick,\n    deg2rad = H.deg2rad;\n/**\n * The Tick class\n * @ignore\n */\n\nH.Tick = function (axis, pos, type, noLabel) {\n  this.axis = axis;\n  this.pos = pos;\n  this.type = type || '';\n  this.isNew = true;\n  this.isNewLabel = true;\n\n  if (!type && !noLabel) {\n    this.addLabel();\n  }\n};\n\nH.Tick.prototype = {\n  /**\n   * Write the tick label\n   */\n  addLabel: function () {\n    var tick = this,\n        axis = tick.axis,\n        options = axis.options,\n        chart = axis.chart,\n        categories = axis.categories,\n        names = axis.names,\n        pos = tick.pos,\n        labelOptions = options.labels,\n        str,\n        tickPositions = axis.tickPositions,\n        isFirst = pos === tickPositions[0],\n        isLast = pos === tickPositions[tickPositions.length - 1],\n        value = categories ? pick(categories[pos], names[pos], pos) : pos,\n        label = tick.label,\n        tickPositionInfo = tickPositions.info,\n        dateTimeLabelFormat,\n        params; // Set the datetime label format. If a higher rank is set for this\n    // position, use that. If not, use the general format.\n\n    if (axis.isDatetimeAxis && tickPositionInfo) {\n      dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n    } // set properties for access in render method\n\n\n    tick.isFirst = isFirst;\n    tick.isLast = isLast; // Get the string. Provide params both as scope (legacy) and as first\n    // parameter which allows use in arrow functions (#8580).\n\n    params = {\n      axis: axis,\n      chart: chart,\n      isFirst: isFirst,\n      isLast: isLast,\n      dateTimeLabelFormat: dateTimeLabelFormat,\n      value: axis.isLog ? correctFloat(axis.lin2log(value)) : value,\n      pos: pos\n    };\n    str = axis.labelFormatter.call(params, params); // first call\n\n    if (!defined(label)) {\n      tick.label = label = defined(str) && labelOptions.enabled ? chart.renderer.text(str, 0, 0, labelOptions.useHTML).add(axis.labelGroup) : null; // Un-rotated length\n\n      if (label) {\n        label.textPxLength = label.getBBox().width;\n      } // Base value to detect change for new calls to getBBox\n\n\n      tick.rotation = 0; // update\n    } else if (label && label.textStr !== str) {\n      // When resetting text, also reset the width if dynamically set\n      // (#8809)\n      if (label.textWidth && !(labelOptions.style && labelOptions.style.width) && !label.styles.width) {\n        label.css({\n          width: null\n        });\n      }\n\n      label.attr({\n        text: str\n      });\n    }\n  },\n\n  /**\n   * Get the offset height or width of the label\n   */\n  getLabelSize: function () {\n    return this.label ? this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] : 0;\n  },\n\n  /**\n   * Handle the label overflow by adjusting the labels to the left and right\n   * edge, or hide them if they collide into the neighbour label.\n   */\n  handleOverflow: function (xy) {\n    var tick = this,\n        axis = this.axis,\n        labelOptions = axis.options.labels,\n        pxPos = xy.x,\n        chartWidth = axis.chart.chartWidth,\n        spacing = axis.chart.spacing,\n        leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),\n        rightBound = pick(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])),\n        label = this.label,\n        rotation = this.rotation,\n        factor = {\n      left: 0,\n      center: 0.5,\n      right: 1\n    }[axis.labelAlign || label.attr('align')],\n        labelWidth = label.getBBox().width,\n        slotWidth = axis.getSlotWidth(tick),\n        modifiedSlotWidth = slotWidth,\n        xCorrection = factor,\n        goRight = 1,\n        leftPos,\n        rightPos,\n        textWidth,\n        css = {}; // Check if the label overshoots the chart spacing box. If it does, move\n    // it. If it now overshoots the slotWidth, add ellipsis.\n\n    if (!rotation && pick(labelOptions.overflow, 'justify') === 'justify') {\n      leftPos = pxPos - factor * labelWidth;\n      rightPos = pxPos + (1 - factor) * labelWidth;\n\n      if (leftPos < leftBound) {\n        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;\n      } else if (rightPos > rightBound) {\n        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;\n        goRight = -1;\n      }\n\n      modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177\n\n      if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {\n        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));\n      } // If the label width exceeds the available space, set a text width\n      // to be picked up below. Also, if a width has been set before, we\n      // need to set a new one because the reported labelWidth will be\n      // limited by the box (#3938).\n\n\n      if (labelWidth > modifiedSlotWidth || axis.autoRotation && (label.styles || {}).width) {\n        textWidth = modifiedSlotWidth;\n      } // Add ellipsis to prevent rotated labels to be clipped against the edge\n      // of the chart\n\n    } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n      textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);\n    } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n      textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));\n    }\n\n    if (textWidth) {\n      css.width = textWidth;\n\n      if (!(labelOptions.style || {}).textOverflow) {\n        css.textOverflow = 'ellipsis';\n      }\n\n      label.css(css);\n    }\n  },\n\n  /**\n   * Get the x and y position for ticks and labels\n   */\n  getPosition: function (horiz, tickPos, tickmarkOffset, old) {\n    var axis = this.axis,\n        chart = axis.chart,\n        cHeight = old && chart.oldChartHeight || chart.chartHeight,\n        pos;\n    pos = {\n      x: horiz ? H.correctFloat(axis.translate(tickPos + tickmarkOffset, null, null, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),\n      y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : H.correctFloat(cHeight - axis.translate(tickPos + tickmarkOffset, null, null, old) - axis.transB)\n    };\n    fireEvent(this, 'afterGetPosition', {\n      pos: pos\n    });\n    return pos;\n  },\n\n  /**\n   * Get the x, y position of the tick label\n   */\n  getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n    var axis = this.axis,\n        transA = axis.transA,\n        reversed = axis.reversed,\n        staggerLines = axis.staggerLines,\n        rotCorr = axis.tickRotCorr || {\n      x: 0,\n      y: 0\n    },\n        yOffset = labelOptions.y,\n        // Adjust for label alignment if we use reserveSpace: true (#5286)\n    labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === 'center' ? 0.5 : 1) : 0,\n        line,\n        pos = {};\n\n    if (!defined(yOffset)) {\n      if (axis.side === 0) {\n        yOffset = label.rotation ? -8 : -label.getBBox().height;\n      } else if (axis.side === 2) {\n        yOffset = rotCorr.y + 8;\n      } else {\n        // #3140, #3140\n        yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);\n      }\n    }\n\n    x = x + labelOptions.x + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n    y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0); // Correct for staggered labels\n\n    if (staggerLines) {\n      line = index / (step || 1) % staggerLines;\n\n      if (axis.opposite) {\n        line = staggerLines - line - 1;\n      }\n\n      y += line * (axis.labelOffset / staggerLines);\n    }\n\n    pos.x = x;\n    pos.y = Math.round(y);\n    fireEvent(this, 'afterGetLabelPosition', {\n      pos: pos\n    });\n    return pos;\n  },\n\n  /**\n   * Extendible method to return the path of the marker\n   */\n  getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n    return renderer.crispLine(['M', x, y, 'L', x + (horiz ? 0 : -tickLength), y + (horiz ? tickLength : 0)], tickWidth);\n  },\n\n  /**\n   * Renders the gridLine.\n   * @param  {Boolean} old         Whether or not the tick is old\n   * @param  {number} opacity      The opacity of the grid line\n   * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n   * @return {undefined}\n   */\n  renderGridLine: function (old, opacity, reverseCrisp) {\n    var tick = this,\n        axis = tick.axis,\n        options = axis.options,\n        gridLine = tick.gridLine,\n        gridLinePath,\n        attribs = {},\n        pos = tick.pos,\n        type = tick.type,\n        tickmarkOffset = axis.tickmarkOffset,\n        renderer = axis.chart.renderer;\n\n    if (!gridLine) {\n      if (!type) {\n        attribs.zIndex = 1;\n      }\n\n      if (old) {\n        attribs.opacity = 0;\n      }\n\n      tick.gridLine = gridLine = renderer.path().attr(attribs).addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line').add(axis.gridGroup);\n    } // If the parameter 'old' is set, the current call will be followed\n    // by another call, therefore do not do any animations this time\n\n\n    if (!old && gridLine) {\n      gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLine.strokeWidth() * reverseCrisp, old, true);\n\n      if (gridLinePath) {\n        gridLine[tick.isNew ? 'attr' : 'animate']({\n          d: gridLinePath,\n          opacity: opacity\n        });\n      }\n    }\n  },\n\n  /**\n   * Renders the tick mark.\n   * @param  {Object} xy           The position vector of the mark\n   * @param  {number} xy.x         The x position of the mark\n   * @param  {number} xy.y         The y position of the mark\n   * @param  {number} opacity      The opacity of the mark\n   * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n   * @return {undefined}\n   */\n  renderMark: function (xy, opacity, reverseCrisp) {\n    var tick = this,\n        axis = tick.axis,\n        options = axis.options,\n        renderer = axis.chart.renderer,\n        type = tick.type,\n        tickPrefix = type ? type + 'Tick' : 'tick',\n        tickSize = axis.tickSize(tickPrefix),\n        mark = tick.mark,\n        isNewMark = !mark,\n        x = xy.x,\n        y = xy.y;\n\n    if (tickSize) {\n      // negate the length\n      if (axis.opposite) {\n        tickSize[0] = -tickSize[0];\n      } // First time, create it\n\n\n      if (isNewMark) {\n        tick.mark = mark = renderer.path().addClass('highcharts-' + (type ? type + '-' : '') + 'tick').add(axis.axisGroup);\n      }\n\n      mark[isNewMark ? 'attr' : 'animate']({\n        d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),\n        opacity: opacity\n      });\n    }\n  },\n\n  /**\n   * Renders the tick label.\n   * Note: The label should already be created in init(), so it should only\n   * have to be moved into place.\n   * @param  {Object} xy      The position vector of the label\n   * @param  {number} xy.x    The x position of the label\n   * @param  {number} xy.y    The y position of the label\n   * @param  {Boolean} old    Whether or not the tick is old\n   * @param  {number} opacity The opacity of the label\n   * @param  {number} index   The index of the tick\n   * @return {undefined}\n   */\n  renderLabel: function (xy, old, opacity, index) {\n    var tick = this,\n        axis = tick.axis,\n        horiz = axis.horiz,\n        options = axis.options,\n        label = tick.label,\n        labelOptions = options.labels,\n        step = labelOptions.step,\n        tickmarkOffset = axis.tickmarkOffset,\n        show = true,\n        x = xy.x,\n        y = xy.y;\n\n    if (label && isNumber(x)) {\n      label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step); // Apply show first and show last. If the tick is both first and\n      // last, it is a single centered tick, in which case we show the\n      // label anyway (#2100).\n\n      if (tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1) || tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1)) {\n        show = false; // Handle label overflow and show or hide accordingly\n      } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n        tick.handleOverflow(xy);\n      } // apply step\n\n\n      if (step && index % step) {\n        // show those indices dividable by step\n        show = false;\n      } // Set the new position, and show or hide\n\n\n      if (show && isNumber(xy.y)) {\n        xy.opacity = opacity;\n        label[tick.isNewLabel ? 'attr' : 'animate'](xy);\n        tick.isNewLabel = false;\n      } else {\n        label.attr('y', -9999); // #1338\n\n        tick.isNewLabel = true;\n      }\n    }\n  },\n\n  /**\n   * Put everything in place\n   *\n   * @param index {Number}\n   * @param old {Boolean} Use old coordinates to prepare an animation into new\n   *                      position\n   */\n  render: function (index, old, opacity) {\n    var tick = this,\n        axis = tick.axis,\n        horiz = axis.horiz,\n        pos = tick.pos,\n        tickmarkOffset = axis.tickmarkOffset,\n        xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n        x = xy.x,\n        y = xy.y,\n        reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1; // #1480, #1687\n\n    opacity = pick(opacity, 1);\n    this.isActive = true; // Create the grid line\n\n    this.renderGridLine(old, opacity, reverseCrisp); // create the tick mark\n\n    this.renderMark(xy, opacity, reverseCrisp); // the label is created on init - now move it into place\n\n    this.renderLabel(xy, old, opacity, index);\n    tick.isNew = false;\n    H.fireEvent(this, 'afterRender');\n  },\n\n  /**\n   * Destructor for the tick prototype\n   */\n  destroy: function () {\n    destroyObjectProperties(this, this.axis);\n  }\n};"
    },
    {
     "id": 264,
     "name": "../node_modules/highcharts/js/es-modules/parts/Tooltip.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nvar doc = H.doc,\n    each = H.each,\n    extend = H.extend,\n    format = H.format,\n    isNumber = H.isNumber,\n    map = H.map,\n    merge = H.merge,\n    pick = H.pick,\n    splat = H.splat,\n    syncTimeout = H.syncTimeout,\n    timeUnits = H.timeUnits;\n/**\n * Tooltip of a chart.\n *\n * @class\n * @name Highcharts.Tooltip\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @param {Highcharts.TooltipOptions} options\n *        Tooltip options.\n */\n\nH.Tooltip = function () {\n  this.init.apply(this, arguments);\n};\n\nH.Tooltip.prototype = {\n  /**\n   * @private\n   * @function Highcharts.Tooltip#init\n   *\n   * @param {Highcharts.Chart} chart\n   *        The chart instance.\n   *\n   * @param {Highcharts.TooltipOptions} options\n   *        Tooltip options.\n   */\n  init: function (chart, options) {\n    /**\n     * Chart of the tooltip.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#chart\n     * @type {Highcharts.Chart}\n     */\n    this.chart = chart;\n    /**\n     * Used tooltip options.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#options\n     * @type {Highcharts.TooltipOptions}\n     */\n\n    this.options = options;\n    /**\n     * List of crosshairs.\n     *\n     * @private\n     * @readonly\n     * @name Highcharts.Tooltip#crosshairs\n     * @type {Array<*>}\n     */\n\n    this.crosshairs = [];\n    /**\n     * Current values of x and y when animating.\n     *\n     * @private\n     * @readonly\n     * @name Highcharts.Tooltip#now\n     * @type {*}\n     */\n\n    this.now = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Tooltips are initially hidden.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#isHidden\n     * @type {boolean}\n     */\n\n    this.isHidden = true;\n    /**\n     * True, if the tooltip is splitted into one label per series, with the\n     * header close to the axis.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#split\n     * @type {boolean}\n     */\n\n    this.split = options.split && !chart.inverted;\n    /**\n     * When the tooltip is shared, the entire plot area will capture mouse\n     * movement or touch events.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#shared\n     * @type {boolean}\n     */\n\n    this.shared = options.shared || this.split;\n    /**\n     * Whether to allow the tooltip to render outside the chart's SVG\n     * element box. By default (false), the tooltip is rendered within the\n     * chart's SVG element, which results in the tooltip being aligned\n     * inside the chart area.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#outside\n     * @type {boolean}\n     *\n     * @todo\n     * Split tooltip does not support outside in the first iteration. Should\n     * not be too complicated to implement.\n     */\n\n    this.outside = options.outside && !this.split;\n  },\n\n  /**\n   * Destroy the single tooltips in a split tooltip.\n   * If the tooltip is active then it is not destroyed, unless forced to.\n   *\n   * @private\n   * @function Highcharts.Tooltip#cleanSplit\n   *\n   * @param {boolean} force\n   *        Force destroy all tooltips.\n   */\n  cleanSplit: function (force) {\n    each(this.chart.series, function (series) {\n      var tt = series && series.tt;\n\n      if (tt) {\n        if (!tt.isActive || force) {\n          series.tt = tt.destroy();\n        } else {\n          tt.isActive = false;\n        }\n      }\n    });\n  },\n\n  /**\n   * In styled mode, apply the default filter for the tooltip drop-shadow. It\n   * needs to have an id specific to the chart, otherwise there will be issues\n   * when one tooltip adopts the filter of a different chart, specifically one\n   * where the container is hidden.\n   *\n   * @private\n   * @function Highcharts.Tooltip#applyFilter\n   */\n  applyFilter: function () {\n    var chart = this.chart;\n    chart.renderer.definition({\n      tagName: 'filter',\n      id: 'drop-shadow-' + chart.index,\n      opacity: 0.5,\n      children: [{\n        tagName: 'feGaussianBlur',\n        in: 'SourceAlpha',\n        stdDeviation: 1\n      }, {\n        tagName: 'feOffset',\n        dx: 1,\n        dy: 1\n      }, {\n        tagName: 'feComponentTransfer',\n        children: [{\n          tagName: 'feFuncA',\n          type: 'linear',\n          slope: 0.3\n        }]\n      }, {\n        tagName: 'feMerge',\n        children: [{\n          tagName: 'feMergeNode'\n        }, {\n          tagName: 'feMergeNode',\n          in: 'SourceGraphic'\n        }]\n      }]\n    });\n    chart.renderer.definition({\n      tagName: 'style',\n      textContent: '.highcharts-tooltip-' + chart.index + '{' + 'filter:url(#drop-shadow-' + chart.index + ')' + '}'\n    });\n  },\n\n  /**\n   * Creates the Tooltip label element if it does not exist, then returns it.\n   *\n   * @function Highcharts.Tooltip#getLabel\n   *\n   * @return {Highcharts.SVGElement}\n   */\n  getLabel: function () {\n    var renderer = this.chart.renderer,\n        options = this.options,\n        container;\n\n    if (!this.label) {\n      if (this.outside) {\n        this.container = container = H.doc.createElement('div');\n        container.className = 'highcharts-tooltip-container';\n        H.css(container, {\n          position: 'absolute',\n          top: '1px',\n          pointerEvents: options.style && options.style.pointerEvents\n        });\n        H.doc.body.appendChild(container);\n        this.renderer = renderer = new H.Renderer(container, 0, 0);\n      } // Create the label\n\n\n      if (this.split) {\n        this.label = renderer.g('tooltip');\n      } else {\n        this.label = renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip').attr({\n          padding: options.padding,\n          r: options.borderRadius\n        });\n      } // Apply the drop-shadow filter\n\n\n      this.applyFilter();\n      this.label.addClass('highcharts-tooltip-' + this.chart.index);\n\n      if (this.outside) {\n        this.label.attr({\n          x: this.distance,\n          y: this.distance\n        });\n\n        this.label.xSetter = function (value) {\n          container.style.left = value + 'px';\n        };\n\n        this.label.ySetter = function (value) {\n          container.style.top = value + 'px';\n        };\n      }\n\n      this.label.attr({\n        zIndex: 8\n      }).add();\n    }\n\n    return this.label;\n  },\n\n  /**\n   * Updates the tooltip with the provided tooltip options.\n   *\n   * @function Highcharts.Tooltip#update\n   *\n   * @param {Highcharts.TooltipOptions} options\n   */\n  update: function (options) {\n    this.destroy(); // Update user options (#6218)\n\n    merge(true, this.chart.options.tooltip.userOptions, options);\n    this.init(this.chart, merge(true, this.options, options));\n  },\n\n  /**\n   * Removes and destroys the tooltip and its elements.\n   *\n   * @function Highcharts.Tooltip#destroy\n   */\n  destroy: function () {\n    // Destroy and clear local variables\n    if (this.label) {\n      this.label = this.label.destroy();\n    }\n\n    if (this.split && this.tt) {\n      this.cleanSplit(this.chart, true);\n      this.tt = this.tt.destroy();\n    }\n\n    if (this.renderer) {\n      this.renderer = this.renderer.destroy();\n      H.discardElement(this.container);\n    }\n\n    H.clearTimeout(this.hideTimer);\n    H.clearTimeout(this.tooltipTimeout);\n  },\n\n  /**\n   * Moves the tooltip with a soft animation to a new position.\n   *\n   * @function Highcharts.Tooltip#move\n   *\n   * @param {number} x\n   *\n   * @param {number} y\n   *\n   * @param {number} anchorX\n   *\n   * @param {number} anchorY\n   */\n  move: function (x, y, anchorX, anchorY) {\n    var tooltip = this,\n        now = tooltip.now,\n        animate = tooltip.options.animation !== false && !tooltip.isHidden && ( // When we get close to the target position, abort animation and\n    // land on the right place (#3056)\n    Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),\n        skipAnchor = tooltip.followPointer || tooltip.len > 1; // Get intermediate values for animation\n\n    extend(now, {\n      x: animate ? (2 * now.x + x) / 3 : x,\n      y: animate ? (now.y + y) / 2 : y,\n      anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n      anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY\n    }); // Move to the intermediate value\n\n    tooltip.getLabel().attr(now); // Run on next tick of the mouse tracker\n\n    if (animate) {\n      // Never allow two timeouts\n      H.clearTimeout(this.tooltipTimeout); // Set the fixed interval ticking for the smooth tooltip\n\n      this.tooltipTimeout = setTimeout(function () {\n        // The interval function may still be running during destroy,\n        // so check that the chart is really there before calling.\n        if (tooltip) {\n          tooltip.move(x, y, anchorX, anchorY);\n        }\n      }, 32);\n    }\n  },\n\n  /**\n   * Hides the tooltip with a fade out animation.\n   *\n   * @function Highcharts.Tooltip#hide\n   *\n   * @param {number} [delay]\n   *        The fade out in milliseconds. If no value is provided the value\n   *        of the tooltip.hideDelay option is used. A value of 0 disables\n   *        the fade out animation.\n   */\n  hide: function (delay) {\n    var tooltip = this; // disallow duplicate timers (#1728, #1766)\n\n    H.clearTimeout(this.hideTimer);\n    delay = pick(delay, this.options.hideDelay, 500);\n\n    if (!this.isHidden) {\n      this.hideTimer = syncTimeout(function () {\n        tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();\n        tooltip.isHidden = true;\n      }, delay);\n    }\n  },\n\n  /**\n   * Extendable method to get the anchor position of the tooltip\n   * from a point or set of points\n   *\n   * @private\n   * @function Highcharts.Tooltip#getAnchor\n   *\n   * @param {Array<Highchart.Points>} points\n   *\n   * @param {global.Event} [mouseEvent]\n   */\n  getAnchor: function (points, mouseEvent) {\n    var ret,\n        chart = this.chart,\n        pointer = chart.pointer,\n        inverted = chart.inverted,\n        plotTop = chart.plotTop,\n        plotLeft = chart.plotLeft,\n        plotX = 0,\n        plotY = 0,\n        yAxis,\n        xAxis;\n    points = splat(points); // When tooltip follows mouse, relate the position to the mouse\n\n    if (this.followPointer && mouseEvent) {\n      if (mouseEvent.chartX === undefined) {\n        mouseEvent = pointer.normalize(mouseEvent);\n      }\n\n      ret = [mouseEvent.chartX - chart.plotLeft, mouseEvent.chartY - plotTop]; // Pie uses a special tooltipPos\n    } else if (points[0].tooltipPos) {\n      ret = points[0].tooltipPos; // When shared, use the average position\n    } else {\n      each(points, function (point) {\n        yAxis = point.series.yAxis;\n        xAxis = point.series.xAxis;\n        plotX += point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0);\n        plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) + (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n      });\n      plotX /= points.length;\n      plotY /= points.length;\n      ret = [inverted ? chart.plotWidth - plotY : plotX, this.shared && !inverted && points.length > 1 && mouseEvent ? // place shared tooltip next to the mouse (#424)\n      mouseEvent.chartY - plotTop : inverted ? chart.plotHeight - plotX : plotY];\n    }\n\n    return map(ret, Math.round);\n  },\n\n  /**\n   * Place the tooltip in a chart without spilling over\n   * and not covering the point it self.\n   *\n   * @private\n   * @function Highcharts.Tooltip#getPosition\n   *\n   * @param {number} boxWidth\n   *\n   * @param {number} boxHeight\n   *\n   * @param {Highcharts.Point} point\n   *\n   * @return {*}\n   */\n  getPosition: function (boxWidth, boxHeight, point) {\n    var chart = this.chart,\n        distance = this.distance,\n        ret = {},\n        // Don't use h if chart isn't inverted (#7242)\n    h = chart.inverted && point.h || 0,\n        // #4117\n    swapped,\n        outside = this.outside,\n        outerWidth = outside ? // substract distance to prevent scrollbars\n    doc.documentElement.clientWidth - 2 * distance : chart.chartWidth,\n        outerHeight = outside ? Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight, doc.body.offsetHeight, doc.documentElement.offsetHeight, doc.documentElement.clientHeight) : chart.chartHeight,\n        chartPosition = chart.pointer.chartPosition,\n        first = ['y', outerHeight, boxHeight, (outside ? chartPosition.top - distance : 0) + point.plotY + chart.plotTop, outside ? 0 : chart.plotTop, outside ? outerHeight : chart.plotTop + chart.plotHeight],\n        second = ['x', outerWidth, boxWidth, (outside ? chartPosition.left - distance : 0) + point.plotX + chart.plotLeft, outside ? 0 : chart.plotLeft, outside ? outerWidth : chart.plotLeft + chart.plotWidth],\n        // The far side is right or bottom\n    preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative),\n        // #4984\n\n    /*\n     * Handle the preferred dimension. When the preferred dimension is\n     * tooltip on top or bottom of the point, it will look for space\n     * there.\n     *\n     * @private\n     */\n    firstDimension = function (dim, outerSize, innerSize, point, min, max) {\n      var roomLeft = innerSize < point - distance,\n          roomRight = point + distance + innerSize < outerSize,\n          alignedLeft = point - distance - innerSize,\n          alignedRight = point + distance;\n\n      if (preferFarSide && roomRight) {\n        ret[dim] = alignedRight;\n      } else if (!preferFarSide && roomLeft) {\n        ret[dim] = alignedLeft;\n      } else if (roomLeft) {\n        ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n      } else if (roomRight) {\n        ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);\n      } else {\n        return false;\n      }\n    },\n\n    /*\n     * Handle the secondary dimension. If the preferred dimension is\n     * tooltip on top or bottom of the point, the second dimension is to\n     * align the tooltip above the point, trying to align center but\n     * allowing left or right align within the chart box.\n     *\n     * @private\n     */\n    secondDimension = function (dim, outerSize, innerSize, point) {\n      var retVal; // Too close to the edge, return false and swap dimensions\n\n      if (point < distance || point > outerSize - distance) {\n        retVal = false; // Align left/top\n      } else if (point < innerSize / 2) {\n        ret[dim] = 1; // Align right/bottom\n      } else if (point > outerSize - innerSize / 2) {\n        ret[dim] = outerSize - innerSize - 2; // Align center\n      } else {\n        ret[dim] = point - innerSize / 2;\n      }\n\n      return retVal;\n    },\n\n    /*\n     * Swap the dimensions\n     */\n    swap = function (count) {\n      var temp = first;\n      first = second;\n      second = temp;\n      swapped = count;\n    },\n        run = function () {\n      if (firstDimension.apply(0, first) !== false) {\n        if (secondDimension.apply(0, second) === false && !swapped) {\n          swap(true);\n          run();\n        }\n      } else if (!swapped) {\n        swap(true);\n        run();\n      } else {\n        ret.x = ret.y = 0;\n      }\n    }; // Under these conditions, prefer the tooltip on the side of the point\n\n\n    if (chart.inverted || this.len > 1) {\n      swap();\n    }\n\n    run();\n    return ret;\n  },\n\n  /**\n   * In case no user defined formatter is given, this will be used. Note that\n   * the context here is an object holding point, series, x, y etc.\n   *\n   * @private\n   * @function Highcharts.Tooltip#defaultFormatter\n   *\n   * @param {Highcharts.Tooltip} tooltip\n   *\n   * @return {Array<string>}\n   */\n  defaultFormatter: function (tooltip) {\n    var items = this.points || splat(this),\n        s; // Build the header\n\n    s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; // build the values\n\n    s = s.concat(tooltip.bodyFormatter(items)); // footer\n\n    s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));\n    return s;\n  },\n\n  /**\n   * Refresh the tooltip's text and position.\n   *\n   * @function Highcharts.Tooltip#refresh\n   *\n   * @param {Highcharts.Point|Array<Highcharts.Point>} pointOrPoints\n   *        Either a point or an array of points.\n   *\n   * @param {global.Event} [mouseEvent]\n   *        Mouse event, that is responsible for the refresh and should be\n   *        used for the tooltip update.\n   */\n  refresh: function (pointOrPoints, mouseEvent) {\n    var tooltip = this,\n        label,\n        options = tooltip.options,\n        x,\n        y,\n        point = pointOrPoints,\n        anchor,\n        textConfig = {},\n        text,\n        pointConfig = [],\n        formatter = options.formatter || tooltip.defaultFormatter,\n        shared = tooltip.shared,\n        currentSeries;\n\n    if (!options.enabled) {\n      return;\n    }\n\n    H.clearTimeout(this.hideTimer); // get the reference point coordinates (pie charts use tooltipPos)\n\n    tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n    anchor = tooltip.getAnchor(point, mouseEvent);\n    x = anchor[0];\n    y = anchor[1]; // shared tooltip, array is sent over\n\n    if (shared && !(point.series && point.series.noSharedTooltip)) {\n      each(point, function (item) {\n        item.setState('hover');\n        pointConfig.push(item.getLabelConfig());\n      });\n      textConfig = {\n        x: point[0].category,\n        y: point[0].y\n      };\n      textConfig.points = pointConfig;\n      point = point[0]; // single point tooltip\n    } else {\n      textConfig = point.getLabelConfig();\n    }\n\n    this.len = pointConfig.length; // #6128\n\n    text = formatter.call(textConfig, tooltip); // register the current series\n\n    currentSeries = point.series;\n    this.distance = pick(currentSeries.tooltipOptions.distance, 16); // update the inner HTML\n\n    if (text === false) {\n      this.hide();\n    } else {\n      label = tooltip.getLabel(); // show it\n\n      if (tooltip.isHidden) {\n        label.attr({\n          opacity: 1\n        }).show();\n      } // update text\n\n\n      if (tooltip.split) {\n        this.renderSplit(text, splat(pointOrPoints));\n      } else {\n        // Prevent the tooltip from flowing over the chart box (#6659)\n        label.css({\n          width: this.chart.spacingBox.width\n        });\n        label.attr({\n          text: text && text.join ? text.join('') : text\n        }); // Set the stroke color of the box to reflect the point\n\n        label.removeClass(/highcharts-color-[\\d]+/g).addClass('highcharts-color-' + pick(point.colorIndex, currentSeries.colorIndex));\n        tooltip.updatePosition({\n          plotX: x,\n          plotY: y,\n          negative: point.negative,\n          ttBelow: point.ttBelow,\n          h: anchor[2] || 0\n        });\n      }\n\n      this.isHidden = false;\n    }\n  },\n\n  /**\n   * Render the split tooltip. Loops over each point's text and adds\n   * a label next to the point, then uses the distribute function to\n   * find best non-overlapping positions.\n   *\n   * @private\n   * @function Highcharts.Tooltip#renderSplit\n   *\n   * @param {Array<Highcharts.Label>} labels\n   *\n   * @param {Array<Highcharts.Point>} points\n   */\n  renderSplit: function (labels, points) {\n    var tooltip = this,\n        boxes = [],\n        chart = this.chart,\n        ren = chart.renderer,\n        rightAligned = true,\n        options = this.options,\n        headerHeight = 0,\n        headerTop,\n        tooltipLabel = this.getLabel(),\n        distributionBoxTop = chart.plotTop; // Graceful degradation for legacy formatters\n\n    if (H.isString(labels)) {\n      labels = [false, labels];\n    } // Create the individual labels for header and points, ignore footer\n\n\n    each(labels.slice(0, points.length + 1), function (str, i) {\n      if (str !== false) {\n        var point = points[i - 1] || // Item 0 is the header. Instead of this, we could also\n        // use the crosshair label\n        {\n          isHeader: true,\n          plotX: points[0].plotX\n        },\n            owner = point.series || tooltip,\n            tt = owner.tt,\n            series = point.series || {},\n            colorClass = 'highcharts-color-' + pick(point.colorIndex, series.colorIndex, 'none'),\n            target,\n            x,\n            bBox,\n            boxWidth; // Store the tooltip referance on the series\n\n        if (!tt) {\n          owner.tt = tt = ren.label(null, null, null, 'callout', null, null, options.useHTML).addClass('highcharts-tooltip-box ' + colorClass + (point.isHeader ? ' highcharts-tooltip-header' : '')).attr({\n            'padding': options.padding,\n            'r': options.borderRadius\n          }).add(tooltipLabel);\n        }\n\n        tt.isActive = true;\n        tt.attr({\n          text: str\n        }); // Get X position now, so we can move all to the other side in\n        // case of overflow\n\n        bBox = tt.getBBox();\n        boxWidth = bBox.width + tt.strokeWidth();\n\n        if (point.isHeader) {\n          headerHeight = bBox.height;\n\n          if (chart.xAxis[0].opposite) {\n            headerTop = true;\n            distributionBoxTop -= headerHeight;\n          }\n\n          x = Math.max(0, // No left overflow\n          Math.min(point.plotX + chart.plotLeft - boxWidth / 2, // No right overflow (#5794)\n          chart.chartWidth + ( // Scrollable plot area\n          chart.scrollablePixels ? chart.scrollablePixels - chart.marginRight : 0) - boxWidth));\n        } else {\n          x = point.plotX + chart.plotLeft - pick(options.distance, 16) - boxWidth;\n        } // If overflow left, we don't use this x in the next loop\n\n\n        if (x < 0) {\n          rightAligned = false;\n        } // Prepare for distribution\n\n\n        target = (point.series && point.series.yAxis && point.series.yAxis.pos) + (point.plotY || 0);\n        target -= distributionBoxTop;\n\n        if (point.isHeader) {\n          target = headerTop ? -headerHeight : chart.plotHeight + headerHeight;\n        }\n\n        boxes.push({\n          target: target,\n          rank: point.isHeader ? 1 : 0,\n          size: owner.tt.getBBox().height + 1,\n          point: point,\n          x: x,\n          tt: tt\n        });\n      }\n    }); // Clean previous run (for missing points)\n\n    this.cleanSplit(); // Distribute and put in place\n\n    H.distribute(boxes, chart.plotHeight + headerHeight);\n    each(boxes, function (box) {\n      var point = box.point,\n          series = point.series; // Put the label in place\n\n      box.tt.attr({\n        visibility: box.pos === undefined ? 'hidden' : 'inherit',\n        x: rightAligned || point.isHeader ? box.x : point.plotX + chart.plotLeft + pick(options.distance, 16),\n        y: box.pos + distributionBoxTop,\n        anchorX: point.isHeader ? point.plotX + chart.plotLeft : point.plotX + series.xAxis.pos,\n        anchorY: point.isHeader ? chart.plotTop + chart.plotHeight / 2 : point.plotY + series.yAxis.pos\n      });\n    });\n  },\n\n  /**\n   * Find the new position and perform the move\n   *\n   * @private\n   * @function Highcharts.Tooltip#updatePosition\n   *\n   * @param {Highcharts.Point} point\n   */\n  updatePosition: function (point) {\n    var chart = this.chart,\n        label = this.getLabel(),\n        pos = (this.options.positioner || this.getPosition).call(this, label.width, label.height, point),\n        anchorX = point.plotX + chart.plotLeft,\n        anchorY = point.plotY + chart.plotTop,\n        pad; // Set the renderer size dynamically to prevent document size to change\n\n    if (this.outside) {\n      pad = (this.options.borderWidth || 0) + 2 * this.distance;\n      this.renderer.setSize(label.width + pad, label.height + pad, false);\n      anchorX += chart.pointer.chartPosition.left - pos.x;\n      anchorY += chart.pointer.chartPosition.top - pos.y;\n    } // do the move\n\n\n    this.move(Math.round(pos.x), Math.round(pos.y || 0), // can be undefined (#3977)\n    anchorX, anchorY);\n  },\n\n  /**\n   * Get the optimal date format for a point, based on a range.\n   *\n   * @private\n   * @function Highcharts.Tooltip#getDateFormat\n   *\n   * @param {number} range\n   *        The time range\n   *\n   * @param {number|Date} date\n   *        The date of the point in question\n   *\n   * @param {number} startOfWeek\n   *        An integer representing the first day of the week, where 0 is\n   *        Sunday.\n   *\n   * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats\n   *        A map of time units to formats.\n   *\n   * @return {string}\n   *         The optimal date format for a point.\n   */\n  getDateFormat: function (range, date, startOfWeek, dateTimeLabelFormats) {\n    var time = this.chart.time,\n        dateStr = time.dateFormat('%m-%d %H:%M:%S.%L', date),\n        format,\n        n,\n        blank = '01-01 00:00:00.000',\n        strpos = {\n      millisecond: 15,\n      second: 12,\n      minute: 9,\n      hour: 6,\n      day: 3\n    },\n        lastN = 'millisecond'; // for sub-millisecond data, #4223\n\n    for (n in timeUnits) {\n      // If the range is exactly one week and we're looking at a\n      // Sunday/Monday, go for the week format\n      if (range === timeUnits.week && +time.dateFormat('%w', date) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {\n        n = 'week';\n        break;\n      } // The first format that is too great for the range\n\n\n      if (timeUnits[n] > range) {\n        n = lastN;\n        break;\n      } // If the point is placed every day at 23:59, we need to show\n      // the minutes as well. #2637.\n\n\n      if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {\n        break;\n      } // Weeks are outside the hierarchy, only apply them on\n      // Mondays/Sundays like in the first condition\n\n\n      if (n !== 'week') {\n        lastN = n;\n      }\n    }\n\n    if (n) {\n      format = dateTimeLabelFormats[n];\n    }\n\n    return format;\n  },\n\n  /**\n   * Get the best X date format based on the closest point range on the axis.\n   *\n   * @private\n   * @function Highcharts.Tooltip#getXDateFormat\n   *\n   * @param {Highcharts.Point} point\n   *\n   * @param {Highcharts.TooltipOptions} options\n   *\n   * @param {Highcharts.Axis} xAxis\n   *\n   * @return {string}\n   */\n  getXDateFormat: function (point, options, xAxis) {\n    var xDateFormat,\n        dateTimeLabelFormats = options.dateTimeLabelFormats,\n        closestPointRange = xAxis && xAxis.closestPointRange;\n\n    if (closestPointRange) {\n      xDateFormat = this.getDateFormat(closestPointRange, point.x, xAxis.options.startOfWeek, dateTimeLabelFormats);\n    } else {\n      xDateFormat = dateTimeLabelFormats.day;\n    }\n\n    return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n  },\n\n  /**\n   * Format the footer/header of the tooltip\n   * #3397: abstraction to enable formatting of footer and header\n   *\n   * @private\n   * @function Highcharts.Tooltip#tooltipFooterHeaderFormatter\n   *\n   * @param {*} labelConfig\n   *\n   * @param {boolean} isFooter\n   *\n   * @return {string}\n   */\n  tooltipFooterHeaderFormatter: function (labelConfig, isFooter) {\n    var footOrHead = isFooter ? 'footer' : 'header',\n        series = labelConfig.series,\n        tooltipOptions = series.tooltipOptions,\n        xDateFormat = tooltipOptions.xDateFormat,\n        xAxis = series.xAxis,\n        isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(labelConfig.key),\n        formatString = tooltipOptions[footOrHead + 'Format']; // Guess the best date format based on the closest point distance (#568,\n    // #3418)\n\n    if (isDateTime && !xDateFormat) {\n      xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);\n    } // Insert the footer date format if any\n\n\n    if (isDateTime && xDateFormat) {\n      each(labelConfig.point && labelConfig.point.tooltipDateKeys || ['key'], function (key) {\n        formatString = formatString.replace('{point.' + key + '}', '{point.' + key + ':' + xDateFormat + '}');\n      });\n    }\n\n    return format(formatString, {\n      point: labelConfig,\n      series: series\n    }, this.chart.time);\n  },\n\n  /**\n   * Build the body (lines) of the tooltip by iterating over the items and\n   * returning one entry for each item, abstracting this functionality allows\n   * to easily overwrite and extend it.\n   *\n   * @private\n   * @function Highcharts.Tooltip#bodyFormatter\n   *\n   * @param {Array<Highcharts.Point>} items\n   *\n   * @return {string}\n   */\n  bodyFormatter: function (items) {\n    return map(items, function (item) {\n      var tooltipOptions = item.series.tooltipOptions;\n      return (tooltipOptions[(item.point.formatPrefix || 'point') + 'Formatter'] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || 'point') + 'Format']);\n    });\n  }\n};"
    },
    {
     "id": 265,
     "name": "../node_modules/highcharts/js/es-modules/parts/ColumnSeries.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Color.js';\nimport './Legend.js';\nimport './Series.js';\nimport './Options.js';\nvar animObject = H.animObject,\n    color = H.color,\n    each = H.each,\n    extend = H.extend,\n    isNumber = H.isNumber,\n    LegendSymbolMixin = H.LegendSymbolMixin,\n    merge = H.merge,\n    noop = H.noop,\n    pick = H.pick,\n    Series = H.Series,\n    seriesType = H.seriesType,\n    svg = H.svg;\n/**\n * The column series type.\n *\n * @constructor seriesTypes.column\n * @augments    Series\n */\n\n/**\n * Column series display one column per value along an X axis.\n *\n * @sample       {highcharts} highcharts/demo/column-basic/ Column chart\n * @sample       {highstock} stock/demo/column/ Column chart\n *\n * @extends      {plotOptions.line}\n * @product      highcharts highstock\n * @excluding    connectNulls,dashStyle,gapSize,gapUnit,linecap,lineWidth,\n *               marker,connectEnds,step\n * @optionparent plotOptions.column\n */\n\nseriesType('column', 'line', {\n  /**\n   * The corner radius of the border surrounding each column or bar.\n   *\n   * @type    {Number}\n   * @sample  {highcharts} highcharts/plotoptions/column-borderradius/\n   *          Rounded columns\n   * @default 0\n   * @product highcharts highstock\n   */\n  borderRadius: 0,\n\n  /**\n   * When using automatic point colors pulled from the global [colors](colors)\n   * or series-specific [plotOptions.column.colors](series.colors)\n   * collections, this option determines whether the chart should receive\n   * one color per series or one color per point.\n   *\n   * In styled mode, the `colors` or `series.colors` arrays are not supported,\n   * and instead this option gives the points individual color class names on\n   * the form `highcharts-color-{n}`.\n   *\n   * @type      {Boolean}\n   * @see       [series colors](#plotOptions.column.colors)\n   * @sample    {highcharts} highcharts/plotoptions/column-colorbypoint-false/\n   *            False by default\n   * @sample    {highcharts} highcharts/plotoptions/column-colorbypoint-true/\n   *            True\n   * @default   false\n   * @since     2.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.colorByPoint\n   */\n\n  /**\n   * A series specific or series type specific color set to apply instead\n   * of the global [colors](#colors) when [colorByPoint](\n   * #plotOptions.column.colorByPoint) is true.\n   *\n   * @type      {Array<Color>}\n   * @since     3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.colors\n   */\n\n  /**\n   * When true, each column edge is rounded to its nearest pixel in order\n   * to render sharp on screen. In some cases, when there are a lot of\n   * densely packed columns, this leads to visible difference in column\n   * widths or distance between columns. In these cases, setting `crisp`\n   * to `false` may look better, even though each column is rendered\n   * blurry.\n   *\n   * @sample  {highcharts} highcharts/plotoptions/column-crisp-false/\n   *          Crisp is false\n   * @since   5.0.10\n   * @product highcharts highstock\n   */\n  crisp: true,\n\n  /**\n   * Padding between each value groups, in x axis units.\n   *\n   * @sample  {highcharts} highcharts/plotoptions/column-grouppadding-default/\n   *          0.2 by default\n   * @sample  {highcharts} highcharts/plotoptions/column-grouppadding-none/\n   *          No group padding - all columns are evenly spaced\n   * @product highcharts highstock\n   */\n  groupPadding: 0.2,\n\n  /**\n   * Whether to group non-stacked columns or to let them render independent\n   * of each other. Non-grouped columns will be laid out individually\n   * and overlap each other.\n   *\n   * @type      {Boolean}\n   * @sample    {highcharts} highcharts/plotoptions/column-grouping-false/\n   *            Grouping disabled\n   * @sample    {highstock} highcharts/plotoptions/column-grouping-false/\n   *            Grouping disabled\n   * @default   true\n   * @since     2.3.0\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.grouping\n   */\n\n  /**\n   * @ignore-option\n   */\n  marker: null,\n  // point options are specified in the base options\n\n  /**\n   * The maximum allowed pixel width for a column, translated to the height\n   * of a bar in a bar chart. This prevents the columns from becoming\n   * too wide when there is a small number of points in the chart.\n   *\n   * @type      {Number}\n   * @see       [pointWidth](#plotOptions.column.pointWidth)\n   * @sample    {highcharts} highcharts/plotoptions/column-maxpointwidth-20/\n   *            Limited to 50\n   * @sample    {highstock} highcharts/plotoptions/column-maxpointwidth-20/\n   *            Limited to 50\n   * @default   null\n   * @since     4.1.8\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.maxPointWidth\n   */\n\n  /**\n   * Padding between each column or bar, in x axis units.\n   *\n   * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-default/\n   *          0.1 by default\n   * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-025/\n   *          0.25\n   * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-none/\n   *          0 for tightly packed columns\n   * @product highcharts highstock\n   */\n  pointPadding: 0.1,\n\n  /**\n   * A pixel value specifying a fixed width for each column or bar. When\n   * `null`, the width is calculated from the `pointPadding` and\n   * `groupPadding`.\n   *\n   * @type      {Number}\n   * @see       [maxPointWidth](#plotOptions.column.maxPointWidth)\n   * @sample    {highcharts} highcharts/plotoptions/column-pointwidth-20/\n   *            20px wide columns regardless of chart width or the amount\n   *            of data points\n   * @default   null\n   * @since     1.2.5\n   * @product   highcharts highstock\n   * @apioption plotOptions.column.pointWidth\n   */\n\n  /**\n   * The minimal height for a column or width for a bar. By default,\n   * 0 values are not shown. To visualize a 0 (or close to zero) point,\n   * set the minimal point length to a pixel value like 3\\. In stacked\n   * column charts, minPointLength might not be respected for tightly\n   * packed values.\n   *\n   * @sample  {highcharts}\n   *          highcharts/plotoptions/column-minpointlength/\n   *          Zero base value\n   * @sample  {highcharts}\n   *          highcharts/plotoptions/column-minpointlength-pos-and-neg/\n   *          Positive and negative close to zero values\n   * @product highcharts highstock\n   */\n  minPointLength: 0,\n\n  /**\n   * When the series contains less points than the crop threshold, all\n   * points are drawn, event if the points fall outside the visible plot\n   * area at the current zoom. The advantage of drawing all points (including\n   * markers and columns), is that animation is performed on updates.\n   * On the other hand, when the series contains more points than the\n   * crop threshold, the series data is cropped to only contain points\n   * that fall within the plot area. The advantage of cropping away invisible\n   * points is to increase performance on large series. .\n   *\n   * @product highcharts highstock\n   */\n  cropThreshold: 50,\n\n  /**\n   * The X axis range that each point is valid for. This determines the\n   * width of the column. On a categorized axis, the range will be 1\n   * by default (one category unit). On linear and datetime axes, the\n   * range will be computed as the distance between the two closest data\n   * points.\n   *\n   * The default `null` means it is computed automatically, but this option\n   * can be used to override the automatic value.\n   *\n   * @type    {Number}\n   * @sample  {highcharts} highcharts/plotoptions/column-pointrange/\n   *          Set the point range to one day on a data set with one week\n   *          between the points\n   * @since   2.3\n   * @product highcharts highstock\n   */\n  pointRange: null,\n  states: {\n    /**\n     * Options for the hovered point. These settings override the normal\n     * state options when a point is moused over or touched.\n     *\n     * @extends   plotOptions.series.states.hover\n     * @excluding halo,lineWidth,lineWidthPlus,marker\n     * @product   highcharts highstock\n     */\n    hover: {\n      /** @ignore-option */\n      halo: false\n      /**\n       * A specific border color for the hovered point. Defaults to\n       * inherit the normal state border color.\n       *\n       * @type      {Color}\n       * @product   highcharts\n       * @apioption plotOptions.column.states.hover.borderColor\n       */\n\n      /**\n       * A specific color for the hovered point.\n       *\n       * @type      {Color}\n       * @default   undefined\n       * @product   highcharts\n       * @apioption plotOptions.column.states.hover.color\n       */\n\n    }\n  },\n  dataLabels: {\n    align: null,\n    // auto\n    verticalAlign: null,\n    // auto\n    y: null\n  },\n\n  /**\n   * When this is true, the series will not cause the Y axis to cross\n   * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n   * unless the data actually crosses the plane.\n   *\n   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n   * 3 will make the Y axis show negative values according to the `minPadding`\n   * option. If `softThreshold` is `true`, the Y axis starts at 0.\n   *\n   * @since   4.1.9\n   * @product highcharts highstock\n   */\n  softThreshold: false,\n  // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/\n\n  /**\n   * @ignore-option\n   */\n  startFromThreshold: true,\n  stickyTracking: false,\n  tooltip: {\n    distance: 6\n  },\n\n  /**\n   * The Y axis value to serve as the base for the columns, for distinguishing\n   * between values above and below a threshold. If `null`, the columns\n   * extend from the padding Y axis minimum.\n   *\n   * @since   2.0\n   * @product highcharts\n   */\n  threshold: 0\n},\n/** @lends seriesTypes.column.prototype */\n{\n  cropShoulder: 0,\n  // When tooltip is not shared, this series (and derivatives) requires direct\n  // touch/hover. KD-tree does not apply.\n  directTouch: true,\n  trackerGroups: ['group', 'dataLabelsGroup'],\n  // use separate negative stacks, unlike area stacks where a negative point\n  // is substracted from previous (#1910)\n  negStacks: true,\n\n  /**\n   * Initialize the series. Extends the basic Series.init method by\n   * marking other series of the same type as dirty.\n   *\n   * @function #init\n   * @memberof seriesTypes.column\n   *\n   */\n  init: function () {\n    Series.prototype.init.apply(this, arguments);\n    var series = this,\n        chart = series.chart; // if the series is added dynamically, force redraw of other\n    // series affected by a new column\n\n    if (chart.hasRendered) {\n      each(chart.series, function (otherSeries) {\n        if (otherSeries.type === series.type) {\n          otherSeries.isDirty = true;\n        }\n      });\n    }\n  },\n\n  /**\n   * Return the width and x offset of the columns adjusted for grouping,\n   * groupPadding, pointPadding, pointWidth etc.\n   */\n  getColumnMetrics: function () {\n    var series = this,\n        options = series.options,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis,\n        reversedStacks = xAxis.options.reversedStacks,\n        // Keep backward compatibility: reversed xAxis had reversed stacks\n    reverseStacks = xAxis.reversed && !reversedStacks || !xAxis.reversed && reversedStacks,\n        stackKey,\n        stackGroups = {},\n        columnCount = 0; // Get the total number of column type series. This is called on every\n    // series. Consider moving this logic to a chart.orderStacks() function\n    // and call it on init, addSeries and removeSeries\n\n    if (options.grouping === false) {\n      columnCount = 1;\n    } else {\n      each(series.chart.series, function (otherSeries) {\n        var otherOptions = otherSeries.options,\n            otherYAxis = otherSeries.yAxis,\n            columnIndex;\n\n        if (otherSeries.type === series.type && (otherSeries.visible || !series.chart.options.chart.ignoreHiddenSeries) && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {\n          // #642, #2086\n          if (otherOptions.stacking) {\n            stackKey = otherSeries.stackKey;\n\n            if (stackGroups[stackKey] === undefined) {\n              stackGroups[stackKey] = columnCount++;\n            }\n\n            columnIndex = stackGroups[stackKey];\n          } else if (otherOptions.grouping !== false) {\n            // #1162\n            columnIndex = columnCount++;\n          }\n\n          otherSeries.columnIndex = columnIndex;\n        }\n      });\n    }\n\n    var categoryWidth = Math.min(Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n    xAxis.len // #1535\n    ),\n        groupPadding = categoryWidth * options.groupPadding,\n        groupWidth = categoryWidth - 2 * groupPadding,\n        pointOffsetWidth = groupWidth / (columnCount || 1),\n        pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))),\n        pointPadding = (pointOffsetWidth - pointWidth) / 2,\n        // #1251, #3737\n    colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0),\n        pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1); // Save it for reading in linked series (Error bars particularly)\n\n    series.columnMetrics = {\n      width: pointWidth,\n      offset: pointXOffset\n    };\n    return series.columnMetrics;\n  },\n\n  /**\n   * Make the columns crisp. The edges are rounded to the nearest full pixel.\n   */\n  crispCol: function (x, y, w, h) {\n    var chart = this.chart,\n        borderWidth = this.borderWidth,\n        xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n        yCrisp = borderWidth % 2 ? 0.5 : 1,\n        right,\n        bottom,\n        fromTop;\n\n    if (chart.inverted && chart.renderer.isVML) {\n      yCrisp += 1;\n    } // Horizontal. We need to first compute the exact right edge, then round\n    // it and compute the width from there.\n\n\n    if (this.options.crisp) {\n      right = Math.round(x + w) + xCrisp;\n      x = Math.round(x) + xCrisp;\n      w = right - x;\n    } // Vertical\n\n\n    bottom = Math.round(y + h) + yCrisp;\n    fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n\n    y = Math.round(y) + yCrisp;\n    h = bottom - y; // Top edges are exceptions\n\n    if (fromTop && h) {\n      // #5146\n      y -= 1;\n      h += 1;\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: w,\n      height: h\n    };\n  },\n\n  /**\n   * Translate each point to the plot area coordinate system and find shape\n   * positions\n   */\n  translate: function () {\n    var series = this,\n        chart = series.chart,\n        options = series.options,\n        dense = series.dense = series.closestPointRange * series.xAxis.transA < 2,\n        borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1 // #3635\n    ),\n        yAxis = series.yAxis,\n        threshold = options.threshold,\n        translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n        minPointLength = pick(options.minPointLength, 5),\n        metrics = series.getColumnMetrics(),\n        pointWidth = metrics.width,\n        // postprocessed for border width\n    seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth),\n        pointXOffset = series.pointXOffset = metrics.offset;\n\n    if (chart.inverted) {\n      translatedThreshold -= 0.5; // #3355\n    } // When the pointPadding is 0, we want the columns to be packed tightly,\n    // so we allow individual columns to have individual sizes. When\n    // pointPadding is greater, we strive for equal-width columns (#2694).\n\n\n    if (options.pointPadding) {\n      seriesBarW = Math.ceil(seriesBarW);\n    }\n\n    Series.prototype.translate.apply(series); // Record the new values\n\n    each(series.points, function (point) {\n      var yBottom = pick(point.yBottom, translatedThreshold),\n          safeDistance = 999 + Math.abs(yBottom),\n          plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance),\n          // Don't draw too far outside plot area (#1303, #2241, #4264)\n      barX = point.plotX + pointXOffset,\n          barW = seriesBarW,\n          barY = Math.min(plotY, yBottom),\n          up,\n          barH = Math.max(plotY, yBottom) - barY; // Handle options.minPointLength\n\n      if (minPointLength && Math.abs(barH) < minPointLength) {\n        barH = minPointLength;\n        up = !yAxis.reversed && !point.negative || yAxis.reversed && point.negative; // Reverse zeros if there's no positive value in the series\n        // in visible range (#7046)\n\n        if (point.y === threshold && series.dataMax <= threshold && yAxis.min < threshold // and if there's room for it (#7311)\n        ) {\n            up = !up;\n          } // If stacked...\n\n\n        barY = Math.abs(barY - translatedThreshold) > minPointLength ? // ...keep position\n        yBottom - minPointLength : // #1485, #4051\n        translatedThreshold - (up ? minPointLength : 0);\n      } // Cache for access in polar\n\n\n      point.barX = barX;\n      point.pointWidth = pointWidth; // Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n\n      point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH]; // Register shape type and arguments to be used in drawPoints\n\n      point.shapeType = 'rect';\n      point.shapeArgs = series.crispCol.apply(series, point.isNull ? // #3169, drilldown from null must have a position to work\n      // from #6585, dataLabel should be placed on xAxis, not\n      // floating in the middle of the chart\n      [barX, translatedThreshold, barW, 0] : [barX, barY, barW, barH]);\n    });\n  },\n  getSymbol: noop,\n\n  /**\n   * Use a solid rectangle like the area series types\n   */\n  drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n  /**\n   * Columns have no graph\n   */\n  drawGraph: function () {\n    this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');\n  },\n\n  /**\n   * Draw the columns. For bars, the series.group is rotated, so the same\n   * coordinates apply for columns and bars. This method is inherited by\n   * scatter series.\n   */\n  drawPoints: function () {\n    var series = this,\n        chart = this.chart,\n        options = series.options,\n        renderer = chart.renderer,\n        animationLimit = options.animationLimit || 250,\n        shapeArgs; // draw the columns\n\n    each(series.points, function (point) {\n      var plotY = point.plotY,\n          graphic = point.graphic,\n          verb = graphic && chart.pointCount < animationLimit ? 'animate' : 'attr';\n\n      if (isNumber(plotY) && point.y !== null) {\n        shapeArgs = point.shapeArgs;\n\n        if (graphic) {\n          // update\n          graphic[verb](merge(shapeArgs));\n        } else {\n          point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);\n        } // Border radius is not stylable (#6900)\n\n\n        if (options.borderRadius) {\n          graphic.attr({\n            r: options.borderRadius\n          });\n        }\n\n        graphic.addClass(point.getClassName(), true);\n      } else if (graphic) {\n        point.graphic = graphic.destroy(); // #1269\n      }\n    });\n  },\n\n  /**\n   * Animate the column heights one by one from zero\n   * @param {Boolean} init Whether to initialize the animation or run it\n   */\n  animate: function (init) {\n    var series = this,\n        yAxis = this.yAxis,\n        options = series.options,\n        inverted = this.chart.inverted,\n        attr = {},\n        translateProp = inverted ? 'translateX' : 'translateY',\n        translateStart,\n        translatedThreshold;\n\n    if (svg) {\n      // VML is too slow anyway\n      if (init) {\n        attr.scaleY = 0.001;\n        translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));\n\n        if (inverted) {\n          attr.translateX = translatedThreshold - yAxis.len;\n        } else {\n          attr.translateY = translatedThreshold;\n        }\n\n        series.group.attr(attr);\n      } else {\n        // run the animation\n        translateStart = series.group.attr(translateProp);\n        series.group.animate({\n          scaleY: 1\n        }, extend(animObject(series.options.animation), {\n          // Do the scale synchronously to ensure smooth updating\n          // (#5030, #7228)\n          step: function (val, fx) {\n            attr[translateProp] = translateStart + fx.pos * (yAxis.pos - translateStart);\n            series.group.attr(attr);\n          }\n        })); // delete this function to allow it only once\n\n        series.animate = null;\n      }\n    }\n  },\n\n  /**\n   * Remove this series from the chart\n   */\n  remove: function () {\n    var series = this,\n        chart = series.chart; // column and bar series affects other series of the same type\n    // as they are either stacked or grouped\n\n    if (chart.hasRendered) {\n      each(chart.series, function (otherSeries) {\n        if (otherSeries.type === series.type) {\n          otherSeries.isDirty = true;\n        }\n      });\n    }\n\n    Series.prototype.remove.apply(series, arguments);\n  }\n});\n/**\n * A `column` series. If the [type](#series.column.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.column\n * @excluding connectNulls,dashStyle,dataParser,dataURL,gapSize,gapUnit,linecap,\n *            lineWidth,marker,connectEnds,step\n * @product   highcharts highstock\n * @apioption series.column\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.column.states.hover\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.column.states.select\n */\n\n/**\n * An array of data points for the series. For the `column` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 6],\n *         [1, 2],\n *         [2, 6]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.column.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 6,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.line.data\n * @excluding marker\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.column.data\n */\n\n/**\n * The color of the border surrounding the column or bar.\n *\n * In styled mode, the border stroke can be set with the `.highcharts-point`\n * rule.\n *\n * @type      {Color}\n * @sample    {highcharts} highcharts/plotoptions/column-bordercolor/\n *            Dark gray border\n * @default   undefined\n * @product   highcharts highstock\n * @apioption series.column.data.borderColor\n */\n\n/**\n * The width of the border surrounding the column or bar.\n *\n * In styled mode, the stroke width can be set with the `.highcharts-point`\n * rule.\n *\n * @type      {Number}\n * @sample    {highcharts} highcharts/plotoptions/column-borderwidth/\n *            2px black border\n * @default   undefined\n * @product   highcharts highstock\n * @apioption series.column.data.borderWidth\n */"
    },
    {
     "id": 270,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid.js?babel-target=es6 + 17 modules"
    },
    {
     "id": 272,
     "name": "../node_modules/@vaadin/vaadin-dialog/src/vaadin-dialog.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 274,
     "name": "../node_modules/@vaadin/vaadin-list-box/theme/lumo/vaadin-list-box.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 276,
     "name": "../node_modules/highcharts/js/es-modules/parts/ScatterSeries.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Options.js';\nimport './Series.js';\nvar Series = H.Series,\n    seriesType = H.seriesType;\n/**\n * A scatter plot uses cartesian coordinates to display values for two variables\n * for a set of data.\n *\n * @sample       {highcharts} highcharts/demo/scatter/\n *               Scatter plot\n * @extends      {plotOptions.line}\n * @excluding    pointPlacement, shadow\n * @product      highcharts highstock\n * @optionparent plotOptions.scatter\n */\n\nseriesType('scatter', 'line', {\n  /**\n   * The width of the line connecting the data points.\n   *\n   * @sample  {highcharts} highcharts/plotoptions/scatter-linewidth-none/\n   *          0 by default\n   * @sample  {highcharts} highcharts/plotoptions/scatter-linewidth-1/\n   *          1px\n   * @product highcharts highstock\n   */\n  lineWidth: 0,\n  findNearestPointBy: 'xy',\n  marker: {\n    enabled: true // Overrides auto-enabling in line series (#3647)\n\n  },\n\n  /**\n   * Sticky tracking of mouse events. When true, the `mouseOut` event\n   * on a series isn't triggered until the mouse moves over another series,\n   * or out of the plot area. When false, the `mouseOut` event on a series\n   * is triggered when the mouse leaves the area around the series' graph\n   * or markers. This also implies the tooltip. When `stickyTracking`\n   * is false and `tooltip.shared` is false, the tooltip will be hidden\n   * when moving the mouse between series.\n   *\n   * @type      {Boolean}\n   * @default   false\n   * @product   highcharts highstock\n   * @apioption plotOptions.scatter.stickyTracking\n   */\n\n  /**\n   * A configuration object for the tooltip rendering of each single\n   * series. Properties are inherited from [tooltip](#tooltip).\n   * Overridable properties are `headerFormat`, `pointFormat`, `yDecimals`,\n   * `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other series, in\n   * a scatter plot the series.name by default shows in the headerFormat\n   * and point.x and point.y in the pointFormat.\n   *\n   * @product highcharts highstock\n   */\n  tooltip: {\n    headerFormat: '<span class=\"highcharts-color-{point.colorIndex}\">\\u25CF</span> ' + '<span class=\"highcharts-header\"> {series.name}</span><br/>',\n    pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n  } // Prototype members\n\n}, {\n  sorted: false,\n  requireSorting: false,\n  noSharedTooltip: true,\n  trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n  takeOrdinalPosition: false,\n  // #2342\n  drawGraph: function () {\n    if (this.options.lineWidth) {\n      Series.prototype.drawGraph.call(this);\n    }\n  }\n});\n/**\n * A `scatter` series. If the [type](#series.scatter.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.scatter\n * @excluding dataParser,dataURL\n * @product   highcharts highstock\n * @apioption series.scatter\n */\n\n/**\n * An array of data points for the series. For the `scatter` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 0],\n *         [1, 8],\n *         [2, 9]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.scatter.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 2,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 4,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.line.data\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.scatter.data\n */"
    },
    {
     "id": 277,
     "name": "../node_modules/@vaadin/vaadin-checkbox/src/vaadin-checkbox.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-checkbox>` is a Web Component for customized checkboxes.\n *\n * ```html\n * <vaadin-checkbox>\n *   Make my profile visible\n * </vaadin-checkbox>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name         | Description\n * ------------------|----------------\n * `checkbox`        | The wrapper element for the native <input type=\"checkbox\">\n * `label`           | The wrapper element in which the component's children, namely the label, is slotted\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|--------------\n * `active`     | Set when the checkbox is pressed down, either with mouse, touch or the keyboard. | `:host`\n * `disabled`   | Set when the checkbox is disabled. | `:host`\n * `focus-ring` | Set when the checkbox is focused using the keyboard. | `:host`\n * `focused`    | Set when the checkbox is focused. | `:host`\n * `indeterminate` | Set when the checkbox is in indeterminate mode. | `:host`\n * `checked` | Set when the checkbox is checked. | `:host`\n * `empty` | Set when there is no label provided. | `label`\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ControlStateMixin\n * @mixes ThemableMixin\n * @mixes GestureEventListeners\n * @demo demo/index.html\n */\n\nclass CheckboxElement extends ElementMixin(ControlStateMixin(ThemableMixin(GestureEventListeners(PolymerElement)))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      label {\n        display: inline-flex;\n        align-items: baseline;\n        outline: none;\n      }\n\n      [part=\"checkbox\"] {\n        position: relative;\n        display: inline-block;\n        flex: none;\n      }\n\n      input[type=\"checkbox\"] {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        width: 100%;\n        height: 100%;\n        opacity: 0;\n        cursor: inherit;\n        margin: 0;\n      }\n\n      :host([disabled]) {\n        -webkit-tap-highlight-color: transparent;\n      }\n    </style>\n\n    <label>\n      <span part=\"checkbox\">\n        <input type=\"checkbox\" checked=\"{{checked::change}}\" disabled\\$=\"[[disabled]]\" indeterminate=\"{{indeterminate::change}}\" role=\"presentation\" tabindex=\"-1\">\n      </span>\n\n      <span part=\"label\">\n        <slot></slot>\n      </span>\n    </label>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-checkbox';\n  }\n\n  static get version() {\n    return '2.5.0';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * True if the checkbox is checked.\n       * @type {boolean}\n       */\n      checked: {\n        type: Boolean,\n        value: false,\n        notify: true,\n        observer: '_checkedChanged',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Indeterminate state of the checkbox when it's neither checked nor unchecked, but undetermined.\n       * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Indeterminate_state_checkboxes\n       * @type {boolean}\n       */\n      indeterminate: {\n        type: Boolean,\n        notify: true,\n        observer: '_indeterminateChanged',\n        reflectToAttribute: true,\n        value: false\n      },\n\n      /**\n       * The value given to the data submitted with the checkbox's name to the server when the control is inside a form.\n       */\n      value: {\n        type: String,\n        value: 'on'\n      },\n\n      /** @private */\n      _nativeCheckbox: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    /**\n     * @type {string}\n     * Name of the element.\n     */\n\n    this.name;\n  }\n\n  get name() {\n    return this.checked ? this._storedName : '';\n  }\n\n  set name(name) {\n    this._storedName = name;\n  }\n\n  ready() {\n    super.ready();\n    this.setAttribute('role', 'checkbox');\n    this._nativeCheckbox = this.shadowRoot.querySelector('input[type=\"checkbox\"]');\n    this.addEventListener('click', this._handleClick.bind(this));\n\n    this._addActiveListeners();\n\n    var attrName = this.getAttribute('name');\n\n    if (attrName) {\n      this.name = attrName;\n    }\n\n    this.shadowRoot.querySelector('[part~=\"label\"]').querySelector('slot').addEventListener('slotchange', this._updateLabelAttribute.bind(this));\n\n    this._updateLabelAttribute();\n  }\n  /** @private */\n\n\n  _updateLabelAttribute() {\n    var label = this.shadowRoot.querySelector('[part~=\"label\"]');\n    var assignedNodes = label.firstElementChild.assignedNodes();\n\n    if (this._isAssignedNodesEmpty(assignedNodes)) {\n      label.setAttribute('empty', '');\n    } else {\n      label.removeAttribute('empty');\n    }\n  }\n  /** @private */\n\n\n  _isAssignedNodesEmpty(nodes) {\n    // The assigned nodes considered to be empty if there is no slotted content or only one empty text node\n    return nodes.length === 0 || nodes.length == 1 && nodes[0].nodeType == Node.TEXT_NODE && nodes[0].textContent.trim() === '';\n  }\n  /** @private */\n\n\n  _checkedChanged(checked) {\n    if (this.indeterminate) {\n      this.setAttribute('aria-checked', 'mixed');\n    } else {\n      this.setAttribute('aria-checked', Boolean(checked));\n    }\n  }\n  /** @private */\n\n\n  _indeterminateChanged(indeterminate) {\n    if (indeterminate) {\n      this.setAttribute('aria-checked', 'mixed');\n    } else {\n      this.setAttribute('aria-checked', this.checked);\n    }\n  }\n  /** @private */\n\n\n  _addActiveListeners() {\n    // DOWN\n    this._addEventListenerToNode(this, 'down', e => {\n      if (this.__interactionsAllowed(e)) {\n        this.setAttribute('active', '');\n      }\n    }); // UP\n\n\n    this._addEventListenerToNode(this, 'up', () => this.removeAttribute('active')); // KEYDOWN\n\n\n    this.addEventListener('keydown', e => {\n      if (this.__interactionsAllowed(e) && e.keyCode === 32) {\n        e.preventDefault();\n        this.setAttribute('active', '');\n      }\n    }); // KEYUP\n\n    this.addEventListener('keyup', e => {\n      if (this.__interactionsAllowed(e) && e.keyCode === 32) {\n        e.preventDefault();\n\n        this._toggleChecked();\n\n        this.removeAttribute('active');\n\n        if (this.indeterminate) {\n          this.indeterminate = false;\n        }\n      }\n    });\n  }\n  /**\n   * @return {!HTMLInputElement}\n   * @protected\n   */\n\n\n  get focusElement() {\n    return this.shadowRoot.querySelector('input');\n  }\n  /**\n   * True if users' interactions (mouse or keyboard)\n   * should toggle the checkbox\n   */\n\n\n  __interactionsAllowed(e) {\n    if (this.disabled) {\n      return false;\n    } // https://github.com/vaadin/vaadin-checkbox/issues/63\n\n\n    if (e.target.localName === 'a') {\n      return false;\n    }\n\n    return true;\n  }\n  /** @private */\n\n\n  _handleClick(e) {\n    if (this.__interactionsAllowed(e)) {\n      if (!this.indeterminate) {\n        if (e.composedPath()[0] !== this._nativeCheckbox) {\n          e.preventDefault();\n\n          this._toggleChecked();\n        }\n      } else {\n        /*\n         * Required for IE 11 and Edge.\n         * See issue here: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7344418/\n         */\n        this.indeterminate = false;\n        e.preventDefault();\n\n        this._toggleChecked();\n      }\n    }\n  }\n  /** @protected */\n\n\n  _toggleChecked() {\n    this.checked = !this.checked;\n    this.dispatchEvent(new CustomEvent('change', {\n      composed: false,\n      bubbles: true\n    }));\n  }\n  /**\n   * Fired when the user commits a value change.\n   *\n   * @event change\n   */\n\n\n}\n\ncustomElements.define(CheckboxElement.is, CheckboxElement);\nexport { CheckboxElement };"
    },
    {
     "id": 278,
     "name": "../node_modules/@vaadin/vaadin-confirm-dialog/src/vaadin-confirm-dialog.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2018 Vaadin Ltd.\nThis program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).\n\nSee <a href=\"https://vaadin.com/license/cval-3\">the website</a> for the complete license.\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport '@vaadin/vaadin-license-checker/vaadin-license-checker.js';\nimport '@vaadin/vaadin-button/src/vaadin-button.js';\nimport '@vaadin/vaadin-dialog/src/vaadin-dialog.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { beforeNextRender } from '@polymer/polymer/lib/utils/render-status.js';\n/**\n * `<vaadin-confirm-dialog>` is a Web Component for showing alerts and asking for user confirmation.\n *\n * ```\n * <vaadin-confirm-dialog on-confirm=\"_doConfirm\">\n *  Sample confirmation question\n * </vaadin-confirm-dialog>\n * ```\n *\n * ### Styling\n *\n * The following Shadow DOM parts are available for styling the dialog parts:\n *\n * Part name  | Description\n * -----------|---------------------------------------------------------|\n * `header`   | Header of the confirmation dialog\n * `message`  | Container for the message of the dialog\n * `footer`   | Container for the buttons\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * ### Custom content\n *\n * The following parts are available for replacement:\n *\n * Slot name         | Description\n * ------------------|---------------------------------------------------------|\n * `header`          | Header of the confirmation dialog\n * `message`         | Container for the message of the dialog\n * `cancel-button`   | Container for the Cancel button\n * `reject-button`   | Container for the Reject button\n * `confirm-button`  | Container for the Confirm button\n *\n * See examples of setting custom buttons into slots in the live demos.\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nclass ConfirmDialogElement extends ElementMixin(ThemableMixin(PolymerElement)) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: none;\n        --_vaadin-confirm-dialog-content-width: auto;\n        --_vaadin-confirm-dialog-content-height: auto;\n        --_vaadin-confirm-dialog-footer-height: auto;\n      }\n    </style>\n    <vaadin-dialog id=\"dialog\" opened=\"{{opened}}\" aria-label=\"[[_getAriaLabel(header)]]\" theme\\$=\"_vaadin-confirm-dialog-dialog-overlay-theme [[theme]]\" no-close-on-outside-click=\"\" no-close-on-esc=\"[[noCloseOnEsc]]\">\n      <template>\n        <div id=\"content\">\n          <div part=\"header\">\n            <slot name=\"header\">\n              <h3 class=\"header\">[[header]]</h3>\n            </slot>\n          </div>\n\n          <div part=\"message\" id=\"message\">\n            <slot></slot>\n            [[message]]\n          </div>\n        </div>\n\n        <div part=\"footer\">\n          <div class=\"cancel-button\">\n            <slot name=\"cancel-button\">\n              <vaadin-button id=\"cancel\" theme\\$=\"[[cancelTheme]]\" on-click=\"_cancel\" hidden\\$=\"[[!cancel]]\" aria-describedby=\"message\">\n                [[cancelText]]\n              </vaadin-button>\n            </slot>\n          </div>\n          <div class=\"reject-button\">\n            <slot name=\"reject-button\">\n              <vaadin-button id=\"reject\" theme\\$=\"[[rejectTheme]]\" on-click=\"_reject\" hidden\\$=\"[[!reject]]\" aria-describedby=\"message\">\n                [[rejectText]]\n              </vaadin-button>\n            </slot>\n          </div>\n          <div class=\"confirm-button\">\n            <slot name=\"confirm-button\">\n              <vaadin-button id=\"confirm\" theme\\$=\"[[confirmTheme]]\" on-click=\"_confirm\" aria-describedby=\"message\">\n                [[confirmText]]\n              </vaadin-button>\n            </slot>\n          </div>\n        </div>\n      </template>\n    </vaadin-dialog>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-confirm-dialog';\n  }\n\n  static get version() {\n    return '1.3.0';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * True if the overlay is currently displayed.\n       * @type {boolean}\n       */\n      opened: {\n        type: Boolean,\n        value: false,\n        notify: true,\n        observer: '_openedChanged'\n      },\n\n      /**\n       * Set the confirmation dialog title.\n       * @type {string}\n       */\n      header: {\n        type: String,\n        value: ''\n      },\n\n      /**\n       * Set the message or confirmation question.\n       */\n      message: {\n        type: String\n      },\n\n      /**\n       * Text displayed on confirm-button.\n       * @attr {string} confirm-text\n       * @type {string}\n       */\n      confirmText: {\n        type: String,\n        value: 'Confirm'\n      },\n\n      /**\n       * Theme for a confirm-button.\n       * @attr {string} confirm-theme\n       * @type {string}\n       */\n      confirmTheme: {\n        type: String,\n        value: 'primary'\n      },\n\n      /**\n       * Set to true to disable closing dialog on Escape press\n       * @attr {boolean} no-close-on-esc\n       * @type {boolean}\n       */\n      noCloseOnEsc: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Whether to show cancel button or not.\n       * @type {boolean}\n       */\n      reject: {\n        type: Boolean,\n        reflectToAttribute: true,\n        value: false,\n        notify: true\n      },\n\n      /**\n       * Text displayed on reject-button.\n       * @attr {string} reject-text\n       * @type {string}\n       */\n      rejectText: {\n        type: String,\n        value: 'Reject'\n      },\n\n      /**\n       * Theme for a reject-button.\n       * @attr {string} reject-theme\n       * @type {string}\n       */\n      rejectTheme: {\n        type: String,\n        value: 'error tertiary'\n      },\n\n      /**\n       * Whether to show cancel button or not.\n       * @type {boolean}\n       */\n      cancel: {\n        type: Boolean,\n        reflectToAttribute: true,\n        value: false,\n        notify: true\n      },\n\n      /**\n       * Text displayed on cancel-button.\n       * @attr {string} cancel-text\n       * @type {string}\n       */\n      cancelText: {\n        type: String,\n        value: 'Cancel'\n      },\n\n      /**\n       * Theme for a cancel-button.\n       * @attr {string} cancel-theme\n       * @type {string}\n       */\n      cancelTheme: {\n        type: String,\n        value: 'tertiary'\n      },\n\n      /** @private */\n      _confirmButton: {\n        type: Element\n      }\n    };\n  }\n  /** @protected */\n\n\n  static _finalizeClass() {\n    super._finalizeClass();\n\n    var devModeCallback = window.Vaadin.developmentModeCallback;\n    var licenseChecker = devModeCallback && devModeCallback['vaadin-license-checker'];\n\n    if (typeof licenseChecker === 'function') {\n      licenseChecker(ConfirmDialogElement);\n    }\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.$.dialog.$.overlay.addEventListener('vaadin-overlay-escape-press', this._escPressed.bind(this));\n\n    if (this._dimensions) {\n      Object.keys(this._dimensions).forEach(name => {\n        this._setDimension(name, this._dimensions[name]);\n      });\n    }\n  }\n  /**\n   * @param {string} name\n   * @param {?string} oldValue\n   * @param {?string} newValue\n   * @protected\n   */\n\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    super.attributeChangedCallback(name, oldValue, newValue);\n\n    if (name === 'dir') {\n      var value = newValue === 'rtl';\n      this.__isRTL = value;\n      this.opened && this.__toggleContentRTL(value);\n    }\n  }\n  /** @private */\n\n\n  __toggleContentRTL(rtl) {\n    var contentBlock = this.$.dialog.$.overlay.content.querySelector('#content');\n    var footerBlock = this.$.dialog.$.overlay.content.querySelector('[part=footer]');\n\n    if (rtl) {\n      contentBlock.setAttribute('dir', 'rtl');\n      footerBlock.setAttribute('dir', 'rtl');\n    } else {\n      contentBlock.removeAttribute('dir');\n      footerBlock.removeAttribute('dir');\n    }\n  }\n  /** @private */\n\n\n  _openedChanged() {\n    if (!this.opened) {\n      return;\n    }\n\n    Array.from(this.childNodes).forEach(c => {\n      var newChild = this.$.dialog.$.overlay.$.content.appendChild(c);\n\n      if (newChild.getAttribute && newChild.getAttribute('slot') == 'confirm-button' && newChild.focus) {\n        this._confirmButton = newChild;\n      }\n    });\n    this.opened && this.__toggleContentRTL(this.__isRTL);\n    beforeNextRender(this, () => {\n      var confirmButton = this._confirmButton || this.$.dialog.$.overlay.content.querySelector('#confirm');\n      confirmButton.focus();\n      var {\n        height\n      } = getComputedStyle(this.$.dialog.$.overlay.content.querySelector('[part=footer]'));\n\n      if (height != this._footerHeight) {\n        window.ShadyCSS.styleSubtree(this.$.dialog.$.overlay, {\n          '--_vaadin-confirm-dialog-footer-height': height\n        });\n        this._footerHeight = height;\n      }\n    });\n  }\n  /** @private */\n\n\n  _escPressed(event) {\n    if (!event.defaultPrevented) {\n      this._cancel();\n    }\n  }\n  /** @private */\n\n\n  _confirm() {\n    this.dispatchEvent(new CustomEvent('confirm'));\n    this.opened = false;\n  }\n  /** @private */\n\n\n  _cancel() {\n    this.dispatchEvent(new CustomEvent('cancel'));\n    this.opened = false;\n  }\n  /** @private */\n\n\n  _reject() {\n    this.dispatchEvent(new CustomEvent('reject'));\n    this.opened = false;\n  }\n  /** @private */\n\n\n  _getAriaLabel(header) {\n    return header || 'confirmation';\n  }\n  /** @private */\n\n\n  _setWidth(width) {\n    this._setDimensionIfAttached('width', width);\n  }\n  /** @private */\n\n\n  _setHeight(height) {\n    this._setDimensionIfAttached('height', height);\n  }\n  /** @private */\n\n\n  _setDimensionIfAttached(name, value) {\n    if (this.$ && this.$.dialog) {\n      this._setDimension(name, value);\n    } else {\n      this._dimensions = this._dimensions || {};\n      this._dimensions[name] = value;\n    }\n  }\n  /** @private */\n\n\n  _setDimension(name, value) {\n    this._propsToUpdate = this._propsToUpdate || {};\n    this._propsToUpdate[`--_vaadin-confirm-dialog-content-${name}`] = value; // To prevent multiple calls to update CSS props\n\n    beforeNextRender(this, () => {\n      if (this._propsToUpdate) {\n        window.ShadyCSS.styleSubtree(this.$.dialog.$.overlay, this._propsToUpdate);\n        this._propsToUpdate = null;\n      }\n    });\n  }\n  /**\n   * @event confirm\n   * fired when Confirm button was pressed.\n   */\n\n  /**\n   * @event cancel\n   * fired when Cancel button or Escape key was pressed.\n   */\n\n  /**\n   * @event reject\n   * fired when Reject button was pressed.\n   */\n\n\n}\n\ncustomElements.define(ConfirmDialogElement.is, ConfirmDialogElement);\nexport { ConfirmDialogElement };"
    },
    {
     "id": 279,
     "name": "../node_modules/@vaadin/vaadin-login/src/vaadin-login-mixin.js?babel-target=es6",
     "source": "/**\n@license\nVaadin Login\nCopyright (C) 2018 Vaadin Ltd\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/**\n * @polymerMixin\n */\nexport var LoginMixin = superClass => class LoginMixin extends superClass {\n  /**\n   * Fired when user clicks on the \"Forgot password\" button.\n   *\n   * @event forgot-password\n   */\n\n  /**\n   * Fired when an user submits the login.\n   * The event contains `username` and `password` values in the `detail` property.\n   *\n   * @event login\n   *\n   */\n  static get properties() {\n    return {\n      /**\n       * If set, a synchronous POST call will be fired to the path defined.\n       * The `login` event is also dispatched, so `event.preventDefault()` can be called to prevent the POST call.\n       * @type {string | null}\n      */\n      action: {\n        type: String,\n        value: null,\n        notify: true\n      },\n\n      /**\n       * If set, disable the \"Log in\" button and prevent user from submitting login form.\n       * It is re-enabled automatically, when error is set to true, allowing form resubmission\n       * after user makes changes.\n       * @type {boolean}\n       */\n      disabled: {\n        type: Boolean,\n        value: false,\n        notify: true\n      },\n\n      /**\n       * If set, the error message is shown. The message is hidden by default.\n       * When set, it changes the disabled state of the submit button.\n       * @type {boolean}\n       */\n      error: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        notify: true\n      },\n\n      /**\n       * Whether to hide the forgot password button. The button is visible by default.\n       * @type {boolean}\n       */\n      noForgotPassword: {\n        type: Boolean,\n        value: false,\n        notify: true\n      },\n\n      /**\n       * The object used to localize this component.\n       * For changing the default localization, change the entire\n       * _i18n_ object or just the property you want to modify.\n       *\n       * The object has the following JSON structure (by default it doesn't include `additionalInformation`\n       * and `header` sections, `header` can be added to override `title` and `description` properties\n       * in `vaadin-login-overlay`):\n         {\n          header: {\n            title: 'App name',\n            description: 'Inspiring application description'\n          },\n          form: {\n            title: 'Log in',\n            username: 'Username',\n            password: 'Password',\n            submit: 'Log in',\n            forgotPassword: 'Forgot password'\n          },\n          errorMessage: {\n            title: 'Incorrect username or password',\n            message: 'Check that you have entered the correct username and password and try again.'\n          },\n          additionalInformation: 'In case you need to provide some additional info for the user.'\n        }\n       * @type {!LoginI18n}\n       * @default {English/US}\n       */\n      i18n: {\n        type: Object,\n        value: function () {\n          return {\n            form: {\n              title: 'Log in',\n              username: 'Username',\n              password: 'Password',\n              submit: 'Log in',\n              forgotPassword: 'Forgot password'\n            },\n            errorMessage: {\n              title: 'Incorrect username or password',\n              message: 'Check that you have entered the correct username and password and try again.'\n            }\n          };\n        },\n        notify: true\n      },\n\n      /**\n       * If set, prevents auto enabling the component when error property is set to true.\n       * @private\n       */\n      _preventAutoEnable: {\n        type: Boolean,\n        value: false\n      }\n    };\n  }\n  /**\n   * @param {!Event} e\n   * @protected\n   */\n\n\n  _retargetEvent(e) {\n    e.stopPropagation();\n    var {\n      detail,\n      composed,\n      cancelable,\n      bubbles\n    } = e;\n    var firedEvent = this.dispatchEvent(new CustomEvent(e.type, {\n      bubbles,\n      cancelable,\n      composed,\n      detail\n    })); // Check if `eventTarget.preventDefault()` was called to prevent default in the original event\n\n    if (!firedEvent) {\n      e.preventDefault();\n    }\n  }\n\n};"
    },
    {
     "id": 284,
     "name": "../node_modules/@vaadin/vaadin-confirm-dialog/theme/lumo/vaadin-confirm-dialog.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 285,
     "name": "../node_modules/@vaadin/vaadin-dialog/theme/lumo/vaadin-dialog.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 286,
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-password-field.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 290,
     "name": "../node_modules/@vaadin/vaadin-list-box/src/vaadin-list-box.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 292,
     "name": "../node_modules/@vaadin/flow-frontend/comboBoxConnector.js?babel-target=es6",
     "source": "// Not using ES6 imports in this file yet because the connector in V14 must\n// still work in Legacy bower projects. See: `comboBoxConnector-es6.js` for\n// the Polymer3 approach.\n(function () {\n  var tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Combo Box', 'vaadin-combo-box-flow');\n  };\n\n  window.Vaadin.Flow.Legacy = window.Vaadin.Flow.Legacy || {};\n  window.Vaadin.Flow.comboBoxConnector = {\n    initLazy: comboBox => tryCatchWrapper(function (comboBox) {\n      // Check whether the connector was already initialized for the ComboBox\n      if (comboBox.$connector) {\n        return;\n      }\n\n      if (window.Polymer) {\n        // Polymer2 approach.\n        window.Vaadin.Flow.Legacy.Debouncer = window.Vaadin.Flow.Legacy.Debouncer || Polymer.Debouncer;\n        window.Vaadin.Flow.Legacy.timeOut = window.Vaadin.Flow.Legacy.timeOut || Polymer.Async.timeOut;\n      } else if (!window.Vaadin.Flow.Legacy.Debouncer) {\n        console.log(\"ComboBox is unable to load Polymer helpers.\");\n        return;\n      }\n\n      var Debouncer = window.Vaadin.Flow.Legacy.Debouncer;\n      var timeOut = window.Vaadin.Flow.Legacy.timeOut;\n      comboBox.$connector = {}; // holds pageIndex -> callback pairs of subsequent indexes (current active range)\n\n      var pageCallbacks = {};\n      var cache = {};\n      var lastFilter = '';\n      var placeHolder = new Vaadin.ComboBoxPlaceholder();\n      var MAX_RANGE_COUNT = Math.max(comboBox.pageSize * 2, 500); // Max item count in active range\n\n      var serverFacade = (() => {\n        // Private variables\n        var lastFilterSentToServer = '';\n        var dataCommunicatorResetNeeded = false; // Public methods\n\n        var needsDataCommunicatorReset = () => dataCommunicatorResetNeeded = true;\n\n        var getLastFilterSentToServer = () => lastFilterSentToServer;\n\n        var requestData = (startIndex, endIndex, params) => {\n          var count = endIndex - startIndex;\n          var filter = params.filter;\n          comboBox.$server.setRequestedRange(startIndex, count, filter);\n          lastFilterSentToServer = filter;\n\n          if (dataCommunicatorResetNeeded) {\n            comboBox.$server.resetDataCommunicator();\n            dataCommunicatorResetNeeded = false;\n          }\n        };\n\n        return {\n          needsDataCommunicatorReset,\n          getLastFilterSentToServer,\n          requestData\n        };\n      })();\n\n      var clearPageCallbacks = (pages = Object.keys(pageCallbacks)) => {\n        // Flush and empty the existing requests\n        pages.forEach(page => {\n          pageCallbacks[page]([], comboBox.size);\n          delete pageCallbacks[page]; // Empty the comboBox's internal cache without invoking observers by filling\n          // the filteredItems array with placeholders (comboBox will request for data when it\n          // encounters a placeholder)\n\n          var pageStart = parseInt(page) * comboBox.pageSize;\n          var pageEnd = pageStart + comboBox.pageSize;\n          var end = Math.min(pageEnd, comboBox.filteredItems.length);\n\n          for (var i = pageStart; i < end; i++) {\n            comboBox.filteredItems[i] = placeHolder;\n          }\n        });\n      };\n\n      comboBox.dataProvider = function (params, callback) {\n        if (params.pageSize != comboBox.pageSize) {\n          throw 'Invalid pageSize';\n        }\n\n        if (comboBox._clientSideFilter) {\n          // For clientside filter we first make sure we have all data which we also\n          // filter based on comboBox.filter. While later we only filter clientside data.\n          if (cache[0]) {\n            performClientSideFilter(cache[0], callback);\n            return;\n          } else {\n            // If client side filter is enabled then we need to first ask all data\n            // and filter it on client side, otherwise next time when user will\n            // input another filter, eg. continue to type, the local cache will be only\n            // what was received for the first filter, which may not be the whole\n            // data from server (keep in mind that client side filter is enabled only\n            // when the items count does not exceed one page).\n            params.filter = \"\";\n          }\n        }\n\n        var filterChanged = params.filter !== lastFilter;\n\n        if (filterChanged) {\n          cache = {};\n          lastFilter = params.filter;\n          this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(500), () => {\n            if (serverFacade.getLastFilterSentToServer() === params.filter) {\n              // Fixes the case when the filter changes\n              // to something else and back to the original value\n              // within debounce timeout, and the\n              // DataCommunicator thinks it doesn't need to send data\n              serverFacade.needsDataCommunicatorReset();\n            }\n\n            if (params.filter !== lastFilter) {\n              throw new Error(\"Expected params.filter to be '\" + lastFilter + \"' but was '\" + params.filter + \"'\");\n            } // Call the method again after debounce.\n\n\n            clearPageCallbacks();\n            comboBox.dataProvider(params, callback);\n          });\n          return;\n        }\n\n        if (cache[params.page]) {\n          // This may happen after skipping pages by scrolling fast\n          commitPage(params.page, callback);\n        } else {\n          pageCallbacks[params.page] = callback;\n          var activePages = Object.keys(pageCallbacks).map(page => parseInt(page));\n          var rangeMin = Math.min(...activePages);\n          var rangeMax = Math.max(...activePages);\n\n          if (activePages.length * params.pageSize > MAX_RANGE_COUNT) {\n            if (params.page === rangeMin) {\n              clearPageCallbacks([String(rangeMax)]);\n            } else {\n              clearPageCallbacks([String(rangeMin)]);\n            }\n\n            comboBox.dataProvider(params, callback);\n          } else if (rangeMax - rangeMin + 1 !== activePages.length) {\n            // Wasn't a sequential page index, clear the cache so combo-box will request for new pages\n            clearPageCallbacks();\n          } else {\n            // The requested page was sequential, extend the requested range\n            var startIndex = params.pageSize * rangeMin;\n            var endIndex = params.pageSize * (rangeMax + 1);\n\n            if (!this._debouncer || !this._debouncer.isActive()) {\n              serverFacade.requestData(startIndex, endIndex, params);\n            } else {\n              this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(200), () => serverFacade.requestData(startIndex, endIndex, params));\n            }\n          }\n        }\n      };\n\n      comboBox.$connector.filter = tryCatchWrapper(function (item, filter) {\n        filter = filter ? filter.toString().toLowerCase() : '';\n        return comboBox._getItemLabel(item).toString().toLowerCase().indexOf(filter) > -1;\n      });\n      comboBox.$connector.set = tryCatchWrapper(function (index, items, filter) {\n        if (filter != serverFacade.getLastFilterSentToServer()) {\n          return;\n        }\n\n        if (index % comboBox.pageSize != 0) {\n          throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + comboBox.pageSize;\n        }\n\n        if (index === 0 && items.length === 0 && pageCallbacks[0]) {\n          // Makes sure that the dataProvider callback is called even when server\n          // returns empty data set (no items match the filter).\n          cache[0] = [];\n          return;\n        }\n\n        var firstPageToSet = index / comboBox.pageSize;\n        var updatedPageCount = Math.ceil(items.length / comboBox.pageSize);\n\n        for (var i = 0; i < updatedPageCount; i++) {\n          var page = firstPageToSet + i;\n          var slice = items.slice(i * comboBox.pageSize, (i + 1) * comboBox.pageSize);\n          cache[page] = slice;\n        }\n      });\n      comboBox.$connector.updateData = tryCatchWrapper(function (items) {\n        // IE11 doesn't work with the transpiled version of the forEach.\n        for (var i = 0; i < items.length; i++) {\n          var item = items[i];\n\n          for (var j = 0; j < comboBox.filteredItems.length; j++) {\n            if (comboBox.filteredItems[j].key === item.key) {\n              comboBox.set('filteredItems.' + j, item);\n              break;\n            }\n          }\n        }\n      });\n      comboBox.$connector.updateSize = tryCatchWrapper(function (newSize) {\n        if (!comboBox._clientSideFilter) {\n          // FIXME: It may be that this size set is unnecessary, since when\n          // providing data to combobox via callback we may use data's size.\n          // However, if this size reflect the whole data size, including\n          // data not fetched yet into client side, and combobox expect it\n          // to be set as such, the at least, we don't need it in case the\n          // filter is clientSide only, since it'll increase the height of\n          // the popup at only at first user filter to this size, while the\n          // filtered items count are less.\n          comboBox.size = newSize;\n        }\n      });\n      comboBox.$connector.reset = tryCatchWrapper(function () {\n        clearPageCallbacks();\n        cache = {};\n        comboBox.clearCache();\n      });\n      comboBox.$connector.confirm = tryCatchWrapper(function (id, filter) {\n        if (filter != serverFacade.getLastFilterSentToServer()) {\n          return;\n        } // We're done applying changes from this batch, resolve pending\n        // callbacks\n\n\n        var activePages = Object.getOwnPropertyNames(pageCallbacks);\n\n        for (var i = 0; i < activePages.length; i++) {\n          var page = activePages[i];\n\n          if (cache[page]) {\n            commitPage(page, pageCallbacks[page]);\n          }\n        } // Let server know we're done\n\n\n        comboBox.$server.confirmUpdate(id);\n      });\n      customElements.whenDefined('vaadin-combo-box').then(tryCatchWrapper(() => {\n        var _isItemSelected = comboBox.$.overlay._isItemSelected; // Override comboBox's _isItemSelected logic to handle remapped items\n\n        comboBox.$.overlay._isItemSelected = (item, selectedItem, itemIdPath) => {\n          var selected = _isItemSelected.call(comboBox, item, selectedItem, itemIdPath);\n\n          if (comboBox._selectedKey) {\n            if (comboBox.filteredItems.indexOf(selectedItem) > -1) {\n              delete comboBox._selectedKey;\n            } else {\n              selected = selected || item.key === comboBox._selectedKey;\n            }\n          }\n\n          return selected;\n        };\n      }));\n      comboBox.$connector.enableClientValidation = tryCatchWrapper(function (enable) {\n        var input = null;\n\n        if (comboBox.$) {\n          input = comboBox.$[\"input\"];\n        }\n\n        if (input) {\n          if (enable) {\n            enableClientValidation(comboBox);\n            enableTextFieldClientValidation(input);\n          } else {\n            disableClientValidation(comboBox);\n            disableTextFieldClientValidation(input, comboBox);\n          }\n\n          comboBox.validate();\n        } else {\n          setTimeout(function () {\n            comboBox.$connector.enableClientValidation(enable);\n          }, 10);\n        }\n      });\n      var disableClientValidation = tryCatchWrapper(function (combo) {\n        if (typeof combo.$checkValidity == 'undefined') {\n          combo.$checkValidity = combo.checkValidity;\n\n          combo.checkValidity = function () {\n            return !comboBox.invalid;\n          };\n        }\n\n        if (typeof combo.$validate == 'undefined') {\n          combo.$validate = combo.validate;\n\n          combo.validate = function () {\n            return !(comboBox.focusElement.invalid = comboBox.invalid);\n          };\n        }\n      });\n      var disableTextFieldClientValidation = tryCatchWrapper(function (field, comboBox) {\n        if (typeof field.$checkValidity == 'undefined') {\n          field.$checkValidity = field.checkValidity;\n\n          field.checkValidity = function () {\n            return !comboBox.invalid;\n          };\n        }\n      });\n      var enableTextFieldClientValidation = tryCatchWrapper(function (field) {\n        if (field.$checkValidity) {\n          field.checkValidity = field.$checkValidity;\n          delete field.$checkValidity;\n        }\n      });\n      var enableClientValidation = tryCatchWrapper(function (combo) {\n        if (combo.$checkValidity) {\n          combo.checkValidity = combo.$checkValidity;\n          delete combo.$checkValidity;\n        }\n\n        if (combo.$validate) {\n          combo.validate = combo.$validate;\n          delete combo.$validate;\n        }\n      });\n      var commitPage = tryCatchWrapper(function (page, callback) {\n        var data = cache[page];\n\n        if (comboBox._clientSideFilter) {\n          performClientSideFilter(data, callback);\n        } else {\n          // Remove the data if server-side filtering, but keep it for client-side\n          // filtering\n          delete cache[page]; // FIXME: It may be that we ought to provide data.length instead of\n          // comboBox.size and remove updateSize function.\n\n          callback(data, comboBox.size);\n        }\n      }); // Perform filter on client side (here) using the items from specified page\n      // and submitting the filtered items to specified callback.\n      // The filter used is the one from combobox, not the lastFilter stored since\n      // that may not reflect user's input.\n\n      var performClientSideFilter = tryCatchWrapper(function (page, callback) {\n        var filteredItems = page;\n\n        if (comboBox.filter) {\n          filteredItems = page.filter(item => comboBox.$connector.filter(item, comboBox.filter));\n        }\n\n        callback(filteredItems, filteredItems.length);\n      }); // https://github.com/vaadin/vaadin-combo-box-flow/issues/232\n\n      comboBox.addEventListener('opened-changed', tryCatchWrapper(e => {\n        e.detail.value && (comboBox.$.overlay._selector._manageFocus = () => {});\n      })); // Prevent setting the custom value as the 'value'-prop automatically\n\n      comboBox.addEventListener('custom-value-set', tryCatchWrapper(e => e.preventDefault()));\n    })(comboBox)\n  };\n})();"
    },
    {
     "id": 293,
     "name": "../node_modules/@vaadin/flow-frontend/contextMenuConnector.js?babel-target=es6",
     "source": "// Not using ES6 imports in this file yet because the connector in V14 must\n// still work in Legacy bower projects. See: `contextMenuConnector-es6.js` for\n// the Polymer3 approach.\n(function () {\n  var tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Context Menu', 'vaadin-context-menu-flow');\n  };\n\n  window.Vaadin.Flow.Legacy = window.Vaadin.Flow.Legacy || {};\n  window.Vaadin.Flow.contextMenuConnector = {\n    // NOTE: This is for the TARGET component, not for the <vaadin-context-menu> itself\n    init: target => tryCatchWrapper(function (target) {\n      if (target.$contextMenuConnector) {\n        return;\n      }\n\n      if (window.Polymer) {\n        // Polymer2 approach.\n        window.Vaadin.Flow.Legacy.GestureEventListeners = window.Vaadin.Flow.Legacy.GestureEventListeners || Polymer.GestureEventListeners;\n        window.Vaadin.Flow.Legacy.Gestures = window.Vaadin.Flow.Legacy.Gestures || Polymer.Gestures;\n      } else if (!window.Vaadin.Flow.Legacy.Gestures) {\n        console.log(\"ContextMenu is unable to load Polymer helpers.\");\n        return;\n      }\n\n      var GestureEventListeners = window.Vaadin.Flow.Legacy.GestureEventListeners;\n      var Gestures = window.Vaadin.Flow.Legacy.Gestures;\n      target.$contextMenuConnector = {\n        openOnHandler: tryCatchWrapper(function (e) {\n          e.preventDefault();\n          e.stopPropagation();\n          this.$contextMenuConnector.openEvent = e;\n          var detail = {};\n\n          if (target.getContextMenuBeforeOpenDetail) {\n            detail = target.getContextMenuBeforeOpenDetail(e);\n          }\n\n          target.dispatchEvent(new CustomEvent('vaadin-context-menu-before-open', {\n            detail: detail\n          }));\n        }),\n        updateOpenOn: tryCatchWrapper(function (eventType) {\n          this.removeListener();\n          this.openOnEventType = eventType;\n          customElements.whenDefined('vaadin-context-menu').then(tryCatchWrapper(() => {\n            if (Gestures.gestures[eventType]) {\n              Gestures.addListener(target, eventType, this.openOnHandler);\n            } else {\n              target.addEventListener(eventType, this.openOnHandler);\n            }\n          }));\n        }),\n        removeListener: tryCatchWrapper(function () {\n          if (this.openOnEventType) {\n            if (Gestures.gestures[this.openOnEventType]) {\n              Gestures.removeListener(target, this.openOnEventType, this.openOnHandler);\n            } else {\n              target.removeEventListener(this.openOnEventType, this.openOnHandler);\n            }\n          }\n        }),\n        openMenu: tryCatchWrapper(function (contextMenu) {\n          contextMenu.open(this.openEvent);\n        }),\n        removeConnector: tryCatchWrapper(function () {\n          this.removeListener();\n          target.$contextMenuConnector = undefined;\n        })\n      };\n    })(target),\n    generateItems: (menu, appId, nodeId) => tryCatchWrapper(function (menu, appId, nodeId) {\n      menu._containerNodeId = nodeId;\n\n      var getContainer = function (nodeId) {\n        try {\n          return window.Vaadin.Flow.clients[appId].getByNodeId(nodeId);\n        } catch (error) {\n          console.error(\"Could not get node %s from app %s\", nodeId, appId);\n          console.error(error);\n        }\n      };\n\n      var getChildItems = function (parent) {\n        var container = getContainer(parent._containerNodeId);\n        var items = container && Array.from(container.children).map(child => {\n          var item = {\n            component: child,\n            checked: child._checked\n          };\n\n          if (child.tagName == \"VAADIN-CONTEXT-MENU-ITEM\" && child._containerNodeId) {\n            item.children = getChildItems(child);\n          }\n\n          child._item = item;\n          return item;\n        });\n        return items;\n      };\n\n      var items = getChildItems(menu);\n      menu.items = items;\n    })(menu, appId, nodeId),\n    setChecked: (component, checked) => tryCatchWrapper(function (component, checked) {\n      if (component._item) {\n        component._item.checked = checked;\n      }\n    })(component, checked)\n  };\n})();"
    },
    {
     "id": 294,
     "name": "../node_modules/@vaadin/flow-frontend/dndConnector.js?babel-target=es6",
     "source": "window.Vaadin = window.Vaadin || {};\nwindow.Vaadin.Flow = window.Vaadin.Flow || {};\nwindow.Vaadin.Flow.dndConnector = {\n  __ondragenterListener: function (event) {\n    // TODO filter by data type\n    // TODO prevent dropping on itself (by default)\n    var effect = event.currentTarget['__dropEffect'];\n\n    if (!event.currentTarget.hasAttribute('disabled')) {\n      if (effect) {\n        event.dataTransfer.dropEffect = effect;\n      }\n\n      if (effect && effect !== 'none') {\n        /* #7108: if drag moves on top of drop target's children, first another ondragenter event\n         * is fired and then a ondragleave event. This happens again once the drag\n         * moves on top of another children, or back on top of the drop target element.\n         * Thus need to \"cancel\" the following ondragleave, to not remove class name.\n         * Drop event will happen even when dropped to a child element. */\n        if (event.currentTarget.classList.contains(\"v-drag-over-target\")) {\n          event.currentTarget['__skip-leave'] = true;\n        } else {\n          event.currentTarget.classList.add(\"v-drag-over-target\");\n        } // enables browser specific pseudo classes (at least FF)\n\n\n        event.preventDefault();\n        event.stopPropagation(); // don't let parents know\n      }\n    }\n  },\n  __ondragoverListener: function (event) {\n    // TODO filter by data type\n    // TODO filter by effectAllowed != dropEffect due to Safari & IE11 ?\n    if (!event.currentTarget.hasAttribute('disabled')) {\n      var effect = event.currentTarget['__dropEffect'];\n\n      if (effect) {\n        event.dataTransfer.dropEffect = effect;\n      } // allows the drop && don't let parents know\n\n\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  },\n  __ondragleaveListener: function (event) {\n    if (event.currentTarget['__skip-leave']) {\n      event.currentTarget['__skip-leave'] = false;\n    } else {\n      event.currentTarget.classList.remove(\"v-drag-over-target\");\n    } // #7109 need to stop or any parent drop target might not get highlighted,\n    // as ondragenter for it is fired before the child gets dragleave.\n\n\n    event.stopPropagation();\n  },\n  __ondropListener: function (event) {\n    var effect = event.currentTarget['__dropEffect'];\n\n    if (effect) {\n      event.dataTransfer.dropEffect = effect;\n    }\n\n    event.currentTarget.classList.remove(\"v-drag-over-target\"); // prevent browser handling && don't let parents know\n\n    event.preventDefault();\n    event.stopPropagation();\n  },\n  updateDropTarget: function (element) {\n    if (element['__active']) {\n      element.addEventListener('dragenter', this.__ondragenterListener, false);\n      element.addEventListener('dragover', this.__ondragoverListener, false);\n      element.addEventListener('dragleave', this.__ondragleaveListener, false);\n      element.addEventListener('drop', this.__ondropListener, false);\n    } else {\n      element.removeEventListener('dragenter', this.__ondragenterListener, false);\n      element.removeEventListener('dragover', this.__ondragoverListener, false);\n      element.removeEventListener('dragleave', this.__ondragleaveListener, false);\n      element.removeEventListener('drop', this.__ondropListener, false);\n      element.classList.remove(\"v-drag-over-target\");\n    }\n  },\n\n  /** DRAG SOURCE METHODS: */\n  __dragstartListener: function (event) {\n    event.stopPropagation();\n    event.dataTransfer.setData(\"text/plain\", \"\");\n\n    if (event.currentTarget.hasAttribute('disabled')) {\n      event.preventDefault();\n    } else {\n      if (event.currentTarget['__effectAllowed']) {\n        event.dataTransfer.effectAllowed = event.currentTarget['__effectAllowed'];\n      }\n\n      event.currentTarget.classList.add('v-dragged');\n    }\n  },\n  __dragendListener: function (event) {\n    event.currentTarget.classList.remove('v-dragged');\n  },\n  updateDragSource: function (element) {\n    if (element['draggable']) {\n      element.addEventListener('dragstart', this.__dragstartListener, false);\n      element.addEventListener('dragend', this.__dragendListener, false);\n    } else {\n      element.removeEventListener('dragstart', this.__dragstartListener, false);\n      element.removeEventListener('dragend', this.__dragendListener, false);\n    }\n  }\n};"
    },
    {
     "id": 295,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-active-item-mixin.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/**\n * @polymerMixin\n */\nexport var ActiveItemMixin = superClass => class ActiveItemMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * The item user has last interacted with. Turns to `null` after user deactivates\n       * the item by re-interacting with the currently active item.\n       * @type {GridItem}\n       */\n      activeItem: {\n        type: Object,\n        notify: true,\n        value: null\n      }\n    };\n  }\n\n  ready() {\n    super.ready();\n    this.$.scroller.addEventListener('click', this._onClick.bind(this));\n    this.addEventListener('cell-activate', this._activateItem.bind(this));\n  }\n  /** @private */\n\n\n  _activateItem(e) {\n    var model = e.detail.model;\n    var clickedItem = model ? model.item : null;\n\n    if (clickedItem) {\n      this.activeItem = !this._itemsEqual(this.activeItem, clickedItem) ? clickedItem : null;\n    }\n  }\n  /**\n   * We need to listen to click instead of tap because on mobile safari, the\n   * document.activeElement has not been updated (focus has not been shifted)\n   * yet at the point when tap event is being executed.\n   * @param {!MouseEvent} e\n   * @protected\n   */\n\n\n  _onClick(e) {\n    if (e.defaultPrevented) {\n      // Something has handled this click already, e. g., <vaadin-grid-sorter>\n      return;\n    }\n\n    var path = e.composedPath();\n    var cell = path[path.indexOf(this.$.table) - 3];\n\n    if (!cell || cell.getAttribute('part').indexOf('details-cell') > -1) {\n      return;\n    }\n\n    var cellContent = cell._content;\n    var activeElement = this.getRootNode().activeElement;\n\n    var cellContentHasFocus = cellContent.contains(activeElement) && ( // MSIE bug: flex children receive focus. Make type & attributes check.\n    !this._ie || this._isFocusable(activeElement));\n\n    if (!cellContentHasFocus && !this._isFocusable(e.target)) {\n      this.dispatchEvent(new CustomEvent('cell-activate', {\n        detail: {\n          model: this.__getRowModel(cell.parentElement)\n        }\n      }));\n    }\n  }\n  /**\n   * @param {!Element} target\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _isFocusable(target) {\n    return isFocusable(target);\n  }\n\n};\n/**\n * @param {!Element} target\n * @return {boolean}\n * @protected\n */\n\nexport var isFocusable = target => {\n  if (!target.parentNode) {\n    return false;\n  }\n\n  var focusables = Array.from(target.parentNode.querySelectorAll('[tabindex], button, input, select, textarea, object, iframe, label, a[href], area[href]')).filter(element => element.getAttribute('part') !== 'cell body-cell');\n  var isFocusableElement = focusables.indexOf(target) !== -1;\n  return !target.disabled && isFocusableElement;\n};"
    },
    {
     "id": 296,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-data-provider-mixin.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nexport var ItemCache = class ItemCache {\n  /**\n   * @param {!HTMLElement} grid\n   * @param {!ItemCache | undefined} parentCache\n   * @param {!GridItem | undefined} parentItem\n   */\n  constructor(grid, parentCache, parentItem) {\n    /** @type {!HTMLElement} */\n    this.grid = grid;\n    /** @type {!ItemCache | undefined} */\n\n    this.parentCache = parentCache;\n    /** @type {!GridItem | undefined} */\n\n    this.parentItem = parentItem;\n    /** @type {object} */\n\n    this.itemCaches = {};\n    /** @type {object} */\n\n    this.items = {};\n    /** @type {number} */\n\n    this.effectiveSize = 0;\n    /** @type {number} */\n\n    this.size = 0;\n    /** @type {object} */\n\n    this.pendingRequests = {};\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  isLoading() {\n    return Boolean(Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(index => {\n      return this.itemCaches[index].isLoading();\n    })[0]);\n  }\n  /**\n   * @param {number} index\n   * @return {!GridItem | undefined}\n   */\n\n\n  getItemForIndex(index) {\n    var {\n      cache,\n      scaledIndex\n    } = this.getCacheAndIndex(index);\n    return cache.items[scaledIndex];\n  }\n\n  updateSize() {\n    this.effectiveSize = !this.parentItem || this.grid._isExpanded(this.parentItem) ? this.size + Object.keys(this.itemCaches).reduce((prev, curr) => {\n      var subCache = this.itemCaches[curr];\n      subCache.updateSize();\n      return prev + subCache.effectiveSize;\n    }, 0) : 0;\n  }\n  /**\n   * @param {number} scaledIndex\n   */\n\n\n  ensureSubCacheForScaledIndex(scaledIndex) {\n    if (!this.itemCaches[scaledIndex]) {\n      var subCache = new ItemCache(this.grid, this, this.items[scaledIndex]);\n      this.itemCaches[scaledIndex] = subCache;\n\n      this.grid._loadPage(0, subCache);\n    }\n  }\n  /**\n   * @param {number} index\n   * @return {{cache: !ItemCache, scaledIndex: number}}\n   */\n\n\n  getCacheAndIndex(index) {\n    var thisLevelIndex = index;\n    var keys = Object.keys(this.itemCaches);\n\n    for (var i = 0; i < keys.length; i++) {\n      var expandedIndex = Number(keys[i]);\n      var subCache = this.itemCaches[expandedIndex];\n\n      if (thisLevelIndex <= expandedIndex) {\n        return {\n          cache: this,\n          scaledIndex: thisLevelIndex\n        };\n      } else if (thisLevelIndex <= expandedIndex + subCache.effectiveSize) {\n        return subCache.getCacheAndIndex(thisLevelIndex - expandedIndex - 1);\n      }\n\n      thisLevelIndex -= subCache.effectiveSize;\n    }\n\n    return {\n      cache: this,\n      scaledIndex: thisLevelIndex\n    };\n  }\n\n};\n/**\n * @polymerMixin\n */\n\nexport var DataProviderMixin = superClass => class DataProviderMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Number of items fetched at a time from the dataprovider.\n       * @attr {number} page-size\n       * @type {number}\n       */\n      pageSize: {\n        type: Number,\n        value: 50,\n        observer: '_pageSizeChanged'\n      },\n\n      /**\n       * Function that provides items lazily. Receives arguments `params`, `callback`\n       *\n       * `params.page` Requested page index\n       *\n       * `params.pageSize` Current page size\n       *\n       * `params.filters` Currently applied filters\n       *\n       * `params.sortOrders` Currently applied sorting orders\n       *\n       * `params.parentItem` When tree is used, and sublevel items\n       * are requested, reference to parent item of the requested sublevel.\n       * Otherwise `undefined`.\n       *\n       * `callback(items, size)` Callback function with arguments:\n       *   - `items` Current page of items\n       *   - `size` Total number of items. When tree sublevel items\n       *     are requested, total number of items in the requested sublevel.\n       *     Optional when tree is not used, required for tree.\n       *\n       * @type {GridDataProvider | null | undefined}\n       */\n      dataProvider: {\n        type: Object,\n        notify: true,\n        observer: '_dataProviderChanged'\n      },\n\n      /**\n       * `true` while data is being requested from the data provider.\n       */\n      loading: {\n        type: Boolean,\n        notify: true,\n        readOnly: true,\n        reflectToAttribute: true\n      },\n\n      /**\n       * @type {!ItemCache}\n       * @protected\n       */\n      _cache: {\n        type: Object,\n        value: function () {\n          var cache = new ItemCache(this);\n          return cache;\n        }\n      },\n\n      /**\n       * Path to an item sub-property that identifies the item.\n       * @attr {string} item-id-path\n       */\n      itemIdPath: {\n        type: String,\n        value: null\n      },\n\n      /**\n       * An array that contains the expanded items.\n       * @type {!Array<!GridItem>}\n       */\n      expandedItems: {\n        type: Object,\n        notify: true,\n        value: () => []\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_sizeChanged(size)', '_itemIdPathChanged(itemIdPath)', '_expandedItemsChanged(expandedItems.*)'];\n  }\n  /** @private */\n\n\n  _sizeChanged(size) {\n    var delta = size - this._cache.size;\n    this._cache.size += delta;\n    this._cache.effectiveSize += delta;\n    this._effectiveSize = this._cache.effectiveSize;\n\n    this._increasePoolIfNeeded(0);\n\n    this._debounceIncreasePool && this._debounceIncreasePool.flush();\n  }\n  /**\n   * @param {number} index\n   * @param {HTMLElement} el\n   * @protected\n   */\n\n\n  _getItem(index, el) {\n    if (index >= this._effectiveSize) {\n      return;\n    }\n\n    el.index = index;\n\n    var {\n      cache,\n      scaledIndex\n    } = this._cache.getCacheAndIndex(index);\n\n    var item = cache.items[scaledIndex];\n\n    if (item) {\n      this._toggleAttribute('loading', false, el);\n\n      this._updateItem(el, item);\n\n      if (this._isExpanded(item)) {\n        cache.ensureSubCacheForScaledIndex(scaledIndex);\n      }\n    } else {\n      this._toggleAttribute('loading', true, el);\n\n      this._loadPage(this._getPageForIndex(scaledIndex), cache);\n    }\n  }\n  /** @private */\n\n\n  _expandedInstanceChangedCallback(inst, value) {\n    if (inst.item === undefined) {\n      return;\n    }\n\n    if (value) {\n      this.expandItem(inst.item);\n    } else {\n      this.collapseItem(inst.item);\n    }\n  }\n  /**\n   * Returns a value that identifies the item. Uses `itemIdPath` if available.\n   * Can be customized by overriding.\n   * @param {!GridItem} item\n   * @return {!GridItem | !unknown}\n   */\n\n\n  getItemId(item) {\n    return this.itemIdPath ? this.get(this.itemIdPath, item) : item;\n  }\n  /**\n   * @param {!GridItem} item\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _isExpanded(item) {\n    return this.__expandedKeys.has(this.getItemId(item));\n  }\n  /** @private */\n\n\n  _expandedItemsChanged(e) {\n    this.__cacheExpandedKeys();\n\n    this._cache.updateSize();\n\n    this._effectiveSize = this._cache.effectiveSize;\n\n    this._assignModels();\n  }\n  /** @private */\n\n\n  _itemIdPathChanged(e) {\n    this.__cacheExpandedKeys();\n  }\n  /** @private */\n\n\n  __cacheExpandedKeys() {\n    if (this.expandedItems) {\n      this.__expandedKeys = new Set();\n      this.expandedItems.forEach(item => {\n        this.__expandedKeys.add(this.getItemId(item));\n      });\n    }\n  }\n  /**\n   * Expands the given item tree.\n   * @param {!GridItem} item\n   */\n\n\n  expandItem(item) {\n    if (!this._isExpanded(item)) {\n      this.push('expandedItems', item);\n    }\n  }\n  /**\n   * Collapses the given item tree.\n   * @param {!GridItem} item\n   */\n\n\n  collapseItem(item) {\n    if (this._isExpanded(item)) {\n      this.splice('expandedItems', this._getItemIndexInArray(item, this.expandedItems), 1);\n    }\n  }\n  /**\n   * @param {number} index\n   * @return {number}\n   * @protected\n   */\n\n\n  _getIndexLevel(index) {\n    var {\n      cache\n    } = this._cache.getCacheAndIndex(index);\n\n    var level = 0;\n\n    while (cache.parentCache) {\n      cache = cache.parentCache;\n      level++;\n    }\n\n    return level;\n  }\n  /**\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _canPopulate() {\n    return Boolean(this._hasData && this._columnTree);\n  }\n  /**\n   * @param {number} page\n   * @param {ItemCache} cache\n   * @protected\n   */\n\n\n  _loadPage(page, cache) {\n    // make sure same page isn't requested multiple times.\n    if (!cache.pendingRequests[page] && this.dataProvider) {\n      this._setLoading(true);\n\n      cache.pendingRequests[page] = true;\n      var params = {\n        page,\n        pageSize: this.pageSize,\n        sortOrders: this._mapSorters(),\n        filters: this._mapFilters(),\n        parentItem: cache.parentItem\n      };\n      this.dataProvider(params, (items, size) => {\n        if (size !== undefined) {\n          cache.size = size;\n        } else {\n          if (params.parentItem) {\n            cache.size = items.length;\n          }\n        }\n\n        var currentItems = Array.from(this.$.items.children).map(row => row._item); // Populate the cache with new items\n\n        items.forEach((item, itemsIndex) => {\n          var itemIndex = page * this.pageSize + itemsIndex;\n          cache.items[itemIndex] = item;\n\n          if (this._isExpanded(item) && currentItems.indexOf(item) > -1) {\n            // Force synchronous data request for expanded item sub-cache\n            cache.ensureSubCacheForScaledIndex(itemIndex);\n          }\n        });\n        this._hasData = true;\n        delete cache.pendingRequests[page];\n        this._debouncerApplyCachedData = Debouncer.debounce(this._debouncerApplyCachedData, timeOut.after(0), () => {\n          this._setLoading(false);\n\n          this._cache.updateSize();\n\n          this._effectiveSize = this._cache.effectiveSize;\n          Array.from(this.$.items.children).filter(row => !row.hidden).forEach(row => {\n            var cachedItem = this._cache.getItemForIndex(row.index);\n\n            if (cachedItem) {\n              this._getItem(row.index, row);\n            }\n          });\n\n          this._increasePoolIfNeeded(0);\n\n          this.__scrollToPendingIndex();\n        });\n\n        if (!this._cache.isLoading()) {\n          this._debouncerApplyCachedData.flush();\n        }\n\n        this.__itemsReceived();\n      });\n    }\n  }\n  /**\n   * @param {number} index\n   * @return {number}\n   * @private\n   */\n\n\n  _getPageForIndex(index) {\n    return Math.floor(index / this.pageSize);\n  }\n  /**\n   * Clears the cached pages and reloads data from dataprovider when needed.\n   */\n\n\n  clearCache() {\n    this._cache = new ItemCache(this);\n    Array.from(this.$.items.children).forEach(row => {\n      Array.from(row.children).forEach(cell => {\n        // Force data system to pick up subproperty changes\n        cell._instance && cell._instance._setPendingProperty('item', {}, false);\n      });\n    });\n    this._cache.size = this.size || 0;\n\n    this._cache.updateSize();\n\n    this._hasData = false;\n\n    this._assignModels();\n\n    if (!this._effectiveSize) {\n      this._loadPage(0, this._cache);\n    }\n  }\n  /** @private */\n\n\n  _pageSizeChanged(pageSize, oldPageSize) {\n    if (oldPageSize !== undefined && pageSize !== oldPageSize) {\n      this.clearCache();\n    }\n  }\n  /** @protected */\n\n\n  _checkSize() {\n    if (this.size === undefined && this._effectiveSize === 0) {\n      console.warn('The <vaadin-grid> needs the total number of items' + ' in order to display rows. Set the total number of items' + ' to the `size` property, or provide the total number of items' + ' in the second argument of the `dataProvider`s `callback` call.');\n    }\n  }\n  /** @private */\n\n\n  _dataProviderChanged(dataProvider, oldDataProvider) {\n    if (oldDataProvider !== undefined) {\n      this.clearCache();\n    }\n\n    if (dataProvider && this.items && this.items.length) {\n      // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>\n      this._scrollToIndex(this._firstVisibleIndex);\n    }\n\n    this._ensureFirstPageLoaded();\n\n    this._debouncerCheckSize = Debouncer.debounce(this._debouncerCheckSize, timeOut.after(2000), this._checkSize.bind(this));\n\n    this._scrollHandler();\n  }\n  /** @protected */\n\n\n  _ensureFirstPageLoaded() {\n    if (!this._hasData) {\n      // load data before adding rows to make sure they have content when\n      // rendered for the first time.\n      this._loadPage(0, this._cache);\n    }\n  }\n  /**\n   * @param {!GridItem} item1\n   * @param {!GridItem} item2\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _itemsEqual(item1, item2) {\n    return this.getItemId(item1) === this.getItemId(item2);\n  }\n  /**\n   * @param {!GridItem} item\n   * @param {!Array<!GridItem>} array\n   * @return {number}\n   * @protected\n   */\n\n\n  _getItemIndexInArray(item, array) {\n    var result = -1;\n    array.forEach((i, idx) => {\n      if (this._itemsEqual(i, item)) {\n        result = idx;\n      }\n    });\n    return result;\n  }\n\n  scrollToIndex(index) {\n    super.scrollToIndex(index);\n\n    if (!isNaN(index) && (this._cache.isLoading() || !this.clientHeight)) {\n      this.__pendingScrollToIndex = index;\n    }\n  }\n\n  __scrollToPendingIndex() {\n    if (this.__pendingScrollToIndex && this.$.items.children.length) {\n      var index = this.__pendingScrollToIndex;\n      delete this.__pendingScrollToIndex;\n      this.scrollToIndex(index);\n    }\n  }\n\n};"
    },
    {
     "id": 297,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-templatizer.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { templatize } from '@polymer/polymer/lib/utils/templatize.js';\n/**\n * `vaadin-grid-templatizer` is a helper element for the `vaadin-grid` that is preparing and\n * stamping instances of cells and columns templates\n *\n * @extends PolymerElement\n * @private\n */\n\nclass GridTemplatizer extends class extends PolymerElement {} {\n  static get is() {\n    return 'vaadin-grid-templatizer';\n  }\n\n  static get properties() {\n    return {\n      dataHost: Object,\n      template: Object,\n      _templateInstances: {\n        type: Array,\n        value: function () {\n          return [];\n        }\n      },\n      _parentPathValues: {\n        value: function () {\n          return {};\n        }\n      },\n      _grid: Object\n    };\n  }\n\n  static get observers() {\n    return ['_templateInstancesChanged(_templateInstances.*, _parentPathValues.*)'];\n  }\n\n  constructor() {\n    super();\n    this._instanceProps = {\n      detailsOpened: true,\n      index: true,\n      item: true,\n      selected: true,\n      expanded: true,\n      level: true\n    };\n  }\n\n  createInstance() {\n    this._ensureTemplatized();\n\n    var instance = new this._TemplateClass({});\n    this.addInstance(instance);\n    return instance;\n  }\n\n  addInstance(instance) {\n    if (this._templateInstances.indexOf(instance) === -1) {\n      this._templateInstances.push(instance);\n\n      requestAnimationFrame(() => this.notifyPath('_templateInstances.*', this._templateInstances));\n    }\n  }\n\n  removeInstance(instance) {\n    var index = this._templateInstances.indexOf(instance);\n\n    this.splice('_templateInstances', index, 1);\n  }\n\n  _ensureTemplatized() {\n    if (!this._TemplateClass) {\n      this._TemplateClass = templatize(this.template, this, {\n        instanceProps: this._instanceProps,\n        parentModel: true,\n        forwardHostProp: function (prop, value) {\n          this._forwardParentProp(prop, value);\n\n          if (this._templateInstances) {\n            this._templateInstances.forEach(inst => inst.notifyPath(prop, value));\n          }\n        },\n        notifyInstanceProp: function (inst, prop, value) {\n          if (prop === 'index' || prop === 'item') {\n            // We dont need a change notification for these.\n            return;\n          }\n\n          var originalProp = `__${prop}__`; // Notify for only user-action changes, not for scrolling updates. E. g.,\n          // if `detailsOpened` is different from `__detailsOpened__`, which was set during render.\n\n          if (inst[originalProp] === value) {\n            return;\n          }\n\n          inst[originalProp] = value;\n          var row = Array.from(this._grid.$.items.children).filter(row => this._grid._itemsEqual(row._item, inst.item))[0];\n\n          if (row) {\n            Array.from(row.children).forEach(cell => {\n              if (cell._instance) {\n                cell._instance[originalProp] = value;\n\n                cell._instance.notifyPath(prop, value);\n              }\n            });\n          }\n\n          var itemPrefix = 'item.';\n\n          if (Array.isArray(this._grid.items) && prop.indexOf(itemPrefix) === 0) {\n            var itemsIndex = this._grid.items.indexOf(inst.item);\n\n            var path = prop.slice(itemPrefix.length);\n\n            this._grid.notifyPath(`items.${itemsIndex}.${path}`, value);\n          }\n\n          var gridCallback = `_${prop}InstanceChangedCallback`;\n\n          if (this._grid && this._grid[gridCallback]) {\n            this._grid[gridCallback](inst, value);\n          }\n        }\n      });\n    }\n  }\n\n  _forwardParentProp(prop, value) {\n    this._parentPathValues[prop] = value;\n\n    this._templateInstances.forEach(inst => inst.notifyPath(prop, value));\n  }\n\n  _templateInstancesChanged(t, p) {\n    var index, count;\n\n    if (t.path === '_templateInstances') {\n      // Iterate all instances\n      index = 0;\n      count = this._templateInstances.length;\n    } else if (t.path === '_templateInstances.splices') {\n      // Iterate only new instances\n      index = t.value.index;\n      count = t.value.addedCount;\n    } else {\n      return;\n    }\n\n    Object.keys(this._parentPathValues || {}).forEach(keyName => {\n      for (var i = index; i < index + count; i++) {\n        this._templateInstances[i].set(keyName, this._parentPathValues[keyName]);\n      }\n    });\n  }\n\n}\n\ncustomElements.define(GridTemplatizer.is, GridTemplatizer);\nexport { GridTemplatizer as Templatizer };"
    },
    {
     "id": 298,
     "name": "../node_modules/@vaadin/flow-frontend/gridConnector.js?babel-target=es6",
     "source": "// Not using ES6 imports in this file yet because the connector in V14 must\n// still work in Legacy bower projects. See: `gridConnector-es6.js` for\n// the Polymer3 approach.\n(function () {\n  var tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Grid', 'vaadin-grid-flow');\n  };\n\n  window.Vaadin.Flow.Legacy = window.Vaadin.Flow.Legacy || {};\n  var isItemCacheInitialized = false;\n  window.Vaadin.Flow.gridConnector = {\n    initLazy: grid => tryCatchWrapper(function (grid) {\n      // Check whether the connector was already initialized for the grid\n      if (grid.$connector) {\n        return;\n      } // Polymer\n\n\n      if (window.Polymer) {\n        // Polymer2 approach.\n        window.Vaadin.Flow.Legacy.Debouncer = Polymer.Debouncer;\n        window.Vaadin.Flow.Legacy.timeOut = Polymer.Async.timeOut;\n        window.Vaadin.Flow.Legacy.animationFrame = Polymer.Async.animationFrame;\n        window.Vaadin.Flow.Legacy.GridElement = Vaadin.GridElement;\n        window.Vaadin.Flow.Legacy.ItemCache = Vaadin.Grid.ItemCache;\n      } else if (!window.Vaadin.Flow.Legacy.Debouncer) {\n        console.log(\"Grid is unable to load Polymer helpers.\");\n        return;\n      }\n\n      var Debouncer = window.Vaadin.Flow.Legacy.Debouncer;\n      var timeOut = window.Vaadin.Flow.Legacy.timeOut;\n      var animationFrame = window.Vaadin.Flow.Legacy.animationFrame;\n      var GridElement = window.Vaadin.Flow.Legacy.GridElement;\n      var ItemCache = window.Vaadin.Flow.Legacy.ItemCache; // Make sure ItemCache patching is done only once, but delay it for when\n      // a server grid is initialized\n\n      if (!isItemCacheInitialized) {\n        isItemCacheInitialized = true; // Storing original implementation of the method to be used for client\n        // side only grids\n\n        ItemCache.prototype.ensureSubCacheForScaledIndexOriginal = ItemCache.prototype.ensureSubCacheForScaledIndex;\n        ItemCache.prototype.ensureSubCacheForScaledIndex = tryCatchWrapper(function (scaledIndex) {\n          if (!this.grid.$connector) {\n            this.ensureSubCacheForScaledIndexOriginal(scaledIndex);\n            return;\n          }\n\n          if (!this.itemCaches[scaledIndex]) {\n            this.grid.$connector.beforeEnsureSubCacheForScaledIndex(this, scaledIndex);\n          }\n        });\n        ItemCache.prototype.isLoading = tryCatchWrapper(function () {\n          return Boolean(ensureSubCacheQueue.length || Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(index => {\n            return this.itemCaches[index].isLoading();\n          })[0]);\n        });\n        ItemCache.prototype.doEnsureSubCacheForScaledIndex = tryCatchWrapper(function (scaledIndex) {\n          if (!this.itemCaches[scaledIndex]) {\n            var subCache = new ItemCache.prototype.constructor(this.grid, this, this.items[scaledIndex]);\n            subCache.itemkeyCaches = {};\n\n            if (!this.itemkeyCaches) {\n              this.itemkeyCaches = {};\n            }\n\n            this.itemCaches[scaledIndex] = subCache;\n            this.itemkeyCaches[this.grid.getItemId(subCache.parentItem)] = subCache;\n\n            this.grid._loadPage(0, subCache);\n          }\n        });\n        ItemCache.prototype.getCacheAndIndexByKey = tryCatchWrapper(function (key) {\n          for (var index in this.items) {\n            if (this.grid.getItemId(this.items[index]) === key) {\n              return {\n                cache: this,\n                scaledIndex: index\n              };\n            }\n          }\n\n          var keys = Object.keys(this.itemkeyCaches);\n\n          for (var i = 0; i < keys.length; i++) {\n            var expandedKey = keys[i];\n            var subCache = this.itemkeyCaches[expandedKey];\n            var cacheAndIndex = subCache.getCacheAndIndexByKey(key);\n\n            if (cacheAndIndex) {\n              return cacheAndIndex;\n            }\n          }\n\n          return undefined;\n        });\n        ItemCache.prototype.getLevel = tryCatchWrapper(function () {\n          var cache = this;\n          var level = 0;\n\n          while (cache.parentCache) {\n            cache = cache.parentCache;\n            level++;\n          }\n\n          return level;\n        });\n      }\n\n      var rootPageCallbacks = {};\n      var treePageCallbacks = {};\n      var cache = {};\n      /* parentRequestDelay - optimizes parent requests by batching several requests\n      *  into one request. Delay in milliseconds. Disable by setting to 0.\n      *  parentRequestBatchMaxSize - maximum size of the batch.\n      */\n\n      var parentRequestDelay = 50;\n      var parentRequestBatchMaxSize = 20;\n      var parentRequestQueue = [];\n      var parentRequestDebouncer;\n      var ensureSubCacheQueue = [];\n      var ensureSubCacheDebouncer;\n      var rootRequestDelay = 150;\n      var rootRequestDebouncer;\n      var lastRequestedRanges = {};\n      var root = 'null';\n      lastRequestedRanges[root] = [0, 0];\n      var validSelectionModes = ['SINGLE', 'NONE', 'MULTI'];\n      var selectedKeys = {};\n      var selectionMode = 'SINGLE';\n      var detailsVisibleOnClick = true;\n      var sorterDirectionsSetFromServer = false;\n      grid.size = 0; // To avoid NaN here and there before we get proper data\n\n      grid.itemIdPath = 'key';\n      grid.$connector = {};\n      grid.$connector.hasEnsureSubCacheQueue = tryCatchWrapper(() => ensureSubCacheQueue.length > 0);\n      grid.$connector.hasParentRequestQueue = tryCatchWrapper(() => parentRequestQueue.length > 0);\n      grid.$connector.hasRootRequestQueue = tryCatchWrapper(() => {\n        return Object.keys(rootPageCallbacks).length > 0 || rootRequestDebouncer && rootRequestDebouncer.isActive();\n      });\n      grid.$connector.beforeEnsureSubCacheForScaledIndex = tryCatchWrapper(function (targetCache, scaledIndex) {\n        // add call to queue\n        ensureSubCacheQueue.push({\n          cache: targetCache,\n          scaledIndex: scaledIndex,\n          itemkey: grid.getItemId(targetCache.items[scaledIndex]),\n          level: targetCache.getLevel()\n        }); // sort by ascending scaledIndex and level\n\n        ensureSubCacheQueue.sort(function (a, b) {\n          return a.scaledIndex - b.scaledIndex || a.level - b.level;\n        });\n        ensureSubCacheDebouncer = Debouncer.debounce(ensureSubCacheDebouncer, animationFrame, () => {\n          while (ensureSubCacheQueue.length) {\n            grid.$connector.flushEnsureSubCache();\n          }\n        });\n      });\n      grid.$connector.doSelection = tryCatchWrapper(function (items, userOriginated) {\n        if (selectionMode === 'NONE' || !items.length || userOriginated && grid.hasAttribute('disabled')) {\n          return;\n        }\n\n        if (selectionMode === 'SINGLE') {\n          grid.selectedItems = [];\n          selectedKeys = {};\n        }\n\n        grid.selectedItems = grid.selectedItems.concat(items);\n        items.forEach(item => {\n          if (item) {\n            selectedKeys[item.key] = item;\n\n            if (userOriginated) {\n              item.selected = true;\n              grid.$server.select(item.key);\n            }\n          }\n\n          var isSelectedItemDifferentOrNull = !grid.activeItem || !item || item.key != grid.activeItem.key;\n\n          if (!userOriginated && selectionMode === 'SINGLE' && isSelectedItemDifferentOrNull) {\n            grid.activeItem = item;\n            grid.$connector.activeItem = item;\n          }\n        });\n      });\n      grid.$connector.doDeselection = tryCatchWrapper(function (items, userOriginated) {\n        if (selectionMode === 'NONE' || !items.length || userOriginated && grid.hasAttribute('disabled')) {\n          return;\n        }\n\n        var updatedSelectedItems = grid.selectedItems.slice();\n\n        while (items.length) {\n          var itemToDeselect = items.shift();\n\n          for (var i = 0; i < updatedSelectedItems.length; i++) {\n            var selectedItem = updatedSelectedItems[i];\n\n            if (itemToDeselect && itemToDeselect.key === selectedItem.key) {\n              updatedSelectedItems.splice(i, 1);\n              break;\n            }\n          }\n\n          if (itemToDeselect) {\n            delete selectedKeys[itemToDeselect.key];\n\n            if (userOriginated) {\n              delete itemToDeselect.selected;\n              grid.$server.deselect(itemToDeselect.key);\n            }\n          }\n        }\n\n        grid.selectedItems = updatedSelectedItems;\n      });\n      grid.__activeItemChanged = tryCatchWrapper(function (newVal, oldVal) {\n        if (selectionMode != 'SINGLE') {\n          return;\n        }\n\n        if (!newVal) {\n          if (oldVal && selectedKeys[oldVal.key]) {\n            if (!grid.$connector.deselectAllowed) {\n              grid.activeItem = oldVal;\n            } else {\n              grid.$connector.doDeselection([oldVal], true);\n            }\n          }\n        } else if (!selectedKeys[newVal.key]) {\n          grid.$connector.doSelection([newVal], true);\n        }\n      });\n\n      grid._createPropertyObserver('activeItem', '__activeItemChanged', true);\n\n      grid.__activeItemChangedDetails = tryCatchWrapper(function (newVal, oldVal) {\n        if (!detailsVisibleOnClick) {\n          return;\n        } // when grid is attached, newVal is not set and oldVal is undefined\n        // do nothing\n\n\n        if (newVal == null && oldVal === undefined) {\n          return;\n        }\n\n        if (newVal && !newVal.detailsOpened) {\n          grid.$server.setDetailsVisible(newVal.key);\n        } else {\n          grid.$server.setDetailsVisible(null);\n        }\n      });\n\n      grid._createPropertyObserver('activeItem', '__activeItemChangedDetails', true);\n\n      grid.$connector.setDetailsVisibleOnClick = tryCatchWrapper(function (visibleOnClick) {\n        detailsVisibleOnClick = visibleOnClick;\n      });\n      grid.$connector._getPageIfSameLevel = tryCatchWrapper(function (parentKey, index, defaultPage) {\n        var cacheAndIndex = grid._cache.getCacheAndIndex(index);\n\n        var parentItem = cacheAndIndex.cache.parentItem;\n        var parentKeyOfIndex = parentItem ? grid.getItemId(parentItem) : root;\n\n        if (parentKey !== parentKeyOfIndex) {\n          return defaultPage;\n        } else {\n          return grid._getPageForIndex(cacheAndIndex.scaledIndex);\n        }\n      });\n      grid.$connector.getCacheByKey = tryCatchWrapper(function (key) {\n        var cacheAndIndex = grid._cache.getCacheAndIndexByKey(key);\n\n        if (cacheAndIndex) {\n          return cacheAndIndex.cache;\n        }\n\n        return undefined;\n      });\n      grid.$connector.flushEnsureSubCache = tryCatchWrapper(function () {\n        var pendingFetch = ensureSubCacheQueue.splice(0, 1)[0];\n        var itemkey = pendingFetch.itemkey;\n        var start = grid._virtualStart;\n        var end = grid._virtualEnd;\n        var buffer = end - start;\n        var firstNeededIndex = Math.max(0, start + grid._vidxOffset - buffer);\n        var lastNeededIndex = Math.min(end + grid._vidxOffset + buffer, grid._effectiveSize); // only fetch if given item is still in visible range\n\n        for (var index = firstNeededIndex; index <= lastNeededIndex; index++) {\n          var item = grid._cache.getItemForIndex(index);\n\n          if (grid.getItemId(item) === itemkey) {\n            if (grid._isExpanded(item)) {\n              pendingFetch.cache.doEnsureSubCacheForScaledIndex(pendingFetch.scaledIndex);\n              return true;\n            } else {\n              break;\n            }\n          }\n        }\n\n        return false;\n      });\n      grid.$connector.flushParentRequests = tryCatchWrapper(function () {\n        var pendingFetches = parentRequestQueue.splice(0, parentRequestBatchMaxSize);\n\n        if (pendingFetches.length) {\n          grid.$server.setParentRequestedRanges(pendingFetches);\n          return true;\n        }\n\n        return false;\n      });\n      grid.$connector.beforeParentRequest = tryCatchWrapper(function (firstIndex, size, parentKey) {\n        // add request in queue\n        parentRequestQueue.push({\n          firstIndex: firstIndex,\n          size: size,\n          parentKey: parentKey\n        });\n        parentRequestDebouncer = Debouncer.debounce(parentRequestDebouncer, timeOut.after(parentRequestDelay), () => {\n          while (parentRequestQueue.length) {\n            grid.$connector.flushParentRequests();\n          }\n        });\n      });\n      grid.$connector.fetchPage = tryCatchWrapper(function (fetch, page, parentKey) {\n        // Determine what to fetch based on scroll position and not only\n        // what grid asked for\n        // The buffer size could be multiplied by some constant defined by the user,\n        // if he needs to reduce the number of items sent to the Grid to improve performance\n        // or to increase it to make Grid smoother when scrolling\n        var start = grid._virtualStart;\n        var end = grid._virtualEnd;\n        var buffer = end - start;\n        var firstNeededIndex = Math.max(0, start + grid._vidxOffset - buffer);\n        var lastNeededIndex = Math.min(end + grid._vidxOffset + buffer, grid._effectiveSize);\n        var firstNeededPage = page;\n        var lastNeededPage = page;\n\n        for (var idx = firstNeededIndex; idx <= lastNeededIndex; idx++) {\n          firstNeededPage = Math.min(firstNeededPage, grid.$connector._getPageIfSameLevel(parentKey, idx, firstNeededPage));\n          lastNeededPage = Math.max(lastNeededPage, grid.$connector._getPageIfSameLevel(parentKey, idx, lastNeededPage));\n        }\n\n        var firstPage = Math.max(0, firstNeededPage);\n        var lastPage = parentKey !== root ? lastNeededPage : Math.min(lastNeededPage, Math.floor(grid.size / grid.pageSize));\n        var lastRequestedRange = lastRequestedRanges[parentKey];\n\n        if (!lastRequestedRange) {\n          lastRequestedRange = [-1, -1];\n        }\n\n        if (lastRequestedRange[0] != firstPage || lastRequestedRange[1] != lastPage) {\n          lastRequestedRange = [firstPage, lastPage];\n          lastRequestedRanges[parentKey] = lastRequestedRange;\n          var count = lastPage - firstPage + 1;\n          fetch(firstPage * grid.pageSize, count * grid.pageSize);\n        }\n      }); // Need to flush FlattenedNodesObserver in order to update `grid._columnTree`\n      // before `_dataProviderChanged` is called. Otherwise, the first page won't\n      // be correctly loaded because of `_canPopulate` returns incorrect result.\n\n      grid._observer.flush();\n\n      grid.dataProvider = tryCatchWrapper(function (params, callback) {\n        if (params.pageSize != grid.pageSize) {\n          throw 'Invalid pageSize';\n        }\n\n        var page = params.page;\n\n        if (params.parentItem) {\n          var parentUniqueKey = grid.getItemId(params.parentItem);\n\n          if (!treePageCallbacks[parentUniqueKey]) {\n            treePageCallbacks[parentUniqueKey] = {};\n          }\n\n          var parentCache = grid.$connector.getCacheByKey(parentUniqueKey);\n          var itemCache = parentCache && parentCache.itemkeyCaches ? parentCache.itemkeyCaches[parentUniqueKey] : undefined;\n\n          if (cache[parentUniqueKey] && cache[parentUniqueKey][page] && itemCache) {\n            // workaround: sometimes grid-element gives page index that overflows\n            page = Math.min(page, Math.floor(cache[parentUniqueKey].size / grid.pageSize));\n            callback(cache[parentUniqueKey][page], cache[parentUniqueKey].size);\n          } else {\n            treePageCallbacks[parentUniqueKey][page] = callback;\n          }\n\n          grid.$connector.fetchPage((firstIndex, size) => grid.$connector.beforeParentRequest(firstIndex, size, params.parentItem.key), page, parentUniqueKey);\n        } else {\n          // workaround: sometimes grid-element gives page index that overflows\n          page = Math.min(page, Math.floor(grid.size / grid.pageSize));\n\n          if (cache[root] && cache[root][page]) {\n            callback(cache[root][page]);\n          } else {\n            rootPageCallbacks[page] = callback;\n          }\n\n          rootRequestDebouncer = Debouncer.debounce(rootRequestDebouncer, timeOut.after(grid._hasData ? rootRequestDelay : 0), () => {\n            grid.$connector.fetchPage((firstIndex, size) => grid.$server.setRequestedRange(firstIndex, size), page, root);\n          });\n        }\n      });\n      var sorterChangeListener = tryCatchWrapper(function (_, oldValue) {\n        if (oldValue !== undefined && !sorterDirectionsSetFromServer) {\n          grid.$server.sortersChanged(grid._sorters.map(function (sorter) {\n            return {\n              path: sorter.path,\n              direction: sorter.direction\n            };\n          }));\n        }\n      });\n      grid.$connector.setSorterDirections = tryCatchWrapper(function (directions) {\n        sorterDirectionsSetFromServer = true;\n        setTimeout(tryCatchWrapper(() => {\n          try {\n            var sorters = Array.from(grid.querySelectorAll('vaadin-grid-sorter'));\n            sorters.forEach(sorter => {\n              if (!directions.filter(d => d.column === sorter.getAttribute('path'))[0]) {\n                sorter.direction = null;\n              }\n            });\n            directions.reverse().forEach(({\n              column,\n              direction\n            }) => {\n              sorters.forEach(sorter => {\n                if (sorter.getAttribute('path') === column && sorter.direction !== direction) {\n                  sorter.direction = direction;\n                }\n              });\n            });\n          } finally {\n            sorterDirectionsSetFromServer = false;\n          }\n        }));\n      });\n\n      grid._createPropertyObserver(\"_previousSorters\", sorterChangeListener);\n\n      grid._updateItem = tryCatchWrapper(function (row, item) {\n        GridElement.prototype._updateItem.call(grid, row, item); // There might be inactive component renderers on hidden rows that still refer to the\n        // same component instance as one of the renderers on a visible row. Making the\n        // inactive/hidden renderer attach the component might steal it from a visible/active one.\n\n\n        if (!row.hidden) {\n          // make sure that component renderers are updated\n          Array.from(row.children).forEach(cell => {\n            if (cell._instance && cell._instance.children) {\n              Array.from(cell._instance.children).forEach(content => {\n                if (content._attachRenderedComponentIfAble) {\n                  content._attachRenderedComponentIfAble();\n                } // In hierarchy column of tree grid, the component renderer is inside its content,\n                // this updates it renderer from innerContent\n\n\n                if (content.children) {\n                  Array.from(content.children).forEach(innerContent => {\n                    if (innerContent._attachRenderedComponentIfAble) {\n                      innerContent._attachRenderedComponentIfAble();\n                    }\n                  });\n                }\n              });\n            }\n          });\n        }\n      });\n      grid._expandedInstanceChangedCallback = tryCatchWrapper(function (inst, value) {\n        // method available only for the TreeGrid server-side component\n        if (inst.item == undefined || grid.$server.updateExpandedState == undefined) {\n          return;\n        }\n\n        var parentKey = grid.getItemId(inst.item);\n        grid.$server.updateExpandedState(parentKey, value);\n\n        if (value) {\n          this.expandItem(inst.item);\n        } else {\n          delete cache[parentKey];\n          var parentCache = grid.$connector.getCacheByKey(parentKey);\n\n          if (parentCache && parentCache.itemkeyCaches && parentCache.itemkeyCaches[parentKey]) {\n            delete parentCache.itemkeyCaches[parentKey];\n          }\n\n          if (parentCache && parentCache.itemkeyCaches) {\n            Object.keys(parentCache.itemCaches).filter(idx => parentCache.items[idx].key === parentKey).forEach(idx => delete parentCache.itemCaches[idx]);\n          }\n\n          delete lastRequestedRanges[parentKey];\n          this.collapseItem(inst.item);\n        }\n      });\n\n      var itemsUpdated = function (items) {\n        if (!items || !Array.isArray(items)) {\n          throw 'Attempted to call itemsUpdated with an invalid value: ' + JSON.stringify(items);\n        }\n\n        var detailsOpenedItems = Array.from(grid.detailsOpenedItems);\n        var updatedSelectedItem = false;\n\n        for (var i = 0; i < items.length; ++i) {\n          var item = items[i];\n\n          if (!item) {\n            continue;\n          }\n\n          if (item.detailsOpened) {\n            if (grid._getItemIndexInArray(item, detailsOpenedItems) < 0) {\n              detailsOpenedItems.push(item);\n            }\n          } else if (grid._getItemIndexInArray(item, detailsOpenedItems) >= 0) {\n            detailsOpenedItems.splice(grid._getItemIndexInArray(item, detailsOpenedItems), 1);\n          }\n\n          if (selectedKeys[item.key]) {\n            selectedKeys[item.key] = item;\n            item.selected = true;\n            updatedSelectedItem = true;\n          }\n        }\n\n        grid.detailsOpenedItems = detailsOpenedItems;\n\n        if (updatedSelectedItem) {\n          // IE 11 Object doesn't support method values\n          grid.selectedItems = Object.keys(selectedKeys).map(function (e) {\n            return selectedKeys[e];\n          });\n        }\n      };\n      /**\n       * Updates the cache for the given page for grid or tree-grid.\n       *\n       * @param page index of the page to update\n       * @param parentKey the key of the parent item for the page\n       * @returns an array of the updated items for the page, or undefined if no items were cached for the page\n       */\n\n\n      var updateGridCache = function (page, parentKey) {\n        var items;\n\n        if ((parentKey || root) !== root) {\n          items = cache[parentKey][page];\n          var parentCache = grid.$connector.getCacheByKey(parentKey);\n\n          if (parentCache && parentCache.itemkeyCaches) {\n            var _cache = parentCache.itemkeyCaches[parentKey];\n            var callbacksForParentKey = treePageCallbacks[parentKey];\n            var callback = callbacksForParentKey && callbacksForParentKey[page];\n\n            _updateGridCache(page, items, callback, _cache);\n          }\n        } else {\n          items = cache[root][page];\n\n          _updateGridCache(page, items, rootPageCallbacks[page], grid._cache);\n        }\n\n        return items;\n      };\n\n      var _updateGridCache = function (page, items, callback, levelcache) {\n        // Force update unless there's a callback waiting\n        if (!callback) {\n          var rangeStart = page * grid.pageSize;\n          var rangeEnd = rangeStart + grid.pageSize;\n\n          if (!items) {\n            if (levelcache && levelcache.items) {\n              for (var idx = rangeStart; idx < rangeEnd; idx++) {\n                delete levelcache.items[idx];\n              }\n            }\n          } else {\n            if (levelcache && levelcache.items) {\n              for (var _idx = rangeStart; _idx < rangeEnd; _idx++) {\n                if (levelcache.items[_idx]) {\n                  levelcache.items[_idx] = items[_idx - rangeStart];\n                }\n              }\n            }\n          }\n        }\n      };\n      /**\n       * Updates all visible grid rows in DOM.\n       */\n\n\n      var updateAllGridRowsInDomBasedOnCache = function () {\n        grid._cache.updateSize();\n\n        grid._effectiveSize = grid._cache.effectiveSize;\n\n        grid._assignModels();\n      };\n      /**\n       * Update the given items in DOM if currently visible.\n       *\n       * @param array items the items to update in DOM\n       */\n\n\n      var updateGridItemsInDomBasedOnCache = function (items) {\n        if (!items || !grid._physicalItems) {\n          return;\n        }\n        /**\n         * Calls the _assignModels function from GridScrollerElement, that triggers\n         * the internal revalidation of the items based on the _cache of the DataProviderMixin.\n         * First mapping the item to physical (iron list) indexes, so that we update\n         * only items in with the correct index that are cached in the iron list.\n         */\n\n\n        var itemKeys = items.map(item => item.key);\n\n        var indexes = grid._physicalItems.map((tr, index) => tr._item && tr._item.key && itemKeys.indexOf(tr._item.key) > -1 ? index : null).filter(idx => idx !== null);\n\n        if (indexes.length > 0) {\n          grid._assignModels(indexes);\n        }\n      };\n\n      grid.$connector.set = tryCatchWrapper(function (index, items, parentKey) {\n        if (index % grid.pageSize != 0) {\n          throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + grid.pageSize;\n        }\n\n        var pkey = parentKey || root;\n        var firstPage = index / grid.pageSize;\n        var updatedPageCount = Math.ceil(items.length / grid.pageSize);\n\n        for (var i = 0; i < updatedPageCount; i++) {\n          var page = firstPage + i;\n          var slice = items.slice(i * grid.pageSize, (i + 1) * grid.pageSize);\n\n          if (!cache[pkey]) {\n            cache[pkey] = {};\n          }\n\n          cache[pkey][page] = slice;\n          grid.$connector.doSelection(slice.filter(item => item.selected && !isSelectedOnGrid(item)));\n          grid.$connector.doDeselection(slice.filter(item => !item.selected && (selectedKeys[item.key] || isSelectedOnGrid(item))));\n          var updatedItems = updateGridCache(page, pkey);\n\n          if (updatedItems) {\n            itemsUpdated(updatedItems);\n            updateGridItemsInDomBasedOnCache(updatedItems);\n          }\n        }\n      });\n\n      var itemToCacheLocation = function (item) {\n        var parent = item.parentUniqueKey || root;\n\n        if (cache[parent]) {\n          for (var page in cache[parent]) {\n            for (var index in cache[parent][page]) {\n              if (grid.getItemId(cache[parent][page][index]) === grid.getItemId(item)) {\n                return {\n                  page: page,\n                  index: index,\n                  parentKey: parent\n                };\n              }\n            }\n          }\n        }\n\n        return null;\n      };\n      /**\n       * Updates the given items for a hierarchical grid.\n       *\n       * @param updatedItems the updated items array\n       */\n\n\n      grid.$connector.updateHierarchicalData = tryCatchWrapper(function (updatedItems) {\n        var pagesToUpdate = []; // locate and update the items in cache\n        // find pages that need updating\n\n        for (var i = 0; i < updatedItems.length; i++) {\n          var cacheLocation = itemToCacheLocation(updatedItems[i]);\n\n          if (cacheLocation) {\n            cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];\n            var key = cacheLocation.parentKey + ':' + cacheLocation.page;\n\n            if (!pagesToUpdate[key]) {\n              pagesToUpdate[key] = {\n                parentKey: cacheLocation.parentKey,\n                page: cacheLocation.page\n              };\n            }\n          }\n        } // IE11 doesn't work with the transpiled version of the forEach.\n\n\n        var keys = Object.keys(pagesToUpdate);\n\n        for (var _i = 0; _i < keys.length; _i++) {\n          var pageToUpdate = pagesToUpdate[keys[_i]];\n          var affectedUpdatedItems = updateGridCache(pageToUpdate.page, pageToUpdate.parentKey);\n\n          if (affectedUpdatedItems) {\n            itemsUpdated(affectedUpdatedItems);\n            updateGridItemsInDomBasedOnCache(affectedUpdatedItems);\n          }\n        }\n      });\n      /**\n       * Updates the given items for a non-hierarchical grid.\n       *\n       * @param updatedItems the updated items array\n       */\n\n      grid.$connector.updateFlatData = tryCatchWrapper(function (updatedItems) {\n        // update (flat) caches\n        for (var i = 0; i < updatedItems.length; i++) {\n          var cacheLocation = itemToCacheLocation(updatedItems[i]);\n\n          if (cacheLocation) {\n            // update connector cache\n            cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i]; // update grid's cache\n\n            var index = parseInt(cacheLocation.page) * grid.pageSize + parseInt(cacheLocation.index);\n\n            if (grid._cache.items[index]) {\n              grid._cache.items[index] = updatedItems[i];\n            }\n          }\n        }\n\n        itemsUpdated(updatedItems);\n        updateGridItemsInDomBasedOnCache(updatedItems);\n      });\n      grid.$connector.clearExpanded = tryCatchWrapper(function () {\n        grid.expandedItems = [];\n        ensureSubCacheQueue = [];\n        parentRequestQueue = [];\n      });\n      grid.$connector.clear = tryCatchWrapper(function (index, length, parentKey) {\n        var pkey = parentKey || root;\n\n        if (!cache[pkey] || Object.keys(cache[pkey]).length === 0) {\n          return;\n        }\n\n        if (index % grid.pageSize != 0) {\n          throw 'Got cleared data for index ' + index + ' which is not aligned with the page size of ' + grid.pageSize;\n        }\n\n        var firstPage = Math.floor(index / grid.pageSize);\n        var updatedPageCount = Math.ceil(length / grid.pageSize);\n\n        for (var i = 0; i < updatedPageCount; i++) {\n          var page = firstPage + i;\n          var items = cache[pkey][page];\n          grid.$connector.doDeselection(items.filter(item => selectedKeys[item.key]));\n          delete cache[pkey][page];\n          var updatedItems = updateGridCache(page, parentKey);\n\n          if (updatedItems) {\n            itemsUpdated(updatedItems);\n          }\n\n          updateGridItemsInDomBasedOnCache(items);\n        }\n      });\n\n      var isSelectedOnGrid = function (item) {\n        var selectedItems = grid.selectedItems;\n\n        for (var i = 0; i < selectedItems; i++) {\n          var selectedItem = selectedItems[i];\n\n          if (selectedItem.key === item.key) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      grid.$connector.reset = tryCatchWrapper(function () {\n        grid.size = 0;\n        deleteObjectContents(cache);\n        deleteObjectContents(grid._cache.items);\n        deleteObjectContents(lastRequestedRanges);\n\n        if (ensureSubCacheDebouncer) {\n          ensureSubCacheDebouncer.cancel();\n        }\n\n        if (parentRequestDebouncer) {\n          parentRequestDebouncer.cancel();\n        }\n\n        if (rootRequestDebouncer) {\n          rootRequestDebouncer.cancel();\n        }\n\n        ensureSubCacheDebouncer = undefined;\n        parentRequestDebouncer = undefined;\n        ensureSubCacheQueue = [];\n        parentRequestQueue = [];\n        updateAllGridRowsInDomBasedOnCache();\n      });\n\n      var deleteObjectContents = obj => Object.keys(obj).forEach(key => delete obj[key]);\n\n      grid.$connector.updateSize = newSize => grid.size = newSize;\n\n      grid.$connector.updateUniqueItemIdPath = path => grid.itemIdPath = path;\n\n      grid.$connector.expandItems = tryCatchWrapper(function (items) {\n        var newExpandedItems = Array.from(grid.expandedItems);\n        items.filter(item => !grid._isExpanded(item)).forEach(item => newExpandedItems.push(item));\n        grid.expandedItems = newExpandedItems;\n      });\n      grid.$connector.collapseItems = tryCatchWrapper(function (items) {\n        var newExpandedItems = Array.from(grid.expandedItems);\n        items.forEach(item => {\n          var index = grid._getItemIndexInArray(item, newExpandedItems);\n\n          if (index >= 0) {\n            newExpandedItems.splice(index, 1);\n          }\n        });\n        grid.expandedItems = newExpandedItems;\n        items.forEach(item => grid.$connector.removeFromQueue(item));\n      });\n      grid.$connector.removeFromQueue = tryCatchWrapper(function (item) {\n        var itemId = grid.getItemId(item);\n        delete treePageCallbacks[itemId];\n        grid.$connector.removeFromArray(ensureSubCacheQueue, item => item.itemkey === itemId);\n        grid.$connector.removeFromArray(parentRequestQueue, item => item.parentKey === itemId);\n      });\n      grid.$connector.removeFromArray = tryCatchWrapper(function (array, removeTest) {\n        if (array.length) {\n          for (var index = array.length - 1; index--;) {\n            if (removeTest(array[index])) {\n              array.splice(index, 1);\n            }\n          }\n        }\n      });\n      grid.$connector.confirmParent = tryCatchWrapper(function (id, parentKey, levelSize) {\n        if (!treePageCallbacks[parentKey]) {\n          return;\n        }\n\n        if (cache[parentKey]) {\n          cache[parentKey].size = levelSize;\n        }\n\n        var outstandingRequests = Object.getOwnPropertyNames(treePageCallbacks[parentKey]);\n\n        for (var i = 0; i < outstandingRequests.length; i++) {\n          var page = outstandingRequests[i];\n          var lastRequestedRange = lastRequestedRanges[parentKey] || [0, 0];\n          var callback = treePageCallbacks[parentKey][page];\n\n          if (cache[parentKey] && cache[parentKey][page] || page < lastRequestedRange[0] || page > lastRequestedRange[1]) {\n            delete treePageCallbacks[parentKey][page];\n            var items = cache[parentKey][page] || new Array(levelSize);\n            callback(items, levelSize);\n          } else if (callback && levelSize === 0) {\n            // The parent item has 0 child items => resolve the callback with an empty array\n            delete treePageCallbacks[parentKey][page];\n            callback([], levelSize);\n          }\n        } // Let server know we're done\n\n\n        grid.$server.confirmParentUpdate(id, parentKey);\n\n        if (!grid.loading) {\n          grid._assignModels();\n        }\n      });\n      grid.$connector.confirm = tryCatchWrapper(function (id) {\n        // We're done applying changes from this batch, resolve outstanding\n        // callbacks\n        var outstandingRequests = Object.getOwnPropertyNames(rootPageCallbacks);\n\n        for (var i = 0; i < outstandingRequests.length; i++) {\n          var page = outstandingRequests[i];\n          var lastRequestedRange = lastRequestedRanges[root] || [0, 0];\n          var lastAvailablePage = grid.size ? Math.ceil(grid.size / grid.pageSize) - 1 : 0; // It's possible that the lastRequestedRange includes a page that's beyond lastAvailablePage if the grid's size got reduced during an ongoing data request\n\n          var lastRequestedRangeEnd = Math.min(lastRequestedRange[1], lastAvailablePage); // Resolve if we have data or if we don't expect to get data\n\n          var callback = rootPageCallbacks[page];\n\n          if (cache[root] && cache[root][page] || page < lastRequestedRange[0] || +page > lastRequestedRangeEnd) {\n            delete rootPageCallbacks[page];\n            callback(cache[root][page] || new Array(grid.pageSize)); // Makes sure to push all new rows before this stack execution is done so any timeout expiration called after will be applied on a fully updated grid\n            //Resolves https://github.com/vaadin/vaadin-grid-flow/issues/511\n\n            if (grid._debounceIncreasePool) {\n              grid._debounceIncreasePool.flush();\n            }\n          } else if (callback && grid.size === 0) {\n            // The grid has 0 items => resolve the callback with an empty array\n            delete rootPageCallbacks[page];\n            callback([]);\n          }\n        } // Let server know we're done\n\n\n        grid.$server.confirmUpdate(id);\n      });\n      grid.$connector.ensureHierarchy = tryCatchWrapper(function () {\n        for (var parentKey in cache) {\n          if (parentKey !== root) {\n            delete cache[parentKey];\n          }\n        }\n\n        deleteObjectContents(lastRequestedRanges);\n        grid._cache.itemCaches = {};\n        grid._cache.itemkeyCaches = {};\n        updateAllGridRowsInDomBasedOnCache();\n      });\n      grid.$connector.setSelectionMode = tryCatchWrapper(function (mode) {\n        if ((typeof mode === 'string' || mode instanceof String) && validSelectionModes.indexOf(mode) >= 0) {\n          selectionMode = mode;\n          selectedKeys = {};\n        } else {\n          throw 'Attempted to set an invalid selection mode';\n        }\n      });\n      grid.$connector.deselectAllowed = true; // TODO: should be removed once https://github.com/vaadin/vaadin-grid/issues/1471 gets implemented\n\n      grid.$connector.setVerticalScrollingEnabled = tryCatchWrapper(function (enabled) {\n        setVerticalScrollingEnabled(grid.$.table, enabled); // Since the scrollbars were toggled, there might have been some changes to layout\n        // size. Notify grid of the resize to ensure everything is in place.\n\n        grid.notifyResize();\n      });\n\n      var setVerticalScrollingEnabled = function (scrollable, enabled) {\n        // Prevent Y axis scrolling with CSS. This will hide the vertical scrollbar.\n        scrollable.style.overflowY = enabled ? '' : 'hidden'; // Clean up an existing listener\n\n        scrollable.removeEventListener('wheel', scrollable.__wheelListener); // Add a wheel event listener with the horizontal scrolling prevention logic\n\n        !enabled && scrollable.addEventListener('wheel', scrollable.__wheelListener = tryCatchWrapper(e => {\n          if (e.deltaX) {\n            // If there was some horizontal delta related to the wheel event, force the vertical\n            // delta to 0 and let grid process the wheel event normally\n            Object.defineProperty(e, 'deltaY', {\n              value: 0\n            });\n          } else {\n            // If there was verical delta only, skip the grid's wheel event processing to\n            // enable scrolling the page even if grid isn't scrolled to end\n            e.stopImmediatePropagation();\n          }\n        }));\n      };\n\n      var contextMenuListener = function (e) {\n        var eventContext = grid.getEventContext(e);\n        var key = eventContext.item && eventContext.item.key;\n        var colId = eventContext.column && eventContext.column.id;\n        grid.$server.updateContextMenuTargetItem(key, colId);\n      };\n\n      grid.addEventListener('vaadin-context-menu-before-open', tryCatchWrapper(function (e) {\n        contextMenuListener(grid.$contextMenuConnector.openEvent);\n      }));\n      grid.getContextMenuBeforeOpenDetail = tryCatchWrapper(function (event) {\n        var eventContext = grid.getEventContext(event);\n        return {\n          key: eventContext.item && eventContext.item.key || \"\"\n        };\n      });\n      grid.addEventListener('cell-activate', tryCatchWrapper(e => {\n        grid.$connector.activeItem = e.detail.model.item;\n        setTimeout(() => grid.$connector.activeItem = undefined);\n      }));\n      grid.addEventListener('click', tryCatchWrapper(e => _fireClickEvent(e, 'item-click')));\n      grid.addEventListener('dblclick', tryCatchWrapper(e => _fireClickEvent(e, 'item-double-click')));\n      grid.addEventListener('column-resize', tryCatchWrapper(e => {\n        var cols = grid._getColumnsInOrder().filter(col => !col.hidden);\n\n        cols.forEach(col => {\n          col.dispatchEvent(new CustomEvent('column-drag-resize'));\n        });\n        grid.dispatchEvent(new CustomEvent('column-drag-resize', {\n          detail: {\n            resizedColumnKey: e.detail.resizedColumn._flowId\n          }\n        }));\n      }));\n      grid.addEventListener('column-reorder', tryCatchWrapper(e => {\n        var columns = grid._columnTree.slice(0).pop().filter(c => c._flowId).sort((b, a) => b._order - a._order).map(c => c._flowId);\n\n        grid.dispatchEvent(new CustomEvent('column-reorder-all-columns', {\n          detail: {\n            columns\n          }\n        }));\n      }));\n\n      function _fireClickEvent(event, eventName) {\n        if (grid.$connector.activeItem) {\n          event.itemKey = grid.$connector.activeItem.key;\n          var eventContext = grid.getEventContext(event); // if you have a details-renderer, getEventContext().column is undefined\n\n          if (eventContext.column) {\n            event.internalColumnId = eventContext.column._flowId;\n          }\n\n          grid.dispatchEvent(new CustomEvent(eventName, {\n            detail: event\n          }));\n        }\n      }\n\n      grid.cellClassNameGenerator = tryCatchWrapper(function (column, rowData) {\n        var style = rowData.item.style;\n\n        if (!style) {\n          return;\n        }\n\n        return (style.row || '') + ' ' + (column && style[column._flowId] || '');\n      });\n      grid.dropFilter = tryCatchWrapper(rowData => !rowData.item.dropDisabled);\n      grid.dragFilter = tryCatchWrapper(rowData => !rowData.item.dragDisabled);\n      grid.addEventListener('grid-dragstart', tryCatchWrapper(e => {\n        if (grid._isSelected(e.detail.draggedItems[0])) {\n          // Dragging selected (possibly multiple) items\n          if (grid.__selectionDragData) {\n            Object.keys(grid.__selectionDragData).forEach(type => {\n              e.detail.setDragData(type, grid.__selectionDragData[type]);\n            });\n          } else {\n            (grid.__dragDataTypes || []).forEach(type => {\n              e.detail.setDragData(type, e.detail.draggedItems.map(item => item.dragData[type]).join('\\n'));\n            });\n          }\n\n          if (grid.__selectionDraggedItemsCount > 1) {\n            e.detail.setDraggedItemsCount(grid.__selectionDraggedItemsCount);\n          }\n        } else {\n          // Dragging just one (non-selected) item\n          (grid.__dragDataTypes || []).forEach(type => {\n            e.detail.setDragData(type, e.detail.draggedItems[0].dragData[type]);\n          });\n        }\n      }));\n    })(grid)\n  };\n})();"
    },
    {
     "id": 299,
     "name": "../node_modules/@vaadin/flow-frontend/ironListConnector.js?babel-target=es6",
     "source": "// Not using ES6 imports in this file yet because the connector in V14 must\n// still work in Legacy bower projects. See: `ironListConnector-es6.js` for \n// the Polymer3 approach.\nwindow.Vaadin.Flow.Legacy = window.Vaadin.Flow.Legacy || {};\nwindow.Vaadin.Flow.ironListConnector = {\n  initLazy: function (list) {\n    // Check whether the connector was already initialized for the Iron list\n    if (list.$connector) {\n      return;\n    }\n\n    if (window.Polymer) {\n      // Polymer2 approach.\n      window.Vaadin.Flow.Legacy.Debouncer = window.Vaadin.Flow.Legacy.Debouncer || Polymer.Debouncer;\n      window.Vaadin.Flow.Legacy.timeOut = window.Vaadin.Flow.Legacy.timeOut || Polymer.Async.timeOut;\n    } else if (!window.Vaadin.Flow.Legacy.Debouncer) {\n      console.log(\"IronList is unable to load Polymer helpers.\");\n      return;\n    }\n\n    var Debouncer = window.Vaadin.Flow.Legacy.Debouncer;\n    var timeOut = window.Vaadin.Flow.Legacy.timeOut;\n    var extraItemsBuffer = 20;\n    var lastRequestedRange = [0, 0];\n    list.$connector = {};\n    list.$connector.placeholderItem = {\n      __placeholder: true\n    };\n\n    var updateRequestedItem = function () {\n      /*\n       * TODO Iron list seems to do a small index adjustment after scrolling\n       * has stopped. This causes a redundant request to be sent to make a\n       * corresponding minimal change to the buffer. We should avoid these\n       * requests by making the logic skip doing a request if the available\n       * buffer is within some tolerance compared to the requested buffer.\n       */\n      var firstNeededItem = list._virtualStart;\n      var lastNeededItem = list._virtualEnd;\n      var first = Math.max(0, firstNeededItem - extraItemsBuffer);\n      var last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);\n\n      if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {\n        lastRequestedRange = [first, last];\n        var count = 1 + last - first;\n        list.$server.setRequestedRange(first, count);\n      }\n    };\n\n    var requestDebounce;\n\n    var scheduleUpdateRequest = function () {\n      requestDebounce = Debouncer.debounce(requestDebounce, timeOut.after(10), updateRequestedItem);\n    };\n    /*\n     * Ensure all items that iron list will be looking at are actually defined.\n     * If this is not done, the component will keep looking ahead through the\n     * array until finding enough present items to render. In our case, that's\n     * a really slow way of achieving nothing since the rest of the array is\n     * empty.\n     */\n\n\n    var originalAssign = list._assignModels;\n\n    list._assignModels = function () {\n      var tempItems = [];\n      var start = list._virtualStart;\n      var count = Math.min(list.items.length, list._physicalCount);\n\n      for (var i = 0; i < count; i++) {\n        if (list.items[start + i] === undefined) {\n          tempItems.push(i);\n          list.items[start + i] = list.$connector.placeholderItem;\n        }\n      }\n\n      originalAssign.apply(list, arguments);\n      /*\n       * TODO: Keep track of placeholder items in the \"active\" range and\n       * avoid deleting them so that the next pass will be faster. Instead,\n       * the end of each pass should only delete placeholders that are no\n       * longer needed.\n       */\n\n      for (var _i = 0; _i < tempItems.length; _i++) {\n        delete list.items[start + tempItems[_i]];\n      }\n      /*\n       * Check if we need to do anything once things have settled down.\n       * This method is called multiple times in sequence for the same user\n       * action, but we only want to do the check once.\n       */\n\n\n      scheduleUpdateRequest();\n    };\n\n    list.items = [];\n\n    list.$connector.set = function (index, items) {\n      for (var i = 0; i < items.length; i++) {\n        var itemsIndex = index + i;\n        list.items[itemsIndex] = items[i];\n      } // Do a full render since dirty detection for splices is broken\n\n\n      list._render();\n    };\n\n    list.$connector.updateData = function (items) {\n      // Find the items by key inside the list update them\n      var oldItems = list.items;\n      var mapByKey = {};\n      var leftToUpdate = items.length;\n\n      for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n        mapByKey[item.key] = item;\n      }\n\n      for (var _i2 = 0; _i2 < oldItems.length; _i2++) {\n        var oldItem = oldItems[_i2];\n        var newItem = mapByKey[oldItem.key];\n\n        if (newItem) {\n          list.items[_i2] = newItem;\n          list.notifyPath(\"items.\" + _i2);\n          leftToUpdate--;\n\n          if (leftToUpdate == 0) {\n            break;\n          }\n        }\n      }\n    };\n\n    list.$connector.clear = function (index, length) {\n      for (var i = 0; i < length; i++) {\n        var itemsIndex = index + i;\n        delete list.items[itemsIndex]; // Most likely a no-op since the affected index isn't in view\n\n        list.notifyPath(\"items.\" + itemsIndex);\n      }\n    };\n\n    list.$connector.updateSize = function (newSize) {\n      var delta = newSize - list.items.length;\n\n      if (delta > 0) {\n        list.items.length = newSize;\n        list.notifySplices(\"items\", [{\n          index: newSize - delta,\n          removed: [],\n          addedCount: delta,\n          object: list.items,\n          type: \"splice\"\n        }]);\n      } else if (delta < 0) {\n        var removed = list.items.slice(newSize, list.items.length);\n        list.items.splice(newSize);\n        list.notifySplices(\"items\", [{\n          index: newSize,\n          removed: removed,\n          addedCount: 0,\n          object: list.items,\n          type: \"splice\"\n        }]);\n      }\n    };\n\n    list.$connector.setPlaceholderItem = function (placeholderItem) {\n      if (!placeholderItem) {\n        placeholderItem = {};\n      }\n\n      placeholderItem.__placeholder = true;\n      list.$connector.placeholderItem = placeholderItem;\n    };\n  }\n};"
    },
    {
     "id": 300,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column.js?babel-target=es6",
     "source": "import '../../src/vaadin-grid-column.js';"
    },
    {
     "id": 301,
     "name": "../node_modules/@vaadin/vaadin-details/theme/lumo/vaadin-details-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-details\" theme-for=\"vaadin-details\">\n  <template>\n    <style>\n      :host {\n        margin: var(--lumo-space-xs) 0;\n        outline: none;\n      }\n\n      [part=\"summary\"] {\n        display: flex;\n        align-items: center;\n        width: 100%;\n        outline: none;\n        padding: var(--lumo-space-s) 0;\n        box-sizing: border-box;\n        font-family: var(--lumo-font-family);\n        font-size: var(--lumo-font-size-m);\n        font-weight: 500;\n        line-height: var(--lumo-line-height-xs);\n        color: var(--lumo-secondary-text-color);\n        background-color: inherit;\n        border-radius: var(--lumo-border-radius-m);\n        cursor: default;\n        -webkit-tap-highlight-color: transparent;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n      }\n\n      :host([focus-ring]) [part=\"summary\"] {\n        box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);\n      }\n\n      [part=\"toggle\"] {\n        display: block;\n        width: 1em;\n        height: 1em;\n        margin-left: calc(var(--lumo-space-xs) * -1);\n        margin-right: var(--lumo-space-xs);\n        font-size: var(--lumo-icon-size-s);\n        line-height: 1;\n        color: var(--lumo-contrast-60pct);\n        font-family: \"lumo-icons\";\n      }\n\n      :host([disabled]) [part=\"summary\"],\n      :host([disabled]) [part=\"toggle\"] {\n        color: var(--lumo-disabled-text-color);\n      }\n\n      @media (hover: hover) {\n        :host(:not([disabled])) [part=\"summary\"]:hover,\n        :host(:not([disabled])) [part=\"summary\"]:hover [part=\"toggle\"] {\n          color: var(--lumo-contrast-80pct);\n        }\n      }\n\n      [part=\"toggle\"]::before {\n        content: var(--lumo-icons-angle-right);\n      }\n\n      :host([opened]) [part=\"toggle\"] {\n        transform: rotate(90deg);\n      }\n\n      [part=\"content\"] {\n        padding: var(--lumo-space-xs) 0 var(--lumo-space-s);\n        font-size: var(--lumo-font-size-m);\n        line-height: var(--lumo-line-height-m);\n      }\n\n      :host([theme~=\"filled\"]) {\n        background-color: var(--lumo-contrast-5pct);\n        border-radius: var(--lumo-border-radius-m);\n      }\n\n      :host([theme~=\"filled\"]) [part=\"summary\"] {\n        padding: var(--lumo-space-s) calc(var(--lumo-space-s) + var(--lumo-space-xs) / 2);\n      }\n\n      :host([theme~=\"filled\"]) [part=\"content\"] {\n        padding-left: var(--lumo-space-m);\n        padding-right: var(--lumo-space-m);\n      }\n\n      :host([theme~=\"small\"]) [part=\"summary\"] {\n        padding-top: var(--lumo-space-xs);\n        padding-bottom: var(--lumo-space-xs);\n      }\n\n      :host([theme~=\"small\"]) [part=\"toggle\"] {\n        margin-right: calc(var(--lumo-space-xs) / 2);\n      }\n\n      :host([theme~=\"small\"]) [part\\$=\"content\"] {\n        font-size: var(--lumo-font-size-s);\n      }\n\n      :host([theme~=\"reverse\"]) [part=\"summary\"] {\n        justify-content: space-between;\n      }\n\n      :host([theme~=\"reverse\"]) [part=\"toggle\"] {\n        order: 1;\n        margin-right: 0;\n      }\n\n      :host([theme~=\"reverse\"][theme~=\"filled\"]) [part=\"summary\"] {\n        padding-left: var(--lumo-space-m);\n      }\n\n      /* RTL specific styles */\n\n      :host([dir=\"rtl\"]) [part=\"toggle\"] {\n        margin-left: var(--lumo-space-xs);\n        margin-right: calc(var(--lumo-space-xs) * -1);\n      }\n\n      :host([dir=\"rtl\"]) [part=\"toggle\"]::before {\n        content: var(--lumo-icons-angle-left);\n      }\n\n      :host([opened][dir=\"rtl\"]) [part=\"toggle\"] {\n        transform: rotate(-90deg);\n      }\n\n      :host([theme~=\"small\"][dir=\"rtl\"]) [part=\"toggle\"] {\n        margin-left: calc(var(--lumo-space-xs) / 2);\n      }\n\n      :host([theme~=\"reverse\"][dir=\"rtl\"]) [part=\"toggle\"] {\n        margin-left: 0;\n      }\n\n      :host([theme~=\"reverse\"][theme~=\"filled\"][dir=\"rtl\"]) [part=\"summary\"] {\n        padding-right: var(--lumo-space-m);\n      }\n\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 302,
     "name": "../node_modules/@vaadin/vaadin-details/src/vaadin-details.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2019 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-details>` is a Web Component which the creates an\n * expandable panel similar to `<details>` HTML element.\n *\n * ```\n * <vaadin-details>\n *   <div slot=\"summary\">Expandable Details</div>\n *   Toggle using mouse, Enter and Space keys.\n * </vaadin-details>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are exposed for styling:\n *\n * Part name        | Description\n * -----------------|----------------\n * `summary`        | The element used to open and close collapsible content.\n * `toggle`         | The element used as indicator, can represent an icon.\n * `summary-content`| The wrapper for the slotted summary content.\n * `content`        | The wrapper for the collapsible details content.\n *\n * The following attributes are exposed for styling:\n *\n * Attribute    | Description\n * -------------| -----------\n * `opened`     | Set when the collapsible content is expanded and visible.\n * `disabled`   | Set when the element is disabled.\n * `focus-ring` | Set when the element is focused using the keyboard.\n * `focused`    | Set when the element is focused.\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ControlStateMixin\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nclass DetailsElement extends ControlStateMixin(ElementMixin(ThemableMixin(PolymerElement))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      [part=\"content\"] {\n        display: none;\n        overflow: hidden;\n      }\n\n      [part=\"summary\"][disabled] {\n        pointer-events: none;\n      }\n\n      :host([opened]) [part=\"content\"] {\n        display: block;\n        overflow: visible;\n      }\n    </style>\n    <div role=\"heading\">\n      <div role=\"button\" part=\"summary\" on-click=\"_onToggleClick\" on-keydown=\"_onToggleKeyDown\" disabled\\$=\"[[disabled]]\" aria-expanded\\$=\"[[_getAriaExpanded(opened)]]\">\n        <span part=\"toggle\"></span>\n        <span part=\"summary-content\"><slot name=\"summary\"></slot></span>\n      </div>\n    </div>\n    <div part=\"content\" aria-hidden\\$=\"[[_getAriaHidden(opened)]]\">\n      <slot></slot>\n    </div>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-details';\n  }\n\n  static get version() {\n    return '1.2.0';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * If true, the details content is visible.\n       * @type {boolean}\n       */\n      opened: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        notify: true,\n        observer: '_openedChanged'\n      }\n    };\n  }\n  /**\n   * @return {!HTMLElement}\n   * @protected\n   */\n\n\n  get _collapsible() {\n    return this.shadowRoot.querySelector('[part=\"content\"]');\n  }\n  /**\n   * Focusable element used by vaadin-control-state-mixin\n   * @return {!HTMLElement}\n   * @protected\n   */\n\n\n  get focusElement() {\n    return this.shadowRoot.querySelector('[part=\"summary\"]');\n  }\n\n  ready() {\n    super.ready(); // prevent Shift + Tab on content from host blur\n\n    this._collapsible.addEventListener('keydown', e => {\n      if (e.shiftKey && e.keyCode === 9) {\n        e.stopPropagation();\n      }\n    });\n  }\n  /** @private */\n\n\n  _getAriaExpanded(opened) {\n    return opened ? 'true' : 'false';\n  }\n  /** @private */\n\n\n  _getAriaHidden(opened) {\n    return opened ? 'false' : 'true';\n  }\n  /** @private */\n\n\n  _openedChanged(opened) {\n    this._collapsible.style.maxHeight = opened ? '' : '0px';\n  }\n  /**\n   * @param {!MouseEvent} e\n   * @protected\n   */\n\n\n  _onToggleClick(e) {\n    this.opened = !this.opened;\n  }\n  /**\n   * @param {!KeyboardEvent} e\n   * @protected\n   */\n\n\n  _onToggleKeyDown(e) {\n    if ([13, 32].indexOf(e.keyCode) > -1) {\n      e.preventDefault();\n      this.opened = !this.opened;\n    }\n  }\n\n}\n\ncustomElements.define(DetailsElement.is, DetailsElement);\nexport { DetailsElement };"
    },
    {
     "id": 303,
     "name": "../node_modules/@vaadin/vaadin-board/theme/lumo/vaadin-board-row.js?babel-target=es6",
     "source": "import '../../src/vaadin-board-row.js';"
    },
    {
     "id": 304,
     "name": "../node_modules/@vaadin/vaadin-charts/src/vaadin-chart.js?babel-target=es6",
     "source": "/**\n@license\nVaadin Charts\nCopyright (C) 2015 Vaadin Ltd\nThis program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).\nSee the file LICENSE.md distributed with this software for more information about licensing.\nSee <a href=\"https://vaadin.com/license/cval-3\">the website</a> for the complete license.\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { beforeNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport '@vaadin/vaadin-license-checker/vaadin-license-checker.js';\nimport { ChartSeriesElement } from './vaadin-chart-series.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { nativeShadow } from '@webcomponents/shadycss/src/style-settings.js';\nimport ScopingShim from '@webcomponents/shadycss/src/scoping-shim.js';\nimport Highcharts from 'highcharts/js/es-modules/masters/highstock.src.js';\nimport 'highcharts/js/es-modules/masters/modules/accessibility.src.js';\nimport 'highcharts/js/es-modules/masters/highcharts-more.src.js';\nimport 'highcharts/js/es-modules/masters/highcharts-3d.src.js';\nimport 'highcharts/js/es-modules/masters/modules/data.src.js';\nimport 'highcharts/js/es-modules/masters/modules/drilldown.src.js';\nimport 'highcharts/js/es-modules/masters/modules/exporting.src.js';\nimport 'highcharts/js/es-modules/masters/modules/funnel.src.js';\nimport 'highcharts/js/es-modules/masters/modules/heatmap.src.js';\nimport 'highcharts/js/es-modules/masters/modules/solid-gauge.src.js';\nimport 'highcharts/js/es-modules/masters/modules/treemap.src.js';\nimport 'highcharts/js/es-modules/masters/modules/no-data-to-display.src.js';\n/** @private */\n// eslint-disable-next-line no-unused-vars\n\nexport var ChartDeepMerger = (() => class {\n  static __isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n  }\n\n  static __deepMerge(target, source) {\n    if (this.__isObject(source) && this.__isObject(target)) {\n      for (var key in source) {\n        if (this.__isObject(source[key])) {\n          if (!target[key]) {\n            Object.assign(target, {\n              [key]: {}\n            });\n          }\n\n          this.__deepMerge(target[key], source[key]);\n        } else {\n          Object.assign(target, {\n            [key]: source[key]\n          });\n        }\n      }\n    }\n\n    return target;\n  }\n\n})();\n\nif (Highcharts) {\n  ['exportChart', 'exportChartLocal', 'getSVG'].forEach(methodName => {\n    Highcharts.wrap(Highcharts.Chart.prototype, methodName, function (proceed) {\n      Highcharts.fireEvent(this, 'beforeExport');\n      var result = proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n      Highcharts.fireEvent(this, 'afterExport');\n      return result;\n    });\n  });\n}\n\nif (Highcharts) {\n  Highcharts.wrap(Highcharts.seriesTypes.column.prototype, 'plotGroup', function (proceed, prop, name, visibility, zIndex, parent) {\n    if (this.chart.is3d() && this[prop]) {\n      delete this[prop];\n    }\n\n    return proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n  });\n}\n\nif (!PolymerElement) {\n  console.warn(`Unexpected Polymer version ${Polymer.version} is used, expected v2.0.0 or later.`);\n}\n/**\n * `<vaadin-chart>` is a Web Component for creating high quality charts.\n *\n * ### Quick Start\n *\n * #### Polymer 2 App\n *\n * 1. Create a Polymer application using [Polymer CLI](https://www.polymer-project.org/2.0/docs/tools/polymer-cli)\n * ```\n * mkdir my-app\n * cd my-app\n * polymer init\n * select `polymer-2-application`\n * ```\n * 1. Install Vaadin Charts\n * ```\n * bower install --save vaadin-charts#6.3.1\n * ```\n * 1. Import `<vaadin-chart>` to your app\n * Edit the file `src/my-app/my-app.html` and add the following snipped before the `<dom-module>` tag\n * ```html\n * <link rel=\"import\" href=\"../../bower_components/vaadin-charts/vaadin-chart.html\">\n * ```\n * 1. Add your first `<vaadin-chart>`\n * Also in `my-app.html` add the following snippet before the `</template>` closing tag\n * ```html\n * <vaadin-chart></vaadin-chart>\n * ```\n * 1. Run your app with:\n * ```\n * polymer serve --open\n * ```\n *\n * #### Polymer 3 App\n *\n * * 1. Create a Polymer application using [Polymer CLI](https://www.polymer-project.org/3.0/docs/tools/polymer-cli)\n * ```\n * mkdir my-app\n * cd my-app\n * polymer init\n * select `polymer-3-application`\n * ```\n * 1. Install Vaadin Charts\n * ```\n * npm i @vaadin/vaadin-charts@6.3.0 --save\n * ```\n * 1. Import `<vaadin-chart>` to your app\n * Edit the file `src/my-app/my-app.js` and add the following snipped on the top, after the first `import` declaration\n * ```js\n * import '@vaadin/vaadin-charts';\n * ```\n * 1. Add your first `<vaadin-chart>`\n * Also in `my-app.js`, at the template getter, add the following snippet after the `</h2>` closing tag\n * ```html\n * <vaadin-chart></vaadin-chart>\n * ```\n * 1. Run your app with:\n * ```\n * polymer serve --npm --open\n * ```\n *\n * Congratulations! You have your first Vaadin Chart setup.\n *\n * ### Basic use\n *\n * Now that we covered the basic steps to create an empty chart, let us show how you can configure it.\n *\n * There are two ways of configuring your `<vaadin-chart>` element: **HTML API**, **JS API** and **JSON API**.\n * Note that you can make use of all APIs in your element.\n *\n * #### Configuring your chart using HTML API\n *\n * `vaadin-chart` has a set of attributes to make it easier for you to customize your chart.\n * Using as a base the project created with in Quick Start:\n *\n * ```html\n *  <vaadin-chart title=\"The chart title\" subtitle=\"The chart subtitle\">\n *    <vaadin-chart-series\n *          type=\"column\"\n *          title=\"The series title\"\n *          values=\"[10,20,30]\">\n *    </vaadin-chart-series>\n *  </vaadin-chart>\n * ```\n *\n * > Note that while you can set type for each series individually, for some types, such as `'bar'`, `'gauge'` and `'solidgauge'`, you\n * > have to set it as the default series type on `<vaadin-chart>` in order to work properly.\n *\n * #### Configuring your chart using JS API\n *\n * Using as a base the project created with in Quick Start\n *\n * Do the following changes in `my-app.html`\n *\n * 1. Set and id for the `<vaadin-chart>` in the template\n * ```html\n *     <vaadin-chart id=\"mychart\"></vaadin-chart>\n * ```\n * 1. Add a function that uses `configuration` property (JS Api) to set chart title, categories and data\n * ```js\n * initChartWithJSApi() {\n *     Polymer.RenderStatus.beforeNextRender(this, () => {\n *        const configuration = this.$.mychart.configuration;\n *        configuration.setTitle({ text: 'The chart title' });\n *        // By default there is one x axis, it is referenced by configuration.xAxis[0].\n *        configuration.xAxis[0].setCategories(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);\n *        configuration.addSeries({\n *            type: 'column',\n *            data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]\n *        });\n *     });\n * }\n * ```\n * 1. Call that function from connectedCallback (when the element is added to a document)\n * ```js\n * connectedCallback() {\n *     super.connectedCallback();\n *     this.initChartWithJSApi();\n * }\n * ```\n * 1. And finally run your app with:\n * ```\n * polymer serve --open\n * ```\n *\n *\n * #### Configuring your chart using JS JSON API\n *\n * JS JSON API is a simple alternative to the JS API.\n *\n * Using as a base the project created with in Quick Start\n *\n * Do the following changes in `my-app.html`\n *\n * 1. Set and id for the `<vaadin-chart>` in the template\n * ```html\n *     <vaadin-chart id=\"mychart\"></vaadin-chart>\n * ```\n * 1. Add a function that uses `update` method (JS JSON Api) to set chart title, categories and data\n * ```js\n * initChartWithJSJSONApi() {\n *     this.$.mychart.update({\n *       title: {\n *         text: 'The chart title'\n *       },\n *       subtitle: {\n *         text: 'Subtitle'\n *       },\n *       xAxis: {\n *         categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n *       },\n *       series: [{\n *         type: 'column',\n *         data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]\n *       }]\n *     });\n * }\n * ```\n * 1. Call that function from connectedCallback (when the element is added to a document)\n * ```js\n * connectedCallback() {\n *     super.connectedCallback();\n *     this.initChartWithJSJSONApi();\n * }\n * ```\n * 1. And finally run your app with:\n * ```\n * polymer serve --open\n * ```\n *\n * It should be noted that chart style customization cannot be done via the JS or JSON API.\n * Styling properties in the JSON configuration will be ignored. The following section discusses chart styling.\n *\n *\n * ### CSS Styling\n * Chart appearance is primarily controlled by CSS style rules.\n * A comprehensive list of the supported style classes can be found at\n * https://www.highcharts.com/docs/chart-design-and-style/style-by-css\n *\n *\n * ### Steps for styling a chart\n *\n * 1. Create a theme file (for example `shared-styles.html`). The theme's dom-module must declare `theme-for=vaadin-chart`.\n * 2. Import `vaadin-chart-default-theme.html` and declare `include=\"vaadin-chart-default-theme\"`\n * on the theme module's style tag to customize Chart's default theme. If there are multiple theme\n * modules *only one* of them should declare this `include`.\n * 3. Specify the desired CSS rules in the theme file.\n * 4. If multiple charts are present, each one can be specifically targeted using the host selector e.g `:host(.my-chart-class)`.\n * 5. Import the theme file.\n *\n *\n * ### Example: Two Charts with a Red Title but only one with a Blue Subtitle\n *\n * ```html\n * <link rel=\"import\" href=\"shared-styles.html\">\n * ...\n * <vaadin-chart title=\"Red Title\" subtitle=\"Not Styled\">\n *   <vaadin-chart-series values=\"[19,12,9,24,5]\"></vaadin-chart-series>\n * </vaadin-chart>\n *\n * <vaadin-chart class=\"blue-subtitle\" title=\"Red Title\" subtitle=\"Blue Subtitle\">\n *   <vaadin-chart-series values=\"[19,12,9,24,5]\"></vaadin-chart-series>\n * </vaadin-chart>\n * ```\n *\n * shared-styles.html\n *\n * ```html\n * <link rel=\"import\" href=\"../bower_components/vaadin-charts/theme/vaadin-chart-default-theme.html\">\n *\n * <dom-module id=\"css-style-example\" theme-for=\"vaadin-chart\">\n *    <template>\n *      <style include=\"vaadin-chart-default-theme\">\n *        .highcharts-title {\n *          fill: red;\n *          font-size: xx-large;\n *        }\n *\n *        :host(.blue-subtitle) .highcharts-subtitle {\n *          fill: blue;\n *        }\n *      </style>\n *    </template>\n * </dom-module>\n * ```\n *\n * ### RTL support\n *\n * `vaadin-charts` as well as [Highcharts](https://www.highcharts.com/) by itself are not adjusting the layout\n * based on the `dir` attribute. In order to make `vaadin-charts` display RTL content properly additional\n * JSON configuration should be used.\n * Each chart should be updated based on the specific needs, but general recommendations are:\n *\n *  1. Set `reversed` to true for xAxis (https://api.highcharts.com/highcharts/xAxis.reversed).\n *  2. Set `useHTML` to true for text elements, i.e. `tooltip` (https://api.highcharts.com/highcharts/tooltip.useHTML).\n *  3. Set `rtl` to true for `legend` (https://api.highcharts.com/highcharts/legend.rtl).\n *\n * Using as a base the project created with in Quick Start and an `additionalOptions` in order to make RTL adjustments:\n *\n * ```html\n *  <vaadin-chart title=\"-  \" subtitle=\"-   \"\n *    additional-options='{\"title\": {\"useHTML\": true}, \"tooltip\": {\"useHTML\": true}, \"subtitle\": {\"useHTML\": true},\n *    \"legend\": {\"rtl\": true}, \"yAxis\": [{\"id\": \"- \", \"title\": {\"text\": \"- \", \"useHTML\": true}}],\n *    \"xAxis\": {\"reversed\": true}}'>\n *    <vaadin-chart-series\n *          type= \"column\"\n *          title=\"-  \"\n *          unit=\"- \"\n *          values=\"[10,20,30]\">\n *    </vaadin-chart-series>\n *  </vaadin-chart>\n * ```\n *\n * ### Setting colors\n *\n * Although charts can be styled as described above, there is a simpler way for setting colors.\n * Colors can be set using CSS custom properties `--vaadin-charts-color-{n}` (where `n` goes from `0 - 9`).\n *\n * For example `--vaadin-charts-color-0` sets the color of the first series on a chart.\n *\n * ### Validating your License\n * After one day using Vaadin Charts in a development environment you will see a pop-up that asks you\n * to validate your license by signing in to vaadin.com.\n *\n * @extends PolymerElement\n * @demo demo/index.html\n */\n\n\nclass ChartElement extends ElementMixin(ThemableMixin(PolymerElement)) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: block;\n        width: 100%;\n        overflow: hidden;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n    </style>\n    <div id=\"chart\"></div>\n    <slot id=\"slot\"></slot>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-chart';\n  }\n\n  static get version() {\n    return '6.3.0';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Configuration object that exposes the JS Api to configure the chart.\n       *\n       * Most important methods are:\n       * - `addSeries (Object options, [Boolean redraw], [Mixed animation])`\n       * - `addAxis (Object options, [Boolean isX], [Boolean redraw], [Mixed animation])`\n       * - `setTitle (Object title, object subtitle, Boolean redraw)`\n       *\n       * Most important properties are:\n       * - `configuration.series`: An array of the chart's series. Detailed API for Series object is\n       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Series)\n       * - `configuration.xAxis`: An array of the chart's x axes. Detailed API for Axis object is\n       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)\n       * - `configuration.yAxis`: An array of the chart's y axes. Detailed API for Axis object is\n       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)\n       * - `configuration.title`: The chart title.\n       *\n       * For detailed documentation of available API check the [API site](http://api.highcharts.com/class-reference/classes.list)\n       * @readonly\n       * @public\n       * @type {Object}\n       */\n      configuration: Object,\n\n      /**\n       * If categories are present names are used instead of numbers for the category axis.\n       * The format of categories can be an `Array` with a list of categories, such as `['2010', '2011', '2012']`\n       * or a mapping `Object`, like `{0:'1',9:'Target (10)', 15: 'Max'}`.\n       */\n      categories: {\n        type: Object,\n        reflectToAttribute: true,\n        observer: '__updateCategories'\n      },\n\n      /**\n       * Category-axis maximum value. Defaults to `undefined`.\n       */\n      categoryMax: {\n        type: Number,\n        observer: '__updateCategoryMax',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Category-axis minimum value. Defaults to `undefined`.\n       */\n      categoryMin: {\n        type: Number,\n        observer: '__updateCategoryMin',\n        reflectToAttribute: true\n      },\n\n      /**\n       * The position of the category axis. Acceptable values are `left`, `right`, `top` and `bottom`\n       * except for bar charts which only accept `left` and `right`.\n       * With the default value, charts appear as though they have `category-position=\"bottom\"`\n       * except for bar charts that appear as though they have `category-position=\"left\"`.\n       *\n       * Defaults to `undefined`\n       */\n      categoryPosition: {\n        type: String,\n        observer: '__updateCategoryPosition',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies whether to hide legend or show.\n       * Legend configuration can be set up via additionalOptions property\n       */\n      noLegend: {\n        type: Boolean,\n        observer: '__hideLegend',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies how series are stacked on top of each other.\n       * Possible values are null, \"normal\" or \"percent\".\n       * If \"stack\" property is not defined on the vaadin-chart-series elements, then series will be put into\n       * the default stack.\n       */\n      stacking: {\n        type: String,\n        observer: '__stackingObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies whether the chart is a normal chart or a timeline chart.\n       */\n      timeline: {\n        type: Boolean,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Represents the title of the chart.\n       */\n      title: {\n        type: String,\n        observer: '__updateTitle',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Whether or not to show tooltip when hovering data points.\n       */\n      tooltip: {\n        type: Boolean,\n        observer: '__tooltipObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Sets the default series type of the chart.\n       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type.\n       */\n      type: {\n        type: String,\n        observer: '__updateType',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Represents the subtitle of the chart.\n       */\n      subtitle: {\n        type: String,\n        observer: '__updateSubtitle',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies whether to show chart in 3 or in 2 dimensions.\n       * Some display angles are added by default to the \"chart.options3d\" (`{alpha: 15, beta: 15, depth: 50}`).\n       * 3D display options can be modified via `additionalOptions`.\n       * The thickness of a Pie chart can be set on `additionalOptions` through `plotOptions.pie.depth`.\n       * 3D is supported by Bar, Column, Pie and Scatter3D charts.\n       * More info available at [Highcharts](https://www.highcharts.com/docs/chart-concepts/3d-charts).\n       */\n      chart3d: {\n        type: Boolean,\n        observer: '__chart3dObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies the message displayed on a chart without displayable data.\n       */\n      emptyText: {\n        type: String,\n        value: ' ',\n        observer: '__emptyTextObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Represents additional JSON configuration.\n       */\n      additionalOptions: {\n        type: Object,\n        reflectToAttribute: true\n      },\n\n      /**\n       * When present, cartesian charts like line, spline, area and column are transformed\n       * into the polar coordinate system.\n       */\n      polar: {\n        type: Boolean,\n        reflectToAttribute: true,\n        observer: '__polarObserver'\n      }\n    };\n  }\n\n  static get observers() {\n    return ['__updateAdditionalOptions(additionalOptions.*)'];\n  }\n  /**\n   * @protected\n   */\n\n\n  static _finalizeClass() {\n    super._finalizeClass();\n\n    var devModeCallback = window.Vaadin.developmentModeCallback;\n    var licenseChecker = devModeCallback && devModeCallback['vaadin-license-checker'];\n\n    if (typeof licenseChecker === 'function') {\n      licenseChecker(ChartElement);\n    }\n  }\n\n  constructor() {\n    super();\n    /**\n     * List of properties that will always be copied from the chart element to the container div\n     **/\n\n    this._copyStyleProperties = ['flex', '-webkit-flex', '-ms-flex'];\n    this._baseConfig = {\n      credits: {\n        enabled: false\n      },\n      exporting: {\n        enabled: false\n      },\n      title: {\n        text: null\n      },\n      series: [],\n      xAxis: {},\n      yAxis: {\n        axisGenerated: true\n      }\n    };\n    this._baseChart3d = {\n      enabled: true,\n      alpha: 15,\n      beta: 15,\n      depth: 50\n    };\n    this.__mutationCallback = this.__mutationCallback.bind(this);\n  }\n  /** @private */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    this.__updateStyles();\n\n    beforeNextRender(this, () => {\n      // Detect if the chart had already been initialized. This might happen in\n      // environments where the chart is lazily attached (e.g Grid).\n      if (this.configuration) {\n        this.__reflow();\n\n        return;\n      }\n\n      var options = Object.assign({}, this.options, this._jsonConfigurationBuffer);\n      this._jsonConfigurationBuffer = null;\n\n      this.__initChart(options);\n\n      this.__addChildObserver();\n\n      var config = {\n        attributes: true,\n        characterData: true\n      };\n      this.__mutationObserver = new MutationObserver(this.__mutationCallback);\n\n      this.__mutationObserver.observe(this, config);\n    });\n  }\n\n  get options() {\n    var options = Object.assign({}, this._baseConfig);\n\n    ChartDeepMerger.__deepMerge(options, this.additionalOptions);\n\n    if (this.type) {\n      options.chart = options.chart || {};\n      options.chart.type = this.type;\n    }\n\n    if (this.polar) {\n      options.chart = options.chart || {};\n      options.chart.polar = true;\n    }\n\n    if (this.title) {\n      options.title = {\n        text: this.title\n      };\n    }\n\n    if (!options.tooltip) {\n      // Workaround for highcharts#7398 to make updating tooltip works\n      options.tooltip = {};\n\n      if (!this.tooltip) {\n        options.tooltip.enabled = false;\n      }\n    }\n\n    if (this.subtitle) {\n      options.subtitle = {\n        text: this.subtitle\n      };\n    }\n\n    if (this.categories) {\n      options.xAxis = options.xAxis || {};\n\n      if (Array.isArray(options.xAxis)) {\n        // Set categories on first x axis\n        options.xAxis[0].categories = this.categories;\n      } else {\n        options.xAxis.categories = this.categories;\n      }\n    }\n\n    if (isFinite(this.categoryMin)) {\n      options.xAxis = options.xAxis || {};\n\n      if (Array.isArray(options.xAxis)) {\n        // Set category-min on first x axis\n        options.xAxis[0].min = this.categoryMin;\n      } else {\n        options.xAxis.min = this.categoryMin;\n      }\n    }\n\n    if (isFinite(this.categoryMax)) {\n      options.xAxis = options.xAxis || {};\n\n      if (Array.isArray(options.xAxis)) {\n        // Set category-max on first x axis\n        options.xAxis[0].max = this.categoryMax;\n      } else {\n        options.xAxis.max = this.categoryMax;\n      }\n    }\n\n    if (this.noLegend) {\n      options.legend = {\n        enabled: false\n      };\n    }\n\n    if (this.emptyText) {\n      options.lang = options.lang || {};\n      options.lang.noData = this.emptyText;\n    }\n\n    if (this.categoryPosition) {\n      options.chart = options.chart || {};\n      options.chart.inverted = this.__shouldInvert();\n\n      if (Array.isArray(options.xAxis)) {\n        options.xAxis.forEach(e => e.opposite = this.__shouldFlipOpposite());\n      } else if (options.xAxis) {\n        options.xAxis.opposite = this.__shouldFlipOpposite();\n      }\n    }\n\n    if (this.stacking) {\n      options.plotOptions = options.plotOptions || {};\n      options.plotOptions.series = options.plotOptions.series || {};\n      options.plotOptions.series.stacking = this.stacking;\n    }\n\n    if (this.chart3d) {\n      options.chart = options.chart || {};\n      options.chart.options3d = Object.assign({}, this._baseChart3d, options.chart.options3d);\n    }\n\n    return options;\n  }\n  /**\n   *  Name of the chart events to add to the configuration and its corresponding event for the chart element\n   **/\n\n\n  get __chartEventNames() {\n    return {\n      /**\n       *\n       * @event chart-add-series  Fired when a new series is added\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      addSeries: 'chart-add-series',\n\n      /**\n       *\n       * @event chart-after-export  Fired after a chart is exported\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      afterExport: 'chart-after-export',\n\n      /**\n       *\n       * @event chart-after-print  Fired after a chart is printed\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      afterPrint: 'chart-after-print',\n\n      /**\n       *\n       * @event chart-before-export  Fired before a chart is exported\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      beforeExport: 'chart-before-export',\n\n      /**\n       *\n       * @event chart-before-print  Fired before a chart is printed\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      beforePrint: 'chart-before-print',\n\n      /**\n       *\n       * @event chart-click  Fired when clicking on the plot background\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      click: 'chart-click',\n\n      /**\n       *\n       * @event chart-drilldown  Fired when drilldown point is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      drilldown: 'chart-drilldown',\n\n      /**\n       *\n       * @event chart-drillup  Fired when drilling up from a drilldown series\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      drillup: 'chart-drillup',\n\n      /**\n       *\n       * @event chart-drillupall  Fired after all the series  has been drilled up\n       *                          if chart has multiple drilldown series\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      drillupall: 'chart-drillupall',\n\n      /**\n       *\n       * @event chart-load  Fired when the chart is finished loading\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      load: 'chart-load',\n\n      /**\n       *\n       * @event chart-redraw  Fired when the chart is redraw. Can be called after a `Chart.configuration.redraw()`\n       *                      or after an axis, series or point is modified with the `redraw` option set to `true`\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      redraw: 'chart-redraw',\n\n      /**\n       *\n       * @event chart-selection  Fired when an area of the chart has been selected\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      selection: 'chart-selection'\n    };\n  }\n  /**\n   *  Name of the series events to add to the configuration and its corresponding event for the chart element\n   **/\n\n\n  get __seriesEventNames() {\n    return {\n      /**\n       *\n       * @event series-after-animate  Fired when the series has finished its initial animation\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      afterAnimate: 'series-after-animate',\n\n      /**\n       *\n       * @event series-checkbox-click  Fired when the checkbox next to the series' name in the legend is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      checkboxClick: 'series-checkbox-click',\n\n      /**\n       *\n       * @event series-click  Fired when the series is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      click: 'series-click',\n\n      /**\n       *\n       * @event series-hide  Fired when the series is hidden after chart generation time\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      hide: 'series-hide',\n\n      /**\n       *\n       * @event series-legend-item-click  Fired when the legend item belonging to the series is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      legendItemClick: 'series-legend-item-click',\n\n      /**\n       *\n       * @event series-mouse-out  Fired when the mouses leave the graph\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      mouseOut: 'series-mouse-out',\n\n      /**\n       *\n       * @event series-mouse-over  Fired when the mouse enters the graph\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      mouseOver: 'series-mouse-over',\n\n      /**\n       *\n       * @event series-show  Fired when the series is show after chart generation time\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      show: 'series-show'\n    };\n  }\n  /**\n   *  Name of the point events to add to the configuration and its corresponding event for the chart element\n   **/\n\n\n  get __pointEventNames() {\n    return {\n      /**\n       *\n       * @event point-click  Fired when the point is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      click: 'point-click',\n\n      /**\n       *\n       * @event point-legend-item-click  Fired when the legend item belonging to the point is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      legendItemClick: 'point-legend-item-click',\n\n      /**\n       *\n       * @event point-mouse-out  Fired when the mouse leaves the area close to the point\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      mouseOut: 'point-mouse-out',\n\n      /**\n       *\n       * @event point-mouse-over  Fired when the mouse enters the area close to the point\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      mouseOver: 'point-mouse-over',\n\n      /**\n       *\n       * @event point-remove  Fired when the point is removed from the series\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      remove: 'point-remove',\n\n      /**\n       *\n       * @event point-select  Fired when the point is selected etheir programmatically or by clicking on the point\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      select: 'point-select',\n\n      /**\n       *\n       * @event point-unselect  Fired when the point is unselected etheir programmatically or by clicking on the point\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      unselect: 'point-unselect',\n\n      /**\n       *\n       * @event point-update  Fired when the point is updated programmatically through `.update()` method\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      update: 'point-update'\n    };\n  }\n\n  get __xAxesEventNames() {\n    return {\n      /**\n       *\n       * @event xaxes-extremes-set  Fired when when the minimum and maximum is set for the x axis\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} axis Point object where the event was sent from\n       */\n      afterSetExtremes: 'xaxes-extremes-set'\n    };\n  }\n\n  get __yAxesEventNames() {\n    return {\n      /**\n       *\n       * @event yaxes-extremes-set  Fired when when the minimum and maximum is set for the y axis\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} axis Point object where the event was sent from\n       */\n      afterSetExtremes: 'yaxes-extremes-set'\n    };\n  }\n\n  __reflow() {\n    if (!this.configuration) {\n      return;\n    }\n\n    beforeNextRender(this, () => {\n      this.configuration.reflow();\n    });\n  }\n\n  __mutationCallback() {\n    var {\n      height: componentHeight\n    } = this.getBoundingClientRect();\n    var {\n      chartHeight\n    } = this.configuration;\n\n    if (componentHeight !== chartHeight) {\n      this.__reflow();\n    }\n  }\n\n  __addChildObserver() {\n    beforeNextRender(this, () => {\n      this._childObserver = new FlattenedNodesObserver(this.$.slot, info => {\n        this.__addSeries(info.addedNodes.filter(this.__filterSeriesNodes));\n\n        this.__removeSeries(info.removedNodes.filter(this.__filterSeriesNodes));\n\n        this.__cleanupAfterSeriesRemoved(info.removedNodes.filter(this.__filterSeriesNodes));\n      });\n    });\n  }\n\n  __filterSeriesNodes(node) {\n    return node.nodeType === Node.ELEMENT_NODE && node instanceof ChartSeriesElement;\n  }\n\n  __addSeries(series) {\n    if (this.__isSeriesEmpty(series)) {\n      return;\n    }\n\n    var seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);\n    var yAxes = this.configuration.yAxis.reduce((acc, axis, index) => {\n      acc[axis.options.id || index] = axis;\n      return acc;\n    }, {});\n\n    for (var i = 0, len = series.length; i < len; i++) {\n      var seriesElement = series[i];\n      var {\n        yAxis: unit,\n        yAxisValueMin: valueMin,\n        yAxisValueMax: valueMax\n      } = seriesElement.options;\n      var idxOnChildList = seriesNodes.indexOf(seriesElement);\n\n      if (!unit && !this.configuration.yAxis.some(e => e.userOptions.id === undefined)) {\n        yAxes[unit] = this.__addAxis({\n          axisGenerated: true\n        });\n      } else if (unit && !yAxes[unit]) {\n        yAxes[unit] = this.__addAxis({\n          id: unit,\n          title: {\n            text: unit\n          },\n          axisGenerated: true\n        });\n      }\n\n      if (isFinite(valueMin)) {\n        this.__setYAxisProps(yAxes, unit, {\n          min: valueMin\n        });\n      }\n\n      if (isFinite(valueMax)) {\n        this.__setYAxisProps(yAxes, unit, {\n          max: valueMax\n        });\n      }\n\n      var seriesConfiguration = this.__updateOrAddSeriesInstance(seriesElement.options, idxOnChildList);\n\n      seriesElement.setSeries(seriesConfiguration);\n    }\n\n    this.__removeAxisIfEmpty();\n  }\n\n  __removeSeries(seriesNodes) {\n    if (this.__isSeriesEmpty(seriesNodes)) {\n      return;\n    }\n\n    seriesNodes.forEach(series => {\n      if (series instanceof ChartSeriesElement) {\n        series._series.remove();\n      }\n    });\n  }\n\n  __setYAxisProps(yAxes, yAxisId, props) {\n    if (yAxisId) {\n      yAxes[yAxisId].update(props);\n    } else {\n      this.configuration.yAxis[0].update(props);\n    }\n  }\n\n  __isSeriesEmpty(series) {\n    return series === null || series.length === 0;\n  }\n\n  __cleanupAfterSeriesRemoved(series) {\n    if (this.__isSeriesEmpty(series)) {\n      return;\n    }\n\n    this.__removeAxisIfEmpty(); // Best effort to make chart display custom empty-text messages when series are removed.\n    // This is needed because Highcharts currently doesn't react. A condition not catered for is\n    // when all points are removed from all series without removing any series.\n\n\n    var isEmpty = this.configuration.series.length === 0 || this.configuration.series.map(e => e.data.length === 0).reduce((e1, e2) => e1 && e2, true);\n\n    if (isEmpty) {\n      this.configuration.hideNoData();\n      this.configuration.showNoData(this.emptyText);\n    }\n  }\n\n  __initChart(options) {\n    this.__initEventsListeners(options); // Workaround for https://github.com/highcharts/highcharts/issues/7523\n\n\n    this.__ensureObjectPath(options, 'drilldown.activeDataLabelStyle');\n\n    if (this.timeline) {\n      this.configuration = Highcharts.stockChart(this.$.chart, options);\n    } else {\n      this.configuration = Highcharts.chart(this.$.chart, options);\n    } // Workaround for https://github.com/highcharts/highcharts/issues/9978\n\n\n    var elementsToChange = [...Array.from(this.$.chart.getElementsByTagName('h4')).filter(el => el.style.left === '-9999px'), this.configuration.screenReaderRegion, this.configuration.tabExitAnchor];\n    elementsToChange.forEach(el => {\n      if (el && el.style) {\n        el.style.left = '';\n        el.style.top = '-999em';\n      }\n    });\n  }\n  /** @private */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__mutationObserver && this.__mutationObserver.disconnect();\n    this._childObserver && this._childObserver.disconnect();\n  }\n  /**\n   * Search for axis with given `id`.\n   *\n   * @param {String} id contains the id that will be searched\n   * @param {Boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.\n   */\n\n\n  __getAxis(id, isXAxis) {\n    id = Number.parseInt(id) || id;\n\n    if (this.configuration) {\n      return (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).find(axis => axis.options.id === id);\n    }\n  }\n  /**\n   * Add an axis with given options\n   *\n   * @param {Object} options axis options\n   * @param {Boolean} isXAxis indicates if axis is X (`true`) or Y (`false`). Defaults to `false`.\n   */\n\n\n  __addAxis(options, isXAxis) {\n    if (this.configuration) {\n      this.__createEventListeners(isXAxis ? this.__xAxesEventNames : this.__yAxesEventNames, options, 'events', 'axis');\n\n      return this.configuration.addAxis(options, isXAxis);\n    }\n  }\n  /**\n   * Iterates over axes (y or x) and removes whenever it doesn't contain any series and was created for unit\n   *\n   * @param {Boolean}  isXAxis indicates if it will remove x or y axes. Defaults to `false`.\n   */\n\n\n  __removeAxisIfEmpty(isXAxis) {\n    if (this.configuration) {\n      (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).forEach(axis => {\n        if (axis.userOptions.axisGenerated && axis.series.length === 0) {\n          axis.remove();\n        }\n      });\n    }\n  }\n  /**\n   * Update the chart configuration.\n   * This JSON API provides a simple single-argument alternative to the configuration property.\n   *\n   * Styling properties specified in this configuration will be ignored. To learn about chart styling\n   * please see the CSS Styling section above.\n   *\n   * @param {Object} jsonConfiguration Object chart configuration. Most important properties are:\n   *\n   * - chart `Object` with options regarding the chart area and plot area as well as general chart options.\n   *    Detailed API for chart object is available in [API Site](http://api.highcharts.com/highcharts/chart)\n   * - credits `Object` with options regarding the chart area and plot area as well as general chart options.\n   *    Detailed API for credits object is available in [API Site](http://api.highcharts.com/highcharts/credits)\n   * - labels `Object[]` with HTML labels that can be positioned anywhere in the chart area\n   *    Detailed API for labels object is available in [API Site](http://api.highcharts.com/highcharts/labels)\n   * - plotOptions `Object` wrapper for config objects for each series type.\n   *    Detailed API for plotOptions object is available in [API Site](http://api.highcharts.com/highcharts/plotOptions)\n   * - series `Object[]` the actual series to append to the chart.\n   *    Detailed API for series object is available in [API Site](http://api.highcharts.com/highcharts/series)\n   * - subtitle `Object` the chart's subtitle.\n   *    Detailed API for subtitle object is available in [API Site](http://api.highcharts.com/highcharts/subtitle)\n   * - title `Object` the chart's main title.\n   *    Detailed API for title object is available in [API Site](http://api.highcharts.com/highcharts/title)\n   * - tooltip `Object` Options for the tooltip that appears when the user hovers over a series or point.\n   *    Detailed API for tooltip object is available in [API Site](http://api.highcharts.com/highcharts/tooltip)\n   * - xAxis `Object[]` The X axis or category axis. Normally this is the horizontal axis.\n   *    Detailed API for xAxis object is available in [API Site](http://api.highcharts.com/highcharts/xAxis)\n   * - yAxis `Object[]` The Y axis or value axis. Normally this is the vertical axis.\n   *    Detailed API for yAxis object is available in [API Site](http://api.highcharts.com/highcharts/yAxis)\n   * - zAxis `Object[]` The Z axis or depth axis for 3D plots.\n   *    Detailed API for zAxis object is available in [API Site](http://api.highcharts.com/highcharts/zAxis)\n   *\n   * @param {Boolean} resetConfiguration Optional boolean that should be set to true if no other chart configuration was set before or\n   *    if existing configuration should be discarded.\n   */\n\n\n  update(jsonConfiguration, resetConfiguration) {\n    if (resetConfiguration || !this._jsonConfigurationBuffer) {\n      this._jsonConfigurationBuffer = {};\n    }\n\n    var configCopy = ChartDeepMerger.__deepMerge({}, jsonConfiguration);\n\n    this.__inflateFunctions(configCopy);\n\n    this._jsonConfigurationBuffer = this.__makeConfigurationBuffer(this._jsonConfigurationBuffer, configCopy);\n    beforeNextRender(this, () => {\n      if (!this.configuration || !this._jsonConfigurationBuffer) {\n        return;\n      }\n\n      if (resetConfiguration) {\n        var initialOptions = Object.assign({}, this.options, this._jsonConfigurationBuffer);\n\n        this.__initChart(initialOptions);\n\n        this._jsonConfigurationBuffer = null;\n        return;\n      }\n\n      this.configuration.update(this._jsonConfigurationBuffer);\n\n      if (this._jsonConfigurationBuffer.credits) {\n        this.__updateOrAddCredits(this._jsonConfigurationBuffer.credits);\n      }\n\n      if (this._jsonConfigurationBuffer.xAxis) {\n        this.__updateOrAddAxes(this._jsonConfigurationBuffer.xAxis, true);\n      }\n\n      if (this._jsonConfigurationBuffer.yAxis) {\n        this.__updateOrAddAxes(this._jsonConfigurationBuffer.yAxis, false);\n      }\n\n      if (this._jsonConfigurationBuffer.series) {\n        this.__updateOrAddSeries(this._jsonConfigurationBuffer.series);\n      }\n\n      this._jsonConfigurationBuffer = null;\n    });\n  }\n\n  __makeConfigurationBuffer(target, source) {\n    var _source = Highcharts.merge(source);\n\n    var _target = Highcharts.merge(target);\n\n    this.__mergeConfigurationArray(_target, _source, 'series');\n\n    this.__mergeConfigurationArray(_target, _source, 'xAxis');\n\n    this.__mergeConfigurationArray(_target, _source, 'yAxis');\n\n    return Highcharts.merge(_target, _source);\n  }\n\n  __mergeConfigurationArray(target, configuration, entry) {\n    if (!configuration || !configuration[entry] || !Array.isArray(configuration[entry])) {\n      return;\n    }\n\n    if (!target[entry]) {\n      target[entry] = Array.from(configuration[entry]);\n      return;\n    }\n\n    var maxLength = Math.max(target[entry].length, configuration[entry].length);\n\n    for (var i = 0; i < maxLength; i++) {\n      target[entry][i] = Highcharts.merge(target[entry][i], configuration[entry][i]);\n    }\n\n    delete configuration[entry];\n  }\n\n  __inflateFunctions(jsonConfiguration) {\n    for (var attr in jsonConfiguration) {\n      if (jsonConfiguration.hasOwnProperty(attr)) {\n        var targetProperty = jsonConfiguration[attr];\n\n        if (attr.indexOf('_fn_') === 0 && (typeof targetProperty === 'string' || targetProperty instanceof String)) {\n          try {\n            jsonConfiguration[attr.substr(4)] = eval('(' + targetProperty + ')');\n          } catch (e) {\n            jsonConfiguration[attr.substr(4)] = eval('(function(){' + targetProperty + '})');\n          }\n\n          delete jsonConfiguration[attr];\n        } else if (targetProperty instanceof Object) {\n          this.__inflateFunctions(targetProperty);\n        }\n      }\n    }\n  }\n\n  __initEventsListeners(configuration) {\n    this.__initChartEventsListeners(configuration);\n\n    this.__initSeriesEventsListeners(configuration);\n\n    this.__initPointsEventsListeners(configuration);\n\n    this.__initAxisEventsListeners(configuration, true);\n\n    this.__initAxisEventsListeners(configuration, false);\n  }\n\n  __initChartEventsListeners(configuration) {\n    this.__createEventListeners(this.__chartEventNames, configuration, 'chart.events', 'chart');\n  }\n\n  __initSeriesEventsListeners(configuration) {\n    this.__createEventListeners(this.__seriesEventNames, configuration, 'plotOptions.series.events', 'series');\n  }\n\n  __initPointsEventsListeners(configuration) {\n    this.__createEventListeners(this.__pointEventNames, configuration, 'plotOptions.series.point.events', 'point');\n  }\n\n  __initAxisEventsListeners(configuration, isXAxis) {\n    var eventNames, axes;\n\n    if (isXAxis) {\n      eventNames = this.__xAxesEventNames;\n      axes = configuration.xAxis;\n    } else {\n      eventNames = this.__yAxesEventNames;\n      axes = configuration.yAxis;\n    }\n\n    if (Array.isArray(axes)) {\n      axes.forEach(axis => this.__createEventListeners(eventNames, axis, 'events', 'axis'));\n    } else {\n      this.__createEventListeners(eventNames, axes, 'events', 'axis');\n    }\n  }\n\n  __createEventListeners(eventList, configuration, pathToAdd, eventType) {\n    var _this = this;\n\n    var self = this;\n\n    var eventObject = this.__ensureObjectPath(configuration, pathToAdd);\n\n    var _loop = function (keys, i) {\n      var key = keys[i];\n\n      if (!eventObject[key]) {\n        var chart = _this;\n\n        eventObject[key] = function (event) {\n          var customEvent = {\n            bubbles: false,\n            composed: true,\n            detail: {\n              originalEvent: event,\n              [eventType]: this\n            }\n          };\n\n          if (event.type === 'afterSetExtremes') {\n            if (event.min == null || event.max == null) {\n              return;\n            }\n          } // Workaround for vaadin-charts-flow because of https://github.com/vaadin/flow/issues/3102\n\n\n          if (event.type === 'selection') {\n            if (event.xAxis && event.xAxis[0]) {\n              customEvent.detail.xAxisMin = event.xAxis[0].min;\n              customEvent.detail.xAxisMax = event.xAxis[0].max;\n            }\n\n            if (event.yAxis && event.yAxis[0]) {\n              customEvent.detail.yAxisMin = event.yAxis[0].min;\n              customEvent.detail.yAxisMax = event.yAxis[0].max;\n            }\n          }\n\n          if (event.type === 'click') {\n            if (event.xAxis && event.xAxis[0]) {\n              customEvent.detail.xValue = event.xAxis[0].value;\n            }\n\n            if (event.yAxis && event.yAxis[0]) {\n              customEvent.detail.yValue = event.yAxis[0].value;\n            }\n          } // Workaround for https://github.com/vaadin/vaadin-charts/issues/389\n          // Hook into beforePrint and beforeExport to ensure correct styling\n\n\n          if (['beforePrint', 'beforeExport'].indexOf(event.type) >= 0) {\n            // Guard against another print 'before print' event coming before\n            // the 'after print' event.\n            if (!this.tempBodyStyle) {\n              var effectiveCss = '';\n\n              if (nativeShadow) {\n                var shadowStyles = self.shadowRoot.querySelectorAll('style');\n\n                for (var _i = 0; _i < shadowStyles.length; _i++) {\n                  effectiveCss = effectiveCss + shadowStyles[_i].textContent;\n                } // Strip off host selectors that target individual instances\n\n\n                effectiveCss = effectiveCss.replace(/:host\\(.+?\\)/g, match => {\n                  var selector = match.substr(6, match.length - 7);\n                  var matchesFn = self.matches || self.msMatchesSelector;\n                  return matchesFn.call(self, selector) ? '' : match;\n                });\n              } else {\n                effectiveCss = ScopingShim.prototype.styleAstToString(ScopingShim.prototype._styleInfoForNode(self)._getStyleRules()); // Remove the style scopes added by ShadyCSS\n                // e.g. '.vaadin-chart-1 .highcharts-container.vaadin-chart'\n                //   -> '.highcharts-container'\n                // 1. Web Component instance scope\n\n                var match = self.className.match(/\\bvaadin-chart-\\d+\\b/);\n\n                if (match) {\n                  effectiveCss = effectiveCss.replace(new RegExp('\\\\.' + match[0], 'g'), '');\n                } // 2. Web Component tag scope\n\n\n                effectiveCss = effectiveCss.replace(/\\.vaadin-chart/g, '');\n              } // Zoom out a bit to avoid clipping the chart's edge on paper\n\n\n              effectiveCss = effectiveCss + +'body {' + '    -moz-transform: scale(0.9, 0.9);' + // Mozilla\n              '    zoom: 0.9;' + // Others\n              '    zoom: 90%;' + // Webkit\n              '}';\n              this.tempBodyStyle = document.createElement('style');\n              this.tempBodyStyle.textContent = effectiveCss;\n              document.body.appendChild(this.tempBodyStyle);\n            }\n          } // Hook into afterPrint and afterExport to revert changes made before\n\n\n          if (['afterPrint', 'afterExport'].indexOf(event.type) >= 0) {\n            if (this.tempBodyStyle) {\n              document.body.removeChild(this.tempBodyStyle);\n              delete this.tempBodyStyle;\n            }\n          }\n\n          self.dispatchEvent(new CustomEvent(eventList[key], customEvent));\n\n          if (event.type === 'legendItemClick' && chart['_visibilityTogglingDisabled']) {\n            return false;\n          }\n        };\n      }\n    };\n\n    for (var keys = Object.keys(eventList), i = 0; i < keys.length; i++) {\n      _loop(keys, i);\n    }\n  }\n\n  __ensureObjectPath(object, path) {\n    if (typeof path !== 'string') {\n      return;\n    }\n\n    path = path.split('.');\n    return path.reduce((obj, key) => {\n      obj[key] = obj[key] || {};\n      return obj[key];\n    }, object);\n  }\n\n  __updateOrAddCredits(credits) {\n    if (this.configuration.credits) {\n      this.configuration.credits.update(credits);\n    } else {\n      this.configuration.addCredits(credits);\n    }\n  }\n\n  __updateOrAddAxes(axes, isX) {\n    if (!Array.isArray(axes)) {\n      axes = [axes];\n    }\n\n    var confAxes = isX ? this.configuration.xAxis : this.configuration.yAxis;\n\n    for (var i = 0; i < axes.length; i++) {\n      var axis = axes[i];\n\n      if (confAxes[i]) {\n        confAxes[i].update(axis);\n      } else {\n        this.configuration.addAxis(axis, isX);\n      }\n    }\n  }\n\n  __updateOrAddSeries(series) {\n    if (!Array.isArray(series)) {\n      throw new Error('The type of jsonConfiguration.series should be Object[]');\n    }\n\n    for (var i = 0; i < series.length; i++) {\n      var currentSeries = series[i];\n\n      this.__updateOrAddSeriesInstance(currentSeries, i);\n    }\n  }\n\n  __updateOrAddSeriesInstance(seriesOptions, position) {\n    if (this.configuration.series[position]) {\n      this.configuration.series[position].update(seriesOptions);\n    } else {\n      this.configuration.addSeries(seriesOptions);\n    }\n\n    return this.configuration.series[position];\n  }\n\n  __updateCategories() {\n    if (!this.configuration) {\n      return;\n    }\n\n    this.__updateOrAddAxes([{\n      categories: this.categories\n    }], true);\n  }\n\n  __updateCategoryMax() {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (!isFinite(this.categoryMax)) {\n      console.warn('<vaadin-chart> Acceptable value for \"category-max\" are Numbers or null');\n      return;\n    }\n\n    this.__updateOrAddAxes([{\n      max: this.categoryMax\n    }], true);\n  }\n\n  __updateCategoryMin() {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (!isFinite(this.categoryMin)) {\n      console.warn('<vaadin-chart> Acceptable value for \"category-min\" are Numbers or null');\n      return;\n    }\n\n    this.__updateOrAddAxes([{\n      min: this.categoryMin\n    }], true);\n  }\n\n  __shouldInvert() {\n    // A bar chart will never be inverted, consider using a column chart.\n    // See https://stackoverflow.com/questions/11235251#answer-21739793\n    if (this.type === 'bar' && ['top', 'bottom'].indexOf(this.categoryPosition) >= 0) {\n      console.warn(`<vaadin-chart> Acceptable \"category-position\" values for bar charts are\n          \"left\" and \"right\". For \"top\" and \"bottom\" positions please consider using a column chart.`);\n      return;\n    }\n\n    var inverted = ['left', 'right'];\n    return inverted.indexOf(this.categoryPosition) >= 0;\n  }\n\n  __shouldFlipOpposite() {\n    var opposite = ['top', 'right'];\n    var oppositeBar = ['right'];\n    return (this.type === 'bar' ? oppositeBar : opposite).indexOf(this.categoryPosition) >= 0;\n  }\n\n  __updateCategoryPosition() {\n    if (!this.configuration) {\n      return;\n    }\n\n    var validPositions = ['left', 'right', 'top', 'bottom'];\n\n    if (validPositions.indexOf(this.categoryPosition) < 0) {\n      console.warn(`<vaadin-chart> Acceptable \"category-position\" values are ${validPositions}`);\n      return;\n    }\n\n    this.configuration.update({\n      chart: {\n        inverted: this.__shouldInvert()\n      }\n    });\n    this.configuration.xAxis.forEach(e => e.update({\n      opposite: this.__shouldFlipOpposite()\n    }));\n  }\n\n  __hideLegend(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (this.configuration.legend) {\n      this.configuration.legend.update({\n        enabled: !newValue\n      });\n    } else {\n      this.configuration.legend = {\n        enabled: !newValue\n      };\n    }\n  }\n\n  __updateTitle(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (newValue && newValue.length > 0) {\n      this.configuration.title.update({\n        text: newValue\n      });\n    }\n  }\n\n  __tooltipObserver(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    this.configuration.tooltip.update({\n      enabled: this.tooltip\n    });\n  }\n\n  __updateType(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (newValue && newValue.length > 0) {\n      this.configuration.update({\n        chart: {\n          type: newValue\n        }\n      });\n    }\n  }\n\n  __updateSubtitle(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (newValue && newValue.length > 0) {\n      if (!this.configuration.subtitle) {\n        this.configuration.setSubtitle({\n          text: newValue\n        });\n      } else {\n        this.configuration.subtitle.update({\n          text: newValue\n        });\n      }\n    }\n  }\n\n  __updateAdditionalOptions() {\n    if (this.configuration) {\n      this.update(this.additionalOptions);\n    }\n  }\n\n  __isStackingValid() {\n    if (['normal', 'percent', null].indexOf(this.stacking) === -1) {\n      this.__showWarn('stacking', '\"normal\", \"percent\" or null');\n\n      return false;\n    }\n\n    return true;\n  }\n\n  __stackingObserver() {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (!this.__isStackingValid()) {\n      this.stacking = null;\n      return;\n    }\n\n    this.configuration.update({\n      plotOptions: {\n        series: {\n          stacking: this.stacking\n        }\n      }\n    });\n  }\n\n  __chart3dObserver() {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (this.chart3d) {\n      this.configuration.update({\n        chart: {\n          options3d: Object.assign({}, this._baseChart3d, this.additionalOptions && this.additionalOptions.chart && this.additionalOptions.chart.options3d, {\n            enabled: true\n          })\n        }\n      });\n    } else {\n      this.configuration.update({\n        chart: {\n          options3d: {\n            enabled: false\n          }\n        }\n      });\n    }\n  }\n\n  __polarObserver() {\n    if (!this.configuration) {\n      return;\n    }\n\n    this.configuration.update({\n      chart: {\n        polar: this.polar\n      }\n    });\n  }\n\n  __emptyTextObserver() {\n    if (!this.configuration) {\n      return;\n    }\n\n    this.configuration.update({\n      lang: {\n        noData: this.emptyText\n      }\n    });\n    this.configuration.hideNoData();\n    this.configuration.showNoData(this.emptyText);\n  }\n\n  __callChartFunction(functionName) {\n    if (this.configuration) {\n      var functionToCall = this.configuration[functionName];\n      var argumentsForCall = Array.prototype.splice.call(arguments, 1);\n\n      if (functionToCall && typeof functionToCall === 'function') {\n        functionToCall.apply(this.configuration, argumentsForCall);\n      }\n    }\n  }\n\n  __callSeriesFunction(functionName, seriesIndex) {\n    if (this.configuration && this.configuration.series[seriesIndex]) {\n      var series = this.configuration.series[seriesIndex];\n      var functionToCall = series[functionName];\n      var argumentsForCall = Array.prototype.splice.call(arguments, 2);\n\n      if (functionToCall && typeof functionToCall === 'function') {\n        functionToCall.apply(series, argumentsForCall);\n      }\n    }\n  }\n\n  __callAxisFunction(functionName, axisCategory, axisIndex) {\n    /*\n     * axisCategory:\n     * 0 - xAxis\n     * 1 - yAxis\n     * 2 - zAxis\n     * 3 - colorAxis\n     */\n    if (this.configuration) {\n      var axes;\n\n      switch (axisCategory) {\n        case 0:\n          axes = this.configuration.xAxis;\n          break;\n\n        case 1:\n          axes = this.configuration.yAxis;\n          break;\n\n        case 2:\n          axes = this.configuration.zAxis;\n          break;\n\n        case 3:\n          axes = this.configuration.colorAxis;\n          break;\n      }\n\n      if (axes && axes[axisIndex]) {\n        var axis = axes[axisIndex];\n        var functionToCall = axis[functionName];\n        var argumentsForCall = Array.prototype.splice.call(arguments, 3);\n\n        if (functionToCall && typeof functionToCall === 'function') {\n          functionToCall.apply(axis, argumentsForCall);\n        }\n      }\n    }\n  }\n\n  __callPointFunction(functionName, seriesIndex, pointIndex) {\n    if (this.configuration && this.configuration.series[seriesIndex] && this.configuration.series[seriesIndex].data[pointIndex]) {\n      var point = this.configuration.series[seriesIndex].data[pointIndex];\n      var functionToCall = point[functionName];\n      var argumentsForCall = Array.prototype.splice.call(arguments, 3);\n\n      if (functionToCall && typeof functionToCall === 'function') {\n        functionToCall.apply(point, argumentsForCall);\n      }\n    }\n  }\n  /**\n   * Updates chart container and current chart style property depending on flex status\n   */\n\n\n  __updateStyles() {\n    // Chrome returns default value if property is not set\n    // check if flex is defined for chart, and different than default value\n    var isFlex = this._copyStyleProperties.some(property => getComputedStyle(this)[property] && getComputedStyle(this)[property] != '0 1 auto', this); // If chart element is a flexible item the chartContainer should be flex too\n\n\n    if (isFlex) {\n      this.$.chart.setAttribute('style', 'flex: 1; -webkit-flex: 1; -ms-flex: 1; ');\n      var style = '';\n\n      if (this.hasAttribute('style')) {\n        style = this.getAttribute('style');\n\n        if (style.charAt(style.length - 1) !== ';') {\n          style += ';';\n        }\n      }\n\n      style += 'display: -ms-flexbox; display: -webkit-flex; display: flex;';\n      this.setAttribute('style', style);\n    } else {\n      this.$.chart.setAttribute('style', 'height:100%; width:100%;');\n    }\n  }\n\n}\n\ncustomElements.define(ChartElement.is, ChartElement);\nexport { ChartElement };"
    },
    {
     "id": 305,
     "name": "../node_modules/highcharts/js/es-modules/mixins/centered-series.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * @private\n * @typedef Highcharts.RadianAngles\n *\n * @property {number} start\n *\n * @property {number} end\n */\n'use strict';\n\nimport H from '../parts/Globals.js';\nimport '../parts/Utilities.js';\nvar deg2rad = H.deg2rad,\n    isNumber = H.isNumber,\n    pick = H.pick,\n    relativeLength = H.relativeLength;\n/**\n * @private\n * @mixin Highcharts.CenteredSeriesMixin\n */\n\nH.CenteredSeriesMixin = {\n  /**\n   * Get the center of the pie based on the size and center options relative\n   * to the plot area. Borrowed by the polar and gauge series types.\n   *\n   * @private\n   * @function Highcharts.CenteredSeriesMixin.getCenter\n   *\n   * @return {Array<number>}\n   */\n  getCenter: function () {\n    var options = this.options,\n        chart = this.chart,\n        slicingRoom = 2 * (options.slicedOffset || 0),\n        handleSlicingRoom,\n        plotWidth = chart.plotWidth - 2 * slicingRoom,\n        plotHeight = chart.plotHeight - 2 * slicingRoom,\n        centerOption = options.center,\n        positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n        smallestSize = Math.min(plotWidth, plotHeight),\n        i,\n        value;\n\n    for (i = 0; i < 4; ++i) {\n      value = positions[i];\n      handleSlicingRoom = i < 2 || i === 2 && /%$/.test(value); // i == 0: centerX, relative to width\n      // i == 1: centerY, relative to height\n      // i == 2: size, relative to smallestSize\n      // i == 3: innerSize, relative to size\n\n      positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);\n    } // innerSize cannot be larger than size (#3632)\n\n\n    if (positions[3] > positions[2]) {\n      positions[3] = positions[2];\n    }\n\n    return positions;\n  },\n\n  /**\n   * getStartAndEndRadians - Calculates start and end angles in radians.\n   * Used in series types such as pie and sunburst.\n   *\n   * @private\n   * @function Highcharts.CenteredSeriesMixin.getStartAndEndRadians\n   *\n   * @param {number} start\n   *        Start angle in degrees.\n   *\n   * @param {number} end\n   *        Start angle in degrees.\n   *\n   * @return {Highcharts.RadianAngles}\n   *         Returns an object containing start and end angles as radians.\n   */\n  getStartAndEndRadians: function getStartAndEndRadians(start, end) {\n    var startAngle = isNumber(start) ? start : 0,\n        // must be a number\n    endAngle = isNumber(end) && // must be a number\n    end > startAngle && // must be larger than the start angle\n    // difference must be less than 360 degrees\n    end - startAngle < 360 ? end : startAngle + 360,\n        correction = -90;\n    return {\n      start: deg2rad * (startAngle + correction),\n      end: deg2rad * (endAngle + correction)\n    };\n  }\n};"
    },
    {
     "id": 306,
     "name": "../node_modules/highcharts/js/es-modules/parts/Interaction.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Chart.js';\nimport './Options.js';\nimport './Legend.js';\nimport './Point.js';\nimport './Series.js';\nvar addEvent = H.addEvent,\n    Chart = H.Chart,\n    createElement = H.createElement,\n    css = H.css,\n    defaultOptions = H.defaultOptions,\n    defaultPlotOptions = H.defaultPlotOptions,\n    each = H.each,\n    extend = H.extend,\n    fireEvent = H.fireEvent,\n    hasTouch = H.hasTouch,\n    inArray = H.inArray,\n    isObject = H.isObject,\n    Legend = H.Legend,\n    merge = H.merge,\n    pick = H.pick,\n    Point = H.Point,\n    Series = H.Series,\n    seriesTypes = H.seriesTypes,\n    svg = H.svg,\n    TrackerMixin;\n/**\n * TrackerMixin for points and graphs.\n *\n * @ignore\n */\n\nTrackerMixin = H.TrackerMixin = {\n  /**\n   * Draw the tracker for a point.\n   */\n  drawTrackerPoint: function () {\n    var series = this,\n        chart = series.chart,\n        pointer = chart.pointer,\n        onMouseOver = function (e) {\n      var point = pointer.getPointFromEvent(e); // undefined on graph in scatterchart\n\n      if (point !== undefined) {\n        pointer.isDirectTouch = true;\n        point.onMouseOver(e);\n      }\n    }; // Add reference to the point\n\n\n    each(series.points, function (point) {\n      if (point.graphic) {\n        point.graphic.element.point = point;\n      }\n\n      if (point.dataLabel) {\n        if (point.dataLabel.div) {\n          point.dataLabel.div.point = point;\n        } else {\n          point.dataLabel.element.point = point;\n        }\n      }\n    }); // Add the event listeners, we need to do this only once\n\n    if (!series._hasTracking) {\n      each(series.trackerGroups, function (key) {\n        if (series[key]) {\n          // we don't always have dataLabelsGroup\n          series[key].addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function (e) {\n            pointer.onTrackerMouseOut(e);\n          });\n\n          if (hasTouch) {\n            series[key].on('touchstart', onMouseOver);\n          }\n        }\n      });\n      series._hasTracking = true;\n    }\n\n    fireEvent(this, 'afterDrawTracker');\n  },\n\n  /**\n   * Draw the tracker object that sits above all data labels and markers to\n   * track mouse events on the graph or points. For the line type charts\n   * the tracker uses the same graphPath, but with a greater stroke width\n   * for better control.\n   */\n  drawTrackerGraph: function () {\n    var series = this,\n        options = series.options,\n        trackByArea = options.trackByArea,\n        trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n        trackerPathLength = trackerPath.length,\n        chart = series.chart,\n        pointer = chart.pointer,\n        renderer = chart.renderer,\n        snap = chart.options.tooltip.snap,\n        tracker = series.tracker,\n        i,\n        onMouseOver = function () {\n      if (chart.hoverSeries !== series) {\n        series.onMouseOver();\n      }\n    },\n\n    /*\n     * Empirical lowest possible opacities for TRACKER_FILL for an\n     * element to stay invisible but clickable\n     * IE6: 0.002\n     * IE7: 0.002\n     * IE8: 0.002\n     * IE9: 0.00000000001 (unlimited)\n     * IE10: 0.0001 (exporting only)\n     * FF: 0.00000000001 (unlimited)\n     * Chrome: 0.000001\n     * Safari: 0.000001\n     * Opera: 0.00000000001 (unlimited)\n     */\n    TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')'; // Extend end points. A better way would be to use round linecaps,\n    // but those are not clickable in VML.\n\n\n    if (trackerPathLength && !trackByArea) {\n      i = trackerPathLength + 1;\n\n      while (i--) {\n        if (trackerPath[i] === 'M') {\n          // extend left side\n          trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');\n        }\n\n        if (i && trackerPath[i] === 'M' || i === trackerPathLength) {\n          // extend right side\n          trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);\n        }\n      }\n    } // draw the tracker\n\n\n    if (tracker) {\n      tracker.attr({\n        d: trackerPath\n      });\n    } else if (series.graph) {\n      // create\n      series.tracker = renderer.path(trackerPath).attr({\n        visibility: series.visible ? 'visible' : 'hidden',\n        zIndex: 2\n      }).addClass(trackByArea ? 'highcharts-tracker-area' : 'highcharts-tracker-line').add(series.group); // The tracker is added to the series group, which is clipped, but\n      // is covered by the marker group. So the marker group also needs to\n      // capture events.\n\n      each([series.tracker, series.markerGroup], function (tracker) {\n        tracker.addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function (e) {\n          pointer.onTrackerMouseOut(e);\n        });\n\n        if (hasTouch) {\n          tracker.on('touchstart', onMouseOver);\n        }\n      });\n    }\n\n    fireEvent(this, 'afterDrawTracker');\n  }\n};\n/* End TrackerMixin */\n\n/**\n * Add tracking event listener to the series group, so the point graphics\n * themselves act as trackers\n */\n\nif (seriesTypes.column) {\n  seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\nif (seriesTypes.pie) {\n  seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\nif (seriesTypes.scatter) {\n  seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n/*\n * Extend Legend for item events\n */\n\n\nextend(Legend.prototype, {\n  setItemEvents: function (item, legendItem, useHTML) {\n    var legend = this,\n        boxWrapper = legend.chart.renderer.boxWrapper,\n        activeClass = 'highcharts-legend-' + (item instanceof Point ? 'point' : 'series') + '-active'; // Set the events on the item group, or in case of useHTML, the item\n    // itself (#1249)\n\n    (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n      item.setState('hover'); // A CSS class to dim or hide other than the hovered series\n\n      boxWrapper.addClass(activeClass);\n    }).on('mouseout', function () {\n      // A CSS class to dim or hide other than the hovered series\n      boxWrapper.removeClass(activeClass);\n      item.setState();\n    }).on('click', function (event) {\n      var strLegendItemClick = 'legendItemClick',\n          fnLegendItemClick = function () {\n        if (item.setVisible) {\n          item.setVisible();\n        }\n      }; // A CSS class to dim or hide other than the hovered series. Event\n      // handling in iOS causes the activeClass to be added prior to click\n      // in some cases (#7418).\n\n\n      boxWrapper.removeClass(activeClass); // Pass over the click/touch event. #4.\n\n      event = {\n        browserEvent: event\n      }; // click the name or symbol\n\n      if (item.firePointEvent) {\n        // point\n        item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n      } else {\n        fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n      }\n    });\n  },\n  createCheckboxForItem: function (item) {\n    var legend = this;\n    item.checkbox = createElement('input', {\n      type: 'checkbox',\n      className: 'highcharts-legend-checkbox',\n      checked: item.selected,\n      defaultChecked: item.selected // required by IE7\n\n    }, legend.options.itemCheckboxStyle, legend.chart.container);\n    addEvent(item.checkbox, 'click', function (event) {\n      var target = event.target;\n      fireEvent(item.series || item, 'checkboxClick', {\n        // #3712\n        checked: target.checked,\n        item: item\n      }, function () {\n        item.select();\n      });\n    });\n  }\n});\n/*\n * Extend the Chart object with interaction\n */\n\nextend(Chart.prototype,\n/** @lends Chart.prototype */\n{\n  /**\n   * Display the zoom button.\n   *\n   * @private\n   */\n  showResetZoom: function () {\n    var chart = this,\n        lang = defaultOptions.lang,\n        btnOptions = chart.options.chart.resetZoomButton,\n        theme = btnOptions.theme,\n        states = theme.states,\n        alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\n    function zoomOut() {\n      chart.zoomOut();\n    }\n\n    fireEvent(this, 'beforeShowResetZoom', null, function () {\n      chart.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover).attr({\n        align: btnOptions.position.align,\n        title: lang.resetZoomTitle\n      }).addClass('highcharts-reset-zoom').add().align(btnOptions.position, false, alignTo);\n    });\n  },\n\n  /**\n   * Zoom the chart out after a user has zoomed in. See also\n   * [Axis.setExtremes](/class-reference/Highcharts.Axis#setExtremes).\n   */\n  zoomOut: function () {\n    fireEvent(this, 'selection', {\n      resetSelection: true\n    }, this.zoom);\n  },\n\n  /**\n   * Zoom into a given portion of the chart given by axis coordinates.\n   * @param {Object} event\n   *\n   * @private\n   */\n  zoom: function (event) {\n    var chart = this,\n        hasZoomed,\n        pointer = chart.pointer,\n        displayButton = false,\n        resetZoomButton; // If zoom is called with no arguments, reset the axes\n\n    if (!event || event.resetSelection) {\n      each(chart.axes, function (axis) {\n        hasZoomed = axis.zoom();\n      });\n      pointer.initiated = false; // #6804\n    } else {\n      // else, zoom in on all axes\n      each(event.xAxis.concat(event.yAxis), function (axisData) {\n        var axis = axisData.axis,\n            isXAxis = axis.isXAxis; // don't zoom more than minRange\n\n        if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {\n          hasZoomed = axis.zoom(axisData.min, axisData.max);\n\n          if (axis.displayBtn) {\n            displayButton = true;\n          }\n        }\n      });\n    } // Show or hide the Reset zoom button\n\n\n    resetZoomButton = chart.resetZoomButton;\n\n    if (displayButton && !resetZoomButton) {\n      chart.showResetZoom();\n    } else if (!displayButton && isObject(resetZoomButton)) {\n      chart.resetZoomButton = resetZoomButton.destroy();\n    } // Redraw\n\n\n    if (hasZoomed) {\n      chart.redraw(pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));\n    }\n  },\n\n  /**\n   * Pan the chart by dragging the mouse across the pane. This function is\n   * called on mouse move, and the distance to pan is computed from chartX\n   * compared to the first chartX position in the dragging operation.\n   *\n   * @private\n   */\n  pan: function (e, panning) {\n    var chart = this,\n        hoverPoints = chart.hoverPoints,\n        doRedraw; // remove active points for shared tooltip\n\n    if (hoverPoints) {\n      each(hoverPoints, function (point) {\n        point.setState();\n      });\n    } // xy is used in maps\n\n\n    each(panning === 'xy' ? [1, 0] : [1], function (isX) {\n      var axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n          horiz = axis.horiz,\n          mousePos = e[horiz ? 'chartX' : 'chartY'],\n          mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',\n          startPos = chart[mouseDown],\n          halfPointRange = (axis.pointRange || 0) / 2,\n          pointRangeDirection = axis.reversed && !chart.inverted || !axis.reversed && chart.inverted ? -1 : 1,\n          extremes = axis.getExtremes(),\n          panMin = axis.toValue(startPos - mousePos, true) + halfPointRange * pointRangeDirection,\n          panMax = axis.toValue(startPos + axis.len - mousePos, true) - halfPointRange * pointRangeDirection,\n          flipped = panMax < panMin,\n          newMin = flipped ? panMax : panMin,\n          newMax = flipped ? panMin : panMax,\n          paddedMin = Math.min(extremes.dataMin, halfPointRange ? extremes.min : axis.toValue(axis.toPixels(extremes.min) - axis.minPixelPadding)),\n          paddedMax = Math.max(extremes.dataMax, halfPointRange ? extremes.max : axis.toValue(axis.toPixels(extremes.max) + axis.minPixelPadding)),\n          spill; // If the new range spills over, either to the min or max, adjust\n      // the new range.\n\n      spill = paddedMin - newMin;\n\n      if (spill > 0) {\n        newMax += spill;\n        newMin = paddedMin;\n      }\n\n      spill = newMax - paddedMax;\n\n      if (spill > 0) {\n        newMax = paddedMax;\n        newMin -= spill;\n      } // Set new extremes if they are actually new\n\n\n      if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max) {\n        axis.setExtremes(newMin, newMax, false, false, {\n          trigger: 'pan'\n        });\n        doRedraw = true;\n      }\n\n      chart[mouseDown] = mousePos; // set new reference for next run\n    });\n\n    if (doRedraw) {\n      chart.redraw(false);\n    }\n\n    css(chart.container, {\n      cursor: 'move'\n    });\n  }\n});\n/*\n * Extend the Point object with interaction\n */\n\nextend(Point.prototype,\n/** @lends Highcharts.Point.prototype */\n{\n  /**\n   * Toggle the selection status of a point.\n   * @param  {Boolean} [selected]\n   *         When `true`, the point is selected. When `false`, the point is\n   *         unselected. When `null` or `undefined`, the selection state is\n   *         toggled.\n   * @param  {Boolean} [accumulate=false]\n   *         When `true`, the selection is added to other selected points.\n   *         When `false`, other selected points are deselected. Internally in\n   *         Highcharts, when {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}\n   *         is `true`, selected points are accumulated on Control, Shift or\n   *         Cmd clicking the point.\n   *\n   * @see    Highcharts.Chart#getSelectedPoints\n   *\n   * @sample highcharts/members/point-select/\n   *         Select a point from a button\n   * @sample highcharts/chart/events-selection-points/\n   *         Select a range of points through a drag selection\n   * @sample maps/series/data-id/\n   *         Select a point in Highmaps\n   */\n  select: function (selected, accumulate) {\n    var point = this,\n        series = point.series,\n        chart = series.chart;\n    selected = pick(selected, !point.selected); // fire the event with the default handler\n\n    point.firePointEvent(selected ? 'select' : 'unselect', {\n      accumulate: accumulate\n    }, function () {\n      /**\n       * Whether the point is selected or not.\n       * @see Point#select\n       * @see Chart#getSelectedPoints\n       * @memberof Point\n       * @name selected\n       * @type {Boolean}\n       */\n      point.selected = point.options.selected = selected;\n      series.options.data[inArray(point, series.data)] = point.options;\n      point.setState(selected && 'select'); // unselect all other points unless Ctrl or Cmd + click\n\n      if (!accumulate) {\n        each(chart.getSelectedPoints(), function (loopPoint) {\n          if (loopPoint.selected && loopPoint !== point) {\n            loopPoint.selected = loopPoint.options.selected = false;\n            series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n            loopPoint.setState('');\n            loopPoint.firePointEvent('unselect');\n          }\n        });\n      }\n    });\n  },\n\n  /**\n   * Runs on mouse over the point. Called internally from mouse and touch\n   * events.\n   *\n   * @param {Object} e The event arguments\n   */\n  onMouseOver: function (e) {\n    var point = this,\n        series = point.series,\n        chart = series.chart,\n        pointer = chart.pointer;\n    e = e ? pointer.normalize(e) : // In cases where onMouseOver is called directly without an event\n    pointer.getChartCoordinatesFromPoint(point, chart.inverted);\n    pointer.runPointActions(e, point);\n  },\n\n  /**\n   * Runs on mouse out from the point. Called internally from mouse and touch\n   * events.\n   */\n  onMouseOut: function () {\n    var point = this,\n        chart = point.series.chart;\n    point.firePointEvent('mouseOut');\n    each(chart.hoverPoints || [], function (p) {\n      p.setState();\n    });\n    chart.hoverPoints = chart.hoverPoint = null;\n  },\n\n  /**\n   * Import events from the series' and point's options. Only do it on\n   * demand, to save processing time on hovering.\n   *\n   * @private\n   */\n  importEvents: function () {\n    if (!this.hasImportedEvents) {\n      var point = this,\n          options = merge(point.series.options.point, point.options),\n          events = options.events;\n      point.events = events;\n      H.objectEach(events, function (event, eventType) {\n        addEvent(point, eventType, event);\n      });\n      this.hasImportedEvents = true;\n    }\n  },\n\n  /**\n   * Set the point's state.\n   * @param  {String} [state]\n   *         The new state, can be one of `''` (an empty string), `hover` or\n   *         `select`.\n   */\n  setState: function (state, move) {\n    var point = this,\n        plotX = Math.floor(point.plotX),\n        // #4586\n    plotY = point.plotY,\n        series = point.series,\n        stateOptions = series.options.states[state || 'normal'] || {},\n        markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,\n        normalDisabled = markerOptions && markerOptions.enabled === false,\n        markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || 'normal'] || {},\n        stateDisabled = markerStateOptions.enabled === false,\n        stateMarkerGraphic = series.stateMarkerGraphic,\n        pointMarker = point.marker || {},\n        chart = series.chart,\n        halo = series.halo,\n        haloOptions,\n        markerAttribs,\n        hasMarkers = markerOptions && series.markerAttribs,\n        newSymbol;\n    state = state || ''; // empty string\n\n    if ( // already has this state\n    state === point.state && !move || // selected points don't respond to hover\n    point.selected && state !== 'select' || // series' state options is disabled\n    stateOptions.enabled === false || // general point marker's state options is disabled\n    state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || // individual point marker's state options is disabled\n    state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false // #1610\n    ) {\n        return;\n      }\n\n    if (hasMarkers) {\n      markerAttribs = series.markerAttribs(point, state);\n    } // Apply hover styles to the existing point\n\n\n    if (point.graphic) {\n      if (point.state) {\n        point.graphic.removeClass('highcharts-point-' + point.state);\n      }\n\n      if (state) {\n        point.graphic.addClass('highcharts-point-' + state);\n      }\n\n      if (markerAttribs) {\n        point.graphic.animate(markerAttribs, pick(chart.options.chart.animation, // Turn off globally\n        markerStateOptions.animation, markerOptions.animation));\n      } // Zooming in from a range with no markers to a range with markers\n\n\n      if (stateMarkerGraphic) {\n        stateMarkerGraphic.hide();\n      }\n    } else {\n      // if a graphic is not applied to each point in the normal state,\n      // create a shared graphic for the hover state\n      if (state && markerStateOptions) {\n        newSymbol = pointMarker.symbol || series.symbol; // If the point has another symbol than the previous one, throw\n        // away the state marker graphic and force a new one (#1459)\n\n        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n          stateMarkerGraphic = stateMarkerGraphic.destroy();\n        } // Add a new state marker graphic\n\n\n        if (!stateMarkerGraphic) {\n          if (newSymbol) {\n            series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);\n            stateMarkerGraphic.currentSymbol = newSymbol;\n          } // Move the existing graphic\n\n        } else {\n          stateMarkerGraphic[move ? 'animate' : 'attr']({\n            // #1054\n            x: markerAttribs.x,\n            y: markerAttribs.y\n          });\n        }\n      }\n\n      if (stateMarkerGraphic) {\n        stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n\n        stateMarkerGraphic.element.point = point; // #4310\n      }\n    } // Show me your halo\n\n\n    haloOptions = stateOptions.halo;\n\n    if (haloOptions && haloOptions.size) {\n      if (!halo) {\n        series.halo = halo = chart.renderer.path() // #5818, #5903, #6705\n        .add((point.graphic || stateMarkerGraphic).parentGroup);\n      }\n\n      halo.show()[move ? 'animate' : 'attr']({\n        d: point.haloPath(haloOptions.size)\n      });\n      halo.attr({\n        'class': 'highcharts-halo highcharts-color-' + pick(point.colorIndex, series.colorIndex) + (point.className ? ' ' + point.className : ''),\n        'zIndex': -1 // #4929, #8276\n\n      });\n      halo.point = point; // #6055\n    } else if (halo && halo.point && halo.point.haloPath) {\n      // Animate back to 0 on the current halo point (#6055)\n      halo.animate({\n        d: halo.point.haloPath(0)\n      }, null, // Hide after unhovering. The `complete` callback runs in the\n      // halo's context (#7681).\n      halo.hide);\n    }\n\n    point.state = state;\n    fireEvent(point, 'afterSetState');\n  },\n\n  /**\n   * Get the path definition for the halo, which is usually a shadow-like\n   * circle around the currently hovered point.\n   * @param  {Number} size\n   *         The radius of the circular halo.\n   * @return {Array} The path definition\n   */\n  haloPath: function (size) {\n    var series = this.series,\n        chart = series.chart;\n    return chart.renderer.symbols.circle(Math.floor(this.plotX) - size, this.plotY - size, size * 2, size * 2);\n  }\n});\n/*\n * Extend the Series object with interaction\n */\n\nextend(Series.prototype,\n/** @lends Highcharts.Series.prototype */\n{\n  /**\n   * Runs on mouse over the series graphical items.\n   */\n  onMouseOver: function () {\n    var series = this,\n        chart = series.chart,\n        hoverSeries = chart.hoverSeries; // set normal state to previous series\n\n    if (hoverSeries && hoverSeries !== series) {\n      hoverSeries.onMouseOut();\n    } // trigger the event, but to save processing time,\n    // only if defined\n\n\n    if (series.options.events.mouseOver) {\n      fireEvent(series, 'mouseOver');\n    } // hover this\n\n\n    series.setState('hover');\n    chart.hoverSeries = series;\n  },\n\n  /**\n   * Runs on mouse out of the series graphical items.\n   */\n  onMouseOut: function () {\n    // trigger the event only if listeners exist\n    var series = this,\n        options = series.options,\n        chart = series.chart,\n        tooltip = chart.tooltip,\n        hoverPoint = chart.hoverPoint; // #182, set to null before the mouseOut event fires\n\n    chart.hoverSeries = null; // trigger mouse out on the point, which must be in this series\n\n    if (hoverPoint) {\n      hoverPoint.onMouseOut();\n    } // fire the mouse out event\n\n\n    if (series && options.events.mouseOut) {\n      fireEvent(series, 'mouseOut');\n    } // hide the tooltip\n\n\n    if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n      tooltip.hide();\n    } // set normal state\n\n\n    series.setState();\n  },\n\n  /**\n   * Set the state of the series. Called internally on mouse interaction\n   * operations, but it can also be called directly to visually\n   * highlight a series.\n   *\n   * @param  {String} [state]\n   *         Can be either `hover` or undefined to set to normal\n   *         state.\n   */\n  setState: function (state) {\n    var series = this,\n        options = series.options,\n        graph = series.graph,\n        stateOptions = options.states,\n        lineWidth = options.lineWidth,\n        attribs,\n        i = 0;\n    state = state || '';\n\n    if (series.state !== state) {\n      // Toggle class names\n      each([series.group, series.markerGroup, series.dataLabelsGroup], function (group) {\n        if (group) {\n          // Old state\n          if (series.state) {\n            group.removeClass('highcharts-series-' + series.state);\n          } // New state\n\n\n          if (state) {\n            group.addClass('highcharts-series-' + state);\n          }\n        }\n      });\n      series.state = state;\n    }\n  },\n\n  /**\n   * Show or hide the series.\n   *\n   * @param  {Boolean} [visible]\n   *         True to show the series, false to hide. If undefined, the\n   *         visibility is toggled.\n   * @param  {Boolean} [redraw=true]\n   *         Whether to redraw the chart after the series is altered. If doing\n   *         more operations on the chart, it is a good idea to set redraw to\n   *         false and call {@link Chart#redraw|chart.redraw()} after.\n   */\n  setVisible: function (vis, redraw) {\n    var series = this,\n        chart = series.chart,\n        legendItem = series.legendItem,\n        showOrHide,\n        ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n        oldVisibility = series.visible; // if called without an argument, toggle visibility\n\n    series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis; // #5618\n\n    showOrHide = vis ? 'show' : 'hide'; // show or hide elements\n\n    each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'], function (key) {\n      if (series[key]) {\n        series[key][showOrHide]();\n      }\n    }); // hide tooltip (#1361)\n\n    if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n      series.onMouseOut();\n    }\n\n    if (legendItem) {\n      chart.legend.colorizeItem(series, vis);\n    } // rescale or adapt to resized chart\n\n\n    series.isDirty = true; // in a stack, all other series are affected\n\n    if (series.options.stacking) {\n      each(chart.series, function (otherSeries) {\n        if (otherSeries.options.stacking && otherSeries.visible) {\n          otherSeries.isDirty = true;\n        }\n      });\n    } // show or hide linked series\n\n\n    each(series.linkedSeries, function (otherSeries) {\n      otherSeries.setVisible(vis, false);\n    });\n\n    if (ignoreHiddenSeries) {\n      chart.isDirtyBox = true;\n    }\n\n    fireEvent(series, showOrHide);\n\n    if (redraw !== false) {\n      chart.redraw();\n    }\n  },\n\n  /**\n   * Show the series if hidden.\n   *\n   * @sample highcharts/members/series-hide/\n   *         Toggle visibility from a button\n   */\n  show: function () {\n    this.setVisible(true);\n  },\n\n  /**\n   * Hide the series if visible. If the {@link\n   * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|\n   * chart.ignoreHiddenSeries} option is true, the chart is redrawn without\n   * this series.\n   *\n   * @sample highcharts/members/series-hide/\n   *         Toggle visibility from a button\n   */\n  hide: function () {\n    this.setVisible(false);\n  },\n\n  /**\n   * Select or unselect the series. This means its {@link\n   * Highcharts.Series.selected|selected} property is set, the checkbox in the\n   * legend is toggled and when selected, the series is returned by the\n   * {@link Highcharts.Chart#getSelectedSeries} function.\n   *\n   * @param  {Boolean} [selected]\n   *         True to select the series, false to unselect. If undefined, the\n   *         selection state is toggled.\n   *\n   * @sample highcharts/members/series-select/\n   *         Select a series from a button\n   */\n  select: function (selected) {\n    var series = this;\n    series.selected = selected = selected === undefined ? !series.selected : selected;\n\n    if (series.checkbox) {\n      series.checkbox.checked = selected;\n    }\n\n    fireEvent(series, selected ? 'select' : 'unselect');\n  },\n  drawTracker: TrackerMixin.drawTrackerGraph\n});"
    },
    {
     "id": 307,
     "name": "../node_modules/highcharts/js/es-modules/parts-more/GaugeSeries.js?babel-target=es6",
     "source": "/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n\nimport H from '../parts/Globals.js';\nimport '../parts/Utilities.js';\nimport '../parts/Options.js';\nimport '../parts/Point.js';\nimport '../parts/Series.js';\nimport '../parts/Interaction.js';\nvar each = H.each,\n    isNumber = H.isNumber,\n    merge = H.merge,\n    noop = H.noop,\n    pick = H.pick,\n    pInt = H.pInt,\n    Series = H.Series,\n    seriesType = H.seriesType,\n    TrackerMixin = H.TrackerMixin;\n/**\n * Gauges are circular plots displaying one or more values with a dial pointing\n * to values along the perimeter.\n *\n * @sample       highcharts/demo/gauge-speedometer/ Gauge chart\n * @extends      {plotOptions.line}\n * @excluding    animationLimit,boostThreshold,connectEnds,connectNulls,\n *               cropThreshold,dashStyle,findNearestPointBy,getExtremesFromAll,\n *               marker,negativeColor,pointPlacement,shadow,softThreshold,\n *               stacking,states,step,threshold,turboThreshold,xAxis,zoneAxis,\n *               zones\n * @product      highcharts\n * @optionparent plotOptions.gauge\n */\n\nseriesType('gauge', 'line', {\n  /**\n   * When this option is `true`, the dial will wrap around the axes. For\n   * instance, in a full-range gauge going from 0 to 360, a value of 400\n   * will point to 40\\. When `wrap` is `false`, the dial stops at 360.\n   *\n   * @type      {Boolean}\n   * @see       [overshoot](#plotOptions.gauge.overshoot)\n   * @default   true\n   * @since     3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.wrap\n   */\n\n  /**\n   * Data labels for the gauge. For gauges, the data labels are enabled\n   * by default and shown in a bordered box below the point.\n   *\n   * @type    {Object}\n   * @extends plotOptions.series.dataLabels\n   * @since   2.3.0\n   * @product highcharts\n   */\n  dataLabels: {\n    /**\n     * Enable or disable the data labels.\n     *\n     * @since   2.3.0\n     * @product highcharts highmaps\n     */\n    enabled: true,\n    defer: false,\n\n    /**\n     * The y position offset of the label relative to the center of the\n     * gauge.\n     *\n     * @since   2.3.0\n     * @product highcharts highmaps\n     */\n    y: 15,\n\n    /**\n     * The border radius in pixels for the gauge's data label.\n     *\n     * @since   2.3.0\n     * @product highcharts highmaps\n     */\n    borderRadius: 3,\n    crop: false,\n\n    /**\n     * The vertical alignment of the data label.\n     *\n     * @product highcharts highmaps\n     */\n    verticalAlign: 'top',\n\n    /**\n     * The Z index of the data labels. A value of 2 display them behind\n     * the dial.\n     *\n     * @since   2.1.5\n     * @product highcharts highmaps\n     */\n    zIndex: 2\n  },\n\n  /**\n   * Options for the dial or arrow pointer of the gauge.\n   *\n   * In styled mode, the dial is styled with the\n   * `.highcharts-gauge-series .highcharts-dial` rule.\n   *\n   * @type    {Object}\n   * @sample  {highcharts} highcharts/css/gauge/ Styled mode\n   * @since   2.3.0\n   * @product highcharts\n   */\n  dial: {},\n\n  /**\n   * The length of the dial's base part, relative to the total radius\n   * or length of the dial.\n   *\n   * @type      {String}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   70%\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.baseLength\n   */\n\n  /**\n   * The pixel width of the base of the gauge dial. The base is the part\n   * closest to the pivot, defined by baseLength.\n   *\n   * @type      {Number}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   3\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.baseWidth\n   */\n\n  /**\n   * The radius or length of the dial, in percentages relative to the\n   * radius of the gauge itself.\n   *\n   * @type      {String}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   80%\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.radius\n   */\n\n  /**\n   * The length of the dial's rear end, the part that extends out on the\n   * other side of the pivot. Relative to the dial's length.\n   *\n   * @type      {String}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   10%\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.rearLength\n   */\n\n  /**\n   * The width of the top of the dial, closest to the perimeter. The pivot\n   * narrows in from the base to the top.\n   *\n   * @type      {Number}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n   *            Dial options demonstrated\n   * @default   1\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.dial.topWidth\n   */\n\n  /**\n   * Allow the dial to overshoot the end of the perimeter axis by this\n   * many degrees. Say if the gauge axis goes from 0 to 60, a value of\n   * 100, or 1000, will show 5 degrees beyond the end of the axis when this\n   * option is set to 5.\n   *\n   * @type      {Number}\n   * @see       [wrap](#plotOptions.gauge.wrap)\n   * @sample    {highcharts} highcharts/plotoptions/gauge-overshoot/\n   *            Allow 5 degrees overshoot\n   * @default   0\n   * @since     3.0.10\n   * @product   highcharts\n   * @apioption plotOptions.gauge.overshoot\n   */\n\n  /**\n   * Options for the pivot or the center point of the gauge.\n   *\n   * In styled mode, the pivot is styled with the\n   * `.highcharts-gauge-series .highcharts-pivot` rule.\n   *\n   * @type    {Object}\n   * @sample  {highcharts} highcharts/css/gauge/ Styled mode\n   * @since   2.3.0\n   * @product highcharts\n   */\n  pivot: {},\n\n  /**\n   * The pixel radius of the pivot.\n   *\n   * @type      {Number}\n   * @sample    {highcharts} highcharts/plotoptions/gauge-pivot/\n   *            Pivot options demonstrated\n   * @default   5\n   * @since     2.3.0\n   * @product   highcharts\n   * @apioption plotOptions.gauge.pivot.radius\n   */\n  tooltip: {\n    headerFormat: ''\n  },\n\n  /**\n   * Whether to display this particular series or series type in the\n   * legend. Defaults to false for gauge series.\n   *\n   * @since   2.3.0\n   * @product highcharts\n   */\n  showInLegend: false // Prototype members\n\n}, {\n  // chart.angular will be set to true when a gauge series is present,\n  // and this will be used on the axes\n  angular: true,\n  directTouch: true,\n  // #5063\n  drawGraph: noop,\n  fixedBox: true,\n  forceDL: true,\n  noSharedTooltip: true,\n  trackerGroups: ['group', 'dataLabelsGroup'],\n\n  /**\n   * Calculate paths etc\n   */\n  translate: function () {\n    var series = this,\n        yAxis = series.yAxis,\n        options = series.options,\n        center = yAxis.center;\n    series.generatePoints();\n    each(series.points, function (point) {\n      var dialOptions = merge(options.dial, point.dial),\n          radius = pInt(pick(dialOptions.radius, 80)) * center[2] / 200,\n          baseLength = pInt(pick(dialOptions.baseLength, 70)) * radius / 100,\n          rearLength = pInt(pick(dialOptions.rearLength, 10)) * radius / 100,\n          baseWidth = dialOptions.baseWidth || 3,\n          topWidth = dialOptions.topWidth || 1,\n          overshoot = options.overshoot,\n          rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true); // Handle the wrap and overshoot options\n\n      if (isNumber(overshoot)) {\n        overshoot = overshoot / 180 * Math.PI;\n        rotation = Math.max(yAxis.startAngleRad - overshoot, Math.min(yAxis.endAngleRad + overshoot, rotation));\n      } else if (options.wrap === false) {\n        rotation = Math.max(yAxis.startAngleRad, Math.min(yAxis.endAngleRad, rotation));\n      }\n\n      rotation = rotation * 180 / Math.PI;\n      point.shapeType = 'path';\n      point.shapeArgs = {\n        d: dialOptions.path || ['M', -rearLength, -baseWidth / 2, 'L', baseLength, -baseWidth / 2, radius, -topWidth / 2, radius, topWidth / 2, baseLength, baseWidth / 2, -rearLength, baseWidth / 2, 'z'],\n        translateX: center[0],\n        translateY: center[1],\n        rotation: rotation\n      }; // Positions for data label\n\n      point.plotX = center[0];\n      point.plotY = center[1];\n    });\n  },\n\n  /**\n   * Draw the points where each point is one needle\n   */\n  drawPoints: function () {\n    var series = this,\n        center = series.yAxis.center,\n        pivot = series.pivot,\n        options = series.options,\n        pivotOptions = options.pivot,\n        renderer = series.chart.renderer;\n    each(series.points, function (point) {\n      var graphic = point.graphic,\n          shapeArgs = point.shapeArgs,\n          d = shapeArgs.d,\n          dialOptions = merge(options.dial, point.dial); // #1233\n\n      if (graphic) {\n        graphic.animate(shapeArgs);\n        shapeArgs.d = d; // animate alters it\n      } else {\n        point.graphic = renderer[point.shapeType](shapeArgs).attr({\n          // required by VML when animation is false\n          rotation: shapeArgs.rotation,\n          zIndex: 1\n        }).addClass('highcharts-dial').add(series.group);\n      }\n    }); // Add or move the pivot\n\n    if (pivot) {\n      pivot.animate({\n        // #1235\n        translateX: center[0],\n        translateY: center[1]\n      });\n    } else {\n      series.pivot = renderer.circle(0, 0, pick(pivotOptions.radius, 5)).attr({\n        zIndex: 2\n      }).addClass('highcharts-pivot').translate(center[0], center[1]).add(series.group);\n    }\n  },\n\n  /**\n   * Animate the arrow up from startAngle\n   */\n  animate: function (init) {\n    var series = this;\n\n    if (!init) {\n      each(series.points, function (point) {\n        var graphic = point.graphic;\n\n        if (graphic) {\n          // start value\n          graphic.attr({\n            rotation: series.yAxis.startAngleRad * 180 / Math.PI\n          }); // animate\n\n          graphic.animate({\n            rotation: point.shapeArgs.rotation\n          }, series.options.animation);\n        }\n      }); // delete this function to allow it only once\n\n      series.animate = null;\n    }\n  },\n  render: function () {\n    this.group = this.plotGroup('group', 'series', this.visible ? 'visible' : 'hidden', this.options.zIndex, this.chart.seriesGroup);\n    Series.prototype.render.call(this);\n    this.group.clip(this.chart.clipRect);\n  },\n\n  /**\n   * Extend the basic setData method by running processData and generatePoints\n   * immediately, in order to access the points from the legend.\n   */\n  setData: function (data, redraw) {\n    Series.prototype.setData.call(this, data, false);\n    this.processData();\n    this.generatePoints();\n\n    if (pick(redraw, true)) {\n      this.chart.redraw();\n    }\n  },\n\n  /**\n   * If the tracking module is loaded, add the point tracker\n   */\n  drawTracker: TrackerMixin && TrackerMixin.drawTrackerPoint // Point members\n\n}, {\n  /**\n   * Don't do any hover colors or anything\n   */\n  setState: function (state) {\n    this.state = state;\n  }\n});\n/**\n * A `gauge` series. If the [type](#series.gauge.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.gauge\n * @excluding animationLimit,boostThreshold,connectEnds,connectNulls,\n *            cropThreshold,dashStyle,dataParser,dataURL,findNearestPointBy,\n *            getExtremesFromAll,marker,negativeColor,pointPlacement,shadow,\n *            softThreshold,stack,stacking,states,step,threshold,\n *            turboThreshold,zoneAxis,zones\n * @product   highcharts\n * @apioption series.gauge\n */\n\n/**\n * An array of data points for the series. For the `gauge` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.gauge.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *     y: 6,\n *     name: \"Point2\",\n *     color: \"#00FF00\"\n * }, {\n *     y: 8,\n *     name: \"Point1\",\n *     color: \"#FF00FF\"\n * }]</pre>\n *\n * The typical gauge only contains a single data value.\n *\n * @type      {Array<Object|Number>}\n * @extends   series.line.data\n * @excluding drilldown,marker,x\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.gauge.data\n */"
    },
    {
     "id": 308,
     "name": "../node_modules/@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-checkbox\" theme-for=\"vaadin-checkbox\">\n  <template>\n    <style include=\"lumo-checkbox-style lumo-checkbox-effects\">\n      /* IE11 only */\n      ::-ms-backdrop,\n      [part=\"checkbox\"] {\n        line-height: 1;\n      }\n    </style>\n  </template>\n</dom-module><dom-module id=\"lumo-checkbox-style\">\n  <template>\n    <style>\n      :host {\n        -webkit-tap-highlight-color: transparent;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n        cursor: default;\n        outline: none;\n      }\n\n      [part=\"label\"]:not([empty]) {\n        margin: 0.1875em 0.875em 0.1875em 0.375em;\n      }\n\n      [part=\"checkbox\"] {\n        width: calc(1em + 2px);\n        height: calc(1em + 2px);\n        margin: 0.1875em;\n        position: relative;\n        border-radius: var(--lumo-border-radius-s);\n        background-color: var(--lumo-contrast-20pct);\n        transition: transform 0.2s cubic-bezier(.12, .32, .54, 2), background-color 0.15s;\n        pointer-events: none;\n        line-height: 1.2;\n      }\n\n      :host([indeterminate]) [part=\"checkbox\"],\n      :host([checked]) [part=\"checkbox\"] {\n        background-color: var(--lumo-primary-color);\n      }\n\n      /* Needed to align the checkbox nicely on the baseline */\n      [part=\"checkbox\"]::before {\n        content: \"\\\\2003\";\n      }\n\n      /* Checkmark */\n      [part=\"checkbox\"]::after {\n        content: \"\";\n        display: inline-block;\n        width: 0;\n        height: 0;\n        border: 0 solid var(--lumo-primary-contrast-color);\n        border-width: 0.1875em 0 0 0.1875em;\n        box-sizing: border-box;\n        transform-origin: 0 0;\n        position: absolute;\n        top: 0.8125em;\n        left: 0.5em;\n        transform: scale(0.55) rotate(-135deg);\n        opacity: 0;\n      }\n\n      :host([checked]) [part=\"checkbox\"]::after {\n        opacity: 1;\n        width: 0.625em;\n        height: 1.0625em;\n      }\n\n      /* Indeterminate checkmark */\n\n      :host([indeterminate]) [part=\"checkbox\"]::after {\n        transform: none;\n        opacity: 1;\n        top: 45%;\n        height: 10%;\n        left: 22%;\n        right: 22%;\n        width: auto;\n        border: 0;\n        background-color: var(--lumo-primary-contrast-color);\n        transition: opacity 0.25s;\n      }\n\n      /* Focus ring */\n\n      :host([focus-ring]) [part=\"checkbox\"] {\n        box-shadow: 0 0 0 3px var(--lumo-primary-color-50pct);\n      }\n\n      /* Disabled */\n\n      :host([disabled]) {\n        pointer-events: none;\n        color: var(--lumo-disabled-text-color);\n      }\n\n      :host([disabled]) [part=\"label\"] ::slotted(*) {\n        color: inherit;\n      }\n\n      :host([disabled]) [part=\"checkbox\"] {\n        background-color: var(--lumo-contrast-10pct);\n      }\n\n      :host([disabled]) [part=\"checkbox\"]::after {\n        border-color: var(--lumo-contrast-30pct);\n      }\n\n      :host([indeterminate][disabled]) [part=\"checkbox\"]::after {\n        background-color: var(--lumo-contrast-30pct);\n      }\n\n      /* RTL specific styles */\n\n      :host([dir=\"rtl\"]) [part=\"label\"]:not([empty]) {\n        margin: 0.1875em 0.375em 0.1875em 0.875em;\n      }\n    </style>\n  </template>\n</dom-module><dom-module id=\"lumo-checkbox-effects\">\n  <template>\n    <style>\n      /* Transition the checkmark if activated with the mouse (disabled for grid select-all this way) */\n      :host(:hover) [part=\"checkbox\"]::after {\n        transition: width 0.1s, height 0.25s;\n      }\n\n      /* Used for activation \"halo\" */\n      [part=\"checkbox\"]::before {\n        color: transparent;\n        display: inline-block;\n        width: 100%;\n        height: 100%;\n        border-radius: inherit;\n        background-color: inherit;\n        transform: scale(1.4);\n        opacity: 0;\n        transition: transform 0.1s, opacity 0.8s;\n      }\n\n      /* Hover */\n\n      :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part=\"checkbox\"] {\n        background-color: var(--lumo-contrast-30pct);\n      }\n\n      /* Disable hover for touch devices */\n      @media (pointer: coarse) {\n        :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part=\"checkbox\"] {\n          background-color: var(--lumo-contrast-20pct);\n        }\n      }\n\n      /* Active */\n\n      :host([active]) [part=\"checkbox\"] {\n        transform: scale(0.9);\n        transition-duration: 0.05s;\n      }\n\n      :host([active][checked]) [part=\"checkbox\"] {\n        transform: scale(1.1);\n      }\n\n      :host([active]:not([checked])) [part=\"checkbox\"]::before {\n        transition-duration: 0.01s, 0.01s;\n        transform: scale(0);\n        opacity: 0.4;\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 309,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js';\nimport './vaadin-grid-styles.js';\nimport '../../src/vaadin-grid.js';"
    },
    {
     "id": 310,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-grid\" theme-for=\"vaadin-grid\">\n  <template>\n    <style>\n      :host {\n        font-family: var(--lumo-font-family);\n        font-size: var(--lumo-font-size-m);\n        line-height: var(--lumo-line-height-s);\n        color: var(--lumo-body-text-color);\n        background-color: var(--lumo-base-color);\n        box-sizing: border-box;\n        -webkit-text-size-adjust: 100%;\n        -webkit-tap-highlight-color: transparent;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n\n        /* For internal use only */\n        --_lumo-grid-border-color: var(--lumo-contrast-20pct);\n        --_lumo-grid-secondary-border-color: var(--lumo-contrast-10pct);\n        --_lumo-grid-border-width: 1px;\n        --_lumo-grid-selected-row-color: var(--lumo-primary-color-10pct);\n      }\n\n      /* No (outer) border */\n\n      :host(:not([theme~=\"no-border\"])) {\n        border: var(--_lumo-grid-border-width) solid var(--_lumo-grid-border-color);\n      }\n\n      /* Cell styles */\n\n      [part~=\"cell\"] {\n        min-height: var(--lumo-size-m);\n        background-color: var(--lumo-base-color);\n      }\n\n      [part~=\"cell\"] ::slotted(vaadin-grid-cell-content) {\n        cursor: default;\n        padding: var(--lumo-space-xs) var(--lumo-space-m);\n      }\n\n      /* Apply row borders by default and introduce the \"no-row-borders\" variant */\n      :host(:not([theme~=\"no-row-borders\"])) [part~=\"cell\"]:not([part~=\"details-cell\"]) {\n        border-top: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);\n      }\n\n      /* Hide first body row top border */\n      :host(:not([theme~=\"no-row-borders\"])) [part=\"row\"][first] [part~=\"cell\"]:not([part~=\"details-cell\"]) {\n        border-top: 0;\n        min-height: calc(var(--lumo-size-m) - var(--_lumo-grid-border-width));\n      }\n\n      /* Focus-ring */\n\n      [part~=\"cell\"]:focus {\n        outline: none;\n      }\n\n      :host([navigating]) [part~=\"cell\"]:focus::before {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        pointer-events: none;\n        box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);\n      }\n\n      /* Drag and Drop styles */\n      :host([dragover])::after {\n        content: \"\";\n        position: absolute;\n        z-index: 100;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        pointer-events: none;\n        box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);\n      }\n\n      [part~=\"row\"][dragover] {\n        z-index: 100 !important;\n      }\n\n      [part~=\"row\"][dragover] [part~=\"cell\"] {\n        overflow: visible;\n      }\n\n      [part~=\"row\"][dragover] [part~=\"cell\"]::after {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        height: calc(var(--_lumo-grid-border-width) + 2px);\n        pointer-events: none;\n        background: var(--lumo-primary-color-50pct);\n      }\n\n      :host([theme~=\"no-row-borders\"]) [dragover] [part~=\"cell\"]::after {\n        height: 2px;\n      }\n\n      [part~=\"row\"][dragover=\"below\"] [part~=\"cell\"]::after {\n        top: 100%;\n        bottom: auto;\n        margin-top: -1px;\n      }\n\n      [part~=\"row\"][dragover=\"above\"] [part~=\"cell\"]::after {\n        top: auto;\n        bottom: 100%;\n        margin-bottom: -1px;\n      }\n\n      [part~=\"row\"][details-opened][dragover=\"below\"] [part~=\"cell\"]:not([part~=\"details-cell\"])::after,\n      [part~=\"row\"][details-opened][dragover=\"above\"] [part~=\"details-cell\"]::after {\n        display: none;\n      }\n\n      [part~=\"row\"][dragover][dragover=\"on-top\"] [part~=\"cell\"]::after {\n        height: 100%;\n      }\n\n      [part~=\"row\"][dragstart] {\n        /* Add bottom-space to the row so the drag number doesn't get clipped. Needed for IE/Edge */\n        border-bottom: 100px solid transparent;\n        z-index: 100 !important;\n        opacity: 0.9;\n      }\n\n      [part~=\"row\"][dragstart] [part~=\"cell\"] {\n        border: none !important;\n        box-shadow: none !important;\n      }\n\n      [part~=\"row\"][dragstart] [part~=\"cell\"][last-column] {\n        border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;\n      }\n\n      [part~=\"row\"][dragstart] [part~=\"cell\"][first-column] {\n        border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);\n      }\n\n      [ios] [part~=\"row\"][dragstart] [part~=\"cell\"] {\n        background: var(--lumo-primary-color-50pct);\n      }\n\n      #scroller:not([ios]) [part~=\"row\"][dragstart]:not([dragstart=\"\"])::after {\n        display: block;\n        position: absolute;\n        left: var(--_grid-drag-start-x);\n        top: var(--_grid-drag-start-y);\n        z-index: 100;\n        content: attr(dragstart);\n        align-items: center;\n        justify-content: center;\n        box-sizing: border-box;\n        padding: calc(var(--lumo-space-xs) * 0.8);\n        color: var(--lumo-error-contrast-color);\n        background-color: var(--lumo-error-color);\n        border-radius: var(--lumo-border-radius-m);\n        font-family: var(--lumo-font-family);\n        font-size: var(--lumo-font-size-xxs);\n        line-height: 1;\n        font-weight: 500;\n        text-transform: initial;\n        letter-spacing: initial;\n        min-width: calc(var(--lumo-size-s) * 0.7);\n        text-align: center;\n      }\n\n      /* Headers and footers */\n\n      [part~=\"header-cell\"] ::slotted(vaadin-grid-cell-content),\n      [part~=\"footer-cell\"] ::slotted(vaadin-grid-cell-content),\n      [part~=\"reorder-ghost\"] {\n        font-size: var(--lumo-font-size-s);\n        font-weight: 500;\n      }\n\n      [part~=\"footer-cell\"] ::slotted(vaadin-grid-cell-content) {\n        font-weight: 400;\n      }\n\n      [part=\"row\"]:only-child [part~=\"header-cell\"] {\n        min-height: var(--lumo-size-xl);\n      }\n\n      /* Header borders */\n\n      /* Hide first header row top border */\n      :host(:not([theme~=\"no-row-borders\"])) [part=\"row\"]:first-child [part~=\"header-cell\"] {\n        border-top: 0;\n      }\n\n      [part=\"row\"]:last-child [part~=\"header-cell\"] {\n        border-bottom: var(--_lumo-grid-border-width) solid transparent;\n      }\n\n      :host(:not([theme~=\"no-row-borders\"])) [part=\"row\"]:last-child [part~=\"header-cell\"] {\n        border-bottom-color: var(--_lumo-grid-secondary-border-color);\n      }\n\n      /* Overflow uses a stronger border color */\n      :host([overflow~=\"top\"]) [part=\"row\"]:last-child [part~=\"header-cell\"] {\n        border-bottom-color: var(--_lumo-grid-border-color);\n      }\n\n      /* Footer borders */\n\n      [part=\"row\"]:first-child [part~=\"footer-cell\"] {\n        border-top: var(--_lumo-grid-border-width) solid transparent;\n      }\n\n      :host(:not([theme~=\"no-row-borders\"])) [part=\"row\"]:first-child [part~=\"footer-cell\"] {\n        border-top-color: var(--_lumo-grid-secondary-border-color);\n      }\n\n      /* Overflow uses a stronger border color */\n      :host([overflow~=\"bottom\"]) [part=\"row\"]:first-child [part~=\"footer-cell\"] {\n        border-top-color: var(--_lumo-grid-border-color);\n      }\n\n      /* Column reordering */\n\n      :host([reordering]) [part~=\"cell\"] {\n        background: linear-gradient(var(--lumo-shade-20pct), var(--lumo-shade-20pct)) var(--lumo-base-color);\n      }\n\n      :host([reordering]) [part~=\"cell\"][reorder-status=\"allowed\"] {\n        background: var(--lumo-base-color);\n      }\n\n      :host([reordering]) [part~=\"cell\"][reorder-status=\"dragging\"] {\n        background: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct)) var(--lumo-base-color);\n      }\n\n      [part~=\"reorder-ghost\"] {\n        opacity: 0.85;\n        box-shadow: var(--lumo-box-shadow-s);\n        /* TODO Use the same styles as for the cell element (reorder-ghost copies styles from the cell element) */\n        padding: var(--lumo-space-s) var(--lumo-space-m) !important;\n      }\n\n      /* Column resizing */\n\n      [part=\"resize-handle\"] {\n        width: 3px;\n        background-color: var(--lumo-primary-color-50pct);\n        opacity: 0;\n        transition: opacity 0.2s;\n      }\n\n      :host(:not([reordering])) *:not([column-resizing]) [part~=\"cell\"]:hover [part=\"resize-handle\"],\n      [part=\"resize-handle\"]:active {\n        opacity: 1;\n        transition-delay: 0.15s;\n      }\n\n      /* Column borders */\n\n      :host([theme~=\"column-borders\"]) [part~=\"cell\"]:not([last-column]):not([part~=\"details-cell\"]) {\n        border-right: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);\n      }\n\n      /* Frozen columns */\n\n      [last-frozen] {\n        border-right: var(--_lumo-grid-border-width) solid transparent;\n        overflow: hidden;\n      }\n\n      :host([overflow~=\"left\"]) [part~=\"cell\"][last-frozen]:not([part~=\"details-cell\"]) {\n        border-right-color: var(--_lumo-grid-border-color);\n      }\n\n      /* Row stripes */\n\n      :host([theme~=\"row-stripes\"]) [part~=\"row\"]:not([odd]) [part~=\"body-cell\"],\n      :host([theme~=\"row-stripes\"]) [part~=\"row\"]:not([odd]) [part~=\"details-cell\"] {\n        background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));\n        background-repeat: repeat-x;\n      }\n\n      /* Selected row */\n\n      /* Raise the selected rows above unselected rows (so that box-shadow can cover unselected rows) */\n      :host(:not([reordering])) [part~=\"row\"][selected] {\n        z-index: 1;\n      }\n\n      :host(:not([reordering])) [part~=\"row\"][selected] [part~=\"body-cell\"]:not([part~=\"details-cell\"]) {\n        background-image: linear-gradient(var(--_lumo-grid-selected-row-color), var(--_lumo-grid-selected-row-color));\n        background-repeat: repeat;\n      }\n\n      /* Cover the border of an unselected row */\n      :host(:not([theme~=\"no-row-borders\"])) [part~=\"row\"][selected] [part~=\"cell\"]:not([part~=\"details-cell\"]) {\n        box-shadow: 0 var(--_lumo-grid-border-width) 0 0 var(--_lumo-grid-selected-row-color);\n      }\n\n      /* Compact */\n\n      :host([theme~=\"compact\"]) [part=\"row\"]:only-child [part~=\"header-cell\"] {\n        min-height: var(--lumo-size-m);\n      }\n\n      :host([theme~=\"compact\"]) [part~=\"cell\"] {\n        min-height: var(--lumo-size-s);\n      }\n\n      :host([theme~=\"compact\"]) [part=\"row\"][first] [part~=\"cell\"]:not([part~=\"details-cell\"]) {\n        min-height: calc(var(--lumo-size-s) - var(--_lumo-grid-border-width));\n      }\n\n      :host([theme~=\"compact\"]) [part~=\"cell\"] ::slotted(vaadin-grid-cell-content) {\n        padding: var(--lumo-space-xs) var(--lumo-space-s);\n      }\n\n      /* Wrap cell contents */\n\n      :host([theme~=\"wrap-cell-content\"]) [part~=\"cell\"] ::slotted(vaadin-grid-cell-content) {\n        white-space: normal;\n      }\n\n      /* RTL specific styles */\n\n      :host([dir=\"rtl\"]) [part~=\"row\"][dragstart] [part~=\"cell\"][last-column] {\n        border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);\n      }\n\n      :host([dir=\"rtl\"]) [part~=\"row\"][dragstart] [part~=\"cell\"][first-column] {\n        border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;\n      }\n\n      :host([dir=\"rtl\"][theme~=\"column-borders\"]) [part~=\"cell\"]:not([last-column]):not([part~=\"details-cell\"]) {\n        border-right: none;\n        border-left: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);\n      }\n\n      :host([dir=\"rtl\"]) [last-frozen] {\n        border-right: none;\n        border-left: var(--_lumo-grid-border-width) solid transparent;\n      }\n\n      :host([dir=\"rtl\"][overflow~=\"right\"]) [part~=\"cell\"][last-frozen]:not([part~=\"details-cell\"]) {\n        border-left-color: var(--_lumo-grid-border-color);\n      }\n    </style>\n  </template>\n</dom-module><dom-module theme-for=\"vaadin-checkbox\" id=\"vaadin-grid-select-all-checkbox-lumo\">\n  <template>\n    <style>\n      :host(.vaadin-grid-select-all-checkbox) {\n        font-size: var(--lumo-font-size-m);\n      }\n   </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 311,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-sorter.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { DirMixin } from '@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<custom-style>\n  <style>\n    @font-face {\n      font-family: 'vaadin-grid-sorter-icons';\n      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQwAA0AAAAABuwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEFAAAABkAAAAcfep+mUdERUYAAAP4AAAAHAAAAB4AJwAOT1MvMgAAAZgAAAA/AAAAYA8TBPpjbWFwAAAB7AAAAFUAAAFeF1fZ4mdhc3AAAAPwAAAACAAAAAgAAAAQZ2x5ZgAAAlgAAABcAAAAnMvguMloZWFkAAABMAAAAC8AAAA2C5Ap72hoZWEAAAFgAAAAHQAAACQGbQPHaG10eAAAAdgAAAAUAAAAHAoAAABsb2NhAAACRAAAABIAAAASAIwAYG1heHAAAAGAAAAAFgAAACAACwAKbmFtZQAAArQAAAECAAACZxWCgKhwb3N0AAADuAAAADUAAABZCrApUXicY2BkYGAA4rDECVrx/DZfGbhZGEDgyqNPOxH0/wNMq5kPALkcDEwgUQBWRA0dAHicY2BkYGA+8P8AAwMLAwgwrWZgZEAFbABY4QM8AAAAeJxjYGRgYOAAQiYGEICQSAAAAi8AFgAAeJxjYGY6yziBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKoAkwODAwvmRiPvD/AIMDMxCD1CDJKjAwAgBktQsXAHicY2GAAMZQCM0EwqshbAALxAEKeJxjYGBgZoBgGQZGBhCIAPIYwXwWBhsgzcXAwcAEhIwMCi+Z/v/9/x+sSuElA4T9/4k4K1gHFwMMMILMY2QDYmaoABOQYGJABUA7WBiGNwAAJd4NIQAAAAAAAAAACAAIABAAGAAmAEAATgAAeJyNjLENgDAMBP9tIURJwQCMQccSZgk2i5fIYBDAidJjycXr7x5EPwE2wY8si7jmyBNXGo/bNBerxJNrpxhbO3/fEFpx8ZICpV+ghxJ74fAMe+h7Ox14AbrsHB14nK2QQWrDMBRER4mTkhQK3ZRQKOgCNk7oGQqhhEIX2WSlWEI1BAlkJ5CDdNsj5Ey9Rncdi38ES+jzNJo/HwTgATcoDEthhY3wBHc4CE+pfwsX5F/hGe7Vo/AcK/UhvMSz+mGXKhZU6pww8ISz3oWn1BvhgnwTnuEJf8Jz1OpFeIlX9YULDLdFi4ASHolkSR0iuYdjLak1vAequBhj21D61Nqyi6l3qWybGPjySbPHGScGJl6dP58MYcQRI0bts7mjebBqrFENH7t3qWtj0OuqHnXcW7b0HOTZFnKryRGW2hFX1m0O2vEM3opNMfTau+CS6Z3Vx6veNnEXY6jwDxhsc2gAAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSrpYEBlIbxjQDrzgsuAAAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKyoz1cD0o087YTQATOcIewAAAA==) format('woff');\n      font-weight: normal;\n      font-style: normal;\n    }\n  </style>\n</custom-style>`;\ndocument.head.appendChild($_documentContainer.content);\n/**\n * `<vaadin-grid-sorter>` is a helper element for the `<vaadin-grid>` that provides out-of-the-box UI controls,\n * visual feedback, and handlers for sorting the grid data.\n *\n * #### Example:\n * ```html\n * <vaadin-grid-column>\n *   <template class=\"header\">\n *     <vaadin-grid-sorter path=\"name.first\">First name</vaadin-grid-sorter>\n *   </template>\n *   <template>[[item.name.first]]</template>\n * </vaadin-grid-column>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ----------------|----------------\n * `content` | The slotted content wrapper\n * `indicators` | The internal sorter indicators.\n * `order` | The internal sorter order\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `direction` | Sort direction of a sorter | :host\n *\n * @extends PolymerElement\n */\n\nclass GridSorterElement extends ThemableMixin(DirMixin(PolymerElement)) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: inline-flex;\n        cursor: pointer;\n        max-width: 100%;\n      }\n\n      [part=\"content\"] {\n        flex: 1 1 auto;\n      }\n\n      [part=\"indicators\"] {\n        position: relative;\n        align-self: center;\n        flex: none;\n      }\n\n      [part=\"order\"] {\n        display: inline;\n        vertical-align: super;\n      }\n\n      [part=\"indicators\"]::before {\n        font-family: 'vaadin-grid-sorter-icons';\n        display: inline-block;\n      }\n\n      :host(:not([direction])) [part=\"indicators\"]::before {\n        content: \"\\\\e901\";\n      }\n\n      :host([direction=asc]) [part=\"indicators\"]::before {\n        content: \"\\\\e900\";\n      }\n\n      :host([direction=desc]) [part=\"indicators\"]::before {\n        content: \"\\\\e902\";\n      }\n    </style>\n\n    <div part=\"content\">\n      <slot></slot>\n    </div>\n    <div part=\"indicators\">\n      <span part=\"order\">[[_getDisplayOrder(_order)]]</span>\n    </div>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-grid-sorter';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * JS Path of the property in the item used for sorting the data.\n       */\n      path: String,\n\n      /**\n       * How to sort the data.\n       * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in\n       * descending direction, or `null` for not sorting the data.\n       * @type {GridSorterDirection | undefined}\n       */\n      direction: {\n        type: String,\n        reflectToAttribute: true,\n        notify: true,\n        value: null\n      },\n\n      /**\n       * @type {number | null}\n       * @protected\n       */\n      _order: {\n        type: Number,\n        value: null\n      },\n\n      /** @private */\n      _isConnected: {\n        type: Boolean,\n        value: false\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_pathOrDirectionChanged(path, direction, _isConnected)', '_directionOrOrderChanged(direction, _order)'];\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.addEventListener('click', this._onClick.bind(this));\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    this._isConnected = true;\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this._isConnected = false;\n  }\n  /** @private */\n\n\n  _pathOrDirectionChanged(path, direction, isConnected) {\n    if (path === undefined || direction === undefined || isConnected === undefined) {\n      return;\n    }\n\n    if (isConnected) {\n      this.dispatchEvent(new CustomEvent('sorter-changed', {\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }\n  /** @private */\n\n\n  _getDisplayOrder(order) {\n    return order === null ? '' : order + 1;\n  }\n  /** @private */\n\n\n  _onClick(e) {\n    var activeElement = this.getRootNode().activeElement;\n\n    if (this !== activeElement && this.contains(activeElement)) {\n      // Some focusable content inside the sorter was clicked, do nothing.\n      return;\n    }\n\n    e.preventDefault();\n\n    if (this.direction === 'asc') {\n      this.direction = 'desc';\n    } else if (this.direction === 'desc') {\n      this.direction = null;\n    } else {\n      this.direction = 'asc';\n    }\n  }\n  /** @private */\n\n\n  _directionOrOrderChanged(direction, order) {\n    if (direction === undefined || order === undefined) {\n      return;\n    } // Safari has an issue with repainting shadow root element styles when a host attribute changes.\n    // Need this workaround (toggle any inline css property on and off) until the issue gets fixed.\n\n\n    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n    if (isSafari && this.root) {\n      this.root.querySelectorAll('*').forEach(function (el) {\n        el.style['-webkit-backface-visibility'] = 'visible';\n        el.style['-webkit-backface-visibility'] = '';\n      });\n    }\n  }\n\n}\n\ncustomElements.define(GridSorterElement.is, GridSorterElement);\nexport { GridSorterElement };"
    },
    {
     "id": 312,
     "name": "../node_modules/@vaadin/vaadin-grid/src/vaadin-grid-column-group.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { microTask } from '@polymer/polymer/lib/utils/async.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { ColumnBaseMixin } from './vaadin-grid-column.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\n/**\n * A `<vaadin-grid-column-group>` is used to make groups of columns in `<vaadin-grid>` and\n * to configure additional headers and footers.\n *\n * Groups can be nested to create complex header and footer configurations.\n *\n * The `class` attribute is used to differentiate header and footer templates.\n *\n * #### Example:\n * ```html\n * <vaadin-grid-column-group resizable>\n *  <template class=\"header\">Name</template>\n *\n *  <vaadin-grid-column>\n *    <template class=\"header\">First</template>\n *    <template>[[item.name.first]]</template>\n *  </vaadin-grid-column>\n *  <vaadin-grid-column>\n *    <template class=\"header\">Last</template>\n *    <template>[[item.name.last]]</template>\n *  </vaadin-grid-column>\n * </vaadin-grid-column-group>\n * ```\n *\n * @extends PolymerElement\n * @mixes ColumnBaseMixin\n */\n\nclass GridColumnGroupElement extends ColumnBaseMixin(PolymerElement) {\n  static get is() {\n    return 'vaadin-grid-column-group';\n  }\n\n  static get properties() {\n    return {\n      /** @private */\n      _childColumns: {\n        value: function () {\n          return this._getChildColumns(this);\n        }\n      },\n\n      /**\n       * Flex grow ratio for the column group as the sum of the ratios of its child columns.\n       * @attr {number} flex-grow\n       */\n      flexGrow: {\n        type: Number,\n        readOnly: true\n      },\n\n      /**\n       * Width of the column group as the sum of the widths of its child columns.\n       */\n      width: {\n        type: String,\n        readOnly: true\n      },\n\n      /** @private */\n      _visibleChildColumns: Array,\n\n      /** @private */\n      _colSpan: Number,\n\n      /** @private */\n      _rootColumns: Array\n    };\n  }\n\n  static get observers() {\n    return ['_updateVisibleChildColumns(_childColumns)', '_childColumnsChanged(_childColumns)', '_groupFrozenChanged(frozen, _rootColumns)', '_groupHiddenChanged(hidden, _rootColumns)', '_visibleChildColumnsChanged(_visibleChildColumns)', '_colSpanChanged(_colSpan, _headerCell, _footerCell)', '_groupOrderChanged(_order, _rootColumns)', '_groupReorderStatusChanged(_reorderStatus, _rootColumns)', '_groupResizableChanged(resizable, _rootColumns)'];\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    this._addNodeObserver();\n\n    this._updateFlexAndWidth();\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this._observer && this._observer.disconnect();\n  }\n  /**\n   * @param {string} path\n   * @param {unknown=} value\n   * @protected\n   */\n\n\n  _columnPropChanged(path, value) {\n    if (path === 'hidden') {\n      this._preventHiddenCascade = true;\n\n      this._updateVisibleChildColumns(this._childColumns);\n\n      this._preventHiddenCascade = false;\n    }\n\n    if (/flexGrow|width|hidden|_childColumns/.test(path)) {\n      this._updateFlexAndWidth();\n    }\n\n    if (path === 'frozen') {\n      // Dont unfreeze the frozen group because of a non-frozen child\n      this.frozen = this.frozen || value;\n    }\n\n    if (path === 'lastFrozen') {\n      // Dont unfreeze the frozen group because of a non-frozen child\n      this._lastFrozen = this._lastFrozen || value;\n    }\n  }\n  /** @private */\n\n\n  _groupOrderChanged(order, rootColumns) {\n    if (rootColumns) {\n      var _rootColumns = rootColumns.slice(0);\n\n      if (!order) {\n        _rootColumns.forEach(column => column._order = 0);\n\n        return;\n      } // The parent column order number cascades downwards to it's children\n      // so that the resulting order numbering constructs as follows:\n      // [             1000              ]\n      // [     1100    ] | [     1200    ]\n      // [1110] | [1120] | [1210] | [1220]\n      // Trailing zeros are counted so we know the level on which we're working on.\n\n\n      var trailingZeros = /(0+)$/.exec(order).pop().length; // In an unlikely situation where a group has more than 9 child columns,\n      // the child scope must have 1 digit less...\n\n      var childCountDigits = ~~(Math.log(rootColumns.length) / Math.log(Math.LN10)) + 1; // Final scope for the child columns needs to mind both factors.\n\n      var scope = Math.pow(10, trailingZeros - childCountDigits);\n\n      if (_rootColumns[0] && _rootColumns[0]._order) {\n        _rootColumns.sort((a, b) => a._order - b._order);\n      }\n\n      _rootColumns.forEach((column, index) => column._order = order + (index + 1) * scope);\n    }\n  }\n  /** @private */\n\n\n  _groupReorderStatusChanged(reorderStatus, rootColumns) {\n    if (reorderStatus === undefined || rootColumns === undefined) {\n      return;\n    }\n\n    rootColumns.forEach(column => column._reorderStatus = reorderStatus);\n  }\n  /** @private */\n\n\n  _groupResizableChanged(resizable, rootColumns) {\n    if (resizable === undefined || rootColumns === undefined) {\n      return;\n    }\n\n    rootColumns.forEach(column => column.resizable = resizable);\n  }\n  /** @private */\n\n\n  _updateVisibleChildColumns(childColumns) {\n    this._visibleChildColumns = Array.prototype.filter.call(childColumns, col => !col.hidden);\n  }\n  /** @private */\n\n\n  _childColumnsChanged(childColumns) {\n    if (!this._autoHidden && this.hidden) {\n      Array.prototype.forEach.call(childColumns, column => column.hidden = true);\n\n      this._updateVisibleChildColumns(childColumns);\n    }\n  }\n  /** @protected */\n\n\n  _updateFlexAndWidth() {\n    if (!this._visibleChildColumns) {\n      return;\n    }\n\n    if (this._visibleChildColumns.length) {\n      this._setWidth('calc(' + Array.prototype.reduce.call(this._visibleChildColumns, (prev, curr) => prev += ' + ' + (curr.width || '0px').replace('calc', ''), '').substring(3) + ')');\n    } else {\n      this._setWidth('0px');\n    }\n\n    this._setFlexGrow(Array.prototype.reduce.call(this._visibleChildColumns, (prev, curr) => prev + curr.flexGrow, 0));\n  }\n  /** @private */\n\n\n  _groupFrozenChanged(frozen, rootColumns) {\n    if (rootColumns === undefined || frozen === undefined) {\n      return;\n    } // Dont propagate the default `false` value.\n\n\n    if (frozen !== false) {\n      Array.from(rootColumns).forEach(col => col.frozen = frozen);\n    }\n  }\n  /** @private */\n\n\n  _groupHiddenChanged(hidden, rootColumns) {\n    if (rootColumns && !this._preventHiddenCascade) {\n      this._ignoreVisibleChildColumns = true;\n      rootColumns.forEach(column => column.hidden = hidden);\n      this._ignoreVisibleChildColumns = false;\n    }\n\n    this._columnPropChanged('hidden');\n  }\n  /** @private */\n\n\n  _visibleChildColumnsChanged(visibleChildColumns) {\n    this._colSpan = visibleChildColumns.length;\n\n    if (!this._ignoreVisibleChildColumns) {\n      if (visibleChildColumns.length === 0) {\n        this._autoHidden = this.hidden = true;\n      } else if (this.hidden && this._autoHidden) {\n        this._autoHidden = this.hidden = false;\n      }\n    }\n  }\n  /** @private */\n\n\n  _colSpanChanged(colSpan, headerCell, footerCell) {\n    if (headerCell) {\n      headerCell.setAttribute('colspan', colSpan);\n      this._grid && this._grid._a11yUpdateCellColspan(headerCell, colSpan);\n    }\n\n    if (footerCell) {\n      footerCell.setAttribute('colspan', colSpan);\n      this._grid && this._grid._a11yUpdateCellColspan(footerCell, colSpan);\n    }\n  }\n  /**\n   * @param {!GridColumnGroupElement} el\n   * @return {!Array<!GridColumnElement>}\n   * @protected\n   */\n\n\n  _getChildColumns(el) {\n    return FlattenedNodesObserver.getFlattenedNodes(el).filter(this._isColumnElement);\n  }\n  /** @private */\n\n\n  _addNodeObserver() {\n    this._observer = new FlattenedNodesObserver(this, info => {\n      if (info.addedNodes.filter(this._isColumnElement).length > 0 || info.removedNodes.filter(this._isColumnElement).length > 0) {\n        this._preventHiddenCascade = true;\n        this._rootColumns = this._getChildColumns(this);\n        this._childColumns = this._rootColumns;\n        this._preventHiddenCascade = false; // Update the column tree with microtask timing to avoid shady style scope issues\n\n        microTask.run(() => {\n          this._grid && this._grid._updateColumnTree && this._grid._updateColumnTree();\n        });\n      }\n    });\n\n    this._observer.flush();\n  }\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _isColumnElement(node) {\n    return node.nodeType === Node.ELEMENT_NODE && /\\bcolumn\\b/.test(node.localName);\n  }\n\n}\n\ncustomElements.define(GridColumnGroupElement.is, GridColumnGroupElement);\nexport { GridColumnGroupElement };"
    },
    {
     "id": 313,
     "name": "../node_modules/@vaadin/vaadin-combo-box/src/vaadin-combo-box-light.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ComboBoxMixin } from './vaadin-combo-box-mixin.js';\nimport { ComboBoxDataProviderMixin } from './vaadin-combo-box-data-provider-mixin.js';\nimport './vaadin-combo-box-dropdown-wrapper.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { dashToCamelCase } from '@polymer/polymer/lib/utils/case-map.js';\n/**\n * `<vaadin-combo-box-light>` is a customizable version of the `<vaadin-combo-box>` providing\n * only the dropdown functionality and leaving the input field definition to the user.\n *\n * The element has the same API as `<vaadin-combo-box>`.\n *\n * To create a custom input field, you need to add a child element which has a two-way\n * data-bindable property representing the input value. The property name is expected\n * to be `value` by default. See the example below for a simplest possible example\n * using a `<vaadin-text-field>` element.\n *\n * ```html\n * <vaadin-combo-box-light>\n *   <vaadin-text-field>\n *   </vaadin-text-field>\n * </vaadin-combo-box-light>\n * ```\n *\n * If you are using other custom input fields like `<iron-input>`, you\n * need to define the name of the bindable property with the `attrForValue` attribute.\n *\n * ```html\n * <vaadin-combo-box-light attr-for-value=\"bind-value\">\n *   <iron-input>\n *     <input>\n *   </iron-input>\n * </vaadin-combo-box-light>\n * ```\n *\n * In the next example you can see how to create a custom input field based\n * on a `<paper-input>` decorated with a custom `<iron-icon>` and\n * two `<paper-button>`s to act as the clear and toggle controls.\n *\n * ```html\n * <vaadin-combo-box-light>\n *   <paper-input label=\"Elements\" class=\"input\">\n *     <iron-icon icon=\"toll\" slot=\"prefix\"></iron-icon>\n *     <paper-button slot=\"suffix\" class=\"clear-button\">Clear</paper-button>\n *     <paper-button slot=\"suffix\" class=\"toggle-button\">Toggle</paper-button>\n *   </paper-input>\n * </vaadin-combo-box-light>\n * ```\n * @extends PolymerElement\n * @mixes ComboBoxDataProviderMixin\n * @mixes ComboBoxMixin\n * @mixes ThemableMixin\n */\n\nclass ComboBoxLightElement extends ThemableMixin(ComboBoxDataProviderMixin(ComboBoxMixin(PolymerElement))) {\n  static get template() {\n    return html`\n    <style>\n      :host([opened]) {\n        pointer-events: auto;\n      }\n    </style>\n\n    <slot></slot>\n\n    <vaadin-combo-box-dropdown-wrapper id=\"overlay\" opened=\"[[opened]]\" position-target=\"[[inputElement]]\" renderer=\"[[renderer]]\" _focused-index=\"[[_focusedIndex]]\" _item-id-path=\"[[itemIdPath]]\" _item-label-path=\"[[itemLabelPath]]\" loading=\"[[loading]]\" theme=\"[[theme]]\">\n    </vaadin-combo-box-dropdown-wrapper>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-combo-box-light';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Name of the two-way data-bindable property representing the\n       * value of the custom input field.\n       * @attr {string} attr-for-value\n       * @type {string}\n       */\n      attrForValue: {\n        type: String,\n        value: 'value'\n      },\n\n      /**\n       * @type {!Element | undefined}\n       */\n      inputElement: {\n        type: Element,\n        readOnly: true\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this._boundInputValueChanged = this._inputValueChanged.bind(this);\n    this.__boundInputValueCommitted = this.__inputValueCommitted.bind(this);\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this._toggleElement = this.querySelector('.toggle-button');\n    this._clearElement = this.querySelector('.clear-button');\n\n    if (this._clearElement) {\n      this._clearElement.addEventListener('mousedown', e => {\n        e.preventDefault(); // Prevent native focus changes\n        // _focusableElement is needed for paper-input\n\n        (this.inputElement._focusableElement || this.inputElement).focus();\n      });\n    }\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  get focused() {\n    return this.getRootNode().activeElement === this.inputElement;\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    var cssSelector = 'vaadin-text-field,iron-input,paper-input,.paper-input-input,.input';\n\n    this._setInputElement(this.querySelector(cssSelector));\n\n    this._revertInputValue();\n\n    this.inputElement.addEventListener('input', this._boundInputValueChanged);\n    this.inputElement.addEventListener('change', this.__boundInputValueCommitted);\n\n    this._preventInputBlur();\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.inputElement.removeEventListener('input', this._boundInputValueChanged);\n    this.inputElement.removeEventListener('change', this.__boundInputValueCommitted);\n\n    this._restoreInputBlur();\n  }\n  /** @private */\n\n\n  __inputValueCommitted(e) {\n    // Detect if the input was cleared (by clicking the clear button on a vaadin-text-field)\n    // and propagate the value change to combo box value immediately.\n    if (e.__fromClearButton) {\n      this._clear();\n    }\n  }\n  /**\n   * @return {string}\n   * @protected\n   */\n\n\n  get _propertyForValue() {\n    return dashToCamelCase(this.attrForValue);\n  }\n  /**\n   * @return {string}\n   * @protected\n   */\n\n\n  get _inputElementValue() {\n    return this.inputElement && this.inputElement[this._propertyForValue];\n  }\n  /**\n   * @param {string} value\n   * @protected\n   */\n\n\n  set _inputElementValue(value) {\n    if (this.inputElement) {\n      this.inputElement[this._propertyForValue] = value;\n    }\n  }\n\n}\n\ncustomElements.define(ComboBoxLightElement.is, ComboBoxLightElement);\nexport { ComboBoxLightElement };"
    },
    {
     "id": 314,
     "name": "../node_modules/@vaadin/vaadin-text-field/src/vaadin-password-field.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport '@polymer/polymer/polymer-element.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nimport { TextFieldElement } from './vaadin-text-field.js';\nimport { DomModule } from '@polymer/polymer/lib/elements/dom-module.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<custom-style>\n  <style>\n    @font-face {\n      font-family: 'vaadin-password-field-icons';\n      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAYMAAsAAAAABcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIFgGNtYXAAAAFoAAAAVAAAAFQXVtKIZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAfwAAAH8yBLEP2hlYWQAAAPAAAAANgAAADYN+RfTaGhlYQAAA/gAAAAkAAAAJAfCA8dobXR4AAAEHAAAABgAAAAYDgAAAGxvY2EAAAQ0AAAADgAAAA4BJgCSbWF4cAAABEQAAAAgAAAAIAAMAFpuYW1lAAAEZAAAAYYAAAGGmUoJ+3Bvc3QAAAXsAAAAIAAAACAAAwAAAAMDVQGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QEDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkB//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAwAAAHoEAALGABQAJABFAAABIg4CMTAeAjMyPgIxMC4CIwc+ATEwBhUUFjEHMCY1NDYTIi4CJz4BNw4BFRQeAjMyPgI1NCYnHgEXDgMjAgChyHAnN3rAiYjFfjsncMihrRg7IA1GExmnY5ZqQg8PWGAFCChGXTU1XUYoCAVgWA8RRW2ZZALGZnpmUmJSUGBQaHxoYA8FRSIhJQ0rIiYz/lQvQkYVInswEygYNV1GKChGXTUYKBMrgCIVRkIvAAAABQAA/8AEAAPAABoAJgA6AEcAVwAAAQceARcOAyMiJicHHgEzMj4CMTAuAicHNCYnATIWMzI+AhMBLgEjIg4CMTAeAhcHFTMBNQEuASc+ATcOARUUFhc3BzAmNTQ2MT4BMTAGFQYWAzo0UlMPEUVtmWQiNR0zJ1QsiMV+OxEsTTw6AgT+zA8dDjVdRijT/ucnXjWhyHAnGTNQN9MtA9P9AE1ZFA9YYAUILSY6QBMZGDsgBAsCczMrcyIWQ0AtCAQzDgtQYFAzS1ckeQ4bCv7TBihGXQH7/uYKEGZ6Zic5RBzNLQPTLf0tIVoYInswEygYNWMihgwrISc5DwVHJiIlAAEAAAAAAADkyo21Xw889QALBAAAAAAA1W1pqwAAAADVbWmrAAD/wAQAA8AAAAAIAAIAAAAAAAAAAQAAA8D/wAAABAAAAAAABAAAAQAAAAAAAAAAAAAAAAAAAAYEAAAAAAAAAAAAAAACAAAABAAAAAQAAAAAAAAAAAoAFAAeAH4A/gAAAAEAAAAGAFgABQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAHAAAAAQAAAAAAAgAHAGAAAQAAAAAAAwAHADYAAQAAAAAABAAHAHUAAQAAAAAABQALABUAAQAAAAAABgAHAEsAAQAAAAAACgAaAIoAAwABBAkAAQAOAAcAAwABBAkAAgAOAGcAAwABBAkAAwAOAD0AAwABBAkABAAOAHwAAwABBAkABQAWACAAAwABBAkABgAOAFIAAwABBAkACgA0AKRpY29tb29uAGkAYwBvAG0AbwBvAG5WZXJzaW9uIDEuMABWAGUAcgBzAGkAbwBuACAAMQAuADBpY29tb29uAGkAYwBvAG0AbwBvAG5pY29tb29uAGkAYwBvAG0AbwBvAG5SZWd1bGFyAFIAZQBnAHUAbABhAHJpY29tb29uAGkAYwBvAG0AbwBvAG5Gb250IGdlbmVyYXRlZCBieSBJY29Nb29uLgBGAG8AbgB0ACAAZwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAC4AAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) format('woff');\n      font-weight: normal;\n      font-style: normal;\n    }\n  </style>\n</custom-style><dom-module id=\"vaadin-password-field-template\">\n  <template>\n    <style>\n      /* Hide the native eye icon for IE/Edge */\n      ::-ms-reveal {\n        display: none;\n      }\n\n      [part=\"reveal-button\"][hidden] {\n        display: none !important;\n      }\n    </style>\n\n    <div part=\"reveal-button\" on-mousedown=\"_revealButtonMouseDown\" on-touchend=\"_togglePasswordVisibilityTouchend\" on-click=\"_togglePasswordVisibility\" hidden\\$=\"[[revealButtonHidden]]\">\n    </div>\n  </template>\n  \n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);\nvar memoizedTemplate;\n/**\n * `<vaadin-password-field>` is a Web Component for password field control in forms.\n *\n * ```html\n * <vaadin-password-field label=\"Password\">\n * </vaadin-password-field>\n * ```\n *\n * ### Styling\n *\n * See vaadin-text-field.html for the styling documentation\n *\n * In addition to vaadin-text-field parts, here's the list of vaadin-password-field specific parts\n *\n * Part name       | Description\n * ----------------|----------------------------------------------------\n * `reveal-button` | The eye icon which toggles the password visibility\n *\n * In addition to vaadin-text-field state attributes, here's the list of vaadin-password-field specific attributes\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `password-visible` | Set when the password is visible | :host\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends TextFieldElement\n * @demo demo/index.html\n */\n\nclass PasswordFieldElement extends TextFieldElement {\n  static get is() {\n    return 'vaadin-password-field';\n  }\n\n  static get version() {\n    return '2.8.2';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Set to true to hide the eye icon which toggles the password visibility.\n       * @attr {boolean} reveal-button-hidden\n       * @type {boolean}\n       */\n      revealButtonHidden: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * True if the password is visible ([type=text]).\n       * @attr {boolean} password-visible\n       * @type {boolean}\n       */\n      passwordVisible: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_passwordVisibleChange',\n        readOnly: true\n      }\n    };\n  }\n\n  static get template() {\n    if (!memoizedTemplate) {\n      // Clone the superclass template\n      memoizedTemplate = super.template.cloneNode(true); // Retrieve this element's dom-module template\n\n      var thisTemplate = DomModule.import(this.is + '-template', 'template');\n      var revealButton = thisTemplate.content.querySelector('[part=\"reveal-button\"]');\n      var styles = thisTemplate.content.querySelector('style'); // Append reveal-button and styles to the text-field template\n\n      var inputField = memoizedTemplate.content.querySelector('[part=\"input-field\"]');\n      inputField.appendChild(revealButton);\n      memoizedTemplate.content.appendChild(styles);\n    }\n\n    return memoizedTemplate;\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.inputElement.type = 'password';\n    this.inputElement.autocapitalize = 'off';\n    this.addEventListener('focusout', () => {\n      if (!this._passwordVisibilityChanging) {\n        this._setPasswordVisible(false);\n\n        if (this._cachedChangeEvent) {\n          this._onChange(this._cachedChangeEvent);\n        }\n      }\n    });\n  }\n  /**\n   * @param {!Event} e\n   * @protected\n   */\n\n\n  _onChange(e) {\n    var slotted = this.querySelector(`${this._slottedTagName}[slot=\"${this._slottedTagName}\"]`);\n\n    if (slotted) {\n      e.stopPropagation();\n    }\n\n    if (this._passwordVisibilityChanging) {\n      this._cachedChangeEvent = e;\n    } else {\n      this._cachedChangeEvent = null;\n\n      super._onChange(e);\n    }\n  }\n  /** @private */\n\n\n  _revealButtonMouseDown(e) {\n    if (this.hasAttribute('focused')) {\n      e.preventDefault();\n    }\n  }\n  /** @private */\n\n\n  _togglePasswordVisibilityTouchend(e) {\n    // Cancel the following click event\n    e.preventDefault();\n\n    this._togglePasswordVisibility();\n\n    this.inputElement.focus();\n  }\n  /** @private */\n\n\n  _togglePasswordVisibility() {\n    this._passwordVisibilityChanging = true;\n    this.inputElement.blur();\n\n    this._setPasswordVisible(!this.passwordVisible);\n\n    this.inputElement.focus();\n    this._passwordVisibilityChanging = false;\n  }\n  /** @private */\n\n\n  _passwordVisibleChange(passwordVisible) {\n    this.inputElement.type = passwordVisible ? 'text' : 'password';\n  }\n\n}\n\ncustomElements.define(PasswordFieldElement.is, PasswordFieldElement);\nexport { PasswordFieldElement };"
    },
    {
     "id": 315,
     "name": "../node_modules/@vaadin/vaadin-login/theme/lumo/vaadin-login-form-wrapper-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-login-form-wrapper\" theme-for=\"vaadin-login-form-wrapper\">\n  <template>\n    <style include=\"lumo-color lumo-typography\">\n      :host {\n        max-width: calc(var(--lumo-size-m) * 10);\n        background: var(--lumo-base-color) linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));\n      }\n\n      [part=\"form\"] {\n        padding: var(--lumo-space-l);\n      }\n\n      [part=\"form-title\"] {\n        margin-top: calc(var(--lumo-font-size-xxxl) - var(--lumo-font-size-xxl));\n      }\n\n      #forgotPasswordButton {\n        margin: var(--lumo-space-s) auto;\n      }\n\n      [part=\"error-message\"] {\n        background-color: var(--lumo-error-color-10pct);\n        padding: var(--lumo-space-m);\n        border-radius: var(--lumo-border-radius);\n        margin-top: var(--lumo-space-m);\n        margin-bottom: var(--lumo-space-s);\n        color: var(--lumo-error-text-color);\n      }\n\n      :host(:not([dir=\"rtl\"])) [part=\"error-message\"] {\n        padding-left: var(--lumo-size-m);\n      }\n\n      :host([dir=\"rtl\"]) [part=\"error-message\"] {\n        padding-right: var(--lumo-size-m);\n      }\n\n      [part=\"error-message\"]::before {\n        content: var(--lumo-icons-error);\n        font-family: lumo-icons;\n        font-size: var(--lumo-icon-size-m);\n        position: absolute;\n        width: var(--lumo-size-m);\n        height: 1em;\n        line-height: 1;\n        text-align: center;\n      }\n\n      :host(:not([dir=\"rtl\"])) [part=\"error-message\"]::before {\n        /* Visual centering */\n        margin-left: calc(var(--lumo-size-m) * -0.95);\n      }\n\n      :host([dir=\"rtl\"]) [part=\"error-message\"]::before {\n        /* Visual centering */\n        margin-right: calc(var(--lumo-size-m) * -0.95);\n      }\n\n      [part=\"error-message-title\"] {\n        margin: 0 0 0.25em;\n        color: inherit;\n      }\n\n      [part=\"error-message-description\"] {\n        font-size: var(--lumo-font-size-s);\n        line-height: var(--lumo-line-height-s);\n        margin: 0;\n        opacity: 0.9;\n      }\n\n      [part=\"footer\"] {\n        font-size: var(--lumo-font-size-xs);\n        line-height: var(--lumo-line-height-s);\n        color: var(--lumo-secondary-text-color);\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 316,
     "name": "../node_modules/@vaadin/vaadin-login/src/vaadin-login-form-wrapper.js?babel-target=es6",
     "source": "/**\n@license\nVaadin Login\nCopyright (C) 2018 Vaadin Ltd\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { LoginMixin } from './vaadin-login-mixin.js';\nimport '@vaadin/vaadin-button/src/vaadin-button.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-login-form-wrapper>` is a helper component providing a wrapper for the login form.\n *\n * See the usage in `<vaadin-login-form>`.\n *\n * ### Styling\n *\n * The following Shadow DOM parts of the `<vaadin-login-form-wrapper>` are available for styling:\n *\n * Part name      | Description\n * ---------------|---------------------------------------------------------|\n * `form`         | Container for the entire component's content\n * `form-title`   | Title of the login form\n * `error-message`| Container for error message, contains error-message-title and error-message-description parts. Hidden by default.\n * `error-message-title`       | Container for error message title\n * `error-message-description` | Container for error message description\n * `error-message-description` | Container for error message description\n * `footer`  | Container additional information text from `i18n` object\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * ### Component's slots\n *\n * The following slots are available for being set\n *\n * Slot name | Description\n * ----------|---------------------------------------------------|\n * `form`    | Html form placeholder. See the usage in `<vaadin-login-form>`.\n *\n * See examples of setting the content into slots in the live demos.\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @mixes Login.LoginMixin\n * @demo demo/index.html\n */\n\nclass LoginFormWrapperElement extends LoginMixin(ElementMixin(ThemableMixin(PolymerElement))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        overflow: hidden;\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      [part=\"form\"] {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n        box-sizing: border-box;\n      }\n\n      [part=\"form-title\"] {\n        margin: 0;\n      }\n\n      [part=\"error-message\"] {\n        position: relative;\n      }\n    </style>\n      <section part=\"form\">\n        <h2 part=\"form-title\">[[i18n.form.title]]</h2>\n        <div part=\"error-message\" hidden\\$=\"[[!error]]\">\n          <h5 part=\"error-message-title\">[[i18n.errorMessage.title]]</h5>\n          <p part=\"error-message-description\">[[i18n.errorMessage.message]]</p>\n        </div>\n\n        <slot name=\"form\">\n        </slot>\n\n        <vaadin-button id=\"forgotPasswordButton\" theme=\"tertiary small forgot-password\" on-click=\"_forgotPassword\" hidden\\$=\"[[noForgotPassword]]\">[[i18n.form.forgotPassword]]</vaadin-button>\n\n        <div part=\"footer\">\n          <p>[[i18n.additionalInformation]]</p>\n        </div>\n      </section>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-login-form-wrapper';\n  }\n\n  _forgotPassword() {\n    this.dispatchEvent(new CustomEvent('forgot-password'));\n  }\n\n}\n\ncustomElements.define(LoginFormWrapperElement.is, LoginFormWrapperElement);\nexport { LoginFormWrapperElement };"
    },
    {
     "id": 317,
     "name": "../node_modules/@vaadin/vaadin-login/src/vaadin-login-form.js?babel-target=es6",
     "source": "import './vaadin-login-form-wrapper.js';\nimport '@vaadin/vaadin-text-field/src/vaadin-text-field.js';\nimport '@vaadin/vaadin-text-field/src/vaadin-password-field.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { LoginMixin } from './vaadin-login-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\n/**\n * `<vaadin-login-form>` is a Web Component providing an easy way to require users\n * to log in into an application. Note that component has no shadowRoot.\n *\n * ```\n * <vaadin-login-form></vaadin-login-form>\n * ```\n *\n * Component has to be accessible from the `document` layer in order to allow password managers to work properly with form values.\n * Using `<vaadin-login-overlay>` allows to always attach the component to the document body.\n *\n * ### Styling\n *\n * The component doesn't have a shadowRoot, so the html form and input fields can be styled in an upper layer. To style\n * `vaadin-login-form-wrapper` check its documentation.\n *\n * See examples of setting the content into slots in the live demos.\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @mixes LoginMixin\n * @demo demo/index.html\n */\n\nclass LoginFormElement extends LoginMixin(ElementMixin(ThemableMixin(PolymerElement))) {\n  static get template() {\n    return html`\n    <style>\n      [part=\"vaadin-login-native-form\"] * {\n        width: 100%;\n      }\n    </style>\n    <vaadin-login-form-wrapper theme\\$=\"[[theme]]\" part=\"vaadin-login-native-form-wrapper\" action=\"{{action}}\" disabled=\"{{disabled}}\" error=\"{{error}}\" no-forgot-password=\"{{noForgotPassword}}\" i18n=\"{{i18n}}\" on-login=\"_retargetEvent\" on-forgot-password=\"_retargetEvent\">\n\n      <form part=\"vaadin-login-native-form\" method=\"POST\" action\\$=\"[[action]]\" slot=\"form\">\n        <vaadin-text-field name=\"username\" label=\"[[i18n.form.username]]\" id=\"vaadinLoginUsername\" required=\"\" on-keydown=\"_handleInputKeydown\" autocapitalize=\"none\" autocorrect=\"off\" spellcheck=\"false\">\n          <input type=\"text\" slot=\"input\" on-keyup=\"_handleInputKeyup\">\n        </vaadin-text-field>\n\n        <vaadin-password-field name=\"password\" label=\"[[i18n.form.password]]\" id=\"vaadinLoginPassword\" required=\"\" on-keydown=\"_handleInputKeydown\" spellcheck=\"false\">\n          <input type=\"password\" slot=\"input\" on-keyup=\"_handleInputKeyup\">\n        </vaadin-password-field>\n\n        <vaadin-button part=\"vaadin-login-submit\" theme=\"primary contained\" on-click=\"submit\" disabled\\$=\"[[disabled]]\">[[i18n.form.submit]]</vaadin-button>\n      </form>\n    </vaadin-login-form-wrapper>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-login-form';\n  }\n\n  static get version() {\n    return '1.2.0';\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    this._handleInputKeydown = this._handleInputKeydown.bind(this);\n  }\n  /**\n   * @param {StampedTemplate} dom\n   * @return {null}\n   * @protected\n   */\n\n\n  _attachDom(dom) {\n    this.appendChild(dom);\n  }\n\n  static get observers() {\n    return ['_errorChanged(error)'];\n  }\n  /** @private */\n\n\n  _errorChanged() {\n    if (this.error && !this._preventAutoEnable) {\n      this.disabled = false;\n    }\n  }\n\n  submit() {\n    if (this.disabled || !(this.__isValid(this.$.vaadinLoginUsername) && this.__isValid(this.$.vaadinLoginPassword))) {\n      return;\n    }\n\n    this.error = false;\n    this.disabled = true;\n    var loginEventDetails = {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        username: this.$.vaadinLoginUsername.value,\n        password: this.$.vaadinLoginPassword.value\n      }\n    };\n    var firedEvent = this.dispatchEvent(new CustomEvent('login', loginEventDetails));\n\n    if (this.action && firedEvent) {\n      this.querySelector('[part=\"vaadin-login-native-form\"]').submit();\n    }\n  }\n  /** @private */\n\n\n  __isValid(input) {\n    return input.validate && input.validate() || input.checkValidity && input.checkValidity();\n  }\n  /** @private */\n\n\n  _isEnterKey(e) {\n    return e.key === 'Enter' || e.keyCode === 13;\n  }\n  /** @private */\n\n\n  _handleInputKeydown(e) {\n    if (this._isEnterKey(e)) {\n      var {\n        currentTarget: inputActive\n      } = e;\n      var nextInput = inputActive.id === 'vaadinLoginUsername' ? this.$.vaadinLoginPassword : this.$.vaadinLoginUsername;\n\n      if (this.__isValid(inputActive)) {\n        if (this.__isValid(nextInput)) {\n          this.submit();\n        } else {\n          nextInput.focus();\n        }\n      }\n    }\n  }\n  /** @private */\n\n\n  _handleInputKeyup(e) {\n    var isTab = e.key === 'Tab' || e.keyCode === 9;\n    var input = e.currentTarget;\n\n    if (isTab && input && input.select) {\n      input.select(); // iOS 9 workaround: https://stackoverflow.com/a/7436574\n\n      setTimeout(() => input.setSelectionRange(0, 9999));\n    }\n  }\n\n}\n\ncustomElements.define(LoginFormElement.is, LoginFormElement);\nexport { LoginFormElement };"
    },
    {
     "id": 318,
     "name": "../node_modules/@vaadin/vaadin-radio-button/src/vaadin-radio-button.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-radio-button>` is a Web Component for radio buttons.\n *\n * ```html\n * <vaadin-radio-button value=\"foo\">Foo</vaadin-radio-button>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name         | Description\n * ------------------|----------------\n * `radio`           | The radio button element\n * `label`           | The label content element\n *\n * The following state attributes are available for styling:\n *\n * Attribute  | Description | Part name\n * -----------|-------------|------------\n * `disabled`   | Set when the radio button is disabled. | :host\n * `focus-ring` | Set when the radio button is focused using the keyboard. | :host\n * `focused`    | Set when the radio button is focused. | :host\n * `checked`    | Set when the radio button is checked. | :host\n * `empty`      | Set when there is no label provided. | label\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ControlStateMixin\n * @mixes ThemableMixin\n * @mixes GestureEventListeners\n * @element vaadin-radio-button\n * @demo demo/index.html\n */\n\nclass RadioButtonElement extends ElementMixin(ControlStateMixin(ThemableMixin(GestureEventListeners(PolymerElement)))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: inline-block;\n      }\n\n      label {\n        display: inline-flex;\n        align-items: baseline;\n        outline: none;\n      }\n\n      [part=\"radio\"] {\n        position: relative;\n        display: inline-block;\n        flex: none;\n      }\n\n      input[type=\"radio\"] {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        width: 100%;\n        height: 100%;\n        opacity: 0;\n        cursor: inherit;\n        margin: 0;\n      }\n\n      :host([disabled]) {\n        -webkit-tap-highlight-color: transparent;\n      }\n    </style>\n\n    <label>\n      <span part=\"radio\">\n        <input type=\"radio\" checked=\"[[checked]]\" disabled\\$=\"[[disabled]]\" role=\"presentation\" on-change=\"_onChange\" tabindex=\"-1\">\n      </span>\n\n      <span part=\"label\">\n        <slot></slot>\n      </span>\n    </label>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-radio-button';\n  }\n\n  static get version() {\n    return '1.5.1';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * True if the radio button is checked.\n       * @type {boolean}\n       */\n      checked: {\n        type: Boolean,\n        value: false,\n        notify: true,\n        observer: '_checkedChanged',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Name of the element.\n       */\n      name: String,\n\n      /**\n       * The value for this element.\n       * @type {string}\n       */\n      value: {\n        type: String,\n        value: 'on'\n      }\n    };\n  }\n\n  get name() {\n    return this.checked ? this._storedName : '';\n  }\n\n  set name(name) {\n    this._storedName = name;\n  }\n  /**\n   * @param {string} prop\n   * @param {?string} oldVal\n   * @param {?string} newVal\n   * @protected\n   */\n\n\n  attributeChangedCallback(prop, oldVal, newVal) {\n    super.attributeChangedCallback(prop, oldVal, newVal); // Needed until Edge has CSS Custom Properties (present in Edge Preview)\n\n    /* istanbul ignore if */\n\n    if (/^(disabled|checked)$/.test(prop)) {\n      // iOS 10.3 Safari has an issue with repainting shadow root element styles when a host attribute changes.\n      // Need this workaround (toggle any inline css property on and off) until we drop iOS 10.\n      var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n      /* istanbul ignore if */\n\n      if (isIOS && this.shadowRoot && parseInt(navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/)[1], 10)) {\n        var WEBKIT_PROPERTY = '-webkit-backface-visibility';\n        this.shadowRoot.querySelectorAll('*').forEach(el => {\n          el.style[WEBKIT_PROPERTY] = 'visible';\n          el.style[WEBKIT_PROPERTY] = '';\n        });\n      }\n    }\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.setAttribute('role', 'radio');\n\n    this._addListeners();\n\n    var attrName = this.getAttribute('name');\n\n    if (attrName) {\n      this.name = attrName;\n    }\n\n    this.shadowRoot.querySelector('[part~=\"label\"]').querySelector('slot').addEventListener('slotchange', this._updateLabelAttribute.bind(this));\n\n    this._updateLabelAttribute();\n  }\n  /** @private */\n\n\n  _updateLabelAttribute() {\n    var label = this.shadowRoot.querySelector('[part~=\"label\"]');\n    var assignedNodes = label.firstElementChild.assignedNodes();\n\n    if (this._isAssignedNodesEmpty(assignedNodes)) {\n      label.setAttribute('empty', '');\n    } else {\n      label.removeAttribute('empty');\n    }\n  }\n  /** @private */\n\n\n  _isAssignedNodesEmpty(nodes) {\n    // The assigned nodes considered to be empty if there is no slotted content or only one empty text node\n    return nodes.length === 0 || nodes.length == 1 && nodes[0].nodeType == Node.TEXT_NODE && nodes[0].textContent.trim() === '';\n  }\n  /** @private */\n\n\n  _checkedChanged(checked) {\n    this.setAttribute('aria-checked', checked);\n  }\n  /** @private */\n\n\n  _addListeners() {\n    this._addEventListenerToNode(this, 'down', e => {\n      if (!this.disabled) {\n        this.setAttribute('active', '');\n      }\n    });\n\n    this._addEventListenerToNode(this, 'up', e => {\n      this.removeAttribute('active');\n\n      if (!this.checked && !this.disabled) {\n        // If you change this block, please test manually that radio-button and\n        // radio-group still works ok on iOS 12/13 and up as it may cause\n        // an issue that is not possible to test programmatically.\n        // See: https://github.com/vaadin/vaadin-radio-button/issues/140\n        this.click();\n      }\n    });\n\n    this.addEventListener('keydown', e => {\n      if (!this.disabled && e.keyCode === 32) {\n        e.preventDefault();\n        this.setAttribute('active', '');\n      }\n    });\n    this.addEventListener('keyup', e => {\n      if (!this.disabled && e.keyCode === 32) {\n        e.preventDefault();\n        this.click();\n        this.removeAttribute('active');\n      }\n    });\n  }\n  /**\n   * Toggles the radio button, so that the native `change` event\n   * is dispatched. Overrides the standard `HTMLElement.prototype.click`.\n   * @protected\n   */\n\n\n  click() {\n    // If you change this block, please test manually that radio-button and\n    // radio-group still works ok on iOS 12/13 and up as it may cause\n    // an issue that is not possible to test programmatically.\n    // See: https://github.com/vaadin/vaadin-radio-button/issues/140\n    if (!this.disabled) {\n      this.shadowRoot.querySelector('input').dispatchEvent(new MouseEvent('click'));\n    }\n  }\n  /**\n   * @return {!HTMLInputElement}\n   * @protected\n   */\n\n\n  get focusElement() {\n    return this.shadowRoot.querySelector('input');\n  }\n  /** @private */\n\n\n  _onChange(e) {\n    this.checked = e.target.checked; // In the Shadow DOM, the `change` event is not leaked into the\n    // ancestor tree, so we must do this manually.\n\n    var changeEvent = new CustomEvent('change', {\n      detail: {\n        sourceEvent: e\n      },\n      bubbles: e.bubbles,\n      cancelable: e.cancelable\n    });\n    this.dispatchEvent(changeEvent);\n  }\n  /**\n   * Fired when the user toggles the radio button.\n   *\n   * @event change\n   */\n\n\n}\n\ncustomElements.define(RadioButtonElement.is, RadioButtonElement);\nexport { RadioButtonElement };"
    },
    {
     "id": 320,
     "name": "../node_modules/@vaadin/vaadin-text-field/src/vaadin-number-field.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport '@polymer/polymer/polymer-element.js';\nimport '@polymer/polymer/lib/elements/custom-style.js';\nimport { TextFieldElement } from './vaadin-text-field.js';\nimport { DomModule } from '@polymer/polymer/lib/elements/dom-module.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"vaadin-number-field-template\">\n  <template>\n    <style>\n      :host([readonly]) [part\\$=\"button\"] {\n        pointer-events: none;\n      }\n\n      [part=\"decrease-button\"]::before {\n        content: \"\";\n      }\n\n      [part=\"increase-button\"]::before {\n        content: \"+\";\n      }\n\n      [part=\"decrease-button\"],\n      [part=\"increase-button\"] {\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      /* Hide the native arrow icons */\n      [part=\"value\"]::-webkit-outer-spin-button,\n      [part=\"value\"]::-webkit-inner-spin-button {\n        -webkit-appearance: none;\n        margin: 0;\n      }\n\n      [part=\"value\"] {\n        /* Older Firefox versions (v47.0) requires !important */\n        -moz-appearance: textfield !important;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"input-field\"] {\n        direction: ltr;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"value\"]::placeholder {\n        direction: rtl;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"input-field\"] ::slotted(input)::placeholder {\n        direction: rtl;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"value\"]:-ms-input-placeholder,\n      :host([dir=\"rtl\"]) [part=\"input-field\"] ::slotted(input):-ms-input-placeholder {\n        direction: rtl;\n      }\n\n      :host([dir=\"rtl\"]:not([has-controls])) [part=\"value\"]::placeholder {\n        text-align: left;\n      }\n\n      :host([dir=\"rtl\"]:not([has-controls])) [part=\"input-field\"] ::slotted(input)::placeholder {\n        text-align: left;\n      }\n\n      :host([dir=\"rtl\"]:not([has-controls])) [part=\"value\"]:-ms-input-placeholder,\n      :host([dir=\"rtl\"]:not([has-controls])) [part=\"input-field\"] ::slotted(input):-ms-input-placeholder {\n        text-align: left;\n      }\n    </style>\n\n    <div disabled\\$=\"[[!_allowed(-1, value, min, max, step)]]\" part=\"decrease-button\" on-click=\"_decreaseValue\" on-touchend=\"_decreaseButtonTouchend\" hidden\\$=\"[[!hasControls]]\">\n    </div>\n\n    <div disabled\\$=\"[[!_allowed(1, value, min, max, step)]]\" part=\"increase-button\" on-click=\"_increaseValue\" on-touchend=\"_increaseButtonTouchend\" hidden\\$=\"[[!hasControls]]\">\n    </div>\n  </template>\n\n  \n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);\nvar memoizedTemplate;\n/**\n * `<vaadin-number-field>` is a Web Component for number field control in forms.\n *\n * ```html\n * <vaadin-number-field label=\"Number\">\n * </vaadin-number-field>\n * ```\n * @extends TextFieldElement\n * @demo demo/index.html\n */\n\nclass NumberFieldElement extends TextFieldElement {\n  static get is() {\n    return 'vaadin-number-field';\n  }\n\n  static get version() {\n    return '2.8.2';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Set to true to display value increase/decrease controls.\n       * @attr {boolean} has-controls\n       * @type {boolean}\n       */\n      hasControls: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * The minimum value of the field.\n       */\n      min: {\n        type: Number,\n        reflectToAttribute: true,\n        observer: '_minChanged'\n      },\n\n      /**\n       * The maximum value of the field.\n       */\n      max: {\n        type: Number,\n        reflectToAttribute: true,\n        observer: '_maxChanged'\n      },\n\n      /**\n       * Specifies the allowed number intervals of the field.\n       * @type {number}\n       */\n      step: {\n        type: Number,\n        value: 1,\n        observer: '_stepChanged'\n      }\n    };\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.__previousValidInput = this.value || '';\n    this.inputElement.type = 'number';\n    this.inputElement.addEventListener('change', this.__onInputChange.bind(this));\n  }\n  /** @private */\n\n\n  _decreaseButtonTouchend(e) {\n    // Cancel the following click and focus events\n    e.preventDefault();\n\n    this._decreaseValue();\n  }\n  /** @private */\n\n\n  _increaseButtonTouchend(e) {\n    // Cancel the following click and focus events\n    e.preventDefault();\n\n    this._increaseValue();\n  }\n\n  static get template() {\n    if (!memoizedTemplate) {\n      // Clone the superclass template\n      memoizedTemplate = super.template.cloneNode(true); // Retrieve this element's dom-module template\n\n      var thisTemplate = DomModule.import(this.is + '-template', 'template');\n      var decreaseButton = thisTemplate.content.querySelector('[part=\"decrease-button\"]');\n      var increaseButton = thisTemplate.content.querySelector('[part=\"increase-button\"]');\n      var styles = thisTemplate.content.querySelector('style'); // Add the buttons and styles to the text-field template\n\n      var inputField = memoizedTemplate.content.querySelector('[part=\"input-field\"]');\n      var prefixSlot = memoizedTemplate.content.querySelector('[name=\"prefix\"]');\n      inputField.insertBefore(decreaseButton, prefixSlot);\n      inputField.appendChild(increaseButton);\n      memoizedTemplate.content.appendChild(styles);\n    }\n\n    return memoizedTemplate;\n  }\n  /** @protected */\n\n\n  _createConstraintsObserver() {\n    // NOTE: do not call \"super\" but instead override the method to add extra arguments\n    this._createMethodObserver('_constraintsChanged(required, minlength, maxlength, pattern, min, max, step)');\n  }\n  /** @private */\n\n\n  _constraintsChanged(required, minlength, maxlength, pattern, min, max, step) {\n    if (!this.invalid) {\n      return;\n    }\n\n    var isNumUnset = n => !n && n !== 0;\n\n    if (!isNumUnset(min) || !isNumUnset(max)) {\n      this.validate();\n    } else {\n      super._constraintsChanged(required, minlength, maxlength, pattern);\n    }\n  }\n  /** @private */\n\n\n  _decreaseValue() {\n    this._incrementValue(-1);\n  }\n  /** @private */\n\n\n  _increaseValue() {\n    this._incrementValue(1);\n  }\n  /** @private */\n\n\n  _incrementValue(incr) {\n    if (this.disabled || this.readonly) {\n      return;\n    }\n\n    var value = parseFloat(this.value);\n\n    if (!this.value) {\n      if (this.min == 0 && incr < 0 || this.max == 0 && incr > 0 || this.max == 0 && this.min == 0) {\n        incr = 0;\n        value = 0;\n      } else if ((this.max == null || this.max >= 0) && (this.min == null || this.min <= 0)) {\n        value = 0;\n      } else if (this.min > 0) {\n        value = this.min;\n\n        if (this.max < 0 && incr < 0) {\n          value = this.max;\n        }\n\n        incr = 0;\n      } else if (this.max < 0) {\n        value = this.max;\n\n        if (incr < 0) {\n          incr = 0;\n        } else {\n          // FIXME(yuriy): find a proper solution to make correct step back\n          if (this._getIncrement(1, value - this.step) > this.max) {\n            value -= 2 * this.step;\n          } else {\n            value -= this.step;\n          }\n        }\n      }\n    } else if (value < this.min) {\n      incr = 0;\n      value = this.min;\n    } else if (value > this.max) {\n      incr = 0;\n      value = this.max;\n    }\n\n    var newValue = this._getIncrement(incr, value);\n\n    if (!this.value || incr == 0 || this._incrementIsInsideTheLimits(incr, value)) {\n      this._setValue(newValue);\n    }\n  }\n  /** @private */\n\n\n  _setValue(value) {\n    this.value = this.inputElement.value = String(parseFloat(value));\n    this.dispatchEvent(new CustomEvent('change', {\n      bubbles: true\n    }));\n  }\n  /** @private */\n\n\n  _getIncrement(incr, currentValue) {\n    var step = this.step || 1,\n        min = this.min || 0; // To avoid problems with decimal math, multiplying to operate with integers.\n\n    var multiplier = Math.max(this._getMultiplier(currentValue), this._getMultiplier(step), this._getMultiplier(min));\n    step *= multiplier;\n    currentValue = Math.round(currentValue * multiplier);\n    min *= multiplier;\n    var margin = (currentValue - min) % step;\n\n    if (incr > 0) {\n      return (currentValue - margin + step) / multiplier;\n    } else if (incr < 0) {\n      return (currentValue - (margin || step)) / multiplier;\n    } else {\n      return currentValue / multiplier;\n    }\n  }\n  /** @private */\n\n\n  _getDecimalCount(number) {\n    var s = String(number);\n    var i = s.indexOf('.');\n    return i === -1 ? 1 : s.length - i - 1;\n  }\n  /** @private */\n\n\n  _getMultiplier(number) {\n    if (!isNaN(number)) {\n      return Math.pow(10, this._getDecimalCount(number));\n    }\n  }\n  /** @private */\n\n\n  _incrementIsInsideTheLimits(incr, value) {\n    if (incr < 0) {\n      return this.min == null || this._getIncrement(incr, value) >= this.min;\n    } else if (incr > 0) {\n      return this.max == null || this._getIncrement(incr, value) <= this.max;\n    } else {\n      return this._getIncrement(incr, value) <= this.max && this._getIncrement(incr, value) >= this.min;\n    }\n  }\n  /** @private */\n\n\n  _allowed(sign) {\n    var incr = sign * (this.step || 1);\n    var value = parseFloat(this.value);\n    return !this.value || !this.disabled && this._incrementIsInsideTheLimits(incr, value);\n  }\n  /**\n   * @param {number} newVal\n   * @param {number | undefined} oldVal\n   * @protected\n   */\n\n\n  _stepChanged(newVal, oldVal) {\n    // Avoid using initial value in validation\n    this.__validateByStep = this.__stepChangedCalled || this.getAttribute('step') !== null;\n    this.inputElement.step = this.__validateByStep ? newVal : 'any';\n    this.__stepChangedCalled = true;\n    this.setAttribute('step', newVal);\n  }\n  /** @private */\n\n\n  _minChanged(min) {\n    this.inputElement.min = min;\n  }\n  /** @private */\n\n\n  _maxChanged(max) {\n    this.inputElement.max = max;\n  }\n  /**\n   * @param {unknown} newVal\n   * @param {unknown} oldVal\n   * @protected\n   */\n\n\n  _valueChanged(newVal, oldVal) {\n    // Validate value to be numeric\n    if (newVal && isNaN(parseFloat(newVal))) {\n      this.value = '';\n    } else if (typeof this.value !== 'string') {\n      this.value = String(this.value);\n    }\n\n    super._valueChanged(this.value, oldVal);\n  }\n  /**\n   * @param {!KeyboardEvent} e\n   * @protected\n   */\n\n\n  _onKeyDown(e) {\n    if (e.keyCode == 38) {\n      e.preventDefault();\n\n      this._increaseValue();\n    } else if (e.keyCode == 40) {\n      e.preventDefault();\n\n      this._decreaseValue();\n    }\n\n    super._onKeyDown(e);\n  }\n  /** @private */\n\n\n  __onInputChange() {\n    this.validate();\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  checkValidity() {\n    // text-field mixin does not check against `min`, `max` and `step`\n    if (this.min !== undefined || this.max !== undefined || this.__validateByStep) {\n      return this.inputElement.checkValidity();\n    }\n\n    return super.checkValidity();\n  }\n\n}\n\nwindow.customElements.define(NumberFieldElement.is, NumberFieldElement);\nexport { NumberFieldElement };"
    },
    {
     "id": 351,
     "name": "../node_modules/@vaadin/vaadin-context-menu/src/vaadin-context-menu.js?babel-target=es6 + 4 modules"
    },
    {
     "id": 353,
     "name": "../node_modules/@vaadin/vaadin-time-picker/theme/lumo/vaadin-time-picker.js?babel-target=es6 + 3 modules"
    },
    {
     "id": 355,
     "name": "../node_modules/@vaadin/vaadin-login/theme/lumo/vaadin-login-form.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 357,
     "name": "../node_modules/@vaadin/vaadin-select/src/vaadin-select.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 359,
     "name": "../node_modules/@vaadin/vaadin-context-menu/theme/lumo/vaadin-context-menu.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 360,
     "name": "../node_modules/@vaadin/vaadin-crud/src/vaadin-crud-edit-column.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 361,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-sorter.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 362,
     "name": "../node_modules/@vaadin/vaadin-select/theme/lumo/vaadin-select.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 363,
     "name": "../node_modules/@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-button.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 364,
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-number-field.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 371,
     "name": "../node_modules/@vaadin/vaadin-time-picker/src/vaadin-time-picker.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 373,
     "name": "../node_modules/@vaadin/flow-frontend/comboBoxConnector-es6.js?babel-target=es6",
     "source": "import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nimport './comboBoxConnector.js';\nimport { ComboBoxPlaceholder } from '@vaadin/vaadin-combo-box/src/vaadin-combo-box-placeholder.js';\nwindow.Vaadin.Flow.Legacy.Debouncer = Debouncer;\nwindow.Vaadin.Flow.Legacy.timeOut = timeOut;\nwindow.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;"
    },
    {
     "id": 374,
     "name": "../node_modules/@vaadin/flow-frontend/contextMenuConnector-es6.js?babel-target=es6",
     "source": "import { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport * as Gestures from '@polymer/polymer/lib/utils/gestures.js';\nimport './contextMenuConnector.js';\nwindow.Vaadin.Flow.Legacy.GestureEventListeners = GestureEventListeners;\nwindow.Vaadin.Flow.Legacy.Gestures = Gestures;"
    },
    {
     "id": 375,
     "name": "../node_modules/@vaadin/flow-frontend/datepickerConnector.js?babel-target=es6",
     "source": "(function () {\n  var tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Date Picker', 'vaadin-date-picker-flow');\n  };\n  /* helper class for parsing regex from formatted date string */\n\n\n  class FlowDatePickerPart {\n    constructor(initial) {\n      this.initial = initial;\n      this.index = 0;\n      this.value = 0;\n    }\n\n    static compare(part1, part2) {\n      if (part1.index < part2.index) {\n        return -1;\n      }\n\n      if (part1.index > part2.index) {\n        return 1;\n      }\n\n      return 0;\n    }\n\n  }\n\n  window.Vaadin.Flow.datepickerConnector = {\n    initLazy: datepicker => tryCatchWrapper(function (datepicker) {\n      // Check whether the connector was already initialized for the datepicker\n      if (datepicker.$connector) {\n        return;\n      }\n\n      datepicker.$connector = {};\n      /* init helper parts for reverse-engineering date-regex */\n\n      datepicker.$connector.dayPart = new FlowDatePickerPart(\"22\");\n      datepicker.$connector.monthPart = new FlowDatePickerPart(\"11\");\n      datepicker.$connector.yearPart = new FlowDatePickerPart(\"1987\");\n      datepicker.$connector.parts = [datepicker.$connector.dayPart, datepicker.$connector.monthPart, datepicker.$connector.yearPart]; // Old locale should always be the default vaadin-date-picker component\n      // locale {English/US} as we init lazily and the date-picker formats\n      // the date using the default i18n settings and we need to use the input\n      // value as we may need to parse user input so we can't use the _selectedDate value.\n\n      var oldLocale = \"en-us\";\n      datepicker.addEventListener('blur', tryCatchWrapper(e => {\n        if (!e.target.value && e.target.invalid) {\n          console.warn(\"Invalid value in the DatePicker.\");\n        }\n      }));\n      var cleanString = tryCatchWrapper(function (string) {\n        // Clear any non ascii characters from the date string,\n        // mainly the LEFT-TO-RIGHT MARK.\n        // This is a problem for many Microsoft browsers where `toLocaleDateString`\n        // adds the LEFT-TO-RIGHT MARK see https://en.wikipedia.org/wiki/Left-to-right_mark\n        return string.replace(/[^\\x00-\\x7F]/g, \"\");\n      });\n      var getInputValue = tryCatchWrapper(function () {\n        var inputValue = '';\n\n        try {\n          inputValue = datepicker._inputValue;\n        } catch (err) {\n          /* component not ready: falling back to stored value */\n          inputValue = datepicker.value || '';\n        }\n\n        return inputValue;\n      });\n      datepicker.$connector.setLocale = tryCatchWrapper(function (locale) {\n        try {\n          // Check whether the locale is supported or not\n          new Date().toLocaleDateString(locale);\n        } catch (e) {\n          locale = \"en-US\";\n          console.warn(\"The locale is not supported, using default locale setting(en-US).\");\n        }\n\n        var currentDate = false;\n        var inputValue = getInputValue();\n\n        if (datepicker.i18n.parseDate !== 'undefined' && inputValue) {\n          /* get current date with old parsing */\n          currentDate = datepicker.i18n.parseDate(inputValue);\n        }\n        /* create test-string where to extract parsing regex */\n\n\n        var testDate = new Date(Date.UTC(datepicker.$connector.yearPart.initial, datepicker.$connector.monthPart.initial - 1, datepicker.$connector.dayPart.initial));\n        var testString = cleanString(testDate.toLocaleDateString(locale, {\n          timeZone: 'UTC'\n        }));\n        datepicker.$connector.parts.forEach(function (part) {\n          part.index = testString.indexOf(part.initial);\n        });\n        /* sort items to match correct places in regex groups */\n\n        datepicker.$connector.parts.sort(FlowDatePickerPart.compare);\n        /* create regex\n        * regex will be the date, so that:\n        * - day-part is '(\\d{1,2})' (1 or 2 digits),\n        * - month-part is '(\\d{1,2})' (1 or 2 digits),\n        * - year-part is '(\\d{4})' (4 digits)\n        *\n        * and everything else is left as is.\n        * For example, us date \"10/20/2010\" => \"(\\d{1,2})/(\\d{1,2})/(\\d{4})\".\n        *\n        * The sorting part solves that which part is which (for example,\n        * here the first part is month, second day and third year)\n        *  */\n\n        datepicker.$connector.regex = testString.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&').replace(datepicker.$connector.dayPart.initial, \"(\\\\d{1,2})\").replace(datepicker.$connector.monthPart.initial, \"(\\\\d{1,2})\").replace(datepicker.$connector.yearPart.initial, \"(\\\\d{4})\");\n        datepicker.i18n.formatDate = tryCatchWrapper(function (date) {\n          var rawDate = new Date(Date.UTC(date.year, date.month, date.day));\n          return cleanString(rawDate.toLocaleDateString(locale, {\n            timeZone: 'UTC'\n          }));\n        });\n        datepicker.i18n.parseDate = tryCatchWrapper(function (dateString) {\n          dateString = cleanString(dateString);\n\n          if (dateString.length == 0) {\n            return;\n          }\n\n          var match = dateString.match(datepicker.$connector.regex);\n\n          if (match && match.length == 4) {\n            for (var i = 1; i < 4; i++) {\n              datepicker.$connector.parts[i - 1].value = parseInt(match[i]);\n            }\n\n            return {\n              day: datepicker.$connector.dayPart.value,\n              month: datepicker.$connector.monthPart.value - 1,\n              year: datepicker.$connector.yearPart.value\n            };\n          } else {\n            return false;\n          }\n        });\n\n        if (inputValue === \"\") {\n          oldLocale = locale;\n        } else if (currentDate) {\n          /* set current date to invoke use of new locale */\n          datepicker._selectedDate = new Date(currentDate.year, currentDate.month, currentDate.day);\n        }\n      });\n    })(datepicker)\n  };\n})();"
    },
    {
     "id": 376,
     "name": "../node_modules/@vaadin/flow-frontend/dndConnector-es6.js?babel-target=es6",
     "source": "import './dndConnector.js';"
    },
    {
     "id": 377,
     "name": "../node_modules/@vaadin/flow-frontend/flow-component-renderer.js?babel-target=es6",
     "source": "import '@polymer/polymer/polymer-legacy.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { animationFrame, idlePeriod } from '@polymer/polymer/lib/utils/async.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\n\nclass FlowComponentRenderer extends PolymerElement {\n  static get template() {\n    return html`\n    <slot></slot>\n`;\n  }\n\n  static get is() {\n    return 'flow-component-renderer';\n  }\n\n  static get properties() {\n    return {\n      nodeid: Number,\n      appid: String\n    };\n  }\n\n  static get observers() {\n    return ['_attachRenderedComponentIfAble(appid, nodeid)'];\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    this._runChrome72ShadowDomBugWorkaround();\n  }\n  /* workaround for issue vaadin/flow#5025 */\n\n\n  _runChrome72ShadowDomBugWorkaround() {\n    var userAgent = navigator.userAgent;\n\n    if (userAgent && userAgent.match('Chrome\\/')) {\n      // example: ... Chrome/72.0.3626.96 ...\n      var majorVersionString = userAgent.split('Chrome\\/')[1].split('.')[0];\n\n      if (majorVersionString && parseInt(majorVersionString) > 71) {\n        var debouncedNotifyResize = this._getDebouncedNotifyResizeFunction(); // if there is no notifyResize function, then just skip\n\n\n        if (debouncedNotifyResize) {\n          this.style.visibility = 'hidden'; // need to use animation frame instead of timeout or focusing won't work\n\n          requestAnimationFrame(() => {\n            this.style.visibility = '';\n            debouncedNotifyResize();\n          });\n        }\n      }\n    }\n  }\n\n  _getDebouncedNotifyResizeFunction() {\n    // 1. dig out the web component that might have the notifyResize function\n    var component = this.parentElement;\n\n    while (true) {\n      if (!component) {\n        return;\n      }\n\n      if (component.notifyResize) {\n        break;\n      } else {\n        component = component.parentElement;\n      }\n    } // 2. assign a debounced proxy to notifyResize, if not yet there\n\n\n    if (!component._debouncedNotifyResize) {\n      component._debouncedNotifyResize = function () {\n        component.__debouncedNotifyResize = Debouncer.debounce(component.__debouncedNotifyResize, // initially undefined\n        animationFrame, component.notifyResize);\n      };\n    }\n\n    return component._debouncedNotifyResize;\n  }\n\n  ready() {\n    super.ready();\n    this.addEventListener(\"click\", function (event) {\n      if (this.firstChild && typeof this.firstChild.click === \"function\" && event.target === this) {\n        this.firstChild.click();\n      }\n    });\n  }\n\n  _asyncAttachRenderedComponentIfAble() {\n    this._debouncer = Debouncer.debounce(this._debouncer, idlePeriod, () => this._attachRenderedComponentIfAble());\n  }\n\n  _attachRenderedComponentIfAble() {\n    if (!this.nodeid || !this.appid) {\n      return;\n    }\n\n    var renderedComponent = this._getRenderedComponent();\n\n    if (this.firstChild) {\n      if (!renderedComponent) {\n        this._clear();\n\n        this._asyncAttachRenderedComponentIfAble();\n      } else if (this.firstChild !== renderedComponent) {\n        this.replaceChild(renderedComponent, this.firstChild);\n\n        this._defineFocusTarget();\n\n        this.onComponentRendered();\n      } else {\n        this._defineFocusTarget();\n\n        this.onComponentRendered();\n      }\n    } else {\n      if (renderedComponent) {\n        this.appendChild(renderedComponent);\n\n        this._defineFocusTarget();\n\n        this.onComponentRendered();\n      } else {\n        this._asyncAttachRenderedComponentIfAble();\n      }\n    }\n  }\n\n  _getRenderedComponent() {\n    try {\n      return window.Vaadin.Flow.clients[this.appid].getByNodeId(this.nodeid);\n    } catch (error) {\n      console.error(\"Could not get node %s from app %s\", this.nodeid, this.appid);\n      console.error(error);\n    }\n\n    return null;\n  }\n\n  _clear() {\n    while (this.firstChild) {\n      this.removeChild(this.firstChild);\n    }\n  }\n\n  onComponentRendered() {// subclasses can override this method to execute custom logic on resize\n  }\n  /* Setting the `focus-target` attribute to the first focusable descendant\n  starting from the firstChild necessary for the focus to be delegated\n  within the flow-component-renderer when used inside a vaadin-grid cell  */\n\n\n  _defineFocusTarget() {\n    var focusable = this._getFirstFocusableDescendant(this.firstChild);\n\n    if (focusable !== null) {\n      focusable.setAttribute('focus-target', 'true');\n    }\n  }\n\n  _getFirstFocusableDescendant(node) {\n    if (this._isFocusable(node)) {\n      return node;\n    }\n\n    if (!node.children) {\n      return null;\n    }\n\n    for (var i = 0; i < node.children.length; i++) {\n      var focusable = this._getFirstFocusableDescendant(node.children[i]);\n\n      if (focusable !== null) {\n        return focusable;\n      }\n    }\n\n    return null;\n  }\n\n  _isFocusable(node) {\n    if (node.hasAttribute && typeof node.hasAttribute === 'function' && (node.hasAttribute(\"disabled\") || node.hasAttribute(\"hidden\"))) {\n      return false;\n    }\n\n    return node.tabIndex === 0;\n  }\n\n}\n\nwindow.customElements.define(FlowComponentRenderer.is, FlowComponentRenderer);"
    },
    {
     "id": 378,
     "name": "../node_modules/@vaadin/flow-frontend/gridConnector-es6.js?babel-target=es6",
     "source": "import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut, animationFrame } from '@polymer/polymer/lib/utils/async.js';\nimport { GridElement } from '@vaadin/vaadin-grid/src/vaadin-grid.js';\nimport { ItemCache } from '@vaadin/vaadin-grid/src/vaadin-grid-data-provider-mixin.js';\nimport './gridConnector.js';\nwindow.Vaadin.Flow.Legacy.Debouncer = Debouncer;\nwindow.Vaadin.Flow.Legacy.timeOut = timeOut;\nwindow.Vaadin.Flow.Legacy.animationFrame = animationFrame;\nwindow.Vaadin.Flow.Legacy.GridElement = GridElement;\nwindow.Vaadin.Flow.Legacy.ItemCache = ItemCache;"
    },
    {
     "id": 379,
     "name": "../node_modules/@vaadin/flow-frontend/gridProConnector.js?babel-target=es6",
     "source": "(function () {\n  var tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Grid Pro', 'vaadin-grid-pro-flow');\n  };\n\n  window.Vaadin.Flow.gridProConnector = {\n    setEditModeRenderer: (column, component) => tryCatchWrapper(function (column, component) {\n      column.editModeRenderer = tryCatchWrapper(function (root) {\n        root.appendChild(component);\n\n        this._grid._cancelStopEdit();\n\n        component.focus();\n      }); // Not needed in case of custom editor as value is set on server-side.\n      // Overridden in order to avoid blinking of the cell content.\n\n      column._setEditorValue = function (editor, value) {};\n\n      column._getEditorValue = function (editor) {\n        return;\n      };\n    })(column, component),\n    patchEditModeRenderer: column => tryCatchWrapper(function (column) {\n      column.__editModeRenderer = tryCatchWrapper(function (root, column, rowData) {\n        var cell = root.assignedSlot.parentNode;\n        var grid = column._grid;\n\n        if (grid.__edited && grid.__edited.model.item.key !== rowData.item.key) {\n          grid._stopEdit();\n\n          return;\n        }\n\n        var tagName = column._getEditorTagName(cell);\n\n        if (!root.firstElementChild || root.firstElementChild.localName.toLowerCase() !== tagName) {\n          root.innerHTML = `<${tagName}></${tagName}>`;\n        }\n      });\n    })(column)\n  };\n})();"
    },
    {
     "id": 380,
     "name": "../node_modules/@vaadin/flow-frontend/ironListConnector-es6.js?babel-target=es6",
     "source": "import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nimport './ironListConnector.js';\nwindow.Vaadin.Flow.Legacy.Debouncer = Debouncer;\nwindow.Vaadin.Flow.Legacy.timeOut = timeOut;"
    },
    {
     "id": 381,
     "name": "../node_modules/@vaadin/flow-frontend/ironListStyles.js?babel-target=es6",
     "source": "import '@polymer/polymer/lib/elements/custom-style.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<style>\n/* Fixes zero width in flex layouts */\niron-list {\n  flex: auto;\n  align-self: stretch;\n}\n</style>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 382,
     "name": "../node_modules/@vaadin/flow-frontend/menubarConnector.js?babel-target=es6",
     "source": "/*\n * Copyright 2000-2019 Vaadin Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n(function () {\n  var tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Menu Bar', 'vaadin-menu-bar-flow');\n  };\n\n  window.Vaadin.Flow.menubarConnector = {\n    initLazy: function (menubar) {\n      if (menubar.$connector) {\n        return;\n      }\n\n      menubar.$connector = {\n        updateButtons: tryCatchWrapper(function () {\n          if (!menubar.shadowRoot) {\n            // workaround for https://github.com/vaadin/flow/issues/5722\n            setTimeout(() => menubar.$connector.updateButtons());\n            return;\n          } // Propagate disabled state from items to parent buttons\n\n\n          menubar.items.forEach(item => item.disabled = item.component.disabled); // Remove hidden items entirely from the array. Just hiding them\n          // could cause the overflow button to be rendered without items.\n          // resetContent needs to be called to make buttons visible again.\n          //\n          // The items-prop needs to be set even when all items are visible\n          // to update the disabled state and re-render buttons.\n\n          menubar.items = menubar.items.filter(item => !item.component.hidden); // Propagate click events from the menu buttons to the item components\n\n          menubar._buttons.forEach(button => {\n            if (button.item && button.item.component) {\n              button.addEventListener('click', e => {\n                if (e.composedPath().indexOf(button.item.component) === -1) {\n                  button.item.component.click();\n                }\n              });\n            }\n          });\n        })\n      };\n    }\n  };\n})();"
    },
    {
     "id": 383,
     "name": "../node_modules/@vaadin/flow-frontend/timepickerConnector.js?babel-target=es6",
     "source": "(function () {\n  var tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Time Picker', 'vaadin-time-picker-flow');\n  };\n\n  window.Vaadin.Flow.timepickerConnector = {\n    initLazy: timepicker => tryCatchWrapper(function (timepicker) {\n      // Check whether the connector was already initialized for the timepicker\n      if (timepicker.$connector) {\n        return;\n      }\n\n      timepicker.$connector = {};\n\n      var getAmPmString = function (locale, testTime) {\n        var testTimeString = testTime.toLocaleTimeString(locale); // AM/PM string is anything from one letter in eastern arabic to standard two letters,\n        // to having space in between, dots ...\n        // cannot disqualify whitespace since some locales use a. m. / p. m.\n        // TODO when more scripts support is added (than Arabic), need to exclude those numbers too\n\n        var endWithAmPmRegex = /[^\\d\\u0660-\\u0669]+$/g;\n        var amPmString = testTimeString.match(endWithAmPmRegex);\n\n        if (!amPmString) {\n          // eg. chinese (and some else too) starts with am/pm\n          amPmString = testTimeString.match(/^[^\\d\\u0660-\\u0669]+/g);\n        }\n\n        if (amPmString) {\n          amPmString = amPmString[0].trim();\n        }\n\n        return amPmString;\n      };\n\n      var testPmTime = new Date('August 19, 1975 23:15:30');\n      var testAmTime = new Date('August 19, 1975 05:15:30');\n\n      var getPmString = function (locale) {\n        return getAmPmString(locale, testPmTime);\n      };\n\n      var getAmString = function (locale) {\n        return getAmPmString(locale, testAmTime);\n      }; // map from unicode eastern arabic number characters to arabic numbers\n\n\n      var arabicDigitMap = {\n        '\\\\u0660': '0',\n        '\\\\u0661': '1',\n        '\\\\u0662': '2',\n        '\\\\u0663': '3',\n        '\\\\u0664': '4',\n        '\\\\u0665': '5',\n        '\\\\u0666': '6',\n        '\\\\u0667': '7',\n        '\\\\u0668': '8',\n        '\\\\u0669': '9'\n      }; // parses eastern arabic number characters to arabic numbers (0-9)\n\n      var anyNumberCharToArabicNumberReplacer = function (charsToReplace) {\n        return charsToReplace.replace(/[\\u0660-\\u0669]/g, function (char) {\n          var unicode = '\\\\u0' + char.charCodeAt(0).toString(16);\n          return arabicDigitMap[unicode];\n        });\n      };\n\n      var parseAnyCharsToInt = function (anyNumberChars) {\n        return parseInt(anyNumberCharToArabicNumberReplacer(anyNumberChars));\n      };\n\n      var parseMillisecondCharsToInt = function (millisecondChars) {\n        millisecondChars = anyNumberCharToArabicNumberReplacer(millisecondChars); // digits are either .1 .01 or .001 so need to \"shift\"\n\n        if (millisecondChars.length === 1) {\n          millisecondChars += \"00\";\n        } else if (millisecondChars.length === 2) {\n          millisecondChars += \"0\";\n        }\n\n        return parseInt(millisecondChars);\n      }; // detecting milliseconds from input, expects am/pm removed from end, eg. .0 or .00 or .000\n\n\n      var millisecondRegExp = /[[\\.][\\d\\u0660-\\u0669]{1,3}$/;\n      timepicker.$connector.setLocale = tryCatchWrapper(function (locale) {\n        // capture previous value if any\n        var previousValueObject;\n\n        if (timepicker.value && timepicker.value !== '') {\n          previousValueObject = timepicker.i18n.parseTime(timepicker.value);\n        }\n\n        try {\n          // Check whether the locale is supported by the browser or not\n          testPmTime.toLocaleTimeString(locale);\n        } catch (e) {\n          locale = \"en-US\"; // FIXME should do a callback for server to throw an exception ?\n\n          throw new Error(\"vaadin-time-picker: The locale \" + locale + \" is not supported, falling back to default locale setting(en-US).\");\n        } // 1. 24 or 12 hour clock, if latter then what are the am/pm strings ?\n\n\n        var pmString = getPmString(locale);\n        var amString = getAmString(locale); // 2. What is the separator ?\n\n        var localeTimeString = testPmTime.toLocaleTimeString(locale); // since the next regex picks first non-number-whitespace, need to discard possible PM from beginning (eg. chinese locale)\n\n        if (pmString && localeTimeString.startsWith(pmString)) {\n          localeTimeString = localeTimeString.replace(pmString, '');\n        }\n\n        var separator = localeTimeString.match(/[^\\u0660-\\u0669\\s\\d]/); // 3. regexp that allows to find the numbers with optional separator and continuing searching after it\n\n        var numbersRegExp = new RegExp('([\\\\d\\\\u0660-\\\\u0669]){1,2}(?:' + separator + ')?', 'g');\n\n        var includeSeconds = function () {\n          return timepicker.step && timepicker.step < 60;\n        };\n\n        var includeMilliSeconds = function () {\n          return timepicker.step && timepicker.step < 1;\n        }; // the web component expects the correct granularity used for the time string,\n        // thus need to format the time object in correct granularity by passing the format options\n\n\n        var cachedStep;\n        var cachedOptions;\n\n        var getTimeFormatOptions = function () {\n          // calculate the format options if none done cached or step has changed\n          if (!cachedOptions || cachedStep !== timepicker.step) {\n            cachedOptions = {\n              hour: \"numeric\",\n              minute: \"numeric\",\n              second: includeSeconds() ? \"numeric\" : undefined\n            };\n            cachedStep = timepicker.step;\n          }\n\n          return cachedOptions;\n        };\n\n        var formatMilliseconds = function (localeTimeString, milliseconds) {\n          if (includeMilliSeconds()) {\n            // might need to inject milliseconds between seconds and AM/PM\n            var cleanedTimeString = localeTimeString;\n\n            if (localeTimeString.endsWith(amString)) {\n              cleanedTimeString = localeTimeString.replace(\" \" + amString, '');\n            } else if (localeTimeString.endsWith(pmString)) {\n              cleanedTimeString = localeTimeString.replace(\" \" + pmString, '');\n            }\n\n            if (milliseconds) {\n              var millisecondsString = milliseconds < 10 ? \"0\" : \"\";\n              millisecondsString += milliseconds < 100 ? \"0\" : \"\";\n              millisecondsString += milliseconds;\n              cleanedTimeString += \".\" + millisecondsString;\n            } else {\n              cleanedTimeString += \".000\";\n            }\n\n            if (localeTimeString.endsWith(amString)) {\n              cleanedTimeString = cleanedTimeString + \" \" + amString;\n            } else if (localeTimeString.endsWith(pmString)) {\n              cleanedTimeString = cleanedTimeString + \" \" + pmString;\n            }\n\n            return cleanedTimeString;\n          }\n\n          return localeTimeString;\n        };\n\n        var cachedTimeString;\n        var cachedTimeObject;\n        timepicker.i18n = {\n          formatTime: tryCatchWrapper(function (timeObject) {\n            if (timeObject) {\n              var timeToBeFormatted = new Date();\n              timeToBeFormatted.setHours(timeObject.hours);\n              timeToBeFormatted.setMinutes(timeObject.minutes);\n              timeToBeFormatted.setSeconds(timeObject.seconds !== undefined ? timeObject.seconds : 0);\n\n              var _localeTimeString = timeToBeFormatted.toLocaleTimeString(locale, getTimeFormatOptions()); // milliseconds not part of the time format API\n\n\n              _localeTimeString = formatMilliseconds(_localeTimeString, timeObject.milliseconds);\n              return _localeTimeString;\n            }\n          }),\n          parseTime: tryCatchWrapper(function (timeString) {\n            if (timeString && timeString === cachedTimeString && cachedTimeObject) {\n              return cachedTimeObject;\n            }\n\n            if (timeString) {\n              var pm = timeString.search(pmString);\n              var am = timeString.search(amString);\n              var numbersOnlyTimeString = timeString.replace(amString, '').replace(pmString, '').trim(); // reset regex to beginning or things can explode when the length of the input changes\n\n              numbersRegExp.lastIndex = 0;\n              var hours = numbersRegExp.exec(numbersOnlyTimeString);\n\n              if (hours) {\n                hours = parseAnyCharsToInt(hours[0].replace(separator, '')); // handle 12 am -> 0\n                // do not do anything if am & pm are not used or if those are the same,\n                // as with locale bg-BG there is always . at the end of the time\n\n                if (pm !== am) {\n                  if (hours === 12 && am !== -1) {\n                    hours = 0;\n                  } else {\n                    hours += pm !== -1 && hours !== 12 ? 12 : 0;\n                  }\n                }\n\n                var minutes = numbersRegExp.exec(numbersOnlyTimeString);\n                var seconds = minutes && numbersRegExp.exec(numbersOnlyTimeString); // reset to end or things can explode\n\n                var milliseconds = seconds && includeMilliSeconds() && millisecondRegExp.exec(numbersOnlyTimeString); // handle case where last numbers are seconds and . is the separator (invalid regexp match)\n\n                if (milliseconds && milliseconds['index'] <= seconds['index']) {\n                  milliseconds = undefined;\n                } // hours is a number at this point, others are either arrays or null\n                // the string in [0] from the arrays includes the separator too\n\n\n                cachedTimeObject = hours !== undefined && {\n                  hours: hours,\n                  minutes: minutes ? parseAnyCharsToInt(minutes[0].replace(separator, '')) : 0,\n                  seconds: seconds ? parseAnyCharsToInt(seconds[0].replace(separator, '')) : 0,\n                  milliseconds: minutes && seconds && milliseconds ? parseMillisecondCharsToInt(milliseconds[0].replace('.', '')) : 0\n                };\n                cachedTimeString = timeString;\n                return cachedTimeObject;\n              } // when nothing is returned, the component shows the invalid state for the input\n\n            }\n          })\n        };\n\n        if (previousValueObject) {\n          var newValue = timepicker.i18n.formatTime(previousValueObject); // FIXME works but uses private API, needs fixes in web component\n\n          if (timepicker.__inputElement.value !== newValue) {\n            timepicker.__inputElement.value = newValue;\n            timepicker.__dropdownElement.value = newValue;\n\n            timepicker.__onInputChange();\n          }\n        }\n      });\n    })(timepicker)\n  };\n})();"
    },
    {
     "id": 384,
     "name": "../node_modules/@vaadin/flow-frontend/vaadin-big-decimal-field.js?babel-target=es6",
     "source": "/*\n * Copyright 2000-2019 Vaadin Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n(function () {\n  var memoizedTemplate;\n  customElements.whenDefined('vaadin-text-field').then(() => {\n    class BigDecimalFieldElement extends customElements.get('vaadin-text-field') {\n      static get template() {\n        if (!memoizedTemplate) {\n          memoizedTemplate = super.template.cloneNode(true);\n          memoizedTemplate.innerHTML += `<style>\n                  :host {\n                    width: 8em;\n                  }\n\n                  :host([dir=\"rtl\"]) [part=\"input-field\"] {\n                    direction: ltr;\n                  }\n\n                  :host([dir=\"rtl\"]) [part=\"value\"]::placeholder {\n                    direction: rtl;\n                  }\n\n                  :host([dir=\"rtl\"]) [part=\"input-field\"] ::slotted(input)::placeholder {\n                    direction: rtl;\n                  }\n\n                  :host([dir=\"rtl\"]) [part=\"value\"]:-ms-input-placeholder,\n                  :host([dir=\"rtl\"]) [part=\"input-field\"] ::slotted(input):-ms-input-placeholder {\n                    direction: rtl;\n                  }\n\n                  :host([dir=\"rtl\"]:not([has-controls])) [part=\"value\"]::placeholder {\n                    text-align: left;\n                  }\n\n                  :host([dir=\"rtl\"]:not([has-controls])) [part=\"input-field\"] ::slotted(input)::placeholder {\n                    text-align: left;\n                  }\n\n                  :host([dir=\"rtl\"]:not([has-controls])) [part=\"value\"]:-ms-input-placeholder,\n                  :host([dir=\"rtl\"]:not([has-controls])) [part=\"input-field\"] ::slotted(input):-ms-input-placeholder {\n                    text-align: left;\n                  }\n\n                  :host([dir=\"rtl\"]) [part=\"value\"],\n                  :host([dir=\"rtl\"]) [part=\"input-field\"] ::slotted(input) {\n                    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em) !important;\n                  }\n            </style>`;\n        }\n\n        return memoizedTemplate;\n      }\n\n      static get is() {\n        return 'vaadin-big-decimal-field';\n      }\n\n      static get properties() {\n        return {\n          _decimalSeparator: {\n            type: String,\n            value: '.',\n            observer: '__decimalSeparatorChanged'\n          }\n        };\n      }\n\n      ready() {\n        super.ready();\n        this.inputElement.setAttribute('inputmode', 'decimal');\n      }\n\n      __decimalSeparatorChanged(separator, oldSeparator) {\n        this._enabledCharPattern = '[\\\\d-+' + separator + ']';\n\n        if (this.value && oldSeparator) {\n          this.value = this.value.split(oldSeparator).join(separator);\n        }\n      }\n\n    }\n\n    customElements.define(BigDecimalFieldElement.is, BigDecimalFieldElement);\n  });\n})();"
    },
    {
     "id": 385,
     "name": "../node_modules/@vaadin/vaadin-board/vaadin-board-row.js?babel-target=es6",
     "source": "import './theme/lumo/vaadin-board-row.js';\nexport * from './src/vaadin-board-row.js';"
    },
    {
     "id": 386,
     "name": "../node_modules/@vaadin/vaadin-charts/src/vaadin-chart-series.js?babel-target=es6",
     "source": "/**\n@license\nVaadin Charts\nCopyright (C) 2015 Vaadin Ltd\nThis program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).\nSee the file LICENSE.md distributed with this software for more information about licensing.\nSee <a href=\"https://vaadin.com/license/cval-3\">the website</a> for the complete license.\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ChartDeepMerger, ChartElement } from './vaadin-chart.js';\n/**\n * `<vaadin-chart-series>` is a custom element for creating series for Vaadin Charts.\n *\n * ### Basic use\n *\n * To use `<vaadin-chart-series>`, simply add it inside a `<vaadin-chart>` element:\n *\n * ```html\n *  <vaadin-chart>\n *    <vaadin-chart-series></vaadin-chart-series>\n *  </vaadin-chart>\n * ```\n *\n * `<vaadin-chart-series>` accepts `values` as an array attribute, so you can add it to your element definition:\n *\n * ```html\n *  <vaadin-chart-series values=\"[10,20,30,40,50]\"></vaadin-chart-series>\n * ```\n *\n * which will add a new line series, where each value will be a data point.\n * Look for the Properties session to see all available attributes.\n *\n * ### Dynamically adding and removing series\n *\n * You are also able to add and remove series by using DOM API.\n *\n * To create a new series, simply call `document.createElement('vaadin-chart-series')` and append it to your `<vaadin-chart>`:\n *\n * ```js\n *  const chart = \\* a <vaadin-chart> reference *\\\n *  const newSeries = document.createElement('vaadin-chart-series');\n *  newSeries.values = [10,20,30,40,50];\n *  chart.appendChild(newSeries);\n * ```\n *\n * In order to remove it, you should use the series to be removed as a reference for the `#removeChild()` call:\n *\n * ```js\n *  const chart = \\* a <vaadin-chart> reference *\\\n *  const seriesToBeRemoved = \\* a <vaadin-chart-series> reference to remove*\\\n *  chart.removeChild(seriesToBeRemoved);\n * ```\n *\n * (There's an issue with `#remove()` method on Firefox, so we advice to remove the element from its parent)\n *\n *\n * @polymer\n * @customElement\n * @extends {Polymer.Element}\n * @extends PolymerElement\n * @demo demo/index.html\n */\n\nclass ChartSeriesElement extends PolymerElement {\n  static get is() {\n    return 'vaadin-chart-series';\n  }\n\n  get options() {\n    var options = ChartDeepMerger.__deepMerge({}, this.additionalOptions);\n\n    if (this.type) {\n      options.type = this.type;\n    }\n\n    if (this.title) {\n      options.name = this.title;\n    }\n\n    if (this.values) {\n      options.data = this.values;\n    }\n\n    if (this.markers) {\n      if (!this.__isMarkersValid()) {\n        this.markers = 'auto';\n      }\n\n      options.marker = this.__markersConfiguration;\n    }\n\n    if (this.unit) {\n      options.yAxis = this.unit;\n    }\n\n    if (this.stack) {\n      options.stack = this.stack;\n    }\n\n    if (isFinite(this.valueMin)) {\n      options.yAxisValueMin = this.valueMin;\n    }\n\n    if (isFinite(this.valueMax)) {\n      options.yAxisValueMax = this.valueMax;\n    }\n\n    if (this.neckWidth) {\n      options.neckWidth = this.neckWidth;\n    }\n\n    if (this.neckPosition) {\n      options.neckHeight = this.neckPosition;\n    }\n\n    return options;\n  }\n\n  static get properties() {\n    return {\n      /**\n       * An array of data used by the series.\n       * Format depends on the chart type and can be:\n       *   - An array of numerical values `[y0, y1, y2, y3,...]`\n       *   - An array of arrays with 2 values (`x`, `y`) `[ [x0, y0], [x1, y1], [x2, y2], ... ]`\n       *   - An array of objects, each one describing one point `[ {x: x0, y: y0, name: 'Point0', color: '#FF0000'}, {...}, ...]`\n       *\n       *  See more in [API Site](https://api.highcharts.com/highcharts/series)\n       *\n       * Note that you should always use [Polymer API](https://www.polymer-project.org/2.0/docs/devguide/model-data#array-mutation)\n       * to mutate the values array in order to make the component aware of the\n       * change and be able to synchronize it.\n       */\n      values: {\n        type: Array,\n        value: () => []\n      },\n\n      /**\n       *  Value-axis minimum-value.\n       *  Sets the value to a series bound by 'unit' property.\n       *  Otherwise sets the value to the first series.\n       *  Undefined by default (determined from data).\n       */\n      valueMin: {\n        type: Number,\n        observer: '__valueMinObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       *  Value-axis maximum-value.\n       *  See the 'valueMin'\n       */\n      valueMax: {\n        type: Number,\n        observer: '__valueMaxObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       *  A string with the type of the series.\n       *  Defaults to `'line'` in case no type is set for the chart.\n       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type on `<vaadin-chart>`.\n       */\n      type: {\n        type: String,\n        observer: '__typeObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * The name of the series as shown in the legend, tooltip etc.\n       */\n      title: {\n        type: String,\n        observer: '__titleObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Shows/hides data-point markers for line-like series.\n       * Acceptable input are:\n       *  - `shown`: markers are always visible\n       *  - `hidden`: markers are always hidden\n       *  - `auto`: markers are visible for widespread data and hidden, when data is dense *(default)*\n       */\n      markers: {\n        type: String,\n        observer: '__markersObserver',\n        reflectToAttribute: true\n      },\n\n      /** Used to connect the series to an axis; if multiple series have the same unit, they will share axis.\n       * Displayed as a title for the axis.\n       * If no unit is defined, then series will be connected to the first axis.\n       */\n      unit: {\n        type: String,\n        observer: '__unitObserver',\n        reflectToAttribute: true\n      },\n\n      /** Used to group series in a different stacks.\n       * \"stacking\" property should be specified either for each series or in plotOptions.\n       * It is recommended to place series in a single stack, when they belong to the same yAxis.\n       */\n      stack: {\n        type: String,\n        observer: '__stackObserver',\n        reflectToAttribute: true\n      },\n\n      /** The height of the neck, the lower part of the funnel.\n       * A number defines pixel width, a percentage string defines a percentage of the plot area height. Defaults to 30%.\n       * Note that this property only applies for \"funnel\" charts.\n       */\n      neckPosition: {\n        type: String,\n        observer: '__neckPositionOberserver',\n        reflectToAttribute: true\n      },\n\n      /** The width of the neck, the lower part of the funnel.\n       * A number defines pixel width, a percentage string defines a percentage of the plot area width. Defaults to 30%.\n       * Note that this property only applies for \"funnel\" charts.\n       */\n      neckWidth: {\n        type: String,\n        observer: '__neckWidthOberserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Object with the configured options defined and used to create a series.\n       *\n       * @readonly\n       */\n      options: {\n        type: Object\n      },\n\n      /**\n       * Represents additional JSON configuration.\n       */\n      additionalOptions: {\n        type: Object,\n        reflectToAttribute: true\n      }\n    };\n  }\n\n  static get observers() {\n    return ['__valuesObserver(values.splices)', '__additionalOptionsObserver(additionalOptions.*)'];\n  }\n  /**\n   * Method to attach a series object of type `Highcharts.Series`.\n   * @param series Object of type `Highcharts.Series`\n   */\n\n\n  setSeries(series) {\n    this._series = series;\n  }\n\n  __valuesObserver() {\n    if (this.__hasSeriesConfig()) {\n      this._series.setData(this.values);\n    }\n  }\n\n  __additionalOptionsObserver() {\n    if (this.__hasSeriesConfig()) {\n      this._series.update(this.additionalOptions);\n    }\n  }\n\n  __valueMinObserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n\n    if (!isFinite(this.valueMin)) {\n      this.__showWarn('value-min', 'Numbers or null');\n\n      return;\n    }\n\n    if (this._series.yAxis) {\n      this._series.yAxis.update({\n        min: this.valueMin\n      });\n    }\n  }\n\n  __valueMaxObserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n\n    if (!isFinite(this.valueMax)) {\n      this.__showWarn('value-max', 'Numbers or null');\n\n      return;\n    }\n\n    if (this._series.yAxis) {\n      this._series.yAxis.update({\n        max: this.valueMax\n      });\n    }\n  }\n\n  __typeObserver() {\n    if (this.__hasSeriesConfig()) {\n      this._series.update({\n        type: this.type\n      });\n    }\n  }\n\n  __titleObserver() {\n    if (this.__hasSeriesConfig()) {\n      this._series.update({\n        name: this.title\n      });\n    }\n  }\n\n  __stackObserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n\n    this._series.update({\n      stack: this.stack\n    });\n  }\n\n  __neckPositionOberserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n\n    this._series.update({\n      neckHeight: this.neckPosition\n    });\n  }\n\n  __neckWidthOberserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n\n    this._series.update({\n      neckWidth: this.neckWidth\n    });\n  }\n\n  __unitObserver() {\n    if (this.__hasSeriesConfig()) {\n      var parent = this.parentNode instanceof ChartElement && this.parentNode;\n\n      if (parent && parent instanceof ChartElement) {\n        if (this.unit && !parent.__getAxis(this.unit)) {\n          var title = {\n            title: {\n              text: this.unit\n            }\n          };\n\n          parent.__addAxis(Object.assign({\n            id: this.unit,\n            axisGenerated: true\n          }, title));\n        }\n\n        this._series.update({\n          yAxis: this.unit || 0\n        });\n\n        this.__valueMinObserver();\n\n        this.__valueMaxObserver();\n\n        parent.__removeAxisIfEmpty();\n      }\n    }\n  }\n\n  __hasSeriesConfig() {\n    return !!this._series;\n  }\n\n  __isMarkersValid() {\n    if (['shown', 'hidden', 'auto'].indexOf(this.markers) === -1) {\n      this.__showWarn('markers', '\"shown\", \"hidden\" or \"auto\"');\n\n      return false;\n    }\n\n    return true;\n  }\n\n  __markersObserver() {\n    if (!this.__isMarkersValid()) {\n      this.markers = 'auto';\n      return;\n    }\n\n    if (this.__hasSeriesConfig()) {\n      this._series.update({\n        marker: this.__markersConfiguration\n      });\n    }\n  }\n\n  get __markersConfiguration() {\n    var config = {};\n\n    switch (this.markers) {\n      case 'shown':\n        config.enabled = true;\n        break;\n\n      case 'hidden':\n        config.enabled = false;\n        break;\n\n      case 'auto':\n      default:\n        config.enabled = null;\n        break;\n    }\n\n    return config;\n  }\n\n  __showWarn(propertyName, acceptedValues) {\n    console.warn('<vaadin-chart-series> Acceptable values for \"' + propertyName + '\" are ' + acceptedValues);\n  }\n\n}\n\ncustomElements.define(ChartSeriesElement.is, ChartSeriesElement);\nexport { ChartSeriesElement };"
    },
    {
     "id": 387,
     "name": "../node_modules/cookieconsent/build/cookieconsent.min.js?babel-target=es6",
     "source": "!function (e) {\n  if (!e.hasInitialised) {\n    var t = {\n      escapeRegExp: function (e) {\n        return e.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n      },\n      hasClass: function (e, t) {\n        var i = \" \";\n        return 1 === e.nodeType && (i + e.className + i).replace(/[\\n\\t]/g, i).indexOf(i + t + i) >= 0;\n      },\n      addClass: function (e, t) {\n        e.className += \" \" + t;\n      },\n      removeClass: function (e, t) {\n        var i = new RegExp(\"\\\\b\" + this.escapeRegExp(t) + \"\\\\b\");\n        e.className = e.className.replace(i, \"\");\n      },\n      interpolateString: function (e, t) {\n        return e.replace(/{{([a-z][a-z0-9\\-_]*)}}/gi, function (e) {\n          return t(arguments[1]) || \"\";\n        });\n      },\n      getCookie: function (e) {\n        var t = (\"; \" + document.cookie).split(\"; \" + e + \"=\");\n        return t.length < 2 ? void 0 : t.pop().split(\";\").shift();\n      },\n      setCookie: function (e, t, i, n, o, s) {\n        var r = new Date();\n        r.setHours(r.getHours() + 24 * (i || 365));\n        var a = [e + \"=\" + t, \"expires=\" + r.toUTCString(), \"path=\" + (o || \"/\")];\n        n && a.push(\"domain=\" + n), s && a.push(\"secure\"), document.cookie = a.join(\";\");\n      },\n      deepExtend: function (e, t) {\n        for (var i in t) {\n          t.hasOwnProperty(i) && (i in e && this.isPlainObject(e[i]) && this.isPlainObject(t[i]) ? this.deepExtend(e[i], t[i]) : e[i] = t[i]);\n        }\n\n        return e;\n      },\n      throttle: function (e, t) {\n        var i = !1;\n        return function () {\n          i || (e.apply(this, arguments), i = !0, setTimeout(function () {\n            i = !1;\n          }, t));\n        };\n      },\n      hash: function (e) {\n        var t,\n            i,\n            n = 0;\n        if (0 === e.length) return n;\n\n        for (t = 0, i = e.length; t < i; ++t) {\n          n = (n << 5) - n + e.charCodeAt(t), n |= 0;\n        }\n\n        return n;\n      },\n      normaliseHex: function (e) {\n        return \"#\" == e[0] && (e = e.substr(1)), 3 == e.length && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]), e;\n      },\n      getContrast: function (e) {\n        return e = this.normaliseHex(e), (299 * parseInt(e.substr(0, 2), 16) + 587 * parseInt(e.substr(2, 2), 16) + 114 * parseInt(e.substr(4, 2), 16)) / 1e3 >= 128 ? \"#000\" : \"#fff\";\n      },\n      getLuminance: function (e) {\n        var t = parseInt(this.normaliseHex(e), 16),\n            i = 38 + (t >> 16),\n            n = 38 + (t >> 8 & 255),\n            o = 38 + (255 & t);\n        return \"#\" + (16777216 + 65536 * (i < 255 ? i < 1 ? 0 : i : 255) + 256 * (n < 255 ? n < 1 ? 0 : n : 255) + (o < 255 ? o < 1 ? 0 : o : 255)).toString(16).slice(1);\n      },\n      isMobile: function () {\n        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n      },\n      isPlainObject: function (e) {\n        return \"object\" == typeof e && null !== e && e.constructor == Object;\n      },\n      traverseDOMPath: function (e, i) {\n        return e && e.parentNode ? t.hasClass(e, i) ? e : this.traverseDOMPath(e.parentNode, i) : null;\n      }\n    };\n    e.status = {\n      deny: \"deny\",\n      allow: \"allow\",\n      dismiss: \"dismiss\"\n    }, e.transitionEnd = function () {\n      var e = document.createElement(\"div\"),\n          t = {\n        t: \"transitionend\",\n        OT: \"oTransitionEnd\",\n        msT: \"MSTransitionEnd\",\n        MozT: \"transitionend\",\n        WebkitT: \"webkitTransitionEnd\"\n      };\n\n      for (var i in t) {\n        if (t.hasOwnProperty(i) && void 0 !== e.style[i + \"ransition\"]) return t[i];\n      }\n\n      return \"\";\n    }(), e.hasTransition = !!e.transitionEnd;\n    var i = Object.keys(e.status).map(t.escapeRegExp);\n    e.customStyles = {}, e.Popup = function () {\n      var n = {\n        enabled: !0,\n        container: null,\n        cookie: {\n          name: \"cookieconsent_status\",\n          path: \"/\",\n          domain: \"\",\n          expiryDays: 365,\n          secure: !1\n        },\n        onPopupOpen: function () {},\n        onPopupClose: function () {},\n        onInitialise: function (e) {},\n        onStatusChange: function (e, t) {},\n        onRevokeChoice: function () {},\n        onNoCookieLaw: function (e, t) {},\n        content: {\n          header: \"Cookies used on the website!\",\n          message: \"This website uses cookies to ensure you get the best experience on our website.\",\n          dismiss: \"Got it!\",\n          allow: \"Allow cookies\",\n          deny: \"Decline\",\n          link: \"Learn more\",\n          href: \"https://www.cookiesandyou.com\",\n          close: \"&#x274c;\",\n          target: \"_blank\",\n          policy: \"Cookie Policy\"\n        },\n        elements: {\n          header: '<span class=\"cc-header\">{{header}}</span>&nbsp;',\n          message: '<span id=\"cookieconsent:desc\" class=\"cc-message\">{{message}}</span>',\n          messagelink: '<span id=\"cookieconsent:desc\" class=\"cc-message\">{{message}} <a aria-label=\"learn more about cookies\" role=button tabindex=\"0\" class=\"cc-link\" href=\"{{href}}\" rel=\"noopener noreferrer nofollow\" target=\"{{target}}\">{{link}}</a></span>',\n          dismiss: '<a aria-label=\"dismiss cookie message\" role=button tabindex=\"0\" class=\"cc-btn cc-dismiss\">{{dismiss}}</a>',\n          allow: '<a aria-label=\"allow cookies\" role=button tabindex=\"0\"  class=\"cc-btn cc-allow\">{{allow}}</a>',\n          deny: '<a aria-label=\"deny cookies\" role=button tabindex=\"0\" class=\"cc-btn cc-deny\">{{deny}}</a>',\n          link: '<a aria-label=\"learn more about cookies\" role=button tabindex=\"0\" class=\"cc-link\" href=\"{{href}}\" rel=\"noopener noreferrer nofollow\" target=\"{{target}}\">{{link}}</a>',\n          close: '<span aria-label=\"dismiss cookie message\" role=button tabindex=\"0\" class=\"cc-close\">{{close}}</span>'\n        },\n        window: '<div role=\"dialog\" aria-live=\"polite\" aria-label=\"cookieconsent\" aria-describedby=\"cookieconsent:desc\" class=\"cc-window {{classes}}\">\\x3c!--googleoff: all--\\x3e{{children}}\\x3c!--googleon: all--\\x3e</div>',\n        revokeBtn: '<div class=\"cc-revoke {{classes}}\">{{policy}}</div>',\n        compliance: {\n          info: '<div class=\"cc-compliance\">{{dismiss}}</div>',\n          \"opt-in\": '<div class=\"cc-compliance cc-highlight\">{{deny}}{{allow}}</div>',\n          \"opt-out\": '<div class=\"cc-compliance cc-highlight\">{{deny}}{{allow}}</div>'\n        },\n        type: \"info\",\n        layouts: {\n          basic: \"{{messagelink}}{{compliance}}\",\n          \"basic-close\": \"{{messagelink}}{{compliance}}{{close}}\",\n          \"basic-header\": \"{{header}}{{message}}{{link}}{{compliance}}\"\n        },\n        layout: \"basic\",\n        position: \"bottom\",\n        theme: \"block\",\n        static: !1,\n        palette: null,\n        revokable: !1,\n        animateRevokable: !0,\n        showLink: !0,\n        dismissOnScroll: !1,\n        dismissOnTimeout: !1,\n        dismissOnWindowClick: !1,\n        ignoreClicksFrom: [\"cc-revoke\", \"cc-btn\"],\n        autoOpen: !0,\n        autoAttach: !0,\n        whitelistPage: [],\n        blacklistPage: [],\n        overrideHTML: null\n      };\n\n      function o() {\n        this.initialise.apply(this, arguments);\n      }\n\n      function s(e) {\n        this.openingTimeout = null, t.removeClass(e, \"cc-invisible\");\n      }\n\n      function r(t) {\n        t.style.display = \"none\", t.removeEventListener(e.transitionEnd, this.afterTransition), this.afterTransition = null;\n      }\n\n      function a() {\n        var e = this.options.position.split(\"-\"),\n            t = [];\n        return e.forEach(function (e) {\n          t.push(\"cc-\" + e);\n        }), t;\n      }\n\n      function c(n) {\n        var o = this.options,\n            s = document.createElement(\"div\"),\n            r = o.container && 1 === o.container.nodeType ? o.container : document.body;\n        s.innerHTML = n;\n        var a = s.children[0];\n        return a.style.display = \"none\", t.hasClass(a, \"cc-window\") && e.hasTransition && t.addClass(a, \"cc-invisible\"), this.onButtonClick = function (n) {\n          var o = t.traverseDOMPath(n.target, \"cc-btn\") || n.target;\n\n          if (t.hasClass(o, \"cc-btn\")) {\n            var s = o.className.match(new RegExp(\"\\\\bcc-(\" + i.join(\"|\") + \")\\\\b\")),\n                r = s && s[1] || !1;\n            r && (this.setStatus(r), this.close(!0));\n          }\n\n          t.hasClass(o, \"cc-close\") && (this.setStatus(e.status.dismiss), this.close(!0));\n          t.hasClass(o, \"cc-revoke\") && this.revokeChoice();\n        }.bind(this), a.addEventListener(\"click\", this.onButtonClick), o.autoAttach && (r.firstChild ? r.insertBefore(a, r.firstChild) : r.appendChild(a)), a;\n      }\n\n      function l(e) {\n        return \"000000\" == (e = t.normaliseHex(e)) ? \"#222\" : t.getLuminance(e);\n      }\n\n      function u(e, t) {\n        for (var i = 0, n = e.length; i < n; ++i) {\n          var o = e[i];\n          if (o instanceof RegExp && o.test(t) || \"string\" == typeof o && o.length && o === t) return !0;\n        }\n\n        return !1;\n      }\n\n      return o.prototype.initialise = function (i) {\n        this.options && this.destroy(), t.deepExtend(this.options = {}, n), t.isPlainObject(i) && t.deepExtend(this.options, i), function () {\n          var t = this.options.onInitialise.bind(this);\n          if (!window.navigator.cookieEnabled) return t(e.status.deny), !0;\n          if (window.CookiesOK || window.navigator.CookiesOK) return t(e.status.allow), !0;\n          var i = Object.keys(e.status),\n              n = this.getStatus(),\n              o = i.indexOf(n) >= 0;\n          o && t(n);\n          return o;\n        }.call(this) && (this.options.enabled = !1), u(this.options.blacklistPage, location.pathname) && (this.options.enabled = !1), u(this.options.whitelistPage, location.pathname) && (this.options.enabled = !0);\n        var o = this.options.window.replace(\"{{classes}}\", function () {\n          var i = this.options,\n              n = \"top\" == i.position || \"bottom\" == i.position ? \"banner\" : \"floating\";\n          t.isMobile() && (n = \"floating\");\n          var o = [\"cc-\" + n, \"cc-type-\" + i.type, \"cc-theme-\" + i.theme];\n          i.static && o.push(\"cc-static\");\n          o.push.apply(o, a.call(this));\n          (function (i) {\n            var n = t.hash(JSON.stringify(i)),\n                o = \"cc-color-override-\" + n,\n                s = t.isPlainObject(i);\n            this.customStyleSelector = s ? o : null, s && function (i, n, o) {\n              if (e.customStyles[i]) return void ++e.customStyles[i].references;\n              var s = {},\n                  r = n.popup,\n                  a = n.button,\n                  c = n.highlight;\n              r && (r.text = r.text ? r.text : t.getContrast(r.background), r.link = r.link ? r.link : r.text, s[o + \".cc-window\"] = [\"color: \" + r.text, \"background-color: \" + r.background], s[o + \".cc-revoke\"] = [\"color: \" + r.text, \"background-color: \" + r.background], s[o + \" .cc-link,\" + o + \" .cc-link:active,\" + o + \" .cc-link:visited\"] = [\"color: \" + r.link], a && (a.text = a.text ? a.text : t.getContrast(a.background), a.border = a.border ? a.border : \"transparent\", s[o + \" .cc-btn\"] = [\"color: \" + a.text, \"border-color: \" + a.border, \"background-color: \" + a.background], a.padding && s[o + \" .cc-btn\"].push(\"padding: \" + a.padding), \"transparent\" != a.background && (s[o + \" .cc-btn:hover, \" + o + \" .cc-btn:focus\"] = [\"background-color: \" + (a.hover || l(a.background))]), c ? (c.text = c.text ? c.text : t.getContrast(c.background), c.border = c.border ? c.border : \"transparent\", s[o + \" .cc-highlight .cc-btn:first-child\"] = [\"color: \" + c.text, \"border-color: \" + c.border, \"background-color: \" + c.background]) : s[o + \" .cc-highlight .cc-btn:first-child\"] = [\"color: \" + r.text]));\n              var u = document.createElement(\"style\");\n              document.head.appendChild(u), e.customStyles[i] = {\n                references: 1,\n                element: u.sheet\n              };\n              var h = -1;\n\n              for (var p in s) {\n                s.hasOwnProperty(p) && u.sheet.insertRule(p + \"{\" + s[p].join(\";\") + \"}\", ++h);\n              }\n            }(n, i, \".\" + o);\n            return s;\n          }).call(this, this.options.palette);\n          this.customStyleSelector && o.push(this.customStyleSelector);\n          return o;\n        }.call(this).join(\" \")).replace(\"{{children}}\", function () {\n          var e = {},\n              i = this.options;\n          i.showLink || (i.elements.link = \"\", i.elements.messagelink = i.elements.message);\n          Object.keys(i.elements).forEach(function (n) {\n            e[n] = t.interpolateString(i.elements[n], function (e) {\n              var t = i.content[e];\n              return e && \"string\" == typeof t && t.length ? t : \"\";\n            });\n          });\n          var n = i.compliance[i.type];\n          n || (n = i.compliance.info);\n          e.compliance = t.interpolateString(n, function (t) {\n            return e[t];\n          });\n          var o = i.layouts[i.layout];\n          o || (o = i.layouts.basic);\n          return t.interpolateString(o, function (t) {\n            return e[t];\n          });\n        }.call(this)),\n            s = this.options.overrideHTML;\n\n        if (\"string\" == typeof s && s.length && (o = s), this.options.static) {\n          var r = c.call(this, '<div class=\"cc-grower\">' + o + \"</div>\");\n          r.style.display = \"\", this.element = r.firstChild, this.element.style.display = \"none\", t.addClass(this.element, \"cc-invisible\");\n        } else this.element = c.call(this, o);\n\n        (function () {\n          var i = this.setStatus.bind(this),\n              n = this.close.bind(this),\n              o = this.options.dismissOnTimeout;\n          \"number\" == typeof o && o >= 0 && (this.dismissTimeout = window.setTimeout(function () {\n            i(e.status.dismiss), n(!0);\n          }, Math.floor(o)));\n          var s = this.options.dismissOnScroll;\n\n          if (\"number\" == typeof s && s >= 0) {\n            var r = function (t) {\n              window.pageYOffset > Math.floor(s) && (i(e.status.dismiss), n(!0), window.removeEventListener(\"scroll\", r), this.onWindowScroll = null);\n            };\n\n            this.options.enabled && (this.onWindowScroll = r, window.addEventListener(\"scroll\", r));\n          }\n\n          var a = this.options.dismissOnWindowClick,\n              c = this.options.ignoreClicksFrom;\n\n          if (a) {\n            var l = function (o) {\n              for (var s = !1, r = o.path.length, a = c.length, u = 0; u < r; u++) {\n                if (!s) for (var h = 0; h < a; h++) {\n                  s || (s = t.hasClass(o.path[u], c[h]));\n                }\n              }\n\n              s || (i(e.status.dismiss), n(!0), window.removeEventListener(\"click\", l), window.removeEventListener(\"touchend\", l), this.onWindowClick = null);\n            }.bind(this);\n\n            this.options.enabled && (this.onWindowClick = l, window.addEventListener(\"click\", l), window.addEventListener(\"touchend\", l));\n          }\n        }).call(this), function () {\n          \"info\" != this.options.type && (this.options.revokable = !0);\n          t.isMobile() && (this.options.animateRevokable = !1);\n\n          if (this.options.revokable) {\n            var e = a.call(this);\n            this.options.animateRevokable && e.push(\"cc-animate\"), this.customStyleSelector && e.push(this.customStyleSelector);\n            var i = this.options.revokeBtn.replace(\"{{classes}}\", e.join(\" \")).replace(\"{{policy}}\", this.options.content.policy);\n            this.revokeBtn = c.call(this, i);\n            var n = this.revokeBtn;\n\n            if (this.options.animateRevokable) {\n              var o = t.throttle(function (e) {\n                var i = !1,\n                    o = window.innerHeight - 20;\n                t.hasClass(n, \"cc-top\") && e.clientY < 20 && (i = !0), t.hasClass(n, \"cc-bottom\") && e.clientY > o && (i = !0), i ? t.hasClass(n, \"cc-active\") || t.addClass(n, \"cc-active\") : t.hasClass(n, \"cc-active\") && t.removeClass(n, \"cc-active\");\n              }, 200);\n              this.onMouseMove = o, window.addEventListener(\"mousemove\", o);\n            }\n          }\n        }.call(this), this.options.autoOpen && this.autoOpen();\n      }, o.prototype.destroy = function () {\n        this.onButtonClick && this.element && (this.element.removeEventListener(\"click\", this.onButtonClick), this.onButtonClick = null), this.dismissTimeout && (clearTimeout(this.dismissTimeout), this.dismissTimeout = null), this.onWindowScroll && (window.removeEventListener(\"scroll\", this.onWindowScroll), this.onWindowScroll = null), this.onWindowClick && (window.removeEventListener(\"click\", this.onWindowClick), this.onWindowClick = null), this.onMouseMove && (window.removeEventListener(\"mousemove\", this.onMouseMove), this.onMouseMove = null), this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = null, this.revokeBtn && this.revokeBtn.parentNode && this.revokeBtn.parentNode.removeChild(this.revokeBtn), this.revokeBtn = null, function (i) {\n          if (t.isPlainObject(i)) {\n            var n = t.hash(JSON.stringify(i)),\n                o = e.customStyles[n];\n\n            if (o && ! --o.references) {\n              var s = o.element.ownerNode;\n              s && s.parentNode && s.parentNode.removeChild(s), e.customStyles[n] = null;\n            }\n          }\n        }(this.options.palette), this.options = null;\n      }, o.prototype.open = function (t) {\n        if (this.element) return this.isOpen() || (e.hasTransition ? this.fadeIn() : this.element.style.display = \"\", this.options.revokable && this.toggleRevokeButton(), this.options.onPopupOpen.call(this)), this;\n      }, o.prototype.close = function (t) {\n        if (this.element) return this.isOpen() && (e.hasTransition ? this.fadeOut() : this.element.style.display = \"none\", t && this.options.revokable && this.toggleRevokeButton(!0), this.options.onPopupClose.call(this)), this;\n      }, o.prototype.fadeIn = function () {\n        var i = this.element;\n\n        if (e.hasTransition && i && (this.afterTransition && r.call(this, i), t.hasClass(i, \"cc-invisible\"))) {\n          if (i.style.display = \"\", this.options.static) {\n            var n = this.element.clientHeight;\n            this.element.parentNode.style.maxHeight = n + \"px\";\n          }\n\n          this.openingTimeout = setTimeout(s.bind(this, i), 20);\n        }\n      }, o.prototype.fadeOut = function () {\n        var i = this.element;\n        e.hasTransition && i && (this.openingTimeout && (clearTimeout(this.openingTimeout), s.bind(this, i)), t.hasClass(i, \"cc-invisible\") || (this.options.static && (this.element.parentNode.style.maxHeight = \"\"), this.afterTransition = r.bind(this, i), i.addEventListener(e.transitionEnd, this.afterTransition), t.addClass(i, \"cc-invisible\")));\n      }, o.prototype.isOpen = function () {\n        return this.element && \"\" == this.element.style.display && (!e.hasTransition || !t.hasClass(this.element, \"cc-invisible\"));\n      }, o.prototype.toggleRevokeButton = function (e) {\n        this.revokeBtn && (this.revokeBtn.style.display = e ? \"\" : \"none\");\n      }, o.prototype.revokeChoice = function (e) {\n        this.options.enabled = !0, this.clearStatus(), this.options.onRevokeChoice.call(this), e || this.autoOpen();\n      }, o.prototype.hasAnswered = function (t) {\n        return Object.keys(e.status).indexOf(this.getStatus()) >= 0;\n      }, o.prototype.hasConsented = function (t) {\n        var i = this.getStatus();\n        return i == e.status.allow || i == e.status.dismiss;\n      }, o.prototype.autoOpen = function (e) {\n        !this.hasAnswered() && this.options.enabled ? this.open() : this.hasAnswered() && this.options.revokable && this.toggleRevokeButton(!0);\n      }, o.prototype.setStatus = function (i) {\n        var n = this.options.cookie,\n            o = t.getCookie(n.name),\n            s = Object.keys(e.status).indexOf(o) >= 0;\n        Object.keys(e.status).indexOf(i) >= 0 ? (t.setCookie(n.name, i, n.expiryDays, n.domain, n.path, n.secure), this.options.onStatusChange.call(this, i, s)) : this.clearStatus();\n      }, o.prototype.getStatus = function () {\n        return t.getCookie(this.options.cookie.name);\n      }, o.prototype.clearStatus = function () {\n        var e = this.options.cookie;\n        t.setCookie(e.name, \"\", -1, e.domain, e.path);\n      }, o;\n    }(), e.Location = function () {\n      var e = {\n        timeout: 5e3,\n        services: [\"ipinfo\"],\n        serviceDefinitions: {\n          ipinfo: function () {\n            return {\n              url: \"//ipinfo.io\",\n              headers: [\"Accept: application/json\"],\n              callback: function (e, t) {\n                try {\n                  var i = JSON.parse(t);\n                  return i.error ? s(i) : {\n                    code: i.country\n                  };\n                } catch (e) {\n                  return s({\n                    error: \"Invalid response (\" + e + \")\"\n                  });\n                }\n              }\n            };\n          },\n          ipinfodb: function (e) {\n            return {\n              url: \"//api.ipinfodb.com/v3/ip-country/?key={api_key}&format=json&callback={callback}\",\n              isScript: !0,\n              callback: function (e, t) {\n                try {\n                  var i = JSON.parse(t);\n                  return \"ERROR\" == i.statusCode ? s({\n                    error: i.statusMessage\n                  }) : {\n                    code: i.countryCode\n                  };\n                } catch (e) {\n                  return s({\n                    error: \"Invalid response (\" + e + \")\"\n                  });\n                }\n              }\n            };\n          },\n          maxmind: function () {\n            return {\n              url: \"//js.maxmind.com/js/apis/geoip2/v2.1/geoip2.js\",\n              isScript: !0,\n              callback: function (e) {\n                window.geoip2 ? geoip2.country(function (t) {\n                  try {\n                    e({\n                      code: t.country.iso_code\n                    });\n                  } catch (t) {\n                    e(s(t));\n                  }\n                }, function (t) {\n                  e(s(t));\n                }) : e(new Error(\"Unexpected response format. The downloaded script should have exported `geoip2` to the global scope\"));\n              }\n            };\n          }\n        }\n      };\n\n      function i(i) {\n        t.deepExtend(this.options = {}, e), t.isPlainObject(i) && t.deepExtend(this.options, i), this.currentServiceIndex = -1;\n      }\n\n      function n(e, t, i) {\n        var n,\n            o = document.createElement(\"script\");\n        o.type = \"text/\" + (e.type || \"javascript\"), o.src = e.src || e, o.async = !1, o.onreadystatechange = o.onload = function () {\n          var e = o.readyState;\n          clearTimeout(n), t.done || e && !/loaded|complete/.test(e) || (t.done = !0, t(), o.onreadystatechange = o.onload = null);\n        }, document.body.appendChild(o), n = setTimeout(function () {\n          t.done = !0, t(), o.onreadystatechange = o.onload = null;\n        }, i);\n      }\n\n      function o(e, t, i, n, o) {\n        var s = new (window.XMLHttpRequest || window.ActiveXObject)(\"MSXML2.XMLHTTP.3.0\");\n        if (s.open(n ? \"POST\" : \"GET\", e, 1), s.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"), Array.isArray(o)) for (var r = 0, a = o.length; r < a; ++r) {\n          var c = o[r].split(\":\", 2);\n          s.setRequestHeader(c[0].replace(/^\\s+|\\s+$/g, \"\"), c[1].replace(/^\\s+|\\s+$/g, \"\"));\n        }\n        \"function\" == typeof t && (s.onreadystatechange = function () {\n          s.readyState > 3 && t(s);\n        }), s.send(n);\n      }\n\n      function s(e) {\n        return new Error(\"Error [\" + (e.code || \"UNKNOWN\") + \"]: \" + e.error);\n      }\n\n      return i.prototype.getNextService = function () {\n        var e;\n\n        do {\n          e = this.getServiceByIdx(++this.currentServiceIndex);\n        } while (this.currentServiceIndex < this.options.services.length && !e);\n\n        return e;\n      }, i.prototype.getServiceByIdx = function (e) {\n        var i = this.options.services[e];\n\n        if (\"function\" == typeof i) {\n          var n = i();\n          return n.name && t.deepExtend(n, this.options.serviceDefinitions[n.name](n)), n;\n        }\n\n        return \"string\" == typeof i ? this.options.serviceDefinitions[i]() : t.isPlainObject(i) ? this.options.serviceDefinitions[i.name](i) : null;\n      }, i.prototype.locate = function (e, t) {\n        var i = this.getNextService();\n        i ? (this.callbackComplete = e, this.callbackError = t, this.runService(i, this.runNextServiceOnError.bind(this))) : t(new Error(\"No services to run\"));\n      }, i.prototype.setupUrl = function (e) {\n        var t = this.getCurrentServiceOpts();\n        return e.url.replace(/\\{(.*?)\\}/g, function (i, n) {\n          if (\"callback\" === n) {\n            var o = \"callback\" + Date.now();\n            return window[o] = function (t) {\n              e.__JSONP_DATA = JSON.stringify(t);\n            }, o;\n          }\n\n          if (n in t.interpolateUrl) return t.interpolateUrl[n];\n        });\n      }, i.prototype.runService = function (e, t) {\n        var i = this;\n        e && e.url && e.callback && (e.isScript ? n : o)(this.setupUrl(e), function (n) {\n          var o = n ? n.responseText : \"\";\n          e.__JSONP_DATA && (o = e.__JSONP_DATA, delete e.__JSONP_DATA), i.runServiceCallback.call(i, t, e, o);\n        }, this.options.timeout, e.data, e.headers);\n      }, i.prototype.runServiceCallback = function (e, t, i) {\n        var n = this,\n            o = t.callback(function (t) {\n          o || n.onServiceResult.call(n, e, t);\n        }, i);\n        o && this.onServiceResult.call(this, e, o);\n      }, i.prototype.onServiceResult = function (e, t) {\n        t instanceof Error || t && t.error ? e.call(this, t, null) : e.call(this, null, t);\n      }, i.prototype.runNextServiceOnError = function (e, t) {\n        if (e) {\n          this.logError(e);\n          var i = this.getNextService();\n          i ? this.runService(i, this.runNextServiceOnError.bind(this)) : this.completeService.call(this, this.callbackError, new Error(\"All services failed\"));\n        } else this.completeService.call(this, this.callbackComplete, t);\n      }, i.prototype.getCurrentServiceOpts = function () {\n        var e = this.options.services[this.currentServiceIndex];\n        return \"string\" == typeof e ? {\n          name: e\n        } : \"function\" == typeof e ? e() : t.isPlainObject(e) ? e : {};\n      }, i.prototype.completeService = function (e, t) {\n        this.currentServiceIndex = -1, e && e(t);\n      }, i.prototype.logError = function (e) {\n        var t = this.currentServiceIndex,\n            i = this.getServiceByIdx(t);\n        console.warn(\"The service[\" + t + \"] (\" + i.url + \") responded with the following error\", e);\n      }, i;\n    }(), e.Law = function () {\n      var e = {\n        regionalLaw: !0,\n        hasLaw: [\"AT\", \"BE\", \"BG\", \"HR\", \"CZ\", \"CY\", \"DK\", \"EE\", \"FI\", \"FR\", \"DE\", \"EL\", \"HU\", \"IE\", \"IT\", \"LV\", \"LT\", \"LU\", \"MT\", \"NL\", \"PL\", \"PT\", \"SK\", \"ES\", \"SE\", \"GB\", \"UK\", \"GR\", \"EU\"],\n        revokable: [\"HR\", \"CY\", \"DK\", \"EE\", \"FR\", \"DE\", \"LV\", \"LT\", \"NL\", \"PT\", \"ES\"],\n        explicitAction: [\"HR\", \"IT\", \"ES\"]\n      };\n\n      function i(e) {\n        this.initialise.apply(this, arguments);\n      }\n\n      return i.prototype.initialise = function (i) {\n        t.deepExtend(this.options = {}, e), t.isPlainObject(i) && t.deepExtend(this.options, i);\n      }, i.prototype.get = function (e) {\n        var t = this.options;\n        return {\n          hasLaw: t.hasLaw.indexOf(e) >= 0,\n          revokable: t.revokable.indexOf(e) >= 0,\n          explicitAction: t.explicitAction.indexOf(e) >= 0\n        };\n      }, i.prototype.applyLaw = function (e, t) {\n        var i = this.get(t);\n        return i.hasLaw || (e.enabled = !1, \"function\" == typeof e.onNoCookieLaw && e.onNoCookieLaw(t, i)), this.options.regionalLaw && (i.revokable && (e.revokable = !0), i.explicitAction && (e.dismissOnScroll = !1, e.dismissOnTimeout = !1)), e;\n      }, i;\n    }(), e.initialise = function (i, n, o) {\n      var s = new e.Law(i.law);\n      n || (n = function () {}), o || (o = function () {});\n      var r = Object.keys(e.status),\n          a = t.getCookie(\"cookieconsent_status\");\n      r.indexOf(a) >= 0 ? n(new e.Popup(i)) : e.getCountryCode(i, function (t) {\n        delete i.law, delete i.location, t.code && (i = s.applyLaw(i, t.code)), n(new e.Popup(i));\n      }, function (t) {\n        delete i.law, delete i.location, o(t, new e.Popup(i));\n      });\n    }, e.getCountryCode = function (t, i, n) {\n      t.law && t.law.countryCode ? i({\n        code: t.law.countryCode\n      }) : t.location ? new e.Location(t.location).locate(function (e) {\n        i(e || {});\n      }, n) : i({});\n    }, e.utils = t, e.hasInitialised = !0, window.cookieconsent = e;\n  }\n}(window.cookieconsent || {});"
    },
    {
     "id": 388,
     "name": "../node_modules/@vaadin/vaadin-details/theme/lumo/vaadin-details.js?babel-target=es6",
     "source": "import './vaadin-details-styles.js';\nimport '../../src/vaadin-details.js';"
    },
    {
     "id": 389,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column-group.js?babel-target=es6",
     "source": "import '../../src/vaadin-grid-column-group.js';"
    },
    {
     "id": 390,
     "name": "../node_modules/@vaadin/vaadin-rich-text-editor/vendor/vaadin-quill.js?babel-target=es6",
     "source": "/*!\n * Quill Editor v1.3.6\n * https://quilljs.com/\n * Copyright (c) 2014, Jason Chen\n * Copyright (c) 2013, salesforce.com\n */\n!function (t, e) {\n  t.Quill = e();\n}(window, function () {\n  return function (t) {\n    function e(r) {\n      if (n[r]) return n[r].exports;\n      var o = n[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return t[r].call(o.exports, o, o.exports, e), o.l = !0, o.exports;\n    }\n\n    var n = {};\n    return e.m = t, e.c = n, e.d = function (t, n, r) {\n      e.o(t, n) || Object.defineProperty(t, n, {\n        configurable: !1,\n        enumerable: !0,\n        get: r\n      });\n    }, e.n = function (t) {\n      var n = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return e.d(n, \"a\", n), n;\n    }, e.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, e.p = \"\", e(e.s = 110);\n  }([function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var r = n(16),\n        o = n(17),\n        i = n(18),\n        a = n(42),\n        l = n(43),\n        u = n(44),\n        s = n(45),\n        c = n(46),\n        f = n(10),\n        d = n(25),\n        p = n(26),\n        h = n(24),\n        y = n(1),\n        v = {\n      Scope: y.Scope,\n      create: y.create,\n      find: y.find,\n      query: y.query,\n      register: y.register,\n      Container: r.default,\n      Format: o.default,\n      Leaf: i.default,\n      Embed: s.default,\n      Scroll: a.default,\n      Block: u.default,\n      Inline: l.default,\n      Text: c.default,\n      Attributor: {\n        Attribute: f.default,\n        Class: d.default,\n        Style: p.default,\n        Store: h.default\n      }\n    };\n    e.default = v;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      var n = i(t);\n      if (null == n) throw new u(\"Unable to create \" + t + \" blot\");\n      var r = n;\n      return new r(t instanceof Node || t.nodeType === Node.TEXT_NODE ? t : r.create(e), e);\n    }\n\n    function o(t, n) {\n      return void 0 === n && (n = !1), null == t ? null : null != t[e.DATA_KEY] ? t[e.DATA_KEY].blot : n ? o(t.parentNode, n) : null;\n    }\n\n    function i(t, e) {\n      void 0 === e && (e = p.ANY);\n      var n;\n      if (\"string\" == typeof t) n = d[t] || s[t];else if (t instanceof Text || t.nodeType === Node.TEXT_NODE) n = d.text;else if (\"number\" == typeof t) t & p.LEVEL & p.BLOCK ? n = d.block : t & p.LEVEL & p.INLINE && (n = d.inline);else if (t instanceof HTMLElement) {\n        var r = (t.getAttribute(\"class\") || \"\").split(/\\s+/);\n\n        for (var o in r) {\n          if (n = c[r[o]]) break;\n        }\n\n        n = n || f[t.tagName];\n      }\n      return null == n ? null : e & p.LEVEL & n.scope && e & p.TYPE & n.scope ? n : null;\n    }\n\n    function a() {\n      for (var t = [], e = 0; e < arguments.length; e++) {\n        t[e] = arguments[e];\n      }\n\n      if (t.length > 1) return t.map(function (t) {\n        return a(t);\n      });\n      var n = t[0];\n      if (\"string\" != typeof n.blotName && \"string\" != typeof n.attrName) throw new u(\"Invalid definition\");\n      if (\"abstract\" === n.blotName) throw new u(\"Cannot register abstract class\");\n      if (d[n.blotName || n.attrName] = n, \"string\" == typeof n.keyName) s[n.keyName] = n;else if (null != n.className && (c[n.className] = n), null != n.tagName) {\n        Array.isArray(n.tagName) ? n.tagName = n.tagName.map(function (t) {\n          return t.toUpperCase();\n        }) : n.tagName = n.tagName.toUpperCase();\n        var r = Array.isArray(n.tagName) ? n.tagName : [n.tagName];\n        r.forEach(function (t) {\n          null != f[t] && null != n.className || (f[t] = n);\n        });\n      }\n      return n;\n    }\n\n    var l = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var u = function (t) {\n      function e(e) {\n        var n = this;\n        return e = \"[Parchment] \" + e, n = t.call(this, e) || this, n.message = e, n.name = n.constructor.name, n;\n      }\n\n      return l(e, t), e;\n    }(Error);\n\n    e.ParchmentError = u;\n    var s = {},\n        c = {},\n        f = {},\n        d = {};\n    e.DATA_KEY = \"__blot\";\n    var p;\n    !function (t) {\n      t[t.TYPE = 3] = \"TYPE\", t[t.LEVEL = 12] = \"LEVEL\", t[t.ATTRIBUTE = 13] = \"ATTRIBUTE\", t[t.BLOT = 14] = \"BLOT\", t[t.INLINE = 7] = \"INLINE\", t[t.BLOCK = 11] = \"BLOCK\", t[t.BLOCK_BLOT = 10] = \"BLOCK_BLOT\", t[t.INLINE_BLOT = 6] = \"INLINE_BLOT\", t[t.BLOCK_ATTRIBUTE = 9] = \"BLOCK_ATTRIBUTE\", t[t.INLINE_ATTRIBUTE = 5] = \"INLINE_ATTRIBUTE\", t[t.ANY = 15] = \"ANY\";\n    }(p = e.Scope || (e.Scope = {})), e.create = r, e.find = o, e.query = i, e.register = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function l(t) {\n      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      return null == t ? e : (\"function\" == typeof t.formats && (e = (0, f.default)(e, t.formats())), null == t.parent || \"scroll\" == t.parent.blotName || t.parent.statics.scope !== t.statics.scope ? e : l(t.parent, e));\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.BlockEmbed = e.bubbleFormats = void 0;\n\n    var u = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        s = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        c = n(3),\n        f = r(c),\n        d = n(5),\n        p = r(d),\n        h = n(0),\n        y = r(h),\n        v = n(14),\n        b = r(v),\n        m = n(4),\n        g = r(m),\n        _ = n(7),\n        O = r(_),\n        E = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), u(e, [{\n        key: \"attach\",\n        value: function () {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"attach\", this).call(this), this.attributes = new y.default.Attributor.Store(this.domNode);\n        }\n      }, {\n        key: \"delta\",\n        value: function () {\n          return new p.default().insert(this.value(), (0, f.default)(this.formats(), this.attributes.values()));\n        }\n      }, {\n        key: \"format\",\n        value: function (t, e) {\n          var n = y.default.query(t, y.default.Scope.BLOCK_ATTRIBUTE);\n          null != n && this.attributes.attribute(n, e);\n        }\n      }, {\n        key: \"formatAt\",\n        value: function (t, e, n, r) {\n          this.format(n, r);\n        }\n      }, {\n        key: \"insertAt\",\n        value: function (t, n, r) {\n          if (\"string\" == typeof n && n.endsWith(\"\\n\")) {\n            var o = y.default.create(N.blotName);\n            this.parent.insertBefore(o, 0 === t ? this : this.next), o.insertAt(0, n.slice(0, -1));\n          } else s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertAt\", this).call(this, t, n, r);\n        }\n      }]), e;\n    }(y.default.Embed);\n\n    E.scope = y.default.Scope.BLOCK_BLOT;\n\n    var N = function (t) {\n      function e(t) {\n        o(this, e);\n        var n = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));\n        return n.cache = {}, n;\n      }\n\n      return a(e, t), u(e, [{\n        key: \"delta\",\n        value: function () {\n          return null == this.cache.delta && (this.cache.delta = this.descendants(y.default.Leaf).reduce(function (t, e) {\n            return 0 === e.length() ? t : t.insert(e.value(), l(e));\n          }, new p.default()).insert(\"\\n\", l(this))), this.cache.delta;\n        }\n      }, {\n        key: \"deleteAt\",\n        value: function (t, n) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"deleteAt\", this).call(this, t, n), this.cache = {};\n        }\n      }, {\n        key: \"formatAt\",\n        value: function (t, n, r, o) {\n          n <= 0 || (y.default.query(r, y.default.Scope.BLOCK) ? t + n === this.length() && this.format(r, o) : s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"formatAt\", this).call(this, t, Math.min(n, this.length() - t - 1), r, o), this.cache = {});\n        }\n      }, {\n        key: \"insertAt\",\n        value: function (t, n, r) {\n          if (null != r) return s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertAt\", this).call(this, t, n, r);\n\n          if (0 !== n.length) {\n            var o = n.split(\"\\n\"),\n                i = o.shift();\n            i.length > 0 && (t < this.length() - 1 || null == this.children.tail ? s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertAt\", this).call(this, Math.min(t, this.length() - 1), i) : this.children.tail.insertAt(this.children.tail.length(), i), this.cache = {});\n            var a = this;\n            o.reduce(function (t, e) {\n              return a = a.split(t, !0), a.insertAt(0, e), e.length;\n            }, t + i.length);\n          }\n        }\n      }, {\n        key: \"insertBefore\",\n        value: function (t, n) {\n          var r = this.children.head;\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertBefore\", this).call(this, t, n), r instanceof b.default && r.remove(), this.cache = {};\n        }\n      }, {\n        key: \"length\",\n        value: function () {\n          return null == this.cache.length && (this.cache.length = s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"length\", this).call(this) + 1), this.cache.length;\n        }\n      }, {\n        key: \"moveChildren\",\n        value: function (t, n) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"moveChildren\", this).call(this, t, n), this.cache = {};\n        }\n      }, {\n        key: \"optimize\",\n        value: function (t) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t), this.cache = {};\n        }\n      }, {\n        key: \"path\",\n        value: function (t) {\n          return s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"path\", this).call(this, t, !0);\n        }\n      }, {\n        key: \"removeChild\",\n        value: function (t) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"removeChild\", this).call(this, t), this.cache = {};\n        }\n      }, {\n        key: \"split\",\n        value: function (t) {\n          var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n\n          if (n && (0 === t || t >= this.length() - 1)) {\n            var r = this.clone();\n            return 0 === t ? (this.parent.insertBefore(r, this), this) : (this.parent.insertBefore(r, this.next), r);\n          }\n\n          var o = s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"split\", this).call(this, t, n);\n          return this.cache = {}, o;\n        }\n      }]), e;\n    }(y.default.Block);\n\n    N.blotName = \"block\", N.tagName = \"P\", N.defaultChild = \"break\", N.allowedChildren = [g.default, y.default.Embed, O.default], e.bubbleFormats = l, e.BlockEmbed = E, e.default = N;\n  }, function (t, e) {\n    \"use strict\";\n\n    var n = Object.prototype.hasOwnProperty,\n        r = Object.prototype.toString,\n        o = Object.defineProperty,\n        i = Object.getOwnPropertyDescriptor,\n        a = function (t) {\n      return \"function\" == typeof Array.isArray ? Array.isArray(t) : \"[object Array]\" === r.call(t);\n    },\n        l = function (t) {\n      if (!t || \"[object Object]\" !== r.call(t)) return !1;\n      var e = n.call(t, \"constructor\"),\n          o = t.constructor && t.constructor.prototype && n.call(t.constructor.prototype, \"isPrototypeOf\");\n      if (t.constructor && !e && !o) return !1;\n      var i;\n\n      for (i in t) {\n        ;\n      }\n\n      return void 0 === i || n.call(t, i);\n    },\n        u = function (t, e) {\n      o && \"__proto__\" === e.name ? o(t, e.name, {\n        enumerable: !0,\n        configurable: !0,\n        value: e.newValue,\n        writable: !0\n      }) : t[e.name] = e.newValue;\n    },\n        s = function (t, e) {\n      if (\"__proto__\" === e) {\n        if (!n.call(t, e)) return;\n        if (i) return i(t, e).value;\n      }\n\n      return t[e];\n    };\n\n    t.exports = function t() {\n      var e,\n          n,\n          r,\n          o,\n          i,\n          c,\n          f = arguments[0],\n          d = 1,\n          p = arguments.length,\n          h = !1;\n\n      for (\"boolean\" == typeof f && (h = f, f = arguments[1] || {}, d = 2), (null == f || \"object\" != typeof f && \"function\" != typeof f) && (f = {}); d < p; ++d) {\n        if (null != (e = arguments[d])) for (n in e) {\n          r = s(f, n), o = s(e, n), f !== o && (h && o && (l(o) || (i = a(o))) ? (i ? (i = !1, c = r && a(r) ? r : []) : c = r && l(r) ? r : {}, u(f, {\n            name: n,\n            newValue: t(h, c, o)\n          })) : void 0 !== o && u(f, {\n            name: n,\n            newValue: o\n          }));\n        }\n      }\n\n      return f;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = n(7),\n        c = r(s),\n        f = n(0),\n        d = r(f),\n        p = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), l(e, [{\n        key: \"formatAt\",\n        value: function (t, n, r, o) {\n          if (e.compare(this.statics.blotName, r) < 0 && d.default.query(r, d.default.Scope.BLOT)) {\n            var i = this.isolate(t, n);\n            o && i.wrap(r, o);\n          } else u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"formatAt\", this).call(this, t, n, r, o);\n        }\n      }, {\n        key: \"optimize\",\n        value: function (t) {\n          if (u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t), this.parent instanceof e && e.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {\n            var n = this.parent.isolate(this.offset(), this.length());\n            this.moveChildren(n), n.wrap(this);\n          }\n        }\n      }], [{\n        key: \"compare\",\n        value: function (t, n) {\n          var r = e.order.indexOf(t),\n              o = e.order.indexOf(n);\n          return r >= 0 || o >= 0 ? r - o : t === n ? 0 : t < n ? -1 : 1;\n        }\n      }]), e;\n    }(d.default.Inline);\n\n    p.allowedChildren = [p, d.default.Embed, c.default], p.order = [\"cursor\", \"inline\", \"underline\", \"strike\", \"italic\", \"bold\", \"script\", \"link\", \"code\"], e.default = p;\n  }, function (t, e, n) {\n    var r = n(48),\n        o = n(11),\n        i = n(3),\n        a = n(19),\n        l = String.fromCharCode(0),\n        u = function (t) {\n      Array.isArray(t) ? this.ops = t : null != t && Array.isArray(t.ops) ? this.ops = t.ops : this.ops = [];\n    };\n\n    u.prototype.insert = function (t, e) {\n      var n = {};\n      return 0 === t.length ? this : (n.insert = t, null != e && \"object\" == typeof e && Object.keys(e).length > 0 && (n.attributes = e), this.push(n));\n    }, u.prototype.delete = function (t) {\n      return t <= 0 ? this : this.push({\n        delete: t\n      });\n    }, u.prototype.retain = function (t, e) {\n      if (t <= 0) return this;\n      var n = {\n        retain: t\n      };\n      return null != e && \"object\" == typeof e && Object.keys(e).length > 0 && (n.attributes = e), this.push(n);\n    }, u.prototype.push = function (t) {\n      var e = this.ops.length,\n          n = this.ops[e - 1];\n\n      if (t = i(!0, {}, t), \"object\" == typeof n) {\n        if (\"number\" == typeof t.delete && \"number\" == typeof n.delete) return this.ops[e - 1] = {\n          delete: n.delete + t.delete\n        }, this;\n        if (\"number\" == typeof n.delete && null != t.insert && (e -= 1, \"object\" != typeof (n = this.ops[e - 1]))) return this.ops.unshift(t), this;\n\n        if (o(t.attributes, n.attributes)) {\n          if (\"string\" == typeof t.insert && \"string\" == typeof n.insert) return this.ops[e - 1] = {\n            insert: n.insert + t.insert\n          }, \"object\" == typeof t.attributes && (this.ops[e - 1].attributes = t.attributes), this;\n          if (\"number\" == typeof t.retain && \"number\" == typeof n.retain) return this.ops[e - 1] = {\n            retain: n.retain + t.retain\n          }, \"object\" == typeof t.attributes && (this.ops[e - 1].attributes = t.attributes), this;\n        }\n      }\n\n      return e === this.ops.length ? this.ops.push(t) : this.ops.splice(e, 0, t), this;\n    }, u.prototype.chop = function () {\n      var t = this.ops[this.ops.length - 1];\n      return t && t.retain && !t.attributes && this.ops.pop(), this;\n    }, u.prototype.filter = function (t) {\n      return this.ops.filter(t);\n    }, u.prototype.forEach = function (t) {\n      this.ops.forEach(t);\n    }, u.prototype.map = function (t) {\n      return this.ops.map(t);\n    }, u.prototype.partition = function (t) {\n      var e = [],\n          n = [];\n      return this.forEach(function (r) {\n        (t(r) ? e : n).push(r);\n      }), [e, n];\n    }, u.prototype.reduce = function (t, e) {\n      return this.ops.reduce(t, e);\n    }, u.prototype.changeLength = function () {\n      return this.reduce(function (t, e) {\n        return e.insert ? t + a.length(e) : e.delete ? t - e.delete : t;\n      }, 0);\n    }, u.prototype.length = function () {\n      return this.reduce(function (t, e) {\n        return t + a.length(e);\n      }, 0);\n    }, u.prototype.slice = function (t, e) {\n      t = t || 0, \"number\" != typeof e && (e = 1 / 0);\n\n      for (var n = [], r = a.iterator(this.ops), o = 0; o < e && r.hasNext();) {\n        var i;\n        o < t ? i = r.next(t - o) : (i = r.next(e - o), n.push(i)), o += a.length(i);\n      }\n\n      return new u(n);\n    }, u.prototype.compose = function (t) {\n      var e = a.iterator(this.ops),\n          n = a.iterator(t.ops),\n          r = [],\n          i = n.peek();\n\n      if (null != i && \"number\" == typeof i.retain && null == i.attributes) {\n        for (var l = i.retain; \"insert\" === e.peekType() && e.peekLength() <= l;) {\n          l -= e.peekLength(), r.push(e.next());\n        }\n\n        i.retain - l > 0 && n.next(i.retain - l);\n      }\n\n      for (var s = new u(r); e.hasNext() || n.hasNext();) {\n        if (\"insert\" === n.peekType()) s.push(n.next());else if (\"delete\" === e.peekType()) s.push(e.next());else {\n          var c = Math.min(e.peekLength(), n.peekLength()),\n              f = e.next(c),\n              d = n.next(c);\n\n          if (\"number\" == typeof d.retain) {\n            var p = {};\n            \"number\" == typeof f.retain ? p.retain = c : p.insert = f.insert;\n            var h = a.attributes.compose(f.attributes, d.attributes, \"number\" == typeof f.retain);\n\n            if (h && (p.attributes = h), s.push(p), !n.hasNext() && o(s.ops[s.ops.length - 1], p)) {\n              var y = new u(e.rest());\n              return s.concat(y).chop();\n            }\n          } else \"number\" == typeof d.delete && \"number\" == typeof f.retain && s.push(d);\n        }\n      }\n\n      return s.chop();\n    }, u.prototype.concat = function (t) {\n      var e = new u(this.ops.slice());\n      return t.ops.length > 0 && (e.push(t.ops[0]), e.ops = e.ops.concat(t.ops.slice(1))), e;\n    }, u.prototype.diff = function (t, e) {\n      if (this.ops === t.ops) return new u();\n      var n = [this, t].map(function (e) {\n        return e.map(function (n) {\n          if (null != n.insert) return \"string\" == typeof n.insert ? n.insert : l;\n          var r = e === t ? \"on\" : \"with\";\n          throw new Error(\"diff() called \" + r + \" non-document\");\n        }).join(\"\");\n      }),\n          i = new u(),\n          s = r(n[0], n[1], e),\n          c = a.iterator(this.ops),\n          f = a.iterator(t.ops);\n      return s.forEach(function (t) {\n        for (var e = t[1].length; e > 0;) {\n          var n = 0;\n\n          switch (t[0]) {\n            case r.INSERT:\n              n = Math.min(f.peekLength(), e), i.push(f.next(n));\n              break;\n\n            case r.DELETE:\n              n = Math.min(e, c.peekLength()), c.next(n), i.delete(n);\n              break;\n\n            case r.EQUAL:\n              n = Math.min(c.peekLength(), f.peekLength(), e);\n              var l = c.next(n),\n                  u = f.next(n);\n              o(l.insert, u.insert) ? i.retain(n, a.attributes.diff(l.attributes, u.attributes)) : i.push(u).delete(n);\n          }\n\n          e -= n;\n        }\n      }), i.chop();\n    }, u.prototype.eachLine = function (t, e) {\n      e = e || \"\\n\";\n\n      for (var n = a.iterator(this.ops), r = new u(), o = 0; n.hasNext();) {\n        if (\"insert\" !== n.peekType()) return;\n        var i = n.peek(),\n            l = a.length(i) - n.peekLength(),\n            s = \"string\" == typeof i.insert ? i.insert.indexOf(e, l) - l : -1;\n        if (s < 0) r.push(n.next());else if (s > 0) r.push(n.next(s));else {\n          if (!1 === t(r, n.next(1).attributes || {}, o)) return;\n          o += 1, r = new u();\n        }\n      }\n\n      r.length() > 0 && t(r, {}, o);\n    }, u.prototype.transform = function (t, e) {\n      if (e = !!e, \"number\" == typeof t) return this.transformPosition(t, e);\n\n      for (var n = a.iterator(this.ops), r = a.iterator(t.ops), o = new u(); n.hasNext() || r.hasNext();) {\n        if (\"insert\" !== n.peekType() || !e && \"insert\" === r.peekType()) {\n          if (\"insert\" === r.peekType()) o.push(r.next());else {\n            var i = Math.min(n.peekLength(), r.peekLength()),\n                l = n.next(i),\n                s = r.next(i);\n            if (l.delete) continue;\n            s.delete ? o.push(s) : o.retain(i, a.attributes.transform(l.attributes, s.attributes, e));\n          }\n        } else o.retain(a.length(n.next()));\n      }\n\n      return o.chop();\n    }, u.prototype.transformPosition = function (t, e) {\n      e = !!e;\n\n      for (var n = a.iterator(this.ops), r = 0; n.hasNext() && r <= t;) {\n        var o = n.peekLength(),\n            i = n.peekType();\n        n.next(), \"delete\" !== i ? (\"insert\" === i && (r < t || !e) && (t += o), r += o) : t -= Math.min(o, t - r);\n      }\n\n      return t;\n    }, t.exports = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (e = (0, j.default)(!0, {\n        container: t,\n        modules: {\n          clipboard: !0,\n          keyboard: !0,\n          history: !0\n        }\n      }, e), e.theme && e.theme !== C.DEFAULTS.theme) {\n        if (e.theme = C.import(\"themes/\" + e.theme), null == e.theme) throw new Error(\"Invalid theme \" + e.theme + \". Did you register it?\");\n      } else e.theme = S.default;\n\n      var n = (0, j.default)(!0, {}, e.theme.DEFAULTS);\n      [n, e].forEach(function (t) {\n        t.modules = t.modules || {}, Object.keys(t.modules).forEach(function (e) {\n          !0 === t.modules[e] && (t.modules[e] = {});\n        });\n      });\n      var r = Object.keys(n.modules).concat(Object.keys(e.modules)),\n          o = r.reduce(function (t, e) {\n        var n = C.import(\"modules/\" + e);\n        return null == n ? P.error(\"Cannot load \" + e + \" module. Are you sure you registered it?\") : t[e] = n.DEFAULTS || {}, t;\n      }, {});\n      return null != e.modules && e.modules.toolbar && e.modules.toolbar.constructor !== Object && (e.modules.toolbar = {\n        container: e.modules.toolbar\n      }), e = (0, j.default)(!0, {}, C.DEFAULTS, {\n        modules: o\n      }, n, e), [\"bounds\", \"container\", \"scrollingContainer\"].forEach(function (t) {\n        \"string\" == typeof e[t] && (e[t] = document.querySelector(e[t]));\n      }), e.modules = Object.keys(e.modules).reduce(function (t, n) {\n        return e.modules[n] && (t[n] = e.modules[n]), t;\n      }, {}), e;\n    }\n\n    function l(t, e, n, r) {\n      if (this.options.strict && !this.isEnabled() && e === m.default.sources.USER) return new h.default();\n      var o = null == n ? null : this.getSelection(),\n          i = this.editor.delta,\n          a = t();\n\n      if (null != o && (!0 === n && (n = o.index), null == r ? o = s(o, a, e) : 0 !== r && (o = s(o, n, r, e)), this.setSelection(o, m.default.sources.SILENT)), a.length() > 0) {\n        var l,\n            u = [m.default.events.TEXT_CHANGE, a, i, e];\n\n        if ((l = this.emitter).emit.apply(l, [m.default.events.EDITOR_CHANGE].concat(u)), e !== m.default.sources.SILENT) {\n          var c;\n          (c = this.emitter).emit.apply(c, u);\n        }\n      }\n\n      return a;\n    }\n\n    function u(t, e, n, r, o) {\n      var i = {};\n      return \"number\" == typeof t.index && \"number\" == typeof t.length ? \"number\" != typeof e ? (o = r, r = n, n = e, e = t.length, t = t.index) : (e = t.length, t = t.index) : \"number\" != typeof e && (o = r, r = n, n = e, e = 0), \"object\" === (void 0 === n ? \"undefined\" : c(n)) ? (i = n, o = r) : \"string\" == typeof n && (null != r ? i[n] = r : o = n), o = o || m.default.sources.API, [t, e, i, o];\n    }\n\n    function s(t, e, n, r) {\n      if (null == t) return null;\n      var o = void 0,\n          i = void 0;\n\n      if (e instanceof h.default) {\n        var a = [t.index, t.index + t.length].map(function (t) {\n          return e.transformPosition(t, r !== m.default.sources.USER);\n        }),\n            l = f(a, 2);\n        o = l[0], i = l[1];\n      } else {\n        var u = [t.index, t.index + t.length].map(function (t) {\n          return t < e || t === e && r === m.default.sources.USER ? t : n >= 0 ? t + n : Math.max(e, t + n);\n        }),\n            s = f(u, 2);\n        o = s[0], i = s[1];\n      }\n\n      return new N.Range(o, i - o);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.overload = e.expandConfig = void 0;\n\n    var c = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    },\n        f = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        d = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }();\n\n    n(47);\n\n    var p = n(5),\n        h = r(p),\n        y = n(51),\n        v = r(y),\n        b = n(13),\n        m = r(b),\n        g = n(9),\n        _ = r(g),\n        O = n(0),\n        E = r(O),\n        N = n(29),\n        w = r(N),\n        k = n(3),\n        j = r(k),\n        x = n(8),\n        A = r(x),\n        T = n(37),\n        S = r(T),\n        P = (0, A.default)(\"quill\"),\n        C = function () {\n      function t(e) {\n        var n = this,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        if (i(this, t), this.options = a(e, r), this.container = this.options.container, null == this.container) return P.error(\"Invalid Quill container\", e);\n        this.options.debug && t.debug(this.options.debug);\n        var o = this.container.innerHTML.trim();\n        this.container.classList.add(\"ql-container\"), this.container.innerHTML = \"\", this.container.__quill = this, this.root = this.addContainer(\"ql-editor\"), this.root.classList.add(\"ql-blank\"), this.root.setAttribute(\"data-gramm\", !1), this.scrollingContainer = this.options.scrollingContainer || this.root, this.emitter = new m.default(), this.scroll = E.default.create(this.root, {\n          emitter: this.emitter,\n          whitelist: this.options.formats\n        }), this.editor = new v.default(this.scroll), this.selection = new w.default(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule(\"keyboard\"), this.clipboard = this.theme.addModule(\"clipboard\"), this.history = this.theme.addModule(\"history\"), this.theme.init(), this.emitter.on(m.default.events.EDITOR_CHANGE, function (t) {\n          t === m.default.events.TEXT_CHANGE && n.root.classList.toggle(\"ql-blank\", n.editor.isBlank());\n        }), this.emitter.on(m.default.events.SCROLL_UPDATE, function (t, e) {\n          var r = n.selection.lastRange,\n              o = r && 0 === r.length ? r.index : void 0;\n          l.call(n, function () {\n            return n.editor.update(null, e, o);\n          }, t);\n        });\n        var u = this.clipboard.convert(\"<div class='ql-editor' style=\\\"white-space: normal;\\\">\" + o + \"<p><br></p></div>\");\n        this.setContents(u), this.history.clear(), this.options.placeholder && this.root.setAttribute(\"data-placeholder\", this.options.placeholder), this.options.readOnly && this.disable();\n      }\n\n      return d(t, null, [{\n        key: \"debug\",\n        value: function (t) {\n          !0 === t && (t = \"log\"), A.default.level(t);\n        }\n      }, {\n        key: \"find\",\n        value: function (t) {\n          return t.__quill || E.default.find(t);\n        }\n      }, {\n        key: \"import\",\n        value: function (t) {\n          return null == this.imports[t] && P.error(\"Cannot import \" + t + \". Are you sure it was registered?\"), this.imports[t];\n        }\n      }, {\n        key: \"register\",\n        value: function (t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n\n          if (\"string\" != typeof t) {\n            var o = t.attrName || t.blotName;\n            \"string\" == typeof o ? this.register(\"formats/\" + o, t, e) : Object.keys(t).forEach(function (r) {\n              n.register(r, t[r], e);\n            });\n          } else null == this.imports[t] || r || P.warn(\"Overwriting \" + t + \" with\", e), this.imports[t] = e, (t.startsWith(\"blots/\") || t.startsWith(\"formats/\")) && \"abstract\" !== e.blotName ? E.default.register(e) : t.startsWith(\"modules\") && \"function\" == typeof e.register && e.register();\n        }\n      }]), d(t, [{\n        key: \"addContainer\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n\n          if (\"string\" == typeof t) {\n            var n = t;\n            t = document.createElement(\"div\"), t.classList.add(n);\n          }\n\n          return this.container.insertBefore(t, e), t;\n        }\n      }, {\n        key: \"blur\",\n        value: function () {\n          this.selection.setRange(null);\n        }\n      }, {\n        key: \"deleteText\",\n        value: function (t, e, n) {\n          var r = this,\n              o = u(t, e, n),\n              i = f(o, 4);\n          return t = i[0], e = i[1], n = i[3], l.call(this, function () {\n            return r.editor.deleteText(t, e);\n          }, n, t, -1 * e);\n        }\n      }, {\n        key: \"disable\",\n        value: function () {\n          this.enable(!1);\n        }\n      }, {\n        key: \"enable\",\n        value: function () {\n          var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n          this.scroll.enable(t), this.container.classList.toggle(\"ql-disabled\", !t);\n        }\n      }, {\n        key: \"focus\",\n        value: function () {\n          var t = this.scrollingContainer.scrollTop;\n          this.selection.focus(), this.scrollingContainer.scrollTop = t, this.scrollIntoView();\n        }\n      }, {\n        key: \"format\",\n        value: function (t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : m.default.sources.API;\n          return l.call(this, function () {\n            var r = n.getSelection(!0),\n                i = new h.default();\n            if (null == r) return i;\n            if (E.default.query(t, E.default.Scope.BLOCK)) i = n.editor.formatLine(r.index, r.length, o({}, t, e));else {\n              if (0 === r.length) return n.selection.format(t, e), i;\n              i = n.editor.formatText(r.index, r.length, o({}, t, e));\n            }\n            return n.setSelection(r, m.default.sources.SILENT), i;\n          }, r);\n        }\n      }, {\n        key: \"formatLine\",\n        value: function (t, e, n, r, o) {\n          var i = this,\n              a = void 0,\n              s = u(t, e, n, r, o),\n              c = f(s, 4);\n          return t = c[0], e = c[1], a = c[2], o = c[3], l.call(this, function () {\n            return i.editor.formatLine(t, e, a);\n          }, o, t, 0);\n        }\n      }, {\n        key: \"formatText\",\n        value: function (t, e, n, r, o) {\n          var i = this,\n              a = void 0,\n              s = u(t, e, n, r, o),\n              c = f(s, 4);\n          return t = c[0], e = c[1], a = c[2], o = c[3], l.call(this, function () {\n            return i.editor.formatText(t, e, a);\n          }, o, t, 0);\n        }\n      }, {\n        key: \"getBounds\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n              n = void 0;\n          n = \"number\" == typeof t ? this.selection.getBounds(t, e) : this.selection.getBounds(t.index, t.length);\n          var r = this.container.getBoundingClientRect();\n          return {\n            bottom: n.bottom - r.top,\n            height: n.height,\n            left: n.left - r.left,\n            right: n.right - r.left,\n            top: n.top - r.top,\n            width: n.width\n          };\n        }\n      }, {\n        key: \"getContents\",\n        value: function () {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t,\n              n = u(t, e),\n              r = f(n, 2);\n          return t = r[0], e = r[1], this.editor.getContents(t, e);\n        }\n      }, {\n        key: \"getFormat\",\n        value: function () {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getSelection(!0),\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n          return \"number\" == typeof t ? this.editor.getFormat(t, e) : this.editor.getFormat(t.index, t.length);\n        }\n      }, {\n        key: \"getIndex\",\n        value: function (t) {\n          return t.offset(this.scroll);\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          return this.scroll.length();\n        }\n      }, {\n        key: \"getLeaf\",\n        value: function (t) {\n          return this.scroll.leaf(t);\n        }\n      }, {\n        key: \"getLine\",\n        value: function (t) {\n          return this.scroll.line(t);\n        }\n      }, {\n        key: \"getLines\",\n        value: function () {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;\n          return \"number\" != typeof t ? this.scroll.lines(t.index, t.length) : this.scroll.lines(t, e);\n        }\n      }, {\n        key: \"getModule\",\n        value: function (t) {\n          return this.theme.modules[t];\n        }\n      }, {\n        key: \"getSelection\",\n        value: function () {\n          return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0];\n        }\n      }, {\n        key: \"getText\",\n        value: function () {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t,\n              n = u(t, e),\n              r = f(n, 2);\n          return t = r[0], e = r[1], this.editor.getText(t, e);\n        }\n      }, {\n        key: \"hasFocus\",\n        value: function () {\n          return this.selection.hasFocus();\n        }\n      }, {\n        key: \"insertEmbed\",\n        value: function (e, n, r) {\n          var o = this,\n              i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.sources.API;\n          return l.call(this, function () {\n            return o.editor.insertEmbed(e, n, r);\n          }, i, e);\n        }\n      }, {\n        key: \"insertText\",\n        value: function (t, e, n, r, o) {\n          var i = this,\n              a = void 0,\n              s = u(t, 0, n, r, o),\n              c = f(s, 4);\n          return t = c[0], a = c[2], o = c[3], l.call(this, function () {\n            return i.editor.insertText(t, e, a);\n          }, o, t, e.length);\n        }\n      }, {\n        key: \"isEnabled\",\n        value: function () {\n          return !this.container.classList.contains(\"ql-disabled\");\n        }\n      }, {\n        key: \"off\",\n        value: function () {\n          return this.emitter.off.apply(this.emitter, arguments);\n        }\n      }, {\n        key: \"on\",\n        value: function () {\n          return this.emitter.on.apply(this.emitter, arguments);\n        }\n      }, {\n        key: \"once\",\n        value: function () {\n          return this.emitter.once.apply(this.emitter, arguments);\n        }\n      }, {\n        key: \"pasteHTML\",\n        value: function (t, e, n) {\n          this.clipboard.dangerouslyPasteHTML(t, e, n);\n        }\n      }, {\n        key: \"removeFormat\",\n        value: function (t, e, n) {\n          var r = this,\n              o = u(t, e, n),\n              i = f(o, 4);\n          return t = i[0], e = i[1], n = i[3], l.call(this, function () {\n            return r.editor.removeFormat(t, e);\n          }, n, t);\n        }\n      }, {\n        key: \"scrollIntoView\",\n        value: function () {\n          this.selection.scrollIntoView(this.scrollingContainer);\n        }\n      }, {\n        key: \"setContents\",\n        value: function (t) {\n          var e = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.default.sources.API;\n          return l.call(this, function () {\n            t = new h.default(t);\n            var n = e.getLength(),\n                r = e.editor.deleteText(0, n),\n                o = e.editor.applyDelta(t),\n                i = o.ops[o.ops.length - 1];\n            return null != i && \"string\" == typeof i.insert && \"\\n\" === i.insert[i.insert.length - 1] && (e.editor.deleteText(e.getLength() - 1, 1), o.delete(1)), r.compose(o);\n          }, n);\n        }\n      }, {\n        key: \"setSelection\",\n        value: function (e, n, r) {\n          if (null == e) this.selection.setRange(null, n || t.sources.API);else {\n            var o = u(e, n, r),\n                i = f(o, 4);\n            e = i[0], n = i[1], r = i[3], this.selection.setRange(new N.Range(e, n), r), r !== m.default.sources.SILENT && this.selection.scrollIntoView(this.scrollingContainer);\n          }\n        }\n      }, {\n        key: \"setText\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.default.sources.API,\n              n = new h.default().insert(t);\n          return this.setContents(n, e);\n        }\n      }, {\n        key: \"update\",\n        value: function () {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m.default.sources.USER,\n              e = this.scroll.update(t);\n          return this.selection.update(t), e;\n        }\n      }, {\n        key: \"updateContents\",\n        value: function (t) {\n          var e = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.default.sources.API;\n          return l.call(this, function () {\n            return t = new h.default(t), e.editor.applyDelta(t, n);\n          }, n, !0);\n        }\n      }]), t;\n    }();\n\n    C.DEFAULTS = {\n      bounds: null,\n      formats: null,\n      modules: {},\n      placeholder: \"\",\n      readOnly: !1,\n      scrollingContainer: null,\n      strict: !0,\n      theme: \"default\"\n    }, C.events = m.default.events, C.sources = m.default.sources, C.version = \"1.3.6\", C.imports = {\n      delta: h.default,\n      parchment: E.default,\n      \"core/module\": _.default,\n      \"core/theme\": S.default\n    }, e.expandConfig = a, e.overload = u, e.default = C;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(0),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default.Text);\n\n    e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      if (i.indexOf(t) <= i.indexOf(a)) {\n        for (var e, n = arguments.length, r = Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) {\n          r[o - 1] = arguments[o];\n        }\n\n        (e = console)[t].apply(e, r);\n      }\n    }\n\n    function o(t) {\n      return i.reduce(function (e, n) {\n        return e[n] = r.bind(console, n, t), e;\n      }, {});\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var i = [\"error\", \"warn\", \"log\", \"info\"],\n        a = \"warn\";\n    r.level = o.level = function (t) {\n      a = t;\n    }, e.default = o;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = function t(e) {\n      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      r(this, t), this.quill = e, this.options = n;\n    };\n\n    o.DEFAULTS = {}, e.default = o;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var r = n(1),\n        o = function () {\n      function t(t, e, n) {\n        void 0 === n && (n = {}), this.attrName = t, this.keyName = e;\n        var o = r.Scope.TYPE & r.Scope.ATTRIBUTE;\n        null != n.scope ? this.scope = n.scope & r.Scope.LEVEL | o : this.scope = r.Scope.ATTRIBUTE, null != n.whitelist && (this.whitelist = n.whitelist);\n      }\n\n      return t.keys = function (t) {\n        return [].map.call(t.attributes, function (t) {\n          return t.name;\n        });\n      }, t.prototype.add = function (t, e) {\n        return !!this.canAdd(t, e) && (t.setAttribute(this.keyName, e), !0);\n      }, t.prototype.canAdd = function (t, e) {\n        return null != r.query(t, r.Scope.BLOT & (this.scope | r.Scope.TYPE)) && (null == this.whitelist || (\"string\" == typeof e ? this.whitelist.indexOf(e.replace(/[\"']/g, \"\")) > -1 : this.whitelist.indexOf(e) > -1));\n      }, t.prototype.remove = function (t) {\n        t.removeAttribute(this.keyName);\n      }, t.prototype.value = function (t) {\n        var e = t.getAttribute(this.keyName);\n        return this.canAdd(t, e) && e ? e : \"\";\n      }, t;\n    }();\n\n    e.default = o;\n  }, function (t, e, n) {\n    function r(t) {\n      return null === t || void 0 === t;\n    }\n\n    function o(t) {\n      return !(!t || \"object\" != typeof t || \"number\" != typeof t.length) && \"function\" == typeof t.copy && \"function\" == typeof t.slice && !(t.length > 0 && \"number\" != typeof t[0]);\n    }\n\n    function i(t, e, n) {\n      var i, c;\n      if (r(t) || r(e)) return !1;\n      if (t.prototype !== e.prototype) return !1;\n      if (u(t)) return !!u(e) && (t = a.call(t), e = a.call(e), s(t, e, n));\n\n      if (o(t)) {\n        if (!o(e)) return !1;\n        if (t.length !== e.length) return !1;\n\n        for (i = 0; i < t.length; i++) {\n          if (t[i] !== e[i]) return !1;\n        }\n\n        return !0;\n      }\n\n      try {\n        var f = l(t),\n            d = l(e);\n      } catch (t) {\n        return !1;\n      }\n\n      if (f.length != d.length) return !1;\n\n      for (f.sort(), d.sort(), i = f.length - 1; i >= 0; i--) {\n        if (f[i] != d[i]) return !1;\n      }\n\n      for (i = f.length - 1; i >= 0; i--) {\n        if (c = f[i], !s(t[c], e[c], n)) return !1;\n      }\n\n      return typeof t == typeof e;\n    }\n\n    var a = Array.prototype.slice,\n        l = n(49),\n        u = n(50),\n        s = t.exports = function (t, e, n) {\n      return n || (n = {}), t === e || (t instanceof Date && e instanceof Date ? t.getTime() === e.getTime() : !t || !e || \"object\" != typeof t && \"object\" != typeof e ? n.strict ? t === e : t == e : i(t, e, n));\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.Code = void 0;\n\n    var l = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        u = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        s = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        c = n(5),\n        f = r(c),\n        d = n(0),\n        p = r(d),\n        h = n(2),\n        y = r(h),\n        v = n(4),\n        b = r(v),\n        m = n(7),\n        g = r(m),\n        _ = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), e;\n    }(b.default);\n\n    _.blotName = \"code\", _.tagName = \"CODE\";\n\n    var O = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), u(e, [{\n        key: \"delta\",\n        value: function () {\n          var t = this,\n              e = this.domNode.textContent;\n          return e.endsWith(\"\\n\") && (e = e.slice(0, -1)), e.split(\"\\n\").reduce(function (e, n) {\n            return e.insert(n).insert(\"\\n\", t.formats());\n          }, new f.default());\n        }\n      }, {\n        key: \"format\",\n        value: function (t, n) {\n          if (t !== this.statics.blotName || !n) {\n            var r = this.descendant(g.default, this.length() - 1),\n                o = l(r, 1),\n                i = o[0];\n            null != i && i.deleteAt(i.length() - 1, 1), s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n          }\n        }\n      }, {\n        key: \"formatAt\",\n        value: function (t, n, r, o) {\n          if (0 !== n && null != p.default.query(r, p.default.Scope.BLOCK) && (r !== this.statics.blotName || o !== this.statics.formats(this.domNode))) {\n            var i = this.newlineIndex(t);\n\n            if (!(i < 0 || i >= t + n)) {\n              var a = this.newlineIndex(t, !0) + 1,\n                  l = i - a + 1,\n                  u = this.isolate(a, l),\n                  s = u.next;\n              u.format(r, o), s instanceof e && s.formatAt(0, t - a + n - l, r, o);\n            }\n          }\n        }\n      }, {\n        key: \"insertAt\",\n        value: function (t, e, n) {\n          if (null == n) {\n            var r = this.descendant(g.default, t),\n                o = l(r, 2),\n                i = o[0],\n                a = o[1];\n            i.insertAt(a, e);\n          }\n        }\n      }, {\n        key: \"length\",\n        value: function () {\n          var t = this.domNode.textContent.length;\n          return this.domNode.textContent.endsWith(\"\\n\") ? t : t + 1;\n        }\n      }, {\n        key: \"newlineIndex\",\n        value: function (t) {\n          if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) return this.domNode.textContent.slice(0, t).lastIndexOf(\"\\n\");\n          var e = this.domNode.textContent.slice(t).indexOf(\"\\n\");\n          return e > -1 ? t + e : -1;\n        }\n      }, {\n        key: \"optimize\",\n        value: function (t) {\n          this.domNode.textContent.endsWith(\"\\n\") || this.appendChild(p.default.create(\"text\", \"\\n\")), s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t);\n          var n = this.next;\n          null != n && n.prev === this && n.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === n.statics.formats(n.domNode) && (n.optimize(t), n.moveChildren(this), n.remove());\n        }\n      }, {\n        key: \"replace\",\n        value: function (t) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"replace\", this).call(this, t), [].slice.call(this.domNode.querySelectorAll(\"*\")).forEach(function (t) {\n            var e = p.default.find(t);\n            null == e ? t.parentNode.removeChild(t) : e instanceof p.default.Embed ? e.remove() : e.unwrap();\n          });\n        }\n      }], [{\n        key: \"create\",\n        value: function (t) {\n          var n = s(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n          return n.setAttribute(\"spellcheck\", !1), n;\n        }\n      }, {\n        key: \"formats\",\n        value: function () {\n          return !0;\n        }\n      }]), e;\n    }(y.default);\n\n    O.blotName = \"code-block\", O.tagName = \"PRE\", O.TAB = \"  \", e.Code = _, e.default = O;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = n(52),\n        c = r(s),\n        f = n(8),\n        d = r(f),\n        p = n(28),\n        h = (0, d.default)(\"quill:events\"),\n        y = [p.SHADOW_SELECTIONCHANGE, \"mousedown\", \"mouseup\", \"click\"],\n        v = [],\n        b = (\"getRootNode\" in document);\n\n    y.forEach(function (t) {\n      document.addEventListener(t, function () {\n        for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) {\n          e[n] = arguments[n];\n        }\n\n        v.forEach(function (t) {\n          t.handleDOM.apply(t, e);\n        });\n      });\n    });\n\n    var m = function (t) {\n      function e() {\n        o(this, e);\n        var t = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));\n        return t.listeners = {}, v.push(t), t.on(\"error\", h.error), t;\n      }\n\n      return a(e, t), l(e, [{\n        key: \"emit\",\n        value: function () {\n          h.log.apply(h, arguments), u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"emit\", this).apply(this, arguments);\n        }\n      }, {\n        key: \"handleDOM\",\n        value: function (t) {\n          for (var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) {\n            n[r - 1] = arguments[r];\n          }\n\n          var o = t.composedPath ? t.composedPath()[0] : t.target,\n              i = function (t, e) {\n            if (!b || e.getRootNode() === document) return t.contains(e);\n\n            for (; !t.contains(e);) {\n              var n = e.getRootNode();\n              if (!n || !n.host) return !1;\n              e = n.host;\n            }\n\n            return !0;\n          };\n\n          (this.listeners[t.type] || []).forEach(function (e) {\n            var r = e.node,\n                a = e.handler;\n            (o === r || i(r, o)) && a.apply(void 0, [t].concat(n));\n          });\n        }\n      }, {\n        key: \"listenDOM\",\n        value: function (t, e, n) {\n          this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push({\n            node: e,\n            handler: n\n          });\n        }\n      }]), e;\n    }(c.default);\n\n    m.events = {\n      EDITOR_CHANGE: \"editor-change\",\n      SCROLL_BEFORE_UPDATE: \"scroll-before-update\",\n      SCROLL_OPTIMIZE: \"scroll-optimize\",\n      SCROLL_UPDATE: \"scroll-update\",\n      SELECTION_CHANGE: \"selection-change\",\n      TEXT_CHANGE: \"text-change\"\n    }, m.sources = {\n      API: \"api\",\n      SILENT: \"silent\",\n      USER: \"user\"\n    }, e.default = m;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"insertInto\",\n        value: function (t, n) {\n          0 === t.children.length ? l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertInto\", this).call(this, t, n) : this.remove();\n        }\n      }, {\n        key: \"length\",\n        value: function () {\n          return 0;\n        }\n      }, {\n        key: \"value\",\n        value: function () {\n          return \"\";\n        }\n      }], [{\n        key: \"value\",\n        value: function () {}\n      }]), e;\n    }(s.default.Embed);\n\n    c.blotName = \"break\", c.tagName = \"BR\", e.default = c;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function a(t, e) {\n      var n = document.createElement(\"a\");\n      n.href = t;\n      var r = n.href.slice(0, n.href.indexOf(\":\"));\n      return e.indexOf(r) > -1;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.sanitize = e.default = void 0;\n\n    var l = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = n(4),\n        c = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(s),\n        f = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), l(e, [{\n        key: \"format\",\n        value: function (t, n) {\n          if (t !== this.statics.blotName || !n) return u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n          n = this.constructor.sanitize(n), this.domNode.setAttribute(\"href\", n);\n        }\n      }], [{\n        key: \"create\",\n        value: function (t) {\n          var n = u(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n          return t = this.sanitize(t), n.setAttribute(\"href\", t), n.setAttribute(\"target\", \"_blank\"), n;\n        }\n      }, {\n        key: \"formats\",\n        value: function (t) {\n          return t.getAttribute(\"href\");\n        }\n      }, {\n        key: \"sanitize\",\n        value: function (t) {\n          return a(t, this.PROTOCOL_WHITELIST) ? t : this.SANITIZED_URL;\n        }\n      }]), e;\n    }(c.default);\n\n    f.blotName = \"link\", f.tagName = \"A\", f.SANITIZED_URL = \"about:blank\", f.PROTOCOL_WHITELIST = [\"http\", \"https\", \"mailto\", \"tel\"], e.default = f, e.sanitize = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      var e = l.find(t);\n      if (null == e) try {\n        e = l.create(t);\n      } catch (n) {\n        e = l.create(l.Scope.INLINE), [].slice.call(t.childNodes).forEach(function (t) {\n          e.domNode.appendChild(t);\n        }), t.parentNode && t.parentNode.replaceChild(e.domNode, t), e.attach();\n      }\n      return e;\n    }\n\n    var o = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var i = n(41),\n        a = n(23),\n        l = n(1),\n        u = function (t) {\n      function e(e) {\n        var n = t.call(this, e) || this;\n        return n.build(), n;\n      }\n\n      return o(e, t), e.prototype.appendChild = function (t) {\n        this.insertBefore(t);\n      }, e.prototype.attach = function () {\n        t.prototype.attach.call(this), this.children.forEach(function (t) {\n          t.attach();\n        });\n      }, e.prototype.build = function () {\n        var t = this;\n        this.children = new i.default(), [].slice.call(this.domNode.childNodes).reverse().forEach(function (e) {\n          try {\n            var n = r(e);\n            t.insertBefore(n, t.children.head || void 0);\n          } catch (t) {\n            if (t instanceof l.ParchmentError) return;\n            throw t;\n          }\n        });\n      }, e.prototype.deleteAt = function (t, e) {\n        if (0 === t && e === this.length()) return this.remove();\n        this.children.forEachAt(t, e, function (t, e, n) {\n          t.deleteAt(e, n);\n        });\n      }, e.prototype.descendant = function (t, n) {\n        var r = this.children.find(n),\n            o = r[0],\n            i = r[1];\n        return null == t.blotName && t(o) || null != t.blotName && o instanceof t ? [o, i] : o instanceof e ? o.descendant(t, i) : [null, -1];\n      }, e.prototype.descendants = function (t, n, r) {\n        void 0 === n && (n = 0), void 0 === r && (r = Number.MAX_VALUE);\n        var o = [],\n            i = r;\n        return this.children.forEachAt(n, r, function (n, r, a) {\n          (null == t.blotName && t(n) || null != t.blotName && n instanceof t) && o.push(n), n instanceof e && (o = o.concat(n.descendants(t, r, i))), i -= a;\n        }), o;\n      }, e.prototype.detach = function () {\n        this.children.forEach(function (t) {\n          t.detach();\n        }), t.prototype.detach.call(this);\n      }, e.prototype.formatAt = function (t, e, n, r) {\n        this.children.forEachAt(t, e, function (t, e, o) {\n          t.formatAt(e, o, n, r);\n        });\n      }, e.prototype.insertAt = function (t, e, n) {\n        var r = this.children.find(t),\n            o = r[0],\n            i = r[1];\n        if (o) o.insertAt(i, e, n);else {\n          var a = null == n ? l.create(\"text\", e) : l.create(e, n);\n          this.appendChild(a);\n        }\n      }, e.prototype.insertBefore = function (t, e) {\n        if (null != this.statics.allowedChildren && !this.statics.allowedChildren.some(function (e) {\n          return t instanceof e;\n        })) throw new l.ParchmentError(\"Cannot insert \" + t.statics.blotName + \" into \" + this.statics.blotName);\n        t.insertInto(this, e);\n      }, e.prototype.length = function () {\n        return this.children.reduce(function (t, e) {\n          return t + e.length();\n        }, 0);\n      }, e.prototype.moveChildren = function (t, e) {\n        this.children.forEach(function (n) {\n          t.insertBefore(n, e);\n        });\n      }, e.prototype.optimize = function (e) {\n        if (t.prototype.optimize.call(this, e), 0 === this.children.length) if (null != this.statics.defaultChild) {\n          var n = l.create(this.statics.defaultChild);\n          this.appendChild(n), n.optimize(e);\n        } else this.remove();\n      }, e.prototype.path = function (t, n) {\n        void 0 === n && (n = !1);\n        var r = this.children.find(t, n),\n            o = r[0],\n            i = r[1],\n            a = [[this, t]];\n        return o instanceof e ? a.concat(o.path(i, n)) : (null != o && a.push([o, i]), a);\n      }, e.prototype.removeChild = function (t) {\n        this.children.remove(t);\n      }, e.prototype.replace = function (n) {\n        n instanceof e && n.moveChildren(this), t.prototype.replace.call(this, n);\n      }, e.prototype.split = function (t, e) {\n        if (void 0 === e && (e = !1), !e) {\n          if (0 === t) return this;\n          if (t === this.length()) return this.next;\n        }\n\n        var n = this.clone();\n        return this.parent.insertBefore(n, this.next), this.children.forEachAt(t, this.length(), function (t, r, o) {\n          t = t.split(r, e), n.appendChild(t);\n        }), n;\n      }, e.prototype.unwrap = function () {\n        this.moveChildren(this.parent, this.next), this.remove();\n      }, e.prototype.update = function (t, e) {\n        var n = this,\n            o = [],\n            i = [];\n        t.forEach(function (t) {\n          t.target === n.domNode && \"childList\" === t.type && (o.push.apply(o, t.addedNodes), i.push.apply(i, t.removedNodes));\n        }), i.forEach(function (t) {\n          if (!(null != t.parentNode && \"IFRAME\" !== t.tagName && document.body.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {\n            var e = l.find(t);\n            null != e && (null != e.domNode.parentNode && e.domNode.parentNode !== n.domNode || e.detach());\n          }\n        }), o.filter(function (t) {\n          return t.parentNode == n.domNode;\n        }).sort(function (t, e) {\n          return t === e ? 0 : t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1;\n        }).forEach(function (t) {\n          var e = null;\n          null != t.nextSibling && (e = l.find(t.nextSibling));\n          var o = r(t);\n          o.next == e && null != o.next || (null != o.parent && o.parent.removeChild(n), n.insertBefore(o, e || void 0));\n        });\n      }, e;\n    }(a.default);\n\n    e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(10),\n        i = n(24),\n        a = n(16),\n        l = n(1),\n        u = function (t) {\n      function e(e) {\n        var n = t.call(this, e) || this;\n        return n.attributes = new i.default(n.domNode), n;\n      }\n\n      return r(e, t), e.formats = function (t) {\n        return \"string\" == typeof this.tagName || (Array.isArray(this.tagName) ? t.tagName.toLowerCase() : void 0);\n      }, e.prototype.format = function (t, e) {\n        var n = l.query(t);\n        n instanceof o.default ? this.attributes.attribute(n, e) : e && (null == n || t === this.statics.blotName && this.formats()[t] === e || this.replaceWith(t, e));\n      }, e.prototype.formats = function () {\n        var t = this.attributes.values(),\n            e = this.statics.formats(this.domNode);\n        return null != e && (t[this.statics.blotName] = e), t;\n      }, e.prototype.replaceWith = function (e, n) {\n        var r = t.prototype.replaceWith.call(this, e, n);\n        return this.attributes.copy(r), r;\n      }, e.prototype.update = function (e, n) {\n        var r = this;\n        t.prototype.update.call(this, e, n), e.some(function (t) {\n          return t.target === r.domNode && \"attributes\" === t.type;\n        }) && this.attributes.build();\n      }, e.prototype.wrap = function (n, r) {\n        var o = t.prototype.wrap.call(this, n, r);\n        return o instanceof e && o.statics.scope === this.statics.scope && this.attributes.move(o), o;\n      }, e;\n    }(a.default);\n\n    e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(23),\n        i = n(1),\n        a = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return r(e, t), e.value = function (t) {\n        return !0;\n      }, e.prototype.index = function (t, e) {\n        return this.domNode === t || this.domNode.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(e, 1) : -1;\n      }, e.prototype.position = function (t, e) {\n        var n = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);\n        return t > 0 && (n += 1), [this.parent.domNode, n];\n      }, e.prototype.value = function () {\n        var t;\n        return t = {}, t[this.statics.blotName] = this.statics.value(this.domNode) || !0, t;\n      }, e.scope = i.Scope.INLINE_BLOT, e;\n    }(o.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    function r(t) {\n      this.ops = t, this.index = 0, this.offset = 0;\n    }\n\n    var o = n(11),\n        i = n(3),\n        a = {\n      attributes: {\n        compose: function (t, e, n) {\n          \"object\" != typeof t && (t = {}), \"object\" != typeof e && (e = {});\n          var r = i(!0, {}, e);\n          n || (r = Object.keys(r).reduce(function (t, e) {\n            return null != r[e] && (t[e] = r[e]), t;\n          }, {}));\n\n          for (var o in t) {\n            void 0 !== t[o] && void 0 === e[o] && (r[o] = t[o]);\n          }\n\n          return Object.keys(r).length > 0 ? r : void 0;\n        },\n        diff: function (t, e) {\n          \"object\" != typeof t && (t = {}), \"object\" != typeof e && (e = {});\n          var n = Object.keys(t).concat(Object.keys(e)).reduce(function (n, r) {\n            return o(t[r], e[r]) || (n[r] = void 0 === e[r] ? null : e[r]), n;\n          }, {});\n          return Object.keys(n).length > 0 ? n : void 0;\n        },\n        transform: function (t, e, n) {\n          if (\"object\" != typeof t) return e;\n\n          if (\"object\" == typeof e) {\n            if (!n) return e;\n            var r = Object.keys(e).reduce(function (n, r) {\n              return void 0 === t[r] && (n[r] = e[r]), n;\n            }, {});\n            return Object.keys(r).length > 0 ? r : void 0;\n          }\n        }\n      },\n      iterator: function (t) {\n        return new r(t);\n      },\n      length: function (t) {\n        return \"number\" == typeof t.delete ? t.delete : \"number\" == typeof t.retain ? t.retain : \"string\" == typeof t.insert ? t.insert.length : 1;\n      }\n    };\n    r.prototype.hasNext = function () {\n      return this.peekLength() < 1 / 0;\n    }, r.prototype.next = function (t) {\n      t || (t = 1 / 0);\n      var e = this.ops[this.index];\n\n      if (e) {\n        var n = this.offset,\n            r = a.length(e);\n        if (t >= r - n ? (t = r - n, this.index += 1, this.offset = 0) : this.offset += t, \"number\" == typeof e.delete) return {\n          delete: t\n        };\n        var o = {};\n        return e.attributes && (o.attributes = e.attributes), \"number\" == typeof e.retain ? o.retain = t : \"string\" == typeof e.insert ? o.insert = e.insert.substr(n, t) : o.insert = e.insert, o;\n      }\n\n      return {\n        retain: 1 / 0\n      };\n    }, r.prototype.peek = function () {\n      return this.ops[this.index];\n    }, r.prototype.peekLength = function () {\n      return this.ops[this.index] ? a.length(this.ops[this.index]) - this.offset : 1 / 0;\n    }, r.prototype.peekType = function () {\n      return this.ops[this.index] ? \"number\" == typeof this.ops[this.index].delete ? \"delete\" : \"number\" == typeof this.ops[this.index].retain ? \"retain\" : \"insert\" : \"retain\";\n    }, r.prototype.rest = function () {\n      if (this.hasNext()) {\n        if (0 === this.offset) return this.ops.slice(this.index);\n        var t = this.offset,\n            e = this.index,\n            n = this.next(),\n            r = this.ops.slice(this.index);\n        return this.offset = t, this.index = e, [n].concat(r);\n      }\n\n      return [];\n    }, t.exports = a;\n  }, function (t, e) {\n    var n = function () {\n      \"use strict\";\n\n      function t(t, e) {\n        return null != e && t instanceof e;\n      }\n\n      function e(n, r, o, i, c) {\n        function f(n, o) {\n          if (null === n) return null;\n          if (0 === o) return n;\n          var y, v;\n          if (\"object\" != typeof n) return n;\n          if (t(n, l)) y = new l();else if (t(n, u)) y = new u();else if (t(n, s)) y = new s(function (t, e) {\n            n.then(function (e) {\n              t(f(e, o - 1));\n            }, function (t) {\n              e(f(t, o - 1));\n            });\n          });else if (e.__isArray(n)) y = [];else if (e.__isRegExp(n)) y = new RegExp(n.source, a(n)), n.lastIndex && (y.lastIndex = n.lastIndex);else if (e.__isDate(n)) y = new Date(n.getTime());else {\n            if (h && Buffer.isBuffer(n)) return y = Buffer.allocUnsafe ? Buffer.allocUnsafe(n.length) : new Buffer(n.length), n.copy(y), y;\n            t(n, Error) ? y = Object.create(n) : void 0 === i ? (v = Object.getPrototypeOf(n), y = Object.create(v)) : (y = Object.create(i), v = i);\n          }\n\n          if (r) {\n            var b = d.indexOf(n);\n            if (-1 != b) return p[b];\n            d.push(n), p.push(y);\n          }\n\n          t(n, l) && n.forEach(function (t, e) {\n            var n = f(e, o - 1),\n                r = f(t, o - 1);\n            y.set(n, r);\n          }), t(n, u) && n.forEach(function (t) {\n            var e = f(t, o - 1);\n            y.add(e);\n          });\n\n          for (var m in n) {\n            var g;\n            v && (g = Object.getOwnPropertyDescriptor(v, m)), g && null == g.set || (y[m] = f(n[m], o - 1));\n          }\n\n          if (Object.getOwnPropertySymbols) for (var _ = Object.getOwnPropertySymbols(n), m = 0; m < _.length; m++) {\n            var O = _[m],\n                E = Object.getOwnPropertyDescriptor(n, O);\n            (!E || E.enumerable || c) && (y[O] = f(n[O], o - 1), E.enumerable || Object.defineProperty(y, O, {\n              enumerable: !1\n            }));\n          }\n          if (c) for (var N = Object.getOwnPropertyNames(n), m = 0; m < N.length; m++) {\n            var w = N[m],\n                E = Object.getOwnPropertyDescriptor(n, w);\n            E && E.enumerable || (y[w] = f(n[w], o - 1), Object.defineProperty(y, w, {\n              enumerable: !1\n            }));\n          }\n          return y;\n        }\n\n        \"object\" == typeof r && (o = r.depth, i = r.prototype, c = r.includeNonEnumerable, r = r.circular);\n        var d = [],\n            p = [],\n            h = \"undefined\" != typeof Buffer;\n        return void 0 === r && (r = !0), void 0 === o && (o = 1 / 0), f(n, o);\n      }\n\n      function n(t) {\n        return Object.prototype.toString.call(t);\n      }\n\n      function r(t) {\n        return \"object\" == typeof t && \"[object Date]\" === n(t);\n      }\n\n      function o(t) {\n        return \"object\" == typeof t && \"[object Array]\" === n(t);\n      }\n\n      function i(t) {\n        return \"object\" == typeof t && \"[object RegExp]\" === n(t);\n      }\n\n      function a(t) {\n        var e = \"\";\n        return t.global && (e += \"g\"), t.ignoreCase && (e += \"i\"), t.multiline && (e += \"m\"), e;\n      }\n\n      var l;\n\n      try {\n        l = Map;\n      } catch (t) {\n        l = function () {};\n      }\n\n      var u;\n\n      try {\n        u = Set;\n      } catch (t) {\n        u = function () {};\n      }\n\n      var s;\n\n      try {\n        s = Promise;\n      } catch (t) {\n        s = function () {};\n      }\n\n      return e.clonePrototype = function (t) {\n        if (null === t) return null;\n\n        var e = function () {};\n\n        return e.prototype = t, new e();\n      }, e.__objToStr = n, e.__isDate = r, e.__isArray = o, e.__isRegExp = i, e.__getRegExpFlags = a, e;\n    }();\n\n    \"object\" == typeof t && t.exports && (t.exports = n);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = n(0),\n        u = r(l),\n        s = n(2),\n        c = r(s),\n        f = function (t) {\n      function e() {\n        return o(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return a(e, t), e;\n    }(u.default.Container);\n\n    f.allowedChildren = [c.default, s.BlockEmbed, f], e.default = f;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.ColorStyle = e.ColorClass = e.ColorAttributor = void 0;\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"value\",\n        value: function (t) {\n          var n = l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"value\", this).call(this, t);\n          return n.startsWith(\"rgb(\") ? (n = n.replace(/^[^\\d]+/, \"\").replace(/[^\\d]+$/, \"\"), \"#\" + n.split(\",\").map(function (t) {\n            return (\"00\" + parseInt(t).toString(16)).slice(-2);\n          }).join(\"\")) : n;\n        }\n      }]), e;\n    }(s.default.Attributor.Style),\n        f = new s.default.Attributor.Class(\"color\", \"ql-color\", {\n      scope: s.default.Scope.INLINE\n    }),\n        d = new c(\"color\", \"color\", {\n      scope: s.default.Scope.INLINE\n    });\n\n    e.ColorAttributor = c, e.ColorClass = f, e.ColorStyle = d;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var r = n(1),\n        o = function () {\n      function t(t) {\n        this.domNode = t, this.domNode[r.DATA_KEY] = {\n          blot: this\n        };\n      }\n\n      return Object.defineProperty(t.prototype, \"statics\", {\n        get: function () {\n          return this.constructor;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), t.create = function (t) {\n        if (null == this.tagName) throw new r.ParchmentError(\"Blot definition missing tagName\");\n        var e;\n        return Array.isArray(this.tagName) ? (\"string\" == typeof t && (t = t.toUpperCase(), parseInt(t).toString() === t && (t = parseInt(t))), e = \"number\" == typeof t ? document.createElement(this.tagName[t - 1]) : this.tagName.indexOf(t) > -1 ? document.createElement(t) : document.createElement(this.tagName[0])) : e = document.createElement(this.tagName), this.className && e.classList.add(this.className), e;\n      }, t.prototype.attach = function () {\n        null != this.parent && (this.scroll = this.parent.scroll);\n      }, t.prototype.clone = function () {\n        var t = this.domNode.cloneNode(!1);\n        return r.create(t);\n      }, t.prototype.detach = function () {\n        null != this.parent && this.parent.removeChild(this), delete this.domNode[r.DATA_KEY];\n      }, t.prototype.deleteAt = function (t, e) {\n        this.isolate(t, e).remove();\n      }, t.prototype.formatAt = function (t, e, n, o) {\n        var i = this.isolate(t, e);\n        if (null != r.query(n, r.Scope.BLOT) && o) i.wrap(n, o);else if (null != r.query(n, r.Scope.ATTRIBUTE)) {\n          var a = r.create(this.statics.scope);\n          i.wrap(a), a.format(n, o);\n        }\n      }, t.prototype.insertAt = function (t, e, n) {\n        var o = null == n ? r.create(\"text\", e) : r.create(e, n),\n            i = this.split(t);\n        this.parent.insertBefore(o, i);\n      }, t.prototype.insertInto = function (t, e) {\n        void 0 === e && (e = null), null != this.parent && this.parent.children.remove(this);\n        var n = null;\n        t.children.insertBefore(this, e), null != e && (n = e.domNode), this.domNode.parentNode == t.domNode && this.domNode.nextSibling == n || t.domNode.insertBefore(this.domNode, n), this.parent = t, this.attach();\n      }, t.prototype.isolate = function (t, e) {\n        var n = this.split(t);\n        return n.split(e), n;\n      }, t.prototype.length = function () {\n        return 1;\n      }, t.prototype.offset = function (t) {\n        return void 0 === t && (t = this.parent), null == this.parent || this == t ? 0 : this.parent.children.offset(this) + this.parent.offset(t);\n      }, t.prototype.optimize = function (t) {\n        null != this.domNode[r.DATA_KEY] && delete this.domNode[r.DATA_KEY].mutations;\n      }, t.prototype.remove = function () {\n        null != this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), this.detach();\n      }, t.prototype.replace = function (t) {\n        null != t.parent && (t.parent.insertBefore(this, t.next), t.remove());\n      }, t.prototype.replaceWith = function (t, e) {\n        var n = \"string\" == typeof t ? r.create(t, e) : t;\n        return n.replace(this), n;\n      }, t.prototype.split = function (t, e) {\n        return 0 === t ? this : this.next;\n      }, t.prototype.update = function (t, e) {}, t.prototype.wrap = function (t, e) {\n        var n = \"string\" == typeof t ? r.create(t, e) : t;\n        return null != this.parent && this.parent.insertBefore(n, this.next), n.appendChild(this), n;\n      }, t.blotName = \"abstract\", t;\n    }();\n\n    e.default = o;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var r = n(10),\n        o = n(25),\n        i = n(26),\n        a = n(1),\n        l = function () {\n      function t(t) {\n        this.attributes = {}, this.domNode = t, this.build();\n      }\n\n      return t.prototype.attribute = function (t, e) {\n        e ? t.add(this.domNode, e) && (null != t.value(this.domNode) ? this.attributes[t.attrName] = t : delete this.attributes[t.attrName]) : (t.remove(this.domNode), delete this.attributes[t.attrName]);\n      }, t.prototype.build = function () {\n        var t = this;\n        this.attributes = {};\n        var e = r.default.keys(this.domNode),\n            n = o.default.keys(this.domNode),\n            l = i.default.keys(this.domNode);\n        e.concat(n).concat(l).forEach(function (e) {\n          var n = a.query(e, a.Scope.ATTRIBUTE);\n          n instanceof r.default && (t.attributes[n.attrName] = n);\n        });\n      }, t.prototype.copy = function (t) {\n        var e = this;\n        Object.keys(this.attributes).forEach(function (n) {\n          var r = e.attributes[n].value(e.domNode);\n          t.format(n, r);\n        });\n      }, t.prototype.move = function (t) {\n        var e = this;\n        this.copy(t), Object.keys(this.attributes).forEach(function (t) {\n          e.attributes[t].remove(e.domNode);\n        }), this.attributes = {};\n      }, t.prototype.values = function () {\n        var t = this;\n        return Object.keys(this.attributes).reduce(function (e, n) {\n          return e[n] = t.attributes[n].value(t.domNode), e;\n        }, {});\n      }, t;\n    }();\n\n    e.default = l;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      return (t.getAttribute(\"class\") || \"\").split(/\\s+/).filter(function (t) {\n        return 0 === t.indexOf(e + \"-\");\n      });\n    }\n\n    var o = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var i = n(10),\n        a = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return o(e, t), e.keys = function (t) {\n        return (t.getAttribute(\"class\") || \"\").split(/\\s+/).map(function (t) {\n          return t.split(\"-\").slice(0, -1).join(\"-\");\n        });\n      }, e.prototype.add = function (t, e) {\n        return !!this.canAdd(t, e) && (this.remove(t), t.classList.add(this.keyName + \"-\" + e), !0);\n      }, e.prototype.remove = function (t) {\n        r(t, this.keyName).forEach(function (e) {\n          t.classList.remove(e);\n        }), 0 === t.classList.length && t.removeAttribute(\"class\");\n      }, e.prototype.value = function (t) {\n        var e = r(t, this.keyName)[0] || \"\",\n            n = e.slice(this.keyName.length + 1);\n        return this.canAdd(t, n) ? n : \"\";\n      }, e;\n    }(i.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      var e = t.split(\"-\"),\n          n = e.slice(1).map(function (t) {\n        return t[0].toUpperCase() + t.slice(1);\n      }).join(\"\");\n      return e[0] + n;\n    }\n\n    var o = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var i = n(10),\n        a = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return o(e, t), e.keys = function (t) {\n        return (t.getAttribute(\"style\") || \"\").split(\";\").map(function (t) {\n          return t.split(\":\")[0].trim();\n        });\n      }, e.prototype.add = function (t, e) {\n        return !!this.canAdd(t, e) && (t.style[r(this.keyName)] = e, !0);\n      }, e.prototype.remove = function (t) {\n        t.style[r(this.keyName)] = \"\", t.getAttribute(\"style\") || t.removeAttribute(\"style\");\n      }, e.prototype.value = function (t) {\n        var e = t.style[r(this.keyName)];\n        return this.canAdd(t, e) ? e : \"\";\n      }, e;\n    }(i.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        c = n(0),\n        f = r(c),\n        d = n(7),\n        p = r(d),\n        h = function (t) {\n      function e(t, n) {\n        o(this, e);\n        var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));\n        return r.selection = n, r.textNode = document.createTextNode(e.CONTENTS), r.domNode.appendChild(r.textNode), r._length = 0, r;\n      }\n\n      return a(e, t), s(e, null, [{\n        key: \"value\",\n        value: function () {}\n      }]), s(e, [{\n        key: \"detach\",\n        value: function () {\n          null != this.parent && this.parent.removeChild(this);\n        }\n      }, {\n        key: \"format\",\n        value: function (t, n) {\n          if (0 !== this._length) return u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n\n          for (var r = this, o = 0; null != r && r.statics.scope !== f.default.Scope.BLOCK_BLOT;) {\n            o += r.offset(r.parent), r = r.parent;\n          }\n\n          null != r && (this._length = e.CONTENTS.length, r.optimize(), r.formatAt(o, e.CONTENTS.length, t, n), this._length = 0);\n        }\n      }, {\n        key: \"index\",\n        value: function (t, n) {\n          return t === this.textNode ? 0 : u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"index\", this).call(this, t, n);\n        }\n      }, {\n        key: \"length\",\n        value: function () {\n          return this._length;\n        }\n      }, {\n        key: \"position\",\n        value: function () {\n          return [this.textNode, this.textNode.data.length];\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"remove\", this).call(this), this.parent = null;\n        }\n      }, {\n        key: \"restore\",\n        value: function () {\n          if (!this.selection.composing && null != this.parent) {\n            var t = this.textNode,\n                n = this.selection.getNativeRange(),\n                r = void 0,\n                o = void 0,\n                i = void 0;\n\n            if (null != n && n.start.node === t && n.end.node === t) {\n              var a = [t, n.start.offset, n.end.offset];\n              r = a[0], o = a[1], i = a[2];\n            }\n\n            for (; null != this.domNode.lastChild && this.domNode.lastChild !== this.textNode;) {\n              this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n            }\n\n            if (this.textNode.data !== e.CONTENTS) {\n              var u = this.textNode.data.split(e.CONTENTS).join(\"\");\n              this.next instanceof p.default ? (r = this.next.domNode, this.next.insertAt(0, u), this.textNode.data = e.CONTENTS) : (this.textNode.data = u, this.parent.insertBefore(f.default.create(this.textNode), this), this.textNode = document.createTextNode(e.CONTENTS), this.domNode.appendChild(this.textNode));\n            }\n\n            if (this.remove(), null != o) {\n              var s = [o, i].map(function (t) {\n                return Math.max(0, Math.min(r.data.length, t - 1));\n              }),\n                  c = l(s, 2);\n              return o = c[0], i = c[1], {\n                startNode: r,\n                startOffset: o,\n                endNode: r,\n                endOffset: i\n              };\n            }\n          }\n        }\n      }, {\n        key: \"update\",\n        value: function (t, e) {\n          var n = this;\n\n          if (t.some(function (t) {\n            return \"characterData\" === t.type && t.target === n.textNode;\n          })) {\n            var r = this.restore();\n            r && (e.range = r);\n          }\n        }\n      }, {\n        key: \"value\",\n        value: function () {\n          return \"\";\n        }\n      }]), e;\n    }(f.default.Embed);\n\n    h.blotName = \"cursor\", h.className = \"ql-cursor\", h.tagName = \"span\", h.CONTENTS = \"\\ufeff\", e.default = h;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return _.includes(t.nodeType);\n    }\n\n    function o(t, e) {\n      var n = [],\n          r = function (t) {\n        for (var e = 0; e < t.length; ++e) {\n          t[e].shadowRoot && n.push(t[e].shadowRoot);\n        }\n      };\n\n      for (e.shadowRoot && n.push(e.shadowRoot), r(e.childNodes); n.length;) {\n        for (var o = n.shift(), i = 0; i < o.childNodes.length; ++i) {\n          if (t.containsNode(o.childNodes[i], !0)) return o;\n        }\n\n        r(o.querySelectorAll(\"*\"));\n      }\n\n      return null;\n    }\n\n    function i(t, e, n) {\n      var o = e.childNodes || e.children;\n      if (!o) return e;\n\n      for (var a = 0; a < o.length; ++a) {\n        var l = n ? a : o.length - 1 - a,\n            u = o[l];\n\n        if (r(u) && t.containsNode(u, !0)) {\n          if (t.containsNode(u, !1)) return u;\n          if (!g.exec(u.localName || \"\")) return i(t, u, n);\n        }\n      }\n\n      return e;\n    }\n\n    function a(t, e, n) {\n      for (var r = e; (e = u(e, n)) && e.contains(r);) {\n        ;\n      }\n\n      return !!e && e instanceof Element && t.containsNode(e, !0);\n    }\n\n    function l(t, e, n) {\n      if (\"Range\" === t.type) {\n        var r = function () {\n          return t.toString().length;\n        },\n            o = r(),\n            i = void 0;\n\n        return t.modify(\"extend\", \"forward\", \"character\"), (i = r()) > o || a(t, n, !0) ? (t.modify(\"extend\", \"backward\", \"character\"), !0) : i < o || !t.containsNode(e) ? (t.modify(\"extend\", \"backward\", \"character\"), !1) : (t.modify(\"extend\", \"backward\", \"character\"), i = r(), i > o || a(t, e, !1) ? (t.modify(\"extend\", \"forward\", \"character\"), !1) : i < o || !t.containsNode(n) ? (t.modify(\"extend\", \"forward\", \"character\"), !0) : void 0);\n      }\n    }\n\n    function u(t, e) {\n      if (!e) return t.previousSibling || t.parentNode || null;\n\n      for (; t;) {\n        if (t.nextSibling) return t.nextSibling;\n        t = t.parentNode;\n      }\n\n      return null;\n    }\n\n    function s(t, e, n) {\n      E.has(t) && (E.delete(t), E.set(t, n)), e.removeAllRanges(), e.addRange(n);\n    }\n\n    function c(t) {\n      if (y) {\n        var e = document.getSelection();\n        return e.rangeCount ? e.getRangeAt(0) : null;\n      }\n\n      if (b) {\n        var n = document.getSelection();\n        return n.containsNode(t, !0) ? n.getRangeAt(0) : null;\n      }\n\n      if (h) {\n        var r = t.getSelection();\n        return r.rangeCount ? r.getRangeAt(0) : null;\n      }\n\n      var o = E.get(t);\n      if (o) return o;\n      var i = f(t);\n      return E.set(t, i.range), window.setTimeout(function () {\n        E.delete(t);\n      }, 0), i.range;\n    }\n\n    function f(t) {\n      var e = window.getSelection();\n      if (\"None\" === e.type) return {\n        range: null,\n        type: \"none\"\n      };\n      if (\"Caret\" !== e.type && \"Range\" !== e.type) throw new TypeError(\"unexpected type: \" + e.type);\n      var n = i(e, t, !0);\n      if (n === t) return {\n        range: null,\n        mode: \"none\"\n      };\n      var r = document.createRange(),\n          o = null,\n          a = void 0;\n      if (\"Range\" === e.type && (o = i(e, t, !1), void 0 === (a = l(e, n, o)))) return r.setStart(n, 0), r.setEnd(o, o.length), {\n        range: r,\n        mode: \"all\"\n      };\n      var u = e.toString().length,\n          s = 0,\n          c = 0;\n      if (null === o) ;else if (o.nodeType === Node.TEXT_NODE) {\n        for (var f = o.textContent, d = o.nextSibling, p = f.length - 1; p >= 0; --p) {\n          o.splitText(p);\n          var h = e.toString().length;\n\n          if (h !== u) {\n            c = p + 1;\n            break;\n          }\n        }\n\n        for (o.insertData(o.length, f.substr(o.length)); o.nextSibling !== d;) {\n          o.nextSibling.remove();\n        }\n      }\n\n      if (n.nodeType === Node.TEXT_NODE) {\n        n !== o && (n.appendData(\"?\"), e.collapseToStart(), e.modify(\"extend\", \"right\", \"character\"));\n\n        for (var y = n.textContent, v = n.nextSibling, b = n === o ? c : y.length - 1, m = b; m >= 0; --m) {\n          if (n.splitText(m), \"\" === e.toString()) {\n            s = m;\n            break;\n          }\n        }\n\n        for (n.insertData(n.length, y.substr(n.length)); n.nextSibling !== v;) {\n          n.nextSibling.remove();\n        }\n\n        n !== o && n.deleteData(n.length - 1, 1), null === o && (o = n, c = s);\n      } else null === o && (o = n);\n\n      return 1 === u && O && O.node === n && O.offset > s && a && (a = !1), !0 === a ? (e.collapse(n, s), e.extend(o, c)) : !1 === a ? (e.collapse(o, c), e.extend(n, s)) : e.setPosition(n, s), r.setStart(n, s), r.setEnd(o, c), {\n        range: r,\n        mode: \"normal\"\n      };\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.findCaretFocus = o, e.addRange = s, e.getRange = c;\n    var d = e.SHADOW_SELECTIONCHANGE = \"-shadow-selectionchange\",\n        p = \"attachShadow\" in Element.prototype && \"getRootNode\" in Element.prototype,\n        h = !(!p || !document.createElement(\"div\").attachShadow({\n      mode: \"open\"\n    }).getSelection),\n        y = window.ShadyDOM && window.ShadyDOM.inUse,\n        v = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,\n        b = !p || y || !h && !v,\n        m = e.usePolyfill = !(h || b),\n        g = /^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|script|source|style|template|track|wbr)$/,\n        _ = [Node.ELEMENT_NODE, Node.TEXT_NODE, Node.DOCUMENT_FRAGMENT_NODE],\n        O = {\n      node: null,\n      offset: -1\n    };\n    !function () {\n      if (!m) return document.addEventListener(\"selectionchange\", function () {\n        document.dispatchEvent(new CustomEvent(d));\n      }), function () {};\n      var t = !1;\n      document.addEventListener(\"selectionchange\", function () {\n        if (!t) {\n          t = !0;\n          var e = window.getSelection();\n\n          if (\"Caret\" === e.type) {\n            var n = o(e, e.anchorNode);\n\n            if (n instanceof window.ShadowRoot) {\n              var r = c(n);\n\n              if (r) {\n                var i = r.startContainer,\n                    a = r.startOffset;\n                O = {\n                  node: i,\n                  offset: a\n                };\n              }\n            }\n          }\n\n          document.dispatchEvent(new CustomEvent(\"-shadow-selectionchange\")), window.requestAnimationFrame(function () {\n            t = !1;\n          });\n        }\n      });\n    }();\n    var E = new Map();\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t) {\n      if (Array.isArray(t)) {\n        for (var e = 0, n = Array(t.length); e < t.length; e++) {\n          n[e] = t[e];\n        }\n\n        return n;\n      }\n\n      return Array.from(t);\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      try {\n        e.parentNode;\n      } catch (t) {\n        return !1;\n      }\n\n      return e instanceof Text && (e = e.parentNode), t.contains(e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.Range = void 0;\n\n    var l = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        u = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        s = n(0),\n        c = r(s),\n        f = n(20),\n        d = r(f),\n        p = n(11),\n        h = r(p),\n        y = n(13),\n        v = r(y),\n        b = n(8),\n        m = r(b),\n        g = n(28),\n        _ = (0, m.default)(\"quill:selection\"),\n        O = function t(e) {\n      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n      i(this, t), this.index = e, this.length = n;\n    },\n        E = function () {\n      function t(e, n) {\n        var r = this;\n        i(this, t), this.emitter = n, this.scroll = e, this.composing = !1, this.mouseDown = !1, this.root = this.scroll.domNode, this.rootDocument = this.root.getRootNode ? this.root.getRootNode() : document, this.cursor = c.default.create(\"cursor\", this), this.lastRange = this.savedRange = new O(0, 0), this.handleComposition(), this.handleDragging(), g.usePolyfill || this.emitter.listenDOM(g.SHADOW_SELECTIONCHANGE, document, function () {\n          r.mouseDown || setTimeout(r.update.bind(r, v.default.sources.USER), 1);\n        }), this.emitter.on(v.default.events.EDITOR_CHANGE, function (t, e) {\n          t === v.default.events.TEXT_CHANGE && e.length() > 0 && r.update(v.default.sources.SILENT);\n        }), this.emitter.on(v.default.events.SCROLL_BEFORE_UPDATE, function () {\n          if (r.hasFocus()) {\n            var t = r.getNativeRange();\n            null != t && t.start.node !== r.cursor.textNode && r.emitter.once(v.default.events.SCROLL_UPDATE, function () {\n              try {\n                r.setNativeRange(t.start.node, t.start.offset, t.end.node, t.end.offset);\n              } catch (t) {}\n            });\n          }\n        }), this.emitter.on(v.default.events.SCROLL_OPTIMIZE, function (t, e) {\n          if (e.range) {\n            var n = e.range,\n                o = n.startNode,\n                i = n.startOffset,\n                a = n.endNode,\n                l = n.endOffset;\n            r.setNativeRange(o, i, a, l);\n          }\n        }), this.update(v.default.sources.SILENT);\n      }\n\n      return u(t, [{\n        key: \"handleComposition\",\n        value: function () {\n          var t = this;\n          this.root.addEventListener(\"compositionstart\", function () {\n            t.composing = !0;\n          }), this.root.addEventListener(\"compositionend\", function () {\n            if (t.composing = !1, t.cursor.parent) {\n              var e = t.cursor.restore();\n              if (!e) return;\n              setTimeout(function () {\n                t.setNativeRange(e.startNode, e.startOffset, e.endNode, e.endOffset);\n              }, 1);\n            }\n          });\n        }\n      }, {\n        key: \"handleDragging\",\n        value: function () {\n          var t = this;\n          this.emitter.listenDOM(\"mousedown\", document.body, function () {\n            t.mouseDown = !0;\n          }), this.emitter.listenDOM(\"mouseup\", document.body, function () {\n            t.mouseDown = !1, t.update(v.default.sources.USER);\n          });\n        }\n      }, {\n        key: \"focus\",\n        value: function () {\n          this.hasFocus() || (this.root.focus(), this.setRange(this.savedRange));\n        }\n      }, {\n        key: \"format\",\n        value: function (t, e) {\n          if (null == this.scroll.whitelist || this.scroll.whitelist[t]) {\n            this.scroll.update();\n            var n = this.getNativeRange();\n\n            if (null != n && n.native.collapsed && !c.default.query(t, c.default.Scope.BLOCK)) {\n              if (n.start.node !== this.cursor.textNode) {\n                var r = c.default.find(n.start.node, !1);\n                if (null == r) return;\n\n                if (r instanceof c.default.Leaf) {\n                  var o = r.split(n.start.offset);\n                  r.parent.insertBefore(this.cursor, o);\n                } else r.insertBefore(this.cursor, n.start.node);\n\n                this.cursor.attach();\n              }\n\n              this.cursor.format(t, e), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();\n            }\n          }\n        }\n      }, {\n        key: \"getBounds\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n              n = this.scroll.length();\n          t = Math.min(t, n - 1), e = Math.min(t + e, n - 1) - t;\n          var r = void 0,\n              o = this.scroll.leaf(t),\n              i = l(o, 2),\n              a = i[0],\n              u = i[1];\n          if (null == a) return null;\n          var s = a.position(u, !0),\n              c = l(s, 2);\n          r = c[0], u = c[1];\n          var f = document.createRange();\n\n          if (e > 0) {\n            f.setStart(r, u);\n            var d = this.scroll.leaf(t + e),\n                p = l(d, 2);\n            if (a = p[0], u = p[1], null == a) return null;\n            var h = a.position(u, !0),\n                y = l(h, 2);\n            return r = y[0], u = y[1], f.setEnd(r, u), f.getBoundingClientRect();\n          }\n\n          var v = \"left\",\n              b = void 0;\n          return r instanceof Text ? (u < r.data.length ? (f.setStart(r, u), f.setEnd(r, u + 1)) : (f.setStart(r, u - 1), f.setEnd(r, u), v = \"right\"), b = f.getBoundingClientRect()) : (b = a.domNode.getBoundingClientRect(), u > 0 && (v = \"right\")), {\n            bottom: b.top + b.height,\n            height: b.height,\n            left: b[v],\n            right: b[v],\n            top: b.top,\n            width: 0\n          };\n        }\n      }, {\n        key: \"getNativeRange\",\n        value: function () {\n          var t = (0, g.getRange)(this.rootDocument);\n          if (null == t) return null;\n          var e = this.normalizeNative(t);\n          return _.info(\"getNativeRange\", e), e;\n        }\n      }, {\n        key: \"getRange\",\n        value: function () {\n          var t = this.getNativeRange();\n          return null == t ? [null, null] : [this.normalizedToRange(t), t];\n        }\n      }, {\n        key: \"hasFocus\",\n        value: function () {\n          return this.rootDocument.activeElement === this.root;\n        }\n      }, {\n        key: \"normalizedToRange\",\n        value: function (t) {\n          var e = this,\n              n = [[t.start.node, t.start.offset]];\n          t.native.collapsed || n.push([t.end.node, t.end.offset]);\n          var r = n.map(function (t) {\n            var n = l(t, 2),\n                r = n[0],\n                o = n[1],\n                i = c.default.find(r, !0),\n                a = i.offset(e.scroll);\n            return 0 === o ? a : i instanceof c.default.Container ? a + i.length() : a + i.index(r, o);\n          }),\n              i = Math.min(Math.max.apply(Math, o(r)), this.scroll.length() - 1),\n              a = Math.min.apply(Math, [i].concat(o(r)));\n          return new O(a, i - a);\n        }\n      }, {\n        key: \"normalizeNative\",\n        value: function (t) {\n          if (!a(this.root, t.startContainer) || !t.collapsed && !a(this.root, t.endContainer)) return null;\n          var e = {\n            start: {\n              node: t.startContainer,\n              offset: t.startOffset\n            },\n            end: {\n              node: t.endContainer,\n              offset: t.endOffset\n            },\n            native: t\n          };\n          return [e.start, e.end].forEach(function (t) {\n            for (var e = t.node, n = t.offset; !(e instanceof Text) && e.childNodes.length > 0;) {\n              if (e.childNodes.length > n) e = e.childNodes[n], n = 0;else {\n                if (e.childNodes.length !== n) break;\n                e = e.lastChild, n = e instanceof Text ? e.data.length : e.childNodes.length + 1;\n              }\n            }\n\n            t.node = e, t.offset = n;\n          }), e;\n        }\n      }, {\n        key: \"rangeToNative\",\n        value: function (t) {\n          var e = this,\n              n = t.collapsed ? [t.index] : [t.index, t.index + t.length],\n              r = [],\n              o = this.scroll.length();\n          return n.forEach(function (t, n) {\n            t = Math.min(o - 1, t);\n            var i = void 0,\n                a = e.scroll.leaf(t),\n                u = l(a, 2),\n                s = u[0],\n                c = u[1],\n                f = s.position(c, 0 !== n),\n                d = l(f, 2);\n            i = d[0], c = d[1], r.push(i, c);\n          }), r.length < 2 && (r = r.concat(r)), r;\n        }\n      }, {\n        key: \"scrollIntoView\",\n        value: function (t) {\n          var e = this.lastRange;\n\n          if (null != e) {\n            var n = this.getBounds(e.index, e.length);\n\n            if (null != n) {\n              var r = this.scroll.length() - 1,\n                  o = this.scroll.line(Math.min(e.index, r)),\n                  i = l(o, 1),\n                  a = i[0],\n                  u = a;\n\n              if (e.length > 0) {\n                var s = this.scroll.line(Math.min(e.index + e.length, r));\n                u = l(s, 1)[0];\n              }\n\n              if (null != a && null != u) {\n                var c = t.getBoundingClientRect();\n                n.top < c.top ? t.scrollTop -= c.top - n.top : n.bottom > c.bottom && (t.scrollTop += n.bottom - c.bottom);\n              }\n            }\n          }\n        }\n      }, {\n        key: \"setNativeRange\",\n        value: function (t, e) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t,\n              r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e,\n              o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];\n\n          if (_.info(\"setNativeRange\", t, e, n, r), null == t || null != this.root.parentNode && null != t.parentNode && null != n.parentNode) {\n            var i = \"function\" == typeof this.rootDocument.getSelection ? this.rootDocument.getSelection() : document.getSelection();\n            if (null != i) if (null != t) {\n              this.hasFocus() || this.root.focus();\n              var a = (this.getNativeRange() || {}).native;\n\n              if (null == a || o || t !== a.startContainer || e !== a.startOffset || n !== a.endContainer || r !== a.endOffset) {\n                \"BR\" == t.tagName && (e = [].indexOf.call(t.parentNode.childNodes, t), t = t.parentNode), \"BR\" == n.tagName && (r = [].indexOf.call(n.parentNode.childNodes, n), n = n.parentNode);\n                var l = document.createRange();\n                l.setStart(t, e), l.setEnd(n, r), (0, g.addRange)(this.rootDocument, i, l);\n              }\n            } else i.removeAllRanges(), this.root.blur(), document.body.focus();\n          }\n        }\n      }, {\n        key: \"setRange\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : v.default.sources.API;\n\n          if (\"string\" == typeof e && (n = e, e = !1), _.info(\"setRange\", t), null != t) {\n            var r = this.rangeToNative(t);\n            this.setNativeRange.apply(this, o(r).concat([e]));\n          } else this.setNativeRange(null);\n\n          this.update(n);\n        }\n      }, {\n        key: \"update\",\n        value: function () {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v.default.sources.USER,\n              e = this.lastRange,\n              n = this.getRange(),\n              r = l(n, 2),\n              o = r[0],\n              i = r[1];\n\n          if (this.lastRange = o, null != this.lastRange && (this.savedRange = this.lastRange), !(0, h.default)(e, this.lastRange)) {\n            var a;\n            !this.composing && null != i && i.native.collapsed && i.start.node !== this.cursor.textNode && this.cursor.restore();\n            var u = [v.default.events.SELECTION_CHANGE, (0, d.default)(this.lastRange), (0, d.default)(e), t];\n\n            if ((a = this.emitter).emit.apply(a, [v.default.events.EDITOR_CHANGE].concat(u)), t !== v.default.sources.SILENT) {\n              var s;\n              (s = this.emitter).emit.apply(s, u);\n            }\n          }\n        }\n      }]), t;\n    }();\n\n    e.Range = O, e.default = E;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.AlignStyle = e.AlignClass = e.AlignAttribute = void 0;\n\n    var r = n(0),\n        o = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(r),\n        i = {\n      scope: o.default.Scope.BLOCK,\n      whitelist: [\"right\", \"center\", \"justify\"]\n    },\n        a = new o.default.Attributor.Attribute(\"align\", \"align\", i),\n        l = new o.default.Attributor.Class(\"align\", \"ql-align\", i),\n        u = new o.default.Attributor.Style(\"align\", \"text-align\", i);\n\n    e.AlignAttribute = a, e.AlignClass = l, e.AlignStyle = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.BackgroundStyle = e.BackgroundClass = void 0;\n\n    var r = n(0),\n        o = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(r),\n        i = n(22),\n        a = new o.default.Attributor.Class(\"background\", \"ql-bg\", {\n      scope: o.default.Scope.INLINE\n    }),\n        l = new i.ColorAttributor(\"background\", \"background-color\", {\n      scope: o.default.Scope.INLINE\n    });\n\n    e.BackgroundClass = a, e.BackgroundStyle = l;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.DirectionStyle = e.DirectionClass = e.DirectionAttribute = void 0;\n\n    var r = n(0),\n        o = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(r),\n        i = {\n      scope: o.default.Scope.BLOCK,\n      whitelist: [\"rtl\"]\n    },\n        a = new o.default.Attributor.Attribute(\"direction\", \"dir\", i),\n        l = new o.default.Attributor.Class(\"direction\", \"ql-direction\", i),\n        u = new o.default.Attributor.Style(\"direction\", \"direction\", i);\n\n    e.DirectionAttribute = a, e.DirectionClass = l, e.DirectionStyle = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.FontClass = e.FontStyle = void 0;\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = {\n      scope: s.default.Scope.INLINE,\n      whitelist: [\"serif\", \"monospace\"]\n    },\n        f = new s.default.Attributor.Class(\"font\", \"ql-font\", c),\n        d = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"value\",\n        value: function (t) {\n          return l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"value\", this).call(this, t).replace(/[\"']/g, \"\");\n        }\n      }]), e;\n    }(s.default.Attributor.Style),\n        p = new d(\"font\", \"font-family\", c);\n\n    e.FontStyle = p, e.FontClass = f;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.SizeStyle = e.SizeClass = void 0;\n\n    var r = n(0),\n        o = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(r),\n        i = new o.default.Attributor.Class(\"size\", \"ql-size\", {\n      scope: o.default.Scope.INLINE,\n      whitelist: [\"small\", \"large\", \"huge\"]\n    }),\n        a = new o.default.Attributor.Style(\"size\", \"font-size\", {\n      scope: o.default.Scope.INLINE,\n      whitelist: [\"10px\", \"18px\", \"32px\"]\n    });\n\n    e.SizeClass = i, e.SizeStyle = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function l(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function u(t, e) {\n      var n,\n          r = t === D.keys.LEFT ? \"prefix\" : \"suffix\";\n      return n = {\n        key: t,\n        shiftKey: e,\n        altKey: null\n      }, o(n, r, /^$/), o(n, \"handler\", function (n) {\n        var r = n.index;\n        t === D.keys.RIGHT && (r += n.length + 1);\n        var o = this.quill.getLeaf(r);\n        return !(b(o, 1)[0] instanceof S.default.Embed) || (t === D.keys.LEFT ? e ? this.quill.setSelection(n.index - 1, n.length + 1, C.default.sources.USER) : this.quill.setSelection(n.index - 1, C.default.sources.USER) : e ? this.quill.setSelection(n.index, n.length + 1, C.default.sources.USER) : this.quill.setSelection(n.index + n.length + 1, C.default.sources.USER), !1);\n      }), n;\n    }\n\n    function s(t, e) {\n      if (!(0 === t.index || this.quill.getLength() <= 1)) {\n        var n = this.quill.getLine(t.index),\n            r = b(n, 1),\n            o = r[0],\n            i = {};\n\n        if (0 === e.offset) {\n          var a = this.quill.getLine(t.index - 1),\n              l = b(a, 1),\n              u = l[0];\n\n          if (null != u && u.length() > 1) {\n            var s = o.formats(),\n                c = this.quill.getFormat(t.index - 1, 1);\n            i = A.default.attributes.diff(s, c) || {};\n          }\n        }\n\n        var f = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(e.prefix) ? 2 : 1;\n        this.quill.deleteText(t.index - f, f, C.default.sources.USER), Object.keys(i).length > 0 && this.quill.formatLine(t.index - f, f, i, C.default.sources.USER), this.quill.focus();\n      }\n    }\n\n    function c(t, e) {\n      var n = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(e.suffix) ? 2 : 1;\n\n      if (!(t.index >= this.quill.getLength() - n)) {\n        var r = {},\n            o = 0,\n            i = this.quill.getLine(t.index),\n            a = b(i, 1),\n            l = a[0];\n\n        if (e.offset >= l.length() - 1) {\n          var u = this.quill.getLine(t.index + 1),\n              s = b(u, 1),\n              c = s[0];\n\n          if (c) {\n            var f = l.formats(),\n                d = this.quill.getFormat(t.index, 1);\n            r = A.default.attributes.diff(f, d) || {}, o = c.length();\n          }\n        }\n\n        this.quill.deleteText(t.index, n, C.default.sources.USER), Object.keys(r).length > 0 && this.quill.formatLine(t.index + o - 1, n, r, C.default.sources.USER);\n      }\n    }\n\n    function f(t) {\n      var e = this.quill.getLines(t),\n          n = {};\n\n      if (e.length > 1) {\n        var r = e[0].formats(),\n            o = e[e.length - 1].formats();\n        n = A.default.attributes.diff(o, r) || {};\n      }\n\n      this.quill.deleteText(t, C.default.sources.USER), Object.keys(n).length > 0 && this.quill.formatLine(t.index, 1, n, C.default.sources.USER), this.quill.setSelection(t.index, C.default.sources.SILENT), this.quill.focus();\n    }\n\n    function d(t, e) {\n      var n = this;\n      t.length > 0 && this.quill.scroll.deleteAt(t.index, t.length);\n      var r = Object.keys(e.format).reduce(function (t, n) {\n        return S.default.query(n, S.default.Scope.BLOCK) && !Array.isArray(e.format[n]) && (t[n] = e.format[n]), t;\n      }, {});\n      this.quill.insertText(t.index, \"\\n\", r, C.default.sources.USER), this.quill.setSelection(t.index + 1, C.default.sources.SILENT), this.quill.focus(), Object.keys(e.format).forEach(function (t) {\n        null == r[t] && (Array.isArray(e.format[t]) || \"link\" !== t && n.quill.format(t, e.format[t], C.default.sources.USER));\n      });\n    }\n\n    function p(t) {\n      return {\n        key: D.keys.TAB,\n        shiftKey: !t,\n        format: {\n          \"code-block\": !0\n        },\n        handler: function (e) {\n          var n = S.default.query(\"code-block\"),\n              r = e.index,\n              o = e.length,\n              i = this.quill.scroll.descendant(n, r),\n              a = b(i, 2),\n              l = a[0],\n              u = a[1];\n\n          if (null != l) {\n            var s = this.quill.getIndex(l),\n                c = l.newlineIndex(u, !0) + 1,\n                f = l.newlineIndex(s + u + o),\n                d = l.domNode.textContent.slice(c, f).split(\"\\n\");\n            u = 0, d.forEach(function (e, i) {\n              t ? (l.insertAt(c + u, n.TAB), u += n.TAB.length, 0 === i ? r += n.TAB.length : o += n.TAB.length) : e.startsWith(n.TAB) && (l.deleteAt(c + u, n.TAB.length), u -= n.TAB.length, 0 === i ? r -= n.TAB.length : o -= n.TAB.length), u += e.length + 1;\n            }), this.quill.update(C.default.sources.USER), this.quill.setSelection(r, o, C.default.sources.SILENT);\n          }\n        }\n      };\n    }\n\n    function h(t) {\n      return {\n        key: t[0].toUpperCase(),\n        shortKey: !0,\n        handler: function (e, n) {\n          this.quill.format(t, !n.format[t], C.default.sources.USER);\n        }\n      };\n    }\n\n    function y(t) {\n      if (\"string\" == typeof t || \"number\" == typeof t) return y({\n        key: t\n      });\n      if (\"object\" === (void 0 === t ? \"undefined\" : v(t)) && (t = (0, _.default)(t, !1)), \"string\" == typeof t.key) if (null != D.keys[t.key.toUpperCase()]) t.key = D.keys[t.key.toUpperCase()];else {\n        if (1 !== t.key.length) return null;\n        t.key = t.key.toUpperCase().charCodeAt(0);\n      }\n      return t.shortKey && (t[B] = t.shortKey, delete t.shortKey), t;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.SHORTKEY = e.default = void 0;\n\n    var v = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    },\n        b = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        m = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        g = n(20),\n        _ = r(g),\n        O = n(11),\n        E = r(O),\n        N = n(3),\n        w = r(N),\n        k = n(5),\n        j = r(k),\n        x = n(19),\n        A = r(x),\n        T = n(0),\n        S = r(T),\n        P = n(6),\n        C = r(P),\n        L = n(8),\n        R = r(L),\n        q = n(9),\n        I = r(q),\n        M = (0, R.default)(\"quill:keyboard\"),\n        B = /Mac/i.test(navigator.platform) ? \"metaKey\" : \"ctrlKey\",\n        D = function (t) {\n      function e(t, n) {\n        i(this, e);\n        var r = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));\n        return r.bindings = {}, Object.keys(r.options.bindings).forEach(function (e) {\n          (\"list autofill\" !== e || null == t.scroll.whitelist || t.scroll.whitelist.list) && r.options.bindings[e] && r.addBinding(r.options.bindings[e]);\n        }), r.addBinding({\n          key: e.keys.ENTER,\n          shiftKey: null\n        }, d), r.addBinding({\n          key: e.keys.ENTER,\n          metaKey: null,\n          ctrlKey: null,\n          altKey: null\n        }, function () {}), /Firefox/i.test(navigator.userAgent) ? (r.addBinding({\n          key: e.keys.BACKSPACE\n        }, {\n          collapsed: !0\n        }, s), r.addBinding({\n          key: e.keys.DELETE\n        }, {\n          collapsed: !0\n        }, c)) : (r.addBinding({\n          key: e.keys.BACKSPACE\n        }, {\n          collapsed: !0,\n          prefix: /^.?$/\n        }, s), r.addBinding({\n          key: e.keys.DELETE\n        }, {\n          collapsed: !0,\n          suffix: /^.?$/\n        }, c)), r.addBinding({\n          key: e.keys.BACKSPACE\n        }, {\n          collapsed: !1\n        }, f), r.addBinding({\n          key: e.keys.DELETE\n        }, {\n          collapsed: !1\n        }, f), r.addBinding({\n          key: e.keys.BACKSPACE,\n          altKey: null,\n          ctrlKey: null,\n          metaKey: null,\n          shiftKey: null\n        }, {\n          collapsed: !0,\n          offset: 0\n        }, s), r.listen(), r;\n      }\n\n      return l(e, t), m(e, null, [{\n        key: \"match\",\n        value: function (t, e) {\n          return e = y(e), ![\"altKey\", \"ctrlKey\", \"metaKey\", \"shiftKey\"].some(function (n) {\n            return !!e[n] !== t[n] && null !== e[n];\n          }) && e.key === (t.which || t.keyCode);\n        }\n      }]), m(e, [{\n        key: \"addBinding\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n              r = y(t);\n          if (null == r || null == r.key) return M.warn(\"Attempted to add invalid keyboard binding\", r);\n          \"function\" == typeof e && (e = {\n            handler: e\n          }), \"function\" == typeof n && (n = {\n            handler: n\n          }), r = (0, w.default)(r, e, n), this.bindings[r.key] = this.bindings[r.key] || [], this.bindings[r.key].push(r);\n        }\n      }, {\n        key: \"listen\",\n        value: function () {\n          var t = this;\n          this.quill.root.addEventListener(\"keydown\", function (n) {\n            if (!n.defaultPrevented) {\n              var r = n.which || n.keyCode,\n                  o = (t.bindings[r] || []).filter(function (t) {\n                return e.match(n, t);\n              });\n\n              if (0 !== o.length) {\n                var i = t.quill.getSelection();\n\n                if (null != i && t.quill.hasFocus()) {\n                  var a = t.quill.getLine(i.index),\n                      l = b(a, 2),\n                      u = l[0],\n                      s = l[1],\n                      c = t.quill.getLeaf(i.index),\n                      f = b(c, 2),\n                      d = f[0],\n                      p = f[1],\n                      h = 0 === i.length ? [d, p] : t.quill.getLeaf(i.index + i.length),\n                      y = b(h, 2),\n                      m = y[0],\n                      g = y[1],\n                      _ = d instanceof S.default.Text ? d.value().slice(0, p) : \"\",\n                      O = m instanceof S.default.Text ? m.value().slice(g) : \"\",\n                      N = {\n                    collapsed: 0 === i.length,\n                    empty: 0 === i.length && u.length() <= 1,\n                    format: t.quill.getFormat(i),\n                    offset: s,\n                    prefix: _,\n                    suffix: O\n                  };\n\n                  o.some(function (e) {\n                    if (null != e.collapsed && e.collapsed !== N.collapsed) return !1;\n                    if (null != e.empty && e.empty !== N.empty) return !1;\n                    if (null != e.offset && e.offset !== N.offset) return !1;\n\n                    if (Array.isArray(e.format)) {\n                      if (e.format.every(function (t) {\n                        return null == N.format[t];\n                      })) return !1;\n                    } else if (\"object\" === v(e.format) && !Object.keys(e.format).every(function (t) {\n                      return !0 === e.format[t] ? null != N.format[t] : !1 === e.format[t] ? null == N.format[t] : (0, E.default)(e.format[t], N.format[t]);\n                    })) return !1;\n\n                    return !(null != e.prefix && !e.prefix.test(N.prefix)) && !(null != e.suffix && !e.suffix.test(N.suffix)) && !0 !== e.handler.call(t, i, N);\n                  }) && n.preventDefault();\n                }\n              }\n            }\n          });\n        }\n      }]), e;\n    }(I.default);\n\n    D.keys = {\n      BACKSPACE: 8,\n      TAB: 9,\n      ENTER: 13,\n      ESCAPE: 27,\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      DOWN: 40,\n      DELETE: 46\n    }, D.DEFAULTS = {\n      bindings: {\n        bold: h(\"bold\"),\n        italic: h(\"italic\"),\n        underline: h(\"underline\"),\n        indent: {\n          key: D.keys.TAB,\n          format: [\"blockquote\", \"indent\", \"list\"],\n          handler: function (t, e) {\n            if (e.collapsed && 0 !== e.offset) return !0;\n            this.quill.format(\"indent\", \"+1\", C.default.sources.USER);\n          }\n        },\n        outdent: {\n          key: D.keys.TAB,\n          shiftKey: !0,\n          format: [\"blockquote\", \"indent\", \"list\"],\n          handler: function (t, e) {\n            if (e.collapsed && 0 !== e.offset) return !0;\n            this.quill.format(\"indent\", \"-1\", C.default.sources.USER);\n          }\n        },\n        \"outdent backspace\": {\n          key: D.keys.BACKSPACE,\n          collapsed: !0,\n          shiftKey: null,\n          metaKey: null,\n          ctrlKey: null,\n          altKey: null,\n          format: [\"indent\", \"list\"],\n          offset: 0,\n          handler: function (t, e) {\n            null != e.format.indent ? this.quill.format(\"indent\", \"-1\", C.default.sources.USER) : null != e.format.list && this.quill.format(\"list\", !1, C.default.sources.USER);\n          }\n        },\n        \"indent code-block\": p(!0),\n        \"outdent code-block\": p(!1),\n        \"remove tab\": {\n          key: D.keys.TAB,\n          shiftKey: !0,\n          collapsed: !0,\n          prefix: /\\t$/,\n          handler: function (t) {\n            this.quill.deleteText(t.index - 1, 1, C.default.sources.USER);\n          }\n        },\n        tab: {\n          key: D.keys.TAB,\n          handler: function (t) {\n            this.quill.history.cutoff();\n            var e = new j.default().retain(t.index).delete(t.length).insert(\"\\t\");\n            this.quill.updateContents(e, C.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t.index + 1, C.default.sources.SILENT);\n          }\n        },\n        \"list empty enter\": {\n          key: D.keys.ENTER,\n          collapsed: !0,\n          format: [\"list\"],\n          empty: !0,\n          handler: function (t, e) {\n            this.quill.format(\"list\", !1, C.default.sources.USER), e.format.indent && this.quill.format(\"indent\", !1, C.default.sources.USER);\n          }\n        },\n        \"checklist enter\": {\n          key: D.keys.ENTER,\n          collapsed: !0,\n          format: {\n            list: \"checked\"\n          },\n          handler: function (t) {\n            var e = this.quill.getLine(t.index),\n                n = b(e, 2),\n                r = n[0],\n                o = n[1],\n                i = (0, w.default)({}, r.formats(), {\n              list: \"checked\"\n            }),\n                a = new j.default().retain(t.index).insert(\"\\n\", i).retain(r.length() - o - 1).retain(1, {\n              list: \"unchecked\"\n            });\n            this.quill.updateContents(a, C.default.sources.USER), this.quill.setSelection(t.index + 1, C.default.sources.SILENT), this.quill.scrollIntoView();\n          }\n        },\n        \"header enter\": {\n          key: D.keys.ENTER,\n          collapsed: !0,\n          format: [\"header\"],\n          suffix: /^$/,\n          handler: function (t, e) {\n            var n = this.quill.getLine(t.index),\n                r = b(n, 2),\n                o = r[0],\n                i = r[1],\n                a = new j.default().retain(t.index).insert(\"\\n\", e.format).retain(o.length() - i - 1).retain(1, {\n              header: null\n            });\n            this.quill.updateContents(a, C.default.sources.USER), this.quill.setSelection(t.index + 1, C.default.sources.SILENT), this.quill.scrollIntoView();\n          }\n        },\n        \"list autofill\": {\n          key: \" \",\n          collapsed: !0,\n          format: {\n            list: !1\n          },\n          prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n          handler: function (t, e) {\n            var n = e.prefix.length,\n                r = this.quill.getLine(t.index),\n                o = b(r, 2),\n                i = o[0],\n                a = o[1];\n            if (a > n) return !0;\n            var l = void 0;\n\n            switch (e.prefix.trim()) {\n              case \"[]\":\n              case \"[ ]\":\n                l = \"unchecked\";\n                break;\n\n              case \"[x]\":\n                l = \"checked\";\n                break;\n\n              case \"-\":\n              case \"*\":\n                l = \"bullet\";\n                break;\n\n              default:\n                l = \"ordered\";\n            }\n\n            this.quill.insertText(t.index, \" \", C.default.sources.USER), this.quill.history.cutoff();\n            var u = new j.default().retain(t.index - a).delete(n + 1).retain(i.length() - 2 - a).retain(1, {\n              list: l\n            });\n            this.quill.updateContents(u, C.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t.index - n, C.default.sources.SILENT);\n          }\n        },\n        \"code exit\": {\n          key: D.keys.ENTER,\n          collapsed: !0,\n          format: [\"code-block\"],\n          prefix: /\\n\\n$/,\n          suffix: /^\\s+$/,\n          handler: function (t) {\n            var e = this.quill.getLine(t.index),\n                n = b(e, 2),\n                r = n[0],\n                o = n[1],\n                i = new j.default().retain(t.index + r.length() - o - 2).retain(1, {\n              \"code-block\": null\n            }).delete(1);\n            this.quill.updateContents(i, C.default.sources.USER);\n          }\n        },\n        \"embed left\": u(D.keys.LEFT, !1),\n        \"embed left shift\": u(D.keys.LEFT, !0),\n        \"embed right\": u(D.keys.RIGHT, !1),\n        \"embed right shift\": u(D.keys.RIGHT, !0)\n      }\n    }, e.default = D, e.SHORTKEY = B;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(4),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"optimize\",\n        value: function (t) {\n          l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);\n        }\n      }], [{\n        key: \"create\",\n        value: function () {\n          return l(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this);\n        }\n      }, {\n        key: \"formats\",\n        value: function () {\n          return !0;\n        }\n      }]), e;\n    }(s.default);\n\n    c.blotName = \"bold\", c.tagName = [\"STRONG\", \"B\"], e.default = c;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        i = function () {\n      function t(e, n) {\n        r(this, t), this.quill = e, this.options = n, this.modules = {};\n      }\n\n      return o(t, [{\n        key: \"init\",\n        value: function () {\n          var t = this;\n          Object.keys(this.options.modules).forEach(function (e) {\n            null == t.modules[e] && t.addModule(e);\n          });\n        }\n      }, {\n        key: \"addModule\",\n        value: function (t) {\n          var e = this.quill.constructor.import(\"modules/\" + t);\n          return this.modules[t] = new e(this.quill, this.options.modules[t] || {}), this.modules[t];\n        }\n      }]), t;\n    }();\n\n    i.DEFAULTS = {\n      modules: {}\n    }, i.themes = {\n      default: i\n    }, e.default = i;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var l = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        u = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        s = n(0),\n        c = r(s),\n        f = n(7),\n        d = r(f),\n        p = \"\\ufeff\",\n        h = function (t) {\n      function e(t) {\n        o(this, e);\n        var n = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));\n        return n.contentNode = document.createElement(\"span\"), n.contentNode.setAttribute(\"contenteditable\", !1), [].slice.call(n.domNode.childNodes).forEach(function (t) {\n          n.contentNode.appendChild(t);\n        }), n.leftGuard = document.createTextNode(p), n.rightGuard = document.createTextNode(p), n.domNode.appendChild(n.leftGuard), n.domNode.appendChild(n.contentNode), n.domNode.appendChild(n.rightGuard), n;\n      }\n\n      return a(e, t), l(e, [{\n        key: \"index\",\n        value: function (t, n) {\n          return t === this.leftGuard ? 0 : t === this.rightGuard ? 1 : u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"index\", this).call(this, t, n);\n        }\n      }, {\n        key: \"restore\",\n        value: function (t) {\n          var e = void 0,\n              n = void 0,\n              r = t.data.split(p).join(\"\");\n          if (t === this.leftGuard) {\n            if (this.prev instanceof d.default) {\n              var o = this.prev.length();\n              this.prev.insertAt(o, r), e = {\n                startNode: this.prev.domNode,\n                startOffset: o + r.length\n              };\n            } else n = document.createTextNode(r), this.parent.insertBefore(c.default.create(n), this), e = {\n              startNode: n,\n              startOffset: r.length\n            };\n          } else t === this.rightGuard && (this.next instanceof d.default ? (this.next.insertAt(0, r), e = {\n            startNode: this.next.domNode,\n            startOffset: r.length\n          }) : (n = document.createTextNode(r), this.parent.insertBefore(c.default.create(n), this.next), e = {\n            startNode: n,\n            startOffset: r.length\n          }));\n          return t.data = p, e;\n        }\n      }, {\n        key: \"update\",\n        value: function (t, e) {\n          var n = this;\n          t.forEach(function (t) {\n            if (\"characterData\" === t.type && (t.target === n.leftGuard || t.target === n.rightGuard)) {\n              var r = n.restore(t.target);\n              r && (e.range = r);\n            }\n          });\n        }\n      }]), e;\n    }(c.default.Embed);\n\n    e.default = h;\n  },, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(0),\n        i = r(o),\n        a = n(6),\n        l = r(a),\n        u = n(2),\n        s = r(u),\n        c = n(14),\n        f = r(c),\n        d = n(21),\n        p = r(d),\n        h = n(27),\n        y = r(h),\n        v = n(38),\n        b = r(v),\n        m = n(4),\n        g = r(m),\n        _ = n(53),\n        O = r(_),\n        E = n(7),\n        N = r(E),\n        w = n(54),\n        k = r(w),\n        j = n(55),\n        x = r(j),\n        A = n(35),\n        T = r(A);\n\n    l.default.register({\n      \"blots/block\": s.default,\n      \"blots/block/embed\": u.BlockEmbed,\n      \"blots/break\": f.default,\n      \"blots/container\": p.default,\n      \"blots/cursor\": y.default,\n      \"blots/embed\": b.default,\n      \"blots/inline\": g.default,\n      \"blots/scroll\": O.default,\n      \"blots/text\": N.default,\n      \"modules/clipboard\": k.default,\n      \"modules/history\": x.default,\n      \"modules/keyboard\": T.default\n    }), i.default.register(s.default, f.default, y.default, g.default, O.default, N.default), e.default = l.default;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var r = function () {\n      function t() {\n        this.head = this.tail = null, this.length = 0;\n      }\n\n      return t.prototype.append = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) {\n          t[e] = arguments[e];\n        }\n\n        this.insertBefore(t[0], null), t.length > 1 && this.append.apply(this, t.slice(1));\n      }, t.prototype.contains = function (t) {\n        for (var e, n = this.iterator(); e = n();) {\n          if (e === t) return !0;\n        }\n\n        return !1;\n      }, t.prototype.insertBefore = function (t, e) {\n        t && (t.next = e, null != e ? (t.prev = e.prev, null != e.prev && (e.prev.next = t), e.prev = t, e === this.head && (this.head = t)) : null != this.tail ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : (t.prev = null, this.head = this.tail = t), this.length += 1);\n      }, t.prototype.offset = function (t) {\n        for (var e = 0, n = this.head; null != n;) {\n          if (n === t) return e;\n          e += n.length(), n = n.next;\n        }\n\n        return -1;\n      }, t.prototype.remove = function (t) {\n        this.contains(t) && (null != t.prev && (t.prev.next = t.next), null != t.next && (t.next.prev = t.prev), t === this.head && (this.head = t.next), t === this.tail && (this.tail = t.prev), this.length -= 1);\n      }, t.prototype.iterator = function (t) {\n        return void 0 === t && (t = this.head), function () {\n          var e = t;\n          return null != t && (t = t.next), e;\n        };\n      }, t.prototype.find = function (t, e) {\n        void 0 === e && (e = !1);\n\n        for (var n, r = this.iterator(); n = r();) {\n          var o = n.length();\n          if (t < o || e && t === o && (null == n.next || 0 !== n.next.length())) return [n, t];\n          t -= o;\n        }\n\n        return [null, 0];\n      }, t.prototype.forEach = function (t) {\n        for (var e, n = this.iterator(); e = n();) {\n          t(e);\n        }\n      }, t.prototype.forEachAt = function (t, e, n) {\n        if (!(e <= 0)) for (var r, o = this.find(t), i = o[0], a = o[1], l = t - a, u = this.iterator(i); (r = u()) && l < t + e;) {\n          var s = r.length();\n          t > l ? n(r, t - l, Math.min(e, l + s - t)) : n(r, 0, Math.min(s, t + e - l)), l += s;\n        }\n      }, t.prototype.map = function (t) {\n        return this.reduce(function (e, n) {\n          return e.push(t(n)), e;\n        }, []);\n      }, t.prototype.reduce = function (t, e) {\n        for (var n, r = this.iterator(); n = r();) {\n          e = t(e, n);\n        }\n\n        return e;\n      }, t;\n    }();\n\n    e.default = r;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(16),\n        i = n(1),\n        a = {\n      attributes: !0,\n      characterData: !0,\n      characterDataOldValue: !0,\n      childList: !0,\n      subtree: !0\n    },\n        l = function (t) {\n      function e(e) {\n        var n = t.call(this, e) || this;\n        return n.scroll = n, n.observer = new MutationObserver(function (t) {\n          n.update(t);\n        }), n.observer.observe(n.domNode, a), n.attach(), n;\n      }\n\n      return r(e, t), e.prototype.detach = function () {\n        t.prototype.detach.call(this), this.observer.disconnect();\n      }, e.prototype.deleteAt = function (e, n) {\n        this.update(), 0 === e && n === this.length() ? this.children.forEach(function (t) {\n          t.remove();\n        }) : t.prototype.deleteAt.call(this, e, n);\n      }, e.prototype.formatAt = function (e, n, r, o) {\n        this.update(), t.prototype.formatAt.call(this, e, n, r, o);\n      }, e.prototype.insertAt = function (e, n, r) {\n        this.update(), t.prototype.insertAt.call(this, e, n, r);\n      }, e.prototype.optimize = function (e, n) {\n        var r = this;\n        void 0 === e && (e = []), void 0 === n && (n = {}), t.prototype.optimize.call(this, n);\n\n        for (var a = [].slice.call(this.observer.takeRecords()); a.length > 0;) {\n          e.push(a.pop());\n        }\n\n        for (var l = function (t, e) {\n          void 0 === e && (e = !0), null != t && t !== r && null != t.domNode.parentNode && (null == t.domNode[i.DATA_KEY].mutations && (t.domNode[i.DATA_KEY].mutations = []), e && l(t.parent));\n        }, u = function (t) {\n          null != t.domNode[i.DATA_KEY] && null != t.domNode[i.DATA_KEY].mutations && (t instanceof o.default && t.children.forEach(u), t.optimize(n));\n        }, s = e, c = 0; s.length > 0; c += 1) {\n          if (c >= 100) throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n\n          for (s.forEach(function (t) {\n            var e = i.find(t.target, !0);\n            null != e && (e.domNode === t.target && (\"childList\" === t.type ? (l(i.find(t.previousSibling, !1)), [].forEach.call(t.addedNodes, function (t) {\n              var e = i.find(t, !1);\n              l(e, !1), e instanceof o.default && e.children.forEach(function (t) {\n                l(t, !1);\n              });\n            })) : \"attributes\" === t.type && l(e.prev)), l(e));\n          }), this.children.forEach(u), s = [].slice.call(this.observer.takeRecords()), a = s.slice(); a.length > 0;) {\n            e.push(a.pop());\n          }\n        }\n      }, e.prototype.update = function (e, n) {\n        var r = this;\n        void 0 === n && (n = {}), e = e || this.observer.takeRecords(), e.map(function (t) {\n          var e = i.find(t.target, !0);\n          return null == e ? null : null == e.domNode[i.DATA_KEY].mutations ? (e.domNode[i.DATA_KEY].mutations = [t], e) : (e.domNode[i.DATA_KEY].mutations.push(t), null);\n        }).forEach(function (t) {\n          null != t && t !== r && null != t.domNode[i.DATA_KEY] && t.update(t.domNode[i.DATA_KEY].mutations || [], n);\n        }), null != this.domNode[i.DATA_KEY].mutations && t.prototype.update.call(this, this.domNode[i.DATA_KEY].mutations, n), this.optimize(e, n);\n      }, e.blotName = \"scroll\", e.defaultChild = \"block\", e.scope = i.Scope.BLOCK_BLOT, e.tagName = \"DIV\", e;\n    }(o.default);\n\n    e.default = l;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (Object.keys(t).length !== Object.keys(e).length) return !1;\n\n      for (var n in t) {\n        if (t[n] !== e[n]) return !1;\n      }\n\n      return !0;\n    }\n\n    var o = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var i = n(17),\n        a = n(1),\n        l = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return o(e, t), e.formats = function (n) {\n        if (n.tagName !== e.tagName) return t.formats.call(this, n);\n      }, e.prototype.format = function (n, r) {\n        var o = this;\n        n !== this.statics.blotName || r ? t.prototype.format.call(this, n, r) : (this.children.forEach(function (t) {\n          t instanceof i.default || (t = t.wrap(e.blotName, !0)), o.attributes.copy(t);\n        }), this.unwrap());\n      }, e.prototype.formatAt = function (e, n, r, o) {\n        if (null != this.formats()[r] || a.query(r, a.Scope.ATTRIBUTE)) {\n          this.isolate(e, n).format(r, o);\n        } else t.prototype.formatAt.call(this, e, n, r, o);\n      }, e.prototype.optimize = function (n) {\n        t.prototype.optimize.call(this, n);\n        var o = this.formats();\n        if (0 === Object.keys(o).length) return this.unwrap();\n        var i = this.next;\n        i instanceof e && i.prev === this && r(o, i.formats()) && (i.moveChildren(this), i.remove());\n      }, e.blotName = \"inline\", e.scope = a.Scope.INLINE_BLOT, e.tagName = \"SPAN\", e;\n    }(i.default);\n\n    e.default = l;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(17),\n        i = n(1),\n        a = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return r(e, t), e.formats = function (n) {\n        var r = i.query(e.blotName).tagName;\n        if (n.tagName !== r) return t.formats.call(this, n);\n      }, e.prototype.format = function (n, r) {\n        null != i.query(n, i.Scope.BLOCK) && (n !== this.statics.blotName || r ? t.prototype.format.call(this, n, r) : this.replaceWith(e.blotName));\n      }, e.prototype.formatAt = function (e, n, r, o) {\n        null != i.query(r, i.Scope.BLOCK) ? this.format(r, o) : t.prototype.formatAt.call(this, e, n, r, o);\n      }, e.prototype.insertAt = function (e, n, r) {\n        if (null == r || null != i.query(n, i.Scope.INLINE)) t.prototype.insertAt.call(this, e, n, r);else {\n          var o = this.split(e),\n              a = i.create(n, r);\n          o.parent.insertBefore(a, o);\n        }\n      }, e.prototype.update = function (e, n) {\n        navigator.userAgent.match(/Trident/) ? this.build() : t.prototype.update.call(this, e, n);\n      }, e.blotName = \"block\", e.scope = i.Scope.BLOCK_BLOT, e.tagName = \"P\", e;\n    }(o.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(18),\n        i = function (t) {\n      function e() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      return r(e, t), e.formats = function (t) {}, e.prototype.format = function (e, n) {\n        t.prototype.formatAt.call(this, 0, this.length(), e, n);\n      }, e.prototype.formatAt = function (e, n, r, o) {\n        0 === e && n === this.length() ? this.format(r, o) : t.prototype.formatAt.call(this, e, n, r, o);\n      }, e.prototype.formats = function () {\n        return this.statics.formats(this.domNode);\n      }, e;\n    }(o.default);\n\n    e.default = i;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = this && this.__extends || function () {\n      var t = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      return function (e, n) {\n        function r() {\n          this.constructor = e;\n        }\n\n        t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }();\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(18),\n        i = n(1),\n        a = function (t) {\n      function e(e) {\n        var n = t.call(this, e) || this;\n        return n.text = n.statics.value(n.domNode), n;\n      }\n\n      return r(e, t), e.create = function (t) {\n        return document.createTextNode(t);\n      }, e.value = function (t) {\n        var e = t.data;\n        return e.normalize && (e = e.normalize()), e;\n      }, e.prototype.deleteAt = function (t, e) {\n        this.domNode.data = this.text = this.text.slice(0, t) + this.text.slice(t + e);\n      }, e.prototype.index = function (t, e) {\n        return this.domNode === t ? e : -1;\n      }, e.prototype.insertAt = function (e, n, r) {\n        null == r ? (this.text = this.text.slice(0, e) + n + this.text.slice(e), this.domNode.data = this.text) : t.prototype.insertAt.call(this, e, n, r);\n      }, e.prototype.length = function () {\n        return this.text.length;\n      }, e.prototype.optimize = function (n) {\n        t.prototype.optimize.call(this, n), this.text = this.statics.value(this.domNode), 0 === this.text.length ? this.remove() : this.next instanceof e && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());\n      }, e.prototype.position = function (t, e) {\n        return void 0 === e && (e = !1), [this.domNode, t];\n      }, e.prototype.split = function (t, e) {\n        if (void 0 === e && (e = !1), !e) {\n          if (0 === t) return this;\n          if (t === this.length()) return this.next;\n        }\n\n        var n = i.create(this.domNode.splitText(t));\n        return this.parent.insertBefore(n, this.next), this.text = this.statics.value(this.domNode), n;\n      }, e.prototype.update = function (t, e) {\n        var n = this;\n        t.some(function (t) {\n          return \"characterData\" === t.type && t.target === n.domNode;\n        }) && (this.text = this.statics.value(this.domNode));\n      }, e.prototype.value = function () {\n        return this.text;\n      }, e.blotName = \"text\", e.scope = i.Scope.INLINE_BLOT, e;\n    }(o.default);\n\n    e.default = a;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = document.createElement(\"div\");\n\n    if (r.classList.toggle(\"test-class\", !1), r.classList.contains(\"test-class\")) {\n      var o = DOMTokenList.prototype.toggle;\n\n      DOMTokenList.prototype.toggle = function (t, e) {\n        return arguments.length > 1 && !this.contains(t) == !e ? e : o.call(this, t);\n      };\n    }\n\n    String.prototype.startsWith || (String.prototype.startsWith = function (t, e) {\n      return e = e || 0, this.substr(e, t.length) === t;\n    }), String.prototype.endsWith || (String.prototype.endsWith = function (t, e) {\n      var n = this.toString();\n      (\"number\" != typeof e || !isFinite(e) || Math.floor(e) !== e || e > n.length) && (e = n.length), e -= t.length;\n      var r = n.indexOf(t, e);\n      return -1 !== r && r === e;\n    }), Array.prototype.find || Object.defineProperty(Array.prototype, \"find\", {\n      value: function (t) {\n        if (null === this) throw new TypeError(\"Array.prototype.find called on null or undefined\");\n        if (\"function\" != typeof t) throw new TypeError(\"predicate must be a function\");\n\n        for (var e, n = Object(this), r = n.length >>> 0, o = arguments[1], i = 0; i < r; i++) {\n          if (e = n[i], t.call(o, e, i, n)) return e;\n        }\n      }\n    }), document.addEventListener(\"DOMContentLoaded\", function () {\n      document.execCommand(\"enableObjectResizing\", !1, !1), document.execCommand(\"autoUrlDetect\", !1, !1);\n    });\n  }, function (t, e) {\n    function n(t, e, n) {\n      if (t == e) return t ? [[v, t]] : [];\n      (n < 0 || t.length < n) && (n = null);\n      var o = a(t, e),\n          i = t.substring(0, o);\n      t = t.substring(o), e = e.substring(o), o = l(t, e);\n      var u = t.substring(t.length - o);\n      t = t.substring(0, t.length - o), e = e.substring(0, e.length - o);\n      var c = r(t, e);\n      return i && c.unshift([v, i]), u && c.push([v, u]), s(c), null != n && (c = f(c, n)), c = d(c);\n    }\n\n    function r(t, e) {\n      var r;\n      if (!t) return [[y, e]];\n      if (!e) return [[h, t]];\n      var i = t.length > e.length ? t : e,\n          a = t.length > e.length ? e : t,\n          l = i.indexOf(a);\n      if (-1 != l) return r = [[y, i.substring(0, l)], [v, a], [y, i.substring(l + a.length)]], t.length > e.length && (r[0][0] = r[2][0] = h), r;\n      if (1 == a.length) return [[h, t], [y, e]];\n      var s = u(t, e);\n\n      if (s) {\n        var c = s[0],\n            f = s[1],\n            d = s[2],\n            p = s[3],\n            b = s[4],\n            m = n(c, d),\n            g = n(f, p);\n        return m.concat([[v, b]], g);\n      }\n\n      return o(t, e);\n    }\n\n    function o(t, e) {\n      for (var n = t.length, r = e.length, o = Math.ceil((n + r) / 2), a = o, l = 2 * o, u = new Array(l), s = new Array(l), c = 0; c < l; c++) {\n        u[c] = -1, s[c] = -1;\n      }\n\n      u[a + 1] = 0, s[a + 1] = 0;\n\n      for (var f = n - r, d = f % 2 != 0, p = 0, v = 0, b = 0, m = 0, g = 0; g < o; g++) {\n        for (var _ = -g + p; _ <= g - v; _ += 2) {\n          var O,\n              E = a + _;\n          O = _ == -g || _ != g && u[E - 1] < u[E + 1] ? u[E + 1] : u[E - 1] + 1;\n\n          for (var N = O - _; O < n && N < r && t.charAt(O) == e.charAt(N);) {\n            O++, N++;\n          }\n\n          if (u[E] = O, O > n) v += 2;else if (N > r) p += 2;else if (d) {\n            var w = a + f - _;\n\n            if (w >= 0 && w < l && -1 != s[w]) {\n              var k = n - s[w];\n              if (O >= k) return i(t, e, O, N);\n            }\n          }\n        }\n\n        for (var j = -g + b; j <= g - m; j += 2) {\n          var k,\n              w = a + j;\n          k = j == -g || j != g && s[w - 1] < s[w + 1] ? s[w + 1] : s[w - 1] + 1;\n\n          for (var x = k - j; k < n && x < r && t.charAt(n - k - 1) == e.charAt(r - x - 1);) {\n            k++, x++;\n          }\n\n          if (s[w] = k, k > n) m += 2;else if (x > r) b += 2;else if (!d) {\n            var E = a + f - j;\n\n            if (E >= 0 && E < l && -1 != u[E]) {\n              var O = u[E],\n                  N = a + O - E;\n              if (k = n - k, O >= k) return i(t, e, O, N);\n            }\n          }\n        }\n      }\n\n      return [[h, t], [y, e]];\n    }\n\n    function i(t, e, r, o) {\n      var i = t.substring(0, r),\n          a = e.substring(0, o),\n          l = t.substring(r),\n          u = e.substring(o),\n          s = n(i, a),\n          c = n(l, u);\n      return s.concat(c);\n    }\n\n    function a(t, e) {\n      if (!t || !e || t.charAt(0) != e.charAt(0)) return 0;\n\n      for (var n = 0, r = Math.min(t.length, e.length), o = r, i = 0; n < o;) {\n        t.substring(i, o) == e.substring(i, o) ? (n = o, i = n) : r = o, o = Math.floor((r - n) / 2 + n);\n      }\n\n      return o;\n    }\n\n    function l(t, e) {\n      if (!t || !e || t.charAt(t.length - 1) != e.charAt(e.length - 1)) return 0;\n\n      for (var n = 0, r = Math.min(t.length, e.length), o = r, i = 0; n < o;) {\n        t.substring(t.length - o, t.length - i) == e.substring(e.length - o, e.length - i) ? (n = o, i = n) : r = o, o = Math.floor((r - n) / 2 + n);\n      }\n\n      return o;\n    }\n\n    function u(t, e) {\n      function n(t, e, n) {\n        for (var r, o, i, u, s = t.substring(n, n + Math.floor(t.length / 4)), c = -1, f = \"\"; -1 != (c = e.indexOf(s, c + 1));) {\n          var d = a(t.substring(n), e.substring(c)),\n              p = l(t.substring(0, n), e.substring(0, c));\n          f.length < p + d && (f = e.substring(c - p, c) + e.substring(c, c + d), r = t.substring(0, n - p), o = t.substring(n + d), i = e.substring(0, c - p), u = e.substring(c + d));\n        }\n\n        return 2 * f.length >= t.length ? [r, o, i, u, f] : null;\n      }\n\n      var r = t.length > e.length ? t : e,\n          o = t.length > e.length ? e : t;\n      if (r.length < 4 || 2 * o.length < r.length) return null;\n      var i,\n          u = n(r, o, Math.ceil(r.length / 4)),\n          s = n(r, o, Math.ceil(r.length / 2));\n      if (!u && !s) return null;\n      i = s ? u && u[4].length > s[4].length ? u : s : u;\n      var c, f, d, p;\n      return t.length > e.length ? (c = i[0], f = i[1], d = i[2], p = i[3]) : (d = i[0], p = i[1], c = i[2], f = i[3]), [c, f, d, p, i[4]];\n    }\n\n    function s(t) {\n      t.push([v, \"\"]);\n\n      for (var e, n = 0, r = 0, o = 0, i = \"\", u = \"\"; n < t.length;) {\n        switch (t[n][0]) {\n          case y:\n            o++, u += t[n][1], n++;\n            break;\n\n          case h:\n            r++, i += t[n][1], n++;\n            break;\n\n          case v:\n            r + o > 1 ? (0 !== r && 0 !== o && (e = a(u, i), 0 !== e && (n - r - o > 0 && t[n - r - o - 1][0] == v ? t[n - r - o - 1][1] += u.substring(0, e) : (t.splice(0, 0, [v, u.substring(0, e)]), n++), u = u.substring(e), i = i.substring(e)), 0 !== (e = l(u, i)) && (t[n][1] = u.substring(u.length - e) + t[n][1], u = u.substring(0, u.length - e), i = i.substring(0, i.length - e))), 0 === r ? t.splice(n - o, r + o, [y, u]) : 0 === o ? t.splice(n - r, r + o, [h, i]) : t.splice(n - r - o, r + o, [h, i], [y, u]), n = n - r - o + (r ? 1 : 0) + (o ? 1 : 0) + 1) : 0 !== n && t[n - 1][0] == v ? (t[n - 1][1] += t[n][1], t.splice(n, 1)) : n++, o = 0, r = 0, i = \"\", u = \"\";\n        }\n      }\n\n      \"\" === t[t.length - 1][1] && t.pop();\n      var c = !1;\n\n      for (n = 1; n < t.length - 1;) {\n        t[n - 1][0] == v && t[n + 1][0] == v && (t[n][1].substring(t[n][1].length - t[n - 1][1].length) == t[n - 1][1] ? (t[n][1] = t[n - 1][1] + t[n][1].substring(0, t[n][1].length - t[n - 1][1].length), t[n + 1][1] = t[n - 1][1] + t[n + 1][1], t.splice(n - 1, 1), c = !0) : t[n][1].substring(0, t[n + 1][1].length) == t[n + 1][1] && (t[n - 1][1] += t[n + 1][1], t[n][1] = t[n][1].substring(t[n + 1][1].length) + t[n + 1][1], t.splice(n + 1, 1), c = !0)), n++;\n      }\n\n      c && s(t);\n    }\n\n    function c(t, e) {\n      if (0 === e) return [v, t];\n\n      for (var n = 0, r = 0; r < t.length; r++) {\n        var o = t[r];\n\n        if (o[0] === h || o[0] === v) {\n          var i = n + o[1].length;\n          if (e === i) return [r + 1, t];\n\n          if (e < i) {\n            t = t.slice();\n            var a = e - n,\n                l = [o[0], o[1].slice(0, a)],\n                u = [o[0], o[1].slice(a)];\n            return t.splice(r, 1, l, u), [r + 1, t];\n          }\n\n          n = i;\n        }\n      }\n\n      throw new Error(\"cursor_pos is out of bounds!\");\n    }\n\n    function f(t, e) {\n      var n = c(t, e),\n          r = n[1],\n          o = n[0],\n          i = r[o],\n          a = r[o + 1];\n      if (null == i) return t;\n      if (i[0] !== v) return t;\n      if (null != a && i[1] + a[1] === a[1] + i[1]) return r.splice(o, 2, a, i), p(r, o, 2);\n\n      if (null != a && 0 === a[1].indexOf(i[1])) {\n        r.splice(o, 2, [a[0], i[1]], [0, i[1]]);\n        var l = a[1].slice(i[1].length);\n        return l.length > 0 && r.splice(o + 2, 0, [a[0], l]), p(r, o, 3);\n      }\n\n      return t;\n    }\n\n    function d(t) {\n      for (var e = !1, n = function (t) {\n        return t.charCodeAt(0) >= 56320 && t.charCodeAt(0) <= 57343;\n      }, r = 2; r < t.length; r += 1) {\n        t[r - 2][0] === v && function (t) {\n          return t.charCodeAt(t.length - 1) >= 55296 && t.charCodeAt(t.length - 1) <= 56319;\n        }(t[r - 2][1]) && t[r - 1][0] === h && n(t[r - 1][1]) && t[r][0] === y && n(t[r][1]) && (e = !0, t[r - 1][1] = t[r - 2][1].slice(-1) + t[r - 1][1], t[r][1] = t[r - 2][1].slice(-1) + t[r][1], t[r - 2][1] = t[r - 2][1].slice(0, -1));\n      }\n\n      if (!e) return t;\n\n      for (var o = [], r = 0; r < t.length; r += 1) {\n        t[r][1].length > 0 && o.push(t[r]);\n      }\n\n      return o;\n    }\n\n    function p(t, e, n) {\n      for (var r = e + n - 1; r >= 0 && r >= e - 1; r--) {\n        if (r + 1 < t.length) {\n          var o = t[r],\n              i = t[r + 1];\n          o[0] === i[1] && t.splice(r, 2, [o[0], o[1] + i[1]]);\n        }\n      }\n\n      return t;\n    }\n\n    var h = -1,\n        y = 1,\n        v = 0,\n        b = n;\n    b.INSERT = y, b.DELETE = h, b.EQUAL = v, t.exports = b;\n  }, function (t, e) {\n    function n(t) {\n      var e = [];\n\n      for (var n in t) {\n        e.push(n);\n      }\n\n      return e;\n    }\n\n    e = t.exports = \"function\" == typeof Object.keys ? Object.keys : n, e.shim = n;\n  }, function (t, e) {\n    function n(t) {\n      return \"[object Arguments]\" == Object.prototype.toString.call(t);\n    }\n\n    function r(t) {\n      return t && \"object\" == typeof t && \"number\" == typeof t.length && Object.prototype.hasOwnProperty.call(t, \"callee\") && !Object.prototype.propertyIsEnumerable.call(t, \"callee\") || !1;\n    }\n\n    var o = \"[object Arguments]\" == function () {\n      return Object.prototype.toString.call(arguments);\n    }();\n\n    e = t.exports = o ? n : r, e.supported = n, e.unsupported = r;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      return Object.keys(e).reduce(function (n, r) {\n        return null == t[r] ? n : (e[r] === t[r] ? n[r] = e[r] : Array.isArray(e[r]) ? e[r].indexOf(t[r]) < 0 && (n[r] = e[r].concat([t[r]])) : n[r] = [e[r], t[r]], n);\n      }, {});\n    }\n\n    function l(t) {\n      return t.reduce(function (t, e) {\n        if (1 === e.insert) {\n          var n = (0, j.default)(e.attributes);\n          return delete n.image, t.insert({\n            image: e.attributes.image\n          }, n);\n        }\n\n        if (null == e.attributes || !0 !== e.attributes.list && !0 !== e.attributes.bullet || (e = (0, j.default)(e), e.attributes.list ? e.attributes.list = \"ordered\" : (e.attributes.list = \"bullet\", delete e.attributes.bullet)), \"string\" == typeof e.insert) {\n          var r = e.insert.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n          return t.insert(r, e.attributes);\n        }\n\n        return t.push(e);\n      }, new d.default());\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var u = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    },\n        s = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        c = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        f = n(5),\n        d = r(f),\n        p = n(19),\n        h = r(p),\n        y = n(0),\n        v = r(y),\n        b = n(12),\n        m = r(b),\n        g = n(27),\n        _ = r(g),\n        O = n(2),\n        E = r(O),\n        N = n(14),\n        w = r(N),\n        k = n(20),\n        j = r(k),\n        x = n(11),\n        A = r(x),\n        T = n(3),\n        S = r(T),\n        P = /^[ -~]*$/,\n        C = function () {\n      function t(e) {\n        i(this, t), this.scroll = e, this.delta = this.getDelta();\n      }\n\n      return c(t, [{\n        key: \"applyDelta\",\n        value: function (t) {\n          var e = this,\n              n = !1;\n          this.scroll.update();\n          var r = this.scroll.length();\n          return this.scroll.batchStart(), t = l(t), t.reduce(function (t, o) {\n            var i = o.retain || o.delete || o.insert.length || 1,\n                a = o.attributes || {};\n\n            if (null != o.insert) {\n              if (\"string\" == typeof o.insert) {\n                var l = o.insert;\n                l.endsWith(\"\\n\") && n && (n = !1, l = l.slice(0, -1)), t >= r && !l.endsWith(\"\\n\") && (n = !0), e.scroll.insertAt(t, l);\n                var c = e.scroll.line(t),\n                    f = s(c, 2),\n                    d = f[0],\n                    p = f[1],\n                    y = (0, S.default)({}, (0, O.bubbleFormats)(d));\n\n                if (d instanceof E.default) {\n                  var b = d.descendant(v.default.Leaf, p),\n                      m = s(b, 1),\n                      g = m[0];\n                  y = (0, S.default)(y, (0, O.bubbleFormats)(g));\n                }\n\n                a = h.default.attributes.diff(y, a) || {};\n              } else if (\"object\" === u(o.insert)) {\n                var _ = Object.keys(o.insert)[0];\n                if (null == _) return t;\n                e.scroll.insertAt(t, _, o.insert[_]);\n              }\n\n              r += i;\n            }\n\n            return Object.keys(a).forEach(function (n) {\n              e.scroll.formatAt(t, i, n, a[n]);\n            }), t + i;\n          }, 0), t.reduce(function (t, n) {\n            return \"number\" == typeof n.delete ? (e.scroll.deleteAt(t, n.delete), t) : t + (n.retain || n.insert.length || 1);\n          }, 0), this.scroll.batchEnd(), this.update(t);\n        }\n      }, {\n        key: \"deleteText\",\n        value: function (t, e) {\n          return this.scroll.deleteAt(t, e), this.update(new d.default().retain(t).delete(e));\n        }\n      }, {\n        key: \"formatLine\",\n        value: function (t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n          return this.scroll.update(), Object.keys(r).forEach(function (o) {\n            if (null == n.scroll.whitelist || n.scroll.whitelist[o]) {\n              var i = n.scroll.lines(t, Math.max(e, 1)),\n                  a = e;\n              i.forEach(function (e) {\n                var i = e.length();\n\n                if (e instanceof m.default) {\n                  var l = t - e.offset(n.scroll),\n                      u = e.newlineIndex(l + a) - l + 1;\n                  e.formatAt(l, u, o, r[o]);\n                } else e.format(o, r[o]);\n\n                a -= i;\n              });\n            }\n          }), this.scroll.optimize(), this.update(new d.default().retain(t).retain(e, (0, j.default)(r)));\n        }\n      }, {\n        key: \"formatText\",\n        value: function (t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n          return Object.keys(r).forEach(function (o) {\n            n.scroll.formatAt(t, e, o, r[o]);\n          }), this.update(new d.default().retain(t).retain(e, (0, j.default)(r)));\n        }\n      }, {\n        key: \"getContents\",\n        value: function (t, e) {\n          return this.delta.slice(t, t + e);\n        }\n      }, {\n        key: \"getDelta\",\n        value: function () {\n          return this.scroll.lines().reduce(function (t, e) {\n            return t.concat(e.delta());\n          }, new d.default());\n        }\n      }, {\n        key: \"getFormat\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n              n = [],\n              r = [];\n          0 === e ? this.scroll.path(t).forEach(function (t) {\n            var e = s(t, 1),\n                o = e[0];\n            o instanceof E.default ? n.push(o) : o instanceof v.default.Leaf && r.push(o);\n          }) : (n = this.scroll.lines(t, e), r = this.scroll.descendants(v.default.Leaf, t, e));\n          var o = [n, r].map(function (t) {\n            if (0 === t.length) return {};\n\n            for (var e = (0, O.bubbleFormats)(t.shift()); Object.keys(e).length > 0;) {\n              var n = t.shift();\n              if (null == n) return e;\n              e = a((0, O.bubbleFormats)(n), e);\n            }\n\n            return e;\n          });\n          return S.default.apply(S.default, o);\n        }\n      }, {\n        key: \"getText\",\n        value: function (t, e) {\n          return this.getContents(t, e).filter(function (t) {\n            return \"string\" == typeof t.insert;\n          }).map(function (t) {\n            return t.insert;\n          }).join(\"\");\n        }\n      }, {\n        key: \"insertEmbed\",\n        value: function (t, e, n) {\n          return this.scroll.insertAt(t, e, n), this.update(new d.default().retain(t).insert(o({}, e, n)));\n        }\n      }, {\n        key: \"insertText\",\n        value: function (t, e) {\n          var n = this,\n              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n          return e = e.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\"), this.scroll.insertAt(t, e), Object.keys(r).forEach(function (o) {\n            n.scroll.formatAt(t, e.length, o, r[o]);\n          }), this.update(new d.default().retain(t).insert(e, (0, j.default)(r)));\n        }\n      }, {\n        key: \"isBlank\",\n        value: function () {\n          if (0 == this.scroll.children.length) return !0;\n          if (this.scroll.children.length > 1) return !1;\n          var t = this.scroll.children.head;\n          return t.statics.blotName === E.default.blotName && !(t.children.length > 1) && t.children.head instanceof w.default;\n        }\n      }, {\n        key: \"removeFormat\",\n        value: function (t, e) {\n          var n = this.getText(t, e),\n              r = this.scroll.line(t + e),\n              o = s(r, 2),\n              i = o[0],\n              a = o[1],\n              l = 0,\n              u = new d.default();\n          null != i && (l = i instanceof m.default ? i.newlineIndex(a) - a + 1 : i.length() - a, u = i.delta().slice(a, a + l - 1).insert(\"\\n\"));\n          var c = this.getContents(t, e + l),\n              f = c.diff(new d.default().insert(n).concat(u)),\n              p = new d.default().retain(t).concat(f);\n          return this.applyDelta(p);\n        }\n      }, {\n        key: \"update\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,\n              r = this.delta;\n\n          if (1 === e.length && \"characterData\" === e[0].type && e[0].target.data.match(P) && v.default.find(e[0].target)) {\n            var o = v.default.find(e[0].target),\n                i = (0, O.bubbleFormats)(o),\n                a = o.offset(this.scroll),\n                l = e[0].oldValue.replace(_.default.CONTENTS, \"\"),\n                u = new d.default().insert(l),\n                s = new d.default().insert(o.value());\n            t = new d.default().retain(a).concat(u.diff(s, n)).reduce(function (t, e) {\n              return e.insert ? t.insert(e.insert, i) : t.push(e);\n            }, new d.default()), this.delta = r.compose(t);\n          } else this.delta = this.getDelta(), t && (0, A.default)(r.compose(t), this.delta) || (t = r.diff(this.delta, n));\n\n          return t;\n        }\n      }]), t;\n    }();\n\n    e.default = C;\n  }, function (t, e) {\n    \"use strict\";\n\n    function n() {}\n\n    function r(t, e, n) {\n      this.fn = t, this.context = e, this.once = n || !1;\n    }\n\n    function o() {\n      this._events = new n(), this._eventsCount = 0;\n    }\n\n    var i = Object.prototype.hasOwnProperty,\n        a = \"~\";\n    Object.create && (n.prototype = Object.create(null), new n().__proto__ || (a = !1)), o.prototype.eventNames = function () {\n      var t,\n          e,\n          n = [];\n      if (0 === this._eventsCount) return n;\n\n      for (e in t = this._events) {\n        i.call(t, e) && n.push(a ? e.slice(1) : e);\n      }\n\n      return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n;\n    }, o.prototype.listeners = function (t, e) {\n      var n = a ? a + t : t,\n          r = this._events[n];\n      if (e) return !!r;\n      if (!r) return [];\n      if (r.fn) return [r.fn];\n\n      for (var o = 0, i = r.length, l = new Array(i); o < i; o++) {\n        l[o] = r[o].fn;\n      }\n\n      return l;\n    }, o.prototype.emit = function (t, e, n, r, o, i) {\n      var l = a ? a + t : t;\n      if (!this._events[l]) return !1;\n      var u,\n          s,\n          c = this._events[l],\n          f = arguments.length;\n\n      if (c.fn) {\n        switch (c.once && this.removeListener(t, c.fn, void 0, !0), f) {\n          case 1:\n            return c.fn.call(c.context), !0;\n\n          case 2:\n            return c.fn.call(c.context, e), !0;\n\n          case 3:\n            return c.fn.call(c.context, e, n), !0;\n\n          case 4:\n            return c.fn.call(c.context, e, n, r), !0;\n\n          case 5:\n            return c.fn.call(c.context, e, n, r, o), !0;\n\n          case 6:\n            return c.fn.call(c.context, e, n, r, o, i), !0;\n        }\n\n        for (s = 1, u = new Array(f - 1); s < f; s++) {\n          u[s - 1] = arguments[s];\n        }\n\n        c.fn.apply(c.context, u);\n      } else {\n        var d,\n            p = c.length;\n\n        for (s = 0; s < p; s++) {\n          switch (c[s].once && this.removeListener(t, c[s].fn, void 0, !0), f) {\n            case 1:\n              c[s].fn.call(c[s].context);\n              break;\n\n            case 2:\n              c[s].fn.call(c[s].context, e);\n              break;\n\n            case 3:\n              c[s].fn.call(c[s].context, e, n);\n              break;\n\n            case 4:\n              c[s].fn.call(c[s].context, e, n, r);\n              break;\n\n            default:\n              if (!u) for (d = 1, u = new Array(f - 1); d < f; d++) {\n                u[d - 1] = arguments[d];\n              }\n              c[s].fn.apply(c[s].context, u);\n          }\n        }\n      }\n\n      return !0;\n    }, o.prototype.on = function (t, e, n) {\n      var o = new r(e, n || this),\n          i = a ? a + t : t;\n      return this._events[i] ? this._events[i].fn ? this._events[i] = [this._events[i], o] : this._events[i].push(o) : (this._events[i] = o, this._eventsCount++), this;\n    }, o.prototype.once = function (t, e, n) {\n      var o = new r(e, n || this, !0),\n          i = a ? a + t : t;\n      return this._events[i] ? this._events[i].fn ? this._events[i] = [this._events[i], o] : this._events[i].push(o) : (this._events[i] = o, this._eventsCount++), this;\n    }, o.prototype.removeListener = function (t, e, r, o) {\n      var i = a ? a + t : t;\n      if (!this._events[i]) return this;\n      if (!e) return 0 == --this._eventsCount ? this._events = new n() : delete this._events[i], this;\n      var l = this._events[i];\n      if (l.fn) l.fn !== e || o && !l.once || r && l.context !== r || (0 == --this._eventsCount ? this._events = new n() : delete this._events[i]);else {\n        for (var u = 0, s = [], c = l.length; u < c; u++) {\n          (l[u].fn !== e || o && !l[u].once || r && l[u].context !== r) && s.push(l[u]);\n        }\n\n        s.length ? this._events[i] = 1 === s.length ? s[0] : s : 0 == --this._eventsCount ? this._events = new n() : delete this._events[i];\n      }\n      return this;\n    }, o.prototype.removeAllListeners = function (t) {\n      var e;\n      return t ? (e = a ? a + t : t, this._events[e] && (0 == --this._eventsCount ? this._events = new n() : delete this._events[e])) : (this._events = new n(), this._eventsCount = 0), this;\n    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prototype.setMaxListeners = function () {\n      return this;\n    }, o.prefixed = a, o.EventEmitter = o, void 0 !== t && (t.exports = o);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function l(t) {\n      return t instanceof v.default || t instanceof y.BlockEmbed;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var u = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        s = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        c = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        f = n(0),\n        d = r(f),\n        p = n(13),\n        h = r(p),\n        y = n(2),\n        v = r(y),\n        b = n(14),\n        m = r(b),\n        g = n(12),\n        _ = r(g),\n        O = n(21),\n        E = r(O),\n        N = function (t) {\n      function e(t, n) {\n        o(this, e);\n        var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));\n        return r.emitter = n.emitter, Array.isArray(n.whitelist) && (r.whitelist = n.whitelist.reduce(function (t, e) {\n          return t[e] = !0, t;\n        }, {})), r.optimize(), r.enable(), r;\n      }\n\n      return a(e, t), s(e, [{\n        key: \"batchStart\",\n        value: function () {\n          this.batch = !0;\n        }\n      }, {\n        key: \"batchEnd\",\n        value: function () {\n          this.batch = !1, this.optimize();\n        }\n      }, {\n        key: \"deleteAt\",\n        value: function (t, n) {\n          var r = this.line(t),\n              o = u(r, 2),\n              i = o[0],\n              a = o[1],\n              l = this.line(t + n),\n              s = u(l, 1),\n              f = s[0];\n\n          if (c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"deleteAt\", this).call(this, t, n), null != f && i !== f && a > 0) {\n            if (i instanceof y.BlockEmbed || f instanceof y.BlockEmbed) return void this.optimize();\n\n            if (i instanceof _.default) {\n              var d = i.newlineIndex(i.length(), !0);\n              if (d > -1 && (i = i.split(d + 1)) === f) return void this.optimize();\n            } else if (f instanceof _.default) {\n              var p = f.newlineIndex(0);\n              p > -1 && f.split(p + 1);\n            }\n\n            var h = f.children.head instanceof m.default ? null : f.children.head;\n            i.moveChildren(f, h), i.remove();\n          }\n\n          this.optimize();\n        }\n      }, {\n        key: \"enable\",\n        value: function () {\n          var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n          this.domNode.setAttribute(\"contenteditable\", t);\n        }\n      }, {\n        key: \"formatAt\",\n        value: function (t, n, r, o) {\n          (null == this.whitelist || this.whitelist[r]) && (c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"formatAt\", this).call(this, t, n, r, o), this.optimize());\n        }\n      }, {\n        key: \"insertAt\",\n        value: function (t, n, r) {\n          if (null == r || null == this.whitelist || this.whitelist[n]) {\n            if (t >= this.length()) {\n              if (null == r || null == d.default.query(n, d.default.Scope.BLOCK)) {\n                var o = d.default.create(this.statics.defaultChild);\n                this.appendChild(o), null == r && n.endsWith(\"\\n\") && (n = n.slice(0, -1)), o.insertAt(0, n, r);\n              } else {\n                var i = d.default.create(n, r);\n                this.appendChild(i);\n              }\n            } else c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertAt\", this).call(this, t, n, r);\n            this.optimize();\n          }\n        }\n      }, {\n        key: \"insertBefore\",\n        value: function (t, n) {\n          if (t.statics.scope === d.default.Scope.INLINE_BLOT) {\n            var r = d.default.create(this.statics.defaultChild);\n            r.appendChild(t), t = r;\n          }\n\n          c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertBefore\", this).call(this, t, n);\n        }\n      }, {\n        key: \"leaf\",\n        value: function (t) {\n          return this.path(t).pop() || [null, -1];\n        }\n      }, {\n        key: \"line\",\n        value: function (t) {\n          return t === this.length() ? this.line(t - 1) : this.descendant(l, t);\n        }\n      }, {\n        key: \"lines\",\n        value: function () {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;\n          return function t(e, n, r) {\n            var o = [],\n                i = r;\n            return e.children.forEachAt(n, r, function (e, n, r) {\n              l(e) ? o.push(e) : e instanceof d.default.Container && (o = o.concat(t(e, n, i))), i -= r;\n            }), o;\n          }(this, t, e);\n        }\n      }, {\n        key: \"optimize\",\n        value: function () {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n          !0 !== this.batch && (c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t, n), t.length > 0 && this.emitter.emit(h.default.events.SCROLL_OPTIMIZE, t, n));\n        }\n      }, {\n        key: \"path\",\n        value: function (t) {\n          return c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"path\", this).call(this, t).slice(1);\n        }\n      }, {\n        key: \"update\",\n        value: function (t) {\n          if (!0 !== this.batch) {\n            var n = h.default.sources.USER;\n            \"string\" == typeof t && (n = t), Array.isArray(t) || (t = this.observer.takeRecords()), t.length > 0 && this.emitter.emit(h.default.events.SCROLL_BEFORE_UPDATE, n, t), c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"update\", this).call(this, t.concat([])), t.length > 0 && this.emitter.emit(h.default.events.SCROLL_UPDATE, n, t);\n          }\n        }\n      }]), e;\n    }(d.default.Scroll);\n\n    N.blotName = \"scroll\", N.className = \"ql-editor\", N.tagName = \"DIV\", N.defaultChild = \"block\", N.allowedChildren = [v.default, y.BlockEmbed, E.default], e.default = N;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function l(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function u(t, e, n) {\n      return \"object\" === (void 0 === e ? \"undefined\" : E(e)) ? Object.keys(e).reduce(function (t, n) {\n        return u(t, n, e[n]);\n      }, t) : t.reduce(function (t, r) {\n        return r.attributes && r.attributes[e] ? t.push(r) : t.insert(r.insert, (0, j.default)({}, o({}, e, n), r.attributes));\n      }, new A.default());\n    }\n\n    function s(t) {\n      if (t.nodeType !== Node.ELEMENT_NODE) return {};\n      return t[\"__ql-computed-style\"] || (t[\"__ql-computed-style\"] = window.getComputedStyle(t));\n    }\n\n    function c(t, e) {\n      for (var n = \"\", r = t.ops.length - 1; r >= 0 && n.length < e.length; --r) {\n        var o = t.ops[r];\n        if (\"string\" != typeof o.insert) break;\n        n = o.insert + n;\n      }\n\n      return n.slice(-1 * e.length) === e;\n    }\n\n    function f(t) {\n      return 0 !== t.childNodes.length && [\"block\", \"list-item\"].indexOf(s(t).display) > -1;\n    }\n\n    function d(t, e, n) {\n      return t.nodeType === t.TEXT_NODE ? n.reduce(function (e, n) {\n        return n(t, e);\n      }, new A.default()) : t.nodeType === t.ELEMENT_NODE ? [].reduce.call(t.childNodes || [], function (r, o) {\n        var i = d(o, e, n);\n        return o.nodeType === t.ELEMENT_NODE && (i = e.reduce(function (t, e) {\n          return e(o, t);\n        }, i), i = (o[G] || []).reduce(function (t, e) {\n          return e(o, t);\n        }, i)), r.concat(i);\n      }, new A.default()) : new A.default();\n    }\n\n    function p(t, e, n) {\n      return u(n, t, !0);\n    }\n\n    function h(t, e) {\n      var n = S.default.Attributor.Attribute.keys(t),\n          r = S.default.Attributor.Class.keys(t),\n          o = S.default.Attributor.Style.keys(t),\n          i = {};\n      return n.concat(r).concat(o).forEach(function (e) {\n        var n = S.default.query(e, S.default.Scope.ATTRIBUTE);\n        null != n && (i[n.attrName] = n.value(t), i[n.attrName]) || (n = V[e], null == n || n.attrName !== e && n.keyName !== e || (i[n.attrName] = n.value(t) || void 0), null == (n = X[e]) || n.attrName !== e && n.keyName !== e || (n = X[e], i[n.attrName] = n.value(t) || void 0));\n      }), Object.keys(i).length > 0 && (e = u(e, i)), e;\n    }\n\n    function y(t, e) {\n      var n = S.default.query(t);\n      if (null == n) return e;\n\n      if (n.prototype instanceof S.default.Embed) {\n        var r = {},\n            o = n.value(t);\n        null != o && (r[n.blotName] = o, e = new A.default().insert(r, n.formats(t)));\n      } else \"function\" == typeof n.formats && (e = u(e, n.blotName, n.formats(t)));\n\n      return e;\n    }\n\n    function v(t, e) {\n      return c(e, \"\\n\") || e.insert(\"\\n\"), e;\n    }\n\n    function b() {\n      return new A.default();\n    }\n\n    function m(t, e) {\n      var n = S.default.query(t);\n      if (null == n || \"list-item\" !== n.blotName || !c(e, \"\\n\")) return e;\n\n      for (var r = -1, o = t.parentNode; !o.classList.contains(\"ql-clipboard\");) {\n        \"list\" === (S.default.query(o) || {}).blotName && (r += 1), o = o.parentNode;\n      }\n\n      return r <= 0 ? e : e.compose(new A.default().retain(e.length() - 1).retain(1, {\n        indent: r\n      }));\n    }\n\n    function g(t, e) {\n      return c(e, \"\\n\") || (f(t) || e.length() > 0 && t.nextSibling && f(t.nextSibling)) && e.insert(\"\\n\"), e;\n    }\n\n    function _(t, e) {\n      var n = {},\n          r = t.style || {};\n      return r.fontStyle && \"italic\" === s(t).fontStyle && (n.italic = !0), r.fontWeight && (s(t).fontWeight.startsWith(\"bold\") || parseInt(s(t).fontWeight) >= 700) && (n.bold = !0), Object.keys(n).length > 0 && (e = u(e, n)), parseFloat(r.textIndent || 0) > 0 && (e = new A.default().insert(\"\\t\").concat(e)), e;\n    }\n\n    function O(t, e) {\n      var n = t.data;\n      if (\"O:P\" === t.parentNode.tagName) return e.insert(n.trim());\n      if (0 === n.trim().length && t.parentNode.classList.contains(\"ql-clipboard\")) return e;\n\n      if (!s(t.parentNode).whiteSpace.startsWith(\"pre\")) {\n        var r = function (t, e) {\n          return e = e.replace(/[^\\u00a0]/g, \"\"), e.length < 1 && t ? \" \" : e;\n        };\n\n        n = n.replace(/\\r\\n/g, \" \").replace(/\\n/g, \" \"), n = n.replace(/\\s\\s+/g, r.bind(r, !0)), (null == t.previousSibling && f(t.parentNode) || null != t.previousSibling && f(t.previousSibling)) && (n = n.replace(/^\\s+/, r.bind(r, !1))), (null == t.nextSibling && f(t.parentNode) || null != t.nextSibling && f(t.nextSibling)) && (n = n.replace(/\\s+$/, r.bind(r, !1)));\n      }\n\n      return e.insert(n);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.matchText = e.matchNewline = e.matchBlot = e.matchAttributor = e.default = void 0;\n\n    var E = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    },\n        N = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        w = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        k = n(3),\n        j = r(k),\n        x = n(5),\n        A = r(x),\n        T = n(0),\n        S = r(T),\n        P = n(6),\n        C = r(P),\n        L = n(8),\n        R = r(L),\n        q = n(9),\n        I = r(q),\n        M = n(30),\n        B = n(31),\n        D = n(12),\n        U = r(D),\n        F = n(22),\n        K = n(32),\n        z = n(33),\n        H = n(34),\n        W = (0, R.default)(\"quill:clipboard\"),\n        G = \"__ql-matcher\",\n        Y = [[Node.TEXT_NODE, O], [Node.TEXT_NODE, g], [\"br\", v], [Node.ELEMENT_NODE, g], [Node.ELEMENT_NODE, y], [Node.ELEMENT_NODE, h], [Node.ELEMENT_NODE, _], [\"li\", m], [\"b\", p.bind(p, \"bold\")], [\"i\", p.bind(p, \"italic\")], [\"style\", b]],\n        V = [M.AlignAttribute, K.DirectionAttribute].reduce(function (t, e) {\n      return t[e.keyName] = e, t;\n    }, {}),\n        X = [M.AlignStyle, B.BackgroundStyle, F.ColorStyle, K.DirectionStyle, z.FontStyle, H.SizeStyle].reduce(function (t, e) {\n      return t[e.keyName] = e, t;\n    }, {}),\n        $ = function (t) {\n      function e(t, n) {\n        i(this, e);\n        var r = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));\n        return r.quill.root.addEventListener(\"paste\", r.onPaste.bind(r)), r.container = r.quill.addContainer(\"ql-clipboard\"), r.container.setAttribute(\"contenteditable\", !0), r.container.setAttribute(\"tabindex\", -1), r.matchers = [], Y.concat(r.options.matchers).forEach(function (t) {\n          var e = N(t, 2),\n              n = e[0],\n              o = e[1];\n          r.addMatcher(n, o);\n        }), r;\n      }\n\n      return l(e, t), w(e, [{\n        key: \"addMatcher\",\n        value: function (t, e) {\n          this.matchers.push([t, e]);\n        }\n      }, {\n        key: \"convert\",\n        value: function (t) {\n          if (\"string\" == typeof t) return this.container.innerHTML = t.replace(/\\>\\r?\\n +\\</g, \"><\"), this.convert();\n          var e = this.quill.getFormat(this.quill.selection.savedRange.index);\n\n          if (e[U.default.blotName]) {\n            var n = this.container.innerText;\n            return this.container.innerHTML = \"\", new A.default().insert(n, o({}, U.default.blotName, e[U.default.blotName]));\n          }\n\n          var r = this.prepareMatching(),\n              i = N(r, 2),\n              a = i[0],\n              l = i[1],\n              u = d(this.container, a, l);\n          return c(u, \"\\n\") && null == u.ops[u.ops.length - 1].attributes && (u = u.compose(new A.default().retain(u.length() - 1).delete(1))), W.log(\"convert\", this.container.innerHTML, u), this.container.innerHTML = \"\", u;\n        }\n      }, {\n        key: \"dangerouslyPasteHTML\",\n        value: function (t, e) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : C.default.sources.API;\n          if (\"string\" == typeof t) this.quill.setContents(this.convert(t), e), this.quill.setSelection(0, C.default.sources.SILENT);else {\n            var r = this.convert(e);\n            this.quill.updateContents(new A.default().retain(t).concat(r), n), this.quill.setSelection(t + r.length(), C.default.sources.SILENT);\n          }\n        }\n      }, {\n        key: \"onPaste\",\n        value: function (t) {\n          var e = this;\n\n          if (!t.defaultPrevented && this.quill.isEnabled()) {\n            var n = this.quill.getSelection(),\n                r = new A.default().retain(n.index),\n                o = this.quill.scrollingContainer.scrollTop;\n            this.container.focus(), this.quill.selection.update(C.default.sources.SILENT), setTimeout(function () {\n              r = r.concat(e.convert()).delete(n.length), e.quill.updateContents(r, C.default.sources.USER), e.quill.setSelection(r.length() - n.length, C.default.sources.SILENT), e.quill.scrollingContainer.scrollTop = o, e.quill.focus();\n            }, 1);\n          }\n        }\n      }, {\n        key: \"prepareMatching\",\n        value: function () {\n          var t = this,\n              e = [],\n              n = [];\n          return this.matchers.forEach(function (r) {\n            var o = N(r, 2),\n                i = o[0],\n                a = o[1];\n\n            switch (i) {\n              case Node.TEXT_NODE:\n                n.push(a);\n                break;\n\n              case Node.ELEMENT_NODE:\n                e.push(a);\n                break;\n\n              default:\n                [].forEach.call(t.container.querySelectorAll(i), function (t) {\n                  t[G] = t[G] || [], t[G].push(a);\n                });\n            }\n          }), [e, n];\n        }\n      }]), e;\n    }(I.default);\n\n    $.DEFAULTS = {\n      matchers: [],\n      matchVisual: !1\n    }, e.default = $, e.matchAttributor = h, e.matchBlot = y, e.matchNewline = g, e.matchText = O;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function i(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function a(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function l(t) {\n      var e = t.ops[t.ops.length - 1];\n      return null != e && (null != e.insert ? \"string\" == typeof e.insert && e.insert.endsWith(\"\\n\") : null != e.attributes && Object.keys(e.attributes).some(function (t) {\n        return null != f.default.query(t, f.default.Scope.BLOCK);\n      }));\n    }\n\n    function u(t) {\n      var e = t.reduce(function (t, e) {\n        return t += e.delete || 0;\n      }, 0),\n          n = t.length() - e;\n      return l(t) && (n -= 1), n;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.getLastChangeIndex = e.default = void 0;\n\n    var s = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        c = n(0),\n        f = r(c),\n        d = n(6),\n        p = r(d),\n        h = n(9),\n        y = r(h),\n        v = function (t) {\n      function e(t, n) {\n        o(this, e);\n        var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));\n        return r.lastRecorded = 0, r.ignoreChange = !1, r.clear(), r.quill.on(p.default.events.EDITOR_CHANGE, function (t, e, n, o) {\n          t !== p.default.events.TEXT_CHANGE || r.ignoreChange || (r.options.userOnly && o !== p.default.sources.USER ? r.transform(e) : r.record(e, n));\n        }), r.quill.keyboard.addBinding({\n          key: \"Z\",\n          shortKey: !0\n        }, r.undo.bind(r)), r.quill.keyboard.addBinding({\n          key: \"Z\",\n          shortKey: !0,\n          shiftKey: !0\n        }, r.redo.bind(r)), /Win/i.test(navigator.platform) && r.quill.keyboard.addBinding({\n          key: \"Y\",\n          shortKey: !0\n        }, r.redo.bind(r)), r;\n      }\n\n      return a(e, t), s(e, [{\n        key: \"change\",\n        value: function (t, e) {\n          if (0 !== this.stack[t].length) {\n            var n = this.stack[t].pop();\n            this.stack[e].push(n), this.lastRecorded = 0, this.ignoreChange = !0, this.quill.updateContents(n[t], p.default.sources.USER), this.ignoreChange = !1;\n            var r = u(n[t]);\n            this.quill.setSelection(r);\n          }\n        }\n      }, {\n        key: \"clear\",\n        value: function () {\n          this.stack = {\n            undo: [],\n            redo: []\n          };\n        }\n      }, {\n        key: \"cutoff\",\n        value: function () {\n          this.lastRecorded = 0;\n        }\n      }, {\n        key: \"record\",\n        value: function (t, e) {\n          if (0 !== t.ops.length) {\n            this.stack.redo = [];\n            var n = this.quill.getContents().diff(e),\n                r = Date.now();\n\n            if (this.lastRecorded + this.options.delay > r && this.stack.undo.length > 0) {\n              var o = this.stack.undo.pop();\n              n = n.compose(o.undo), t = o.redo.compose(t);\n            } else this.lastRecorded = r;\n\n            this.stack.undo.push({\n              redo: t,\n              undo: n\n            }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift();\n          }\n        }\n      }, {\n        key: \"redo\",\n        value: function () {\n          this.change(\"redo\", \"undo\");\n        }\n      }, {\n        key: \"transform\",\n        value: function (t) {\n          this.stack.undo.forEach(function (e) {\n            e.undo = t.transform(e.undo, !0), e.redo = t.transform(e.redo, !0);\n          }), this.stack.redo.forEach(function (e) {\n            e.undo = t.transform(e.undo, !0), e.redo = t.transform(e.redo, !0);\n          });\n        }\n      }, {\n        key: \"undo\",\n        value: function () {\n          this.change(\"undo\", \"redo\");\n        }\n      }]), e;\n    }(y.default);\n\n    v.DEFAULTS = {\n      delay: 1e3,\n      maxStack: 100,\n      userOnly: !1\n    }, e.default = v, e.getLastChangeIndex = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.IndentClass = void 0;\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"add\",\n        value: function (t, n) {\n          if (\"+1\" === n || \"-1\" === n) {\n            var r = this.value(t) || 0;\n            n = \"+1\" === n ? r + 1 : r - 1;\n          }\n\n          return 0 === n ? (this.remove(t), !0) : l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"add\", this).call(this, t, n);\n        }\n      }, {\n        key: \"canAdd\",\n        value: function (t, n) {\n          return l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"canAdd\", this).call(this, t, n) || l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"canAdd\", this).call(this, t, parseInt(n));\n        }\n      }, {\n        key: \"value\",\n        value: function (t) {\n          return parseInt(l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"value\", this).call(this, t)) || void 0;\n        }\n      }]), e;\n    }(s.default.Attributor.Class),\n        f = new c(\"indent\", \"ql-indent\", {\n      scope: s.default.Scope.BLOCK,\n      whitelist: [1, 2, 3, 4, 5, 6, 7, 8]\n    });\n\n    e.IndentClass = f;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(2),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default);\n\n    u.blotName = \"blockquote\", u.tagName = \"blockquote\", e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = n(2),\n        u = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(l),\n        s = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, null, [{\n        key: \"formats\",\n        value: function (t) {\n          return this.tagName.indexOf(t.tagName) + 1;\n        }\n      }]), e;\n    }(u.default);\n\n    s.blotName = \"header\", s.tagName = [\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\"], e.default = s;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function l(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = e.ListItem = void 0;\n\n    var u = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        s = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        c = n(0),\n        f = r(c),\n        d = n(2),\n        p = r(d),\n        h = n(21),\n        y = r(h),\n        v = function (t) {\n      function e() {\n        return i(this, e), a(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return l(e, t), u(e, [{\n        key: \"format\",\n        value: function (t, n) {\n          t !== b.blotName || n ? s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n) : this.replaceWith(f.default.create(this.statics.scope));\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          null == this.prev && null == this.next ? this.parent.remove() : s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"remove\", this).call(this);\n        }\n      }, {\n        key: \"replaceWith\",\n        value: function (t, n) {\n          return this.parent.isolate(this.offset(this.parent), this.length()), t === this.parent.statics.blotName ? (this.parent.replaceWith(t, n), this) : (this.parent.unwrap(), s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"replaceWith\", this).call(this, t, n));\n        }\n      }], [{\n        key: \"formats\",\n        value: function (t) {\n          return t.tagName === this.tagName ? void 0 : s(e.__proto__ || Object.getPrototypeOf(e), \"formats\", this).call(this, t);\n        }\n      }]), e;\n    }(p.default);\n\n    v.blotName = \"list-item\", v.tagName = \"LI\";\n\n    var b = function (t) {\n      function e(t) {\n        i(this, e);\n\n        var n = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t)),\n            r = function (e) {\n          if (e.target.parentNode === t) {\n            var r = n.statics.formats(t),\n                o = f.default.find(e.target);\n            \"checked\" === r ? o.format(\"list\", \"unchecked\") : \"unchecked\" === r && o.format(\"list\", \"checked\");\n          }\n        };\n\n        return t.addEventListener(\"touchstart\", r), t.addEventListener(\"mousedown\", r), n;\n      }\n\n      return l(e, t), u(e, null, [{\n        key: \"create\",\n        value: function (t) {\n          var n = \"ordered\" === t ? \"OL\" : \"UL\",\n              r = s(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, n);\n          return \"checked\" !== t && \"unchecked\" !== t || r.setAttribute(\"data-checked\", \"checked\" === t), r;\n        }\n      }, {\n        key: \"formats\",\n        value: function (t) {\n          return \"OL\" === t.tagName ? \"ordered\" : \"UL\" === t.tagName ? t.hasAttribute(\"data-checked\") ? \"true\" === t.getAttribute(\"data-checked\") ? \"checked\" : \"unchecked\" : \"bullet\" : void 0;\n        }\n      }]), u(e, [{\n        key: \"format\",\n        value: function (t, e) {\n          this.children.length > 0 && this.children.tail.format(t, e);\n        }\n      }, {\n        key: \"formats\",\n        value: function () {\n          return o({}, this.statics.blotName, this.statics.formats(this.domNode));\n        }\n      }, {\n        key: \"insertBefore\",\n        value: function (t, n) {\n          if (t instanceof v) s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"insertBefore\", this).call(this, t, n);else {\n            var r = null == n ? this.length() : n.offset(this),\n                o = this.split(r);\n            o.parent.insertBefore(t, o);\n          }\n        }\n      }, {\n        key: \"optimize\",\n        value: function (t) {\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"optimize\", this).call(this, t);\n          var n = this.next;\n          null != n && n.prev === this && n.statics.blotName === this.statics.blotName && n.domNode.tagName === this.domNode.tagName && n.domNode.getAttribute(\"data-checked\") === this.domNode.getAttribute(\"data-checked\") && (n.moveChildren(this), n.remove());\n        }\n      }, {\n        key: \"replace\",\n        value: function (t) {\n          if (t.statics.blotName !== this.statics.blotName) {\n            var n = f.default.create(this.statics.defaultChild);\n            t.moveChildren(n), this.appendChild(n);\n          }\n\n          s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"replace\", this).call(this, t);\n        }\n      }]), e;\n    }(y.default);\n\n    b.blotName = \"list\", b.scope = f.default.Scope.BLOCK_BLOT, b.tagName = [\"OL\", \"UL\"], b.defaultChild = \"list-item\", b.allowedChildren = [v], e.ListItem = v, e.default = b;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(36),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default);\n\n    u.blotName = \"italic\", u.tagName = [\"EM\", \"I\"], e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(4),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, null, [{\n        key: \"create\",\n        value: function (t) {\n          return \"super\" === t ? document.createElement(\"sup\") : \"sub\" === t ? document.createElement(\"sub\") : l(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n        }\n      }, {\n        key: \"formats\",\n        value: function (t) {\n          return \"SUB\" === t.tagName ? \"sub\" : \"SUP\" === t.tagName ? \"super\" : void 0;\n        }\n      }]), e;\n    }(s.default);\n\n    c.blotName = \"script\", c.tagName = [\"SUB\", \"SUP\"], e.default = c;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(4),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default);\n\n    u.blotName = \"strike\", u.tagName = \"S\", e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = n(4),\n        l = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(a),\n        u = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), e;\n    }(l.default);\n\n    u.blotName = \"underline\", u.tagName = \"U\", e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(0),\n        s = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(u),\n        c = n(15),\n        f = [\"alt\", \"height\", \"width\"],\n        d = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"format\",\n        value: function (t, n) {\n          f.indexOf(t) > -1 ? n ? this.domNode.setAttribute(t, n) : this.domNode.removeAttribute(t) : l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n        }\n      }], [{\n        key: \"create\",\n        value: function (t) {\n          var n = l(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n          return \"string\" == typeof t && n.setAttribute(\"src\", this.sanitize(t)), n;\n        }\n      }, {\n        key: \"formats\",\n        value: function (t) {\n          return f.reduce(function (e, n) {\n            return t.hasAttribute(n) && (e[n] = t.getAttribute(n)), e;\n          }, {});\n        }\n      }, {\n        key: \"match\",\n        value: function (t) {\n          return /\\.(jpe?g|gif|png)$/.test(t) || /^data:image\\/.+;base64/.test(t);\n        }\n      }, {\n        key: \"sanitize\",\n        value: function (t) {\n          return (0, c.sanitize)(t, [\"http\", \"https\", \"data\"]) ? t : \"//:0\";\n        }\n      }, {\n        key: \"value\",\n        value: function (t) {\n          return t.getAttribute(\"src\");\n        }\n      }]), e;\n    }(s.default.Embed);\n\n    d.blotName = \"image\", d.tagName = \"IMG\", e.default = d;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function t(e, n, r) {\n      null === e && (e = Function.prototype);\n      var o = Object.getOwnPropertyDescriptor(e, n);\n\n      if (void 0 === o) {\n        var i = Object.getPrototypeOf(e);\n        return null === i ? void 0 : t(i, n, r);\n      }\n\n      if (\"value\" in o) return o.value;\n      var a = o.get;\n      if (void 0 !== a) return a.call(r);\n    },\n        u = n(2),\n        s = n(15),\n        c = function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }(s),\n        f = [\"height\", \"width\"],\n        d = function (t) {\n      function e() {\n        return r(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));\n      }\n\n      return i(e, t), a(e, [{\n        key: \"format\",\n        value: function (t, n) {\n          f.indexOf(t) > -1 ? n ? this.domNode.setAttribute(t, n) : this.domNode.removeAttribute(t) : l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), \"format\", this).call(this, t, n);\n        }\n      }], [{\n        key: \"create\",\n        value: function (t) {\n          var n = l(e.__proto__ || Object.getPrototypeOf(e), \"create\", this).call(this, t);\n          return n.setAttribute(\"frameborder\", \"0\"), n.setAttribute(\"allowfullscreen\", !0), n.setAttribute(\"src\", this.sanitize(t)), n;\n        }\n      }, {\n        key: \"formats\",\n        value: function (t) {\n          return f.reduce(function (e, n) {\n            return t.hasAttribute(n) && (e[n] = t.getAttribute(n)), e;\n          }, {});\n        }\n      }, {\n        key: \"sanitize\",\n        value: function (t) {\n          return c.default.sanitize(t);\n        }\n      }, {\n        key: \"value\",\n        value: function (t) {\n          return t.getAttribute(\"src\");\n        }\n      }]), e;\n    }(u.BlockEmbed);\n\n    d.blotName = \"video\", d.className = \"ql-video\", d.tagName = \"IFRAME\", e.default = d;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    function o(t, e, n) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = n, t;\n    }\n\n    function i(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function a(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function l(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    function u(t, e, n) {\n      var r = document.createElement(\"button\");\n      r.setAttribute(\"type\", \"button\"), r.classList.add(\"ql-\" + e), null != n && (r.value = n), t.appendChild(r);\n    }\n\n    function s(t, e) {\n      Array.isArray(e[0]) || (e = [e]), e.forEach(function (e) {\n        var n = document.createElement(\"span\");\n        n.classList.add(\"ql-formats\"), e.forEach(function (t) {\n          if (\"string\" == typeof t) u(n, t);else {\n            var e = Object.keys(t)[0],\n                r = t[e];\n            Array.isArray(r) ? c(n, e, r) : u(n, e, r);\n          }\n        }), t.appendChild(n);\n      });\n    }\n\n    function c(t, e, n) {\n      var r = document.createElement(\"select\");\n      r.classList.add(\"ql-\" + e), n.forEach(function (t) {\n        var e = document.createElement(\"option\");\n        !1 !== t ? e.setAttribute(\"value\", t) : e.setAttribute(\"selected\", \"selected\"), r.appendChild(e);\n      }), t.appendChild(r);\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.addControls = e.default = void 0;\n\n    var f = function () {\n      function t(t, e) {\n        var n = [],\n            r = !0,\n            o = !1,\n            i = void 0;\n\n        try {\n          for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n            ;\n          }\n        } catch (t) {\n          o = !0, i = t;\n        } finally {\n          try {\n            !r && l.return && l.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n\n        return n;\n      }\n\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return t(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        d = function () {\n      function t(t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        p = n(5),\n        h = r(p),\n        y = n(0),\n        v = r(y),\n        b = n(6),\n        m = r(b),\n        g = n(8),\n        _ = r(g),\n        O = n(9),\n        E = r(O),\n        N = (\"getRootNode\" in document),\n        w = (0, _.default)(\"quill:toolbar\"),\n        k = function (t) {\n      function e(t, n) {\n        i(this, e);\n        var r = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));\n\n        if (Array.isArray(r.options.container)) {\n          var o = document.createElement(\"div\");\n          s(o, r.options.container), t.container.parentNode.insertBefore(o, t.container), r.container = o;\n        } else if (\"string\" == typeof r.options.container) {\n          var l = N ? t.container.getRootNode() : document;\n          r.container = l.querySelector(r.options.container);\n        } else r.container = r.options.container;\n\n        if (!(r.container instanceof HTMLElement)) {\n          var u;\n          return u = w.error(\"Container required for toolbar\", r.options), a(r, u);\n        }\n\n        return r.container.classList.add(\"ql-toolbar\"), r.controls = [], r.handlers = {}, Object.keys(r.options.handlers).forEach(function (t) {\n          r.addHandler(t, r.options.handlers[t]);\n        }), [].forEach.call(r.container.querySelectorAll(\"button, select\"), function (t) {\n          r.attach(t);\n        }), r.quill.on(m.default.events.EDITOR_CHANGE, function (t, e) {\n          t === m.default.events.SELECTION_CHANGE && r.update(e);\n        }), r.quill.on(m.default.events.SCROLL_OPTIMIZE, function () {\n          var t = r.quill.selection.getRange(),\n              e = f(t, 1),\n              n = e[0];\n          r.update(n);\n        }), r;\n      }\n\n      return l(e, t), d(e, [{\n        key: \"addHandler\",\n        value: function (t, e) {\n          this.handlers[t] = e;\n        }\n      }, {\n        key: \"attach\",\n        value: function (t) {\n          var e = this,\n              n = [].find.call(t.classList, function (t) {\n            return 0 === t.indexOf(\"ql-\");\n          });\n\n          if (n) {\n            if (n = n.slice(\"ql-\".length), \"BUTTON\" === t.tagName && t.setAttribute(\"type\", \"button\"), null == this.handlers[n]) {\n              if (null != this.quill.scroll.whitelist && null == this.quill.scroll.whitelist[n]) return void w.warn(\"ignoring attaching to disabled format\", n, t);\n              if (null == v.default.query(n)) return void w.warn(\"ignoring attaching to nonexistent format\", n, t);\n            }\n\n            var r = \"SELECT\" === t.tagName ? \"change\" : \"click\";\n            t.addEventListener(r, function (r) {\n              var i = void 0;\n\n              if (\"SELECT\" === t.tagName) {\n                if (t.selectedIndex < 0) return;\n                var a = t.options[t.selectedIndex];\n                i = !a.hasAttribute(\"selected\") && (a.value || !1);\n              } else i = !t.classList.contains(\"ql-active\") && (t.value || !t.hasAttribute(\"value\")), r.preventDefault();\n\n              e.quill.focus();\n              var l = e.quill.selection.getRange(),\n                  u = f(l, 1),\n                  s = u[0];\n              if (null != e.handlers[n]) e.handlers[n].call(e, i);else if (v.default.query(n).prototype instanceof v.default.Embed) {\n                if (!(i = prompt(\"Enter \" + n))) return;\n                e.quill.updateContents(new h.default().retain(s.index).delete(s.length).insert(o({}, n, i)), m.default.sources.USER);\n              } else e.quill.format(n, i, m.default.sources.USER);\n              e.update(s);\n            }), this.controls.push([n, t]);\n          }\n        }\n      }, {\n        key: \"update\",\n        value: function (t) {\n          var e = null == t ? {} : this.quill.getFormat(t);\n          this.controls.forEach(function (n) {\n            var r = f(n, 2),\n                o = r[0],\n                i = r[1];\n\n            if (\"SELECT\" === i.tagName) {\n              var a = void 0;\n              if (null == t) a = null;else if (null == e[o]) a = i.querySelector(\"option[selected]\");else if (!Array.isArray(e[o])) {\n                var l = e[o];\n                \"string\" == typeof l && (l = l.replace(/\\\"/g, '\\\\\"')), a = i.querySelector('option[value=\"' + l + '\"]');\n              }\n              null == a ? (i.value = \"\", i.selectedIndex = -1) : a.selected = !0;\n            } else if (null == t) i.classList.remove(\"ql-active\");else if (i.hasAttribute(\"value\")) {\n              var u = e[o] === i.getAttribute(\"value\") || null != e[o] && e[o].toString() === i.getAttribute(\"value\") || null == e[o] && !i.getAttribute(\"value\");\n              i.classList.toggle(\"ql-active\", u);\n            } else i.classList.toggle(\"ql-active\", null != e[o]);\n          });\n        }\n      }]), e;\n    }(E.default);\n\n    k.DEFAULTS = {}, k.DEFAULTS = {\n      container: null,\n      handlers: {\n        clean: function () {\n          var t = this,\n              e = this.quill.getSelection();\n          if (null != e) if (0 == e.length) {\n            var n = this.quill.getFormat();\n            Object.keys(n).forEach(function (e) {\n              null != v.default.query(e, v.default.Scope.INLINE) && t.quill.format(e, !1);\n            });\n          } else this.quill.removeFormat(e, m.default.sources.USER);\n        },\n        direction: function (t) {\n          var e = this.quill.getFormat().align;\n          \"rtl\" === t && null == e ? this.quill.format(\"align\", \"right\", m.default.sources.USER) : t || \"right\" !== e || this.quill.format(\"align\", !1, m.default.sources.USER), this.quill.format(\"direction\", t, m.default.sources.USER);\n        },\n        indent: function (t) {\n          var e = this.quill.getSelection(),\n              n = this.quill.getFormat(e),\n              r = parseInt(n.indent || 0);\n\n          if (\"+1\" === t || \"-1\" === t) {\n            var o = \"+1\" === t ? 1 : -1;\n            \"rtl\" === n.direction && (o *= -1), this.quill.format(\"indent\", r + o, m.default.sources.USER);\n          }\n        },\n        link: function (t) {\n          !0 === t && (t = prompt(\"Enter link URL:\")), this.quill.format(\"link\", t, m.default.sources.USER);\n        },\n        list: function (t) {\n          var e = this.quill.getSelection(),\n              n = this.quill.getFormat(e);\n          \"check\" === t ? \"checked\" === n.list || \"unchecked\" === n.list ? this.quill.format(\"list\", !1, m.default.sources.USER) : this.quill.format(\"list\", \"unchecked\", m.default.sources.USER) : this.quill.format(\"list\", t, m.default.sources.USER);\n        }\n      }\n    }, e.default = k, e.addControls = s;\n  },,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var o = n(40),\n        i = r(o),\n        a = n(30),\n        l = n(32),\n        u = n(56),\n        s = n(57),\n        c = r(s),\n        f = n(58),\n        d = r(f),\n        p = n(59),\n        h = r(p),\n        y = n(31),\n        v = n(22),\n        b = n(33),\n        m = n(34),\n        g = n(36),\n        _ = r(g),\n        O = n(60),\n        E = r(O),\n        N = n(15),\n        w = r(N),\n        k = n(61),\n        j = r(k),\n        x = n(62),\n        A = r(x),\n        T = n(63),\n        S = r(T),\n        P = n(64),\n        C = r(P),\n        L = n(65),\n        R = r(L),\n        q = n(12),\n        I = r(q),\n        M = n(66),\n        B = r(M);\n\n    i.default.register({\n      \"attributors/attribute/direction\": l.DirectionAttribute,\n      \"attributors/class/align\": a.AlignClass,\n      \"attributors/class/background\": y.BackgroundClass,\n      \"attributors/class/color\": v.ColorClass,\n      \"attributors/class/direction\": l.DirectionClass,\n      \"attributors/class/font\": b.FontClass,\n      \"attributors/class/size\": m.SizeClass,\n      \"attributors/style/align\": a.AlignStyle,\n      \"attributors/style/background\": y.BackgroundStyle,\n      \"attributors/style/color\": v.ColorStyle,\n      \"attributors/style/direction\": l.DirectionStyle,\n      \"attributors/style/font\": b.FontStyle,\n      \"attributors/style/size\": m.SizeStyle\n    }, !0), i.default.register({\n      \"formats/align\": a.AlignClass,\n      \"formats/direction\": l.DirectionClass,\n      \"formats/indent\": u.IndentClass,\n      \"formats/background\": y.BackgroundStyle,\n      \"formats/color\": v.ColorStyle,\n      \"formats/font\": b.FontClass,\n      \"formats/size\": m.SizeClass,\n      \"formats/blockquote\": c.default,\n      \"formats/code-block\": I.default,\n      \"formats/header\": d.default,\n      \"formats/list\": h.default,\n      \"formats/bold\": _.default,\n      \"formats/code\": q.Code,\n      \"formats/italic\": E.default,\n      \"formats/link\": w.default,\n      \"formats/script\": j.default,\n      \"formats/strike\": A.default,\n      \"formats/underline\": S.default,\n      \"formats/image\": C.default,\n      \"formats/video\": R.default,\n      \"formats/list/item\": p.ListItem,\n      \"modules/toolbar\": B.default\n    }, !0), e.default = i.default;\n  }]).default;\n});"
    },
    {
     "id": 395,
     "name": "../node_modules/@vaadin/vaadin-rich-text-editor/src/vaadin-rich-text-editor-content-styles.js?babel-target=es6",
     "source": "var $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<dom-module id=\"vaadin-rich-text-editor-content-styles\">\n  <template>\n    <style>\n      [part=\"content\"] {\n        box-sizing: border-box;\n        position: relative;\n        flex: auto;\n        display: flex;\n        flex-direction: column;\n        overflow: hidden;\n      }\n\n      /*\n        Quill core styles.\n        CSS selectors removed: margin & padding reset, check list, indentation, video, colors, ordered & unordered list, h1-6, anchor\n      */\n      .ql-clipboard {\n        left: -100000px;\n        height: 1px;\n        overflow-y: hidden;\n        position: absolute;\n        top: 50%;\n      }\n\n      .ql-clipboard p {\n        margin: 0;\n        padding: 0;\n      }\n\n      .ql-editor {\n        box-sizing: border-box;\n        line-height: 1.42;\n        height: 100%;\n        outline: none;\n        overflow-y: auto;\n        padding: 0.75em 1em;\n        tab-size: 4;\n        -moz-tab-size: 4;\n        text-align: left;\n        white-space: pre-wrap;\n        word-wrap: break-word;\n        flex: 1;\n      }\n\n      .ql-editor > * {\n        cursor: text;\n      }\n\n      .ql-align-left {\n        text-align: left;\n      }\n\n      .ql-direction-rtl {\n        direction: rtl;\n        text-align: inherit;\n      }\n\n      .ql-align-center {\n        text-align: center;\n      }\n\n      .ql-align-justify {\n        text-align: justify;\n      }\n\n      .ql-align-right {\n        text-align: right;\n      }\n      /* quill core end */\n\n      blockquote {\n        border-left: 0.25em solid #ccc;\n        margin-bottom: 0.3125em;\n        margin-top: 0.3125em;\n        padding-left: 1em;\n      }\n\n      code,\n      pre {\n        background-color: #f0f0f0;\n        border-radius: 0.1875em;\n      }\n\n      pre {\n        white-space: pre-wrap;\n        margin-bottom: 0.3125em;\n        margin-top: 0.3125em;\n        padding: 0.3125em 0.625em;\n      }\n\n      code {\n        font-size: 85%;\n        padding: 0.125em 0.25em;\n      }\n\n      img {\n        max-width: 100%;\n      }\n\n      /* RTL specific styles */\n\n      :host([dir=\"rtl\"]) .ql-editor {\n        direction: rtl;\n        text-align: right;\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "id": 396,
     "name": "../node_modules/@vaadin/flow-frontend/selectConnector.js?babel-target=es6",
     "source": "(function () {\n  var tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Select', 'vaadin-select-flow');\n  };\n\n  window.Vaadin.Flow.selectConnector = {\n    initLazy: select => tryCatchWrapper(function (select) {\n      var _findListBoxElement = tryCatchWrapper(function () {\n        for (var i = 0; i < select.childElementCount; i++) {\n          var child = select.children[i];\n\n          if (\"VAADIN-LIST-BOX\" === child.tagName.toUpperCase()) {\n            return child;\n          }\n        }\n      }); // do not init this connector twice for the given select\n\n\n      if (select.$connector) {\n        return;\n      }\n\n      select.$connector = {};\n      select.renderer = tryCatchWrapper(function (root) {\n        var listBox = _findListBoxElement();\n\n        if (listBox) {\n          if (root.firstChild) {\n            root.removeChild(root.firstChild);\n          }\n\n          root.appendChild(listBox);\n        }\n      });\n    })(select)\n  };\n})();"
    },
    {
     "id": 420,
     "name": "../node_modules/highcharts/js/es-modules/masters/highstock.src.js?babel-target=es6 + 31 modules"
    },
    {
     "id": 422,
     "name": "../node_modules/highcharts/js/es-modules/masters/highcharts-more.src.js?babel-target=es6 + 11 modules"
    },
    {
     "id": 424,
     "name": "../node_modules/@vaadin/vaadin-menu-bar/theme/lumo/vaadin-menu-bar.js?babel-target=es6 + 9 modules"
    },
    {
     "id": 426,
     "name": "../node_modules/highcharts/js/es-modules/masters/highcharts-3d.src.js?babel-target=es6 + 9 modules"
    },
    {
     "id": 428,
     "name": "../node_modules/@vaadin/vaadin-crud/theme/lumo/vaadin-crud.js?babel-target=es6 + 8 modules"
    },
    {
     "id": 430,
     "name": "../node_modules/@vaadin/vaadin-date-time-picker/theme/lumo/vaadin-date-time-picker.js?babel-target=es6 + 7 modules"
    },
    {
     "id": 431,
     "name": "../node_modules/@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro-edit-column.js?babel-target=es6 + 7 modules"
    },
    {
     "id": 434,
     "name": "../node_modules/@webcomponents/shadycss/src/scoping-shim.js?babel-target=es6 + 6 modules"
    },
    {
     "id": 436,
     "name": "../node_modules/@vaadin/vaadin-rich-text-editor/theme/lumo/vaadin-rich-text-editor.js?babel-target=es6 + 5 modules"
    },
    {
     "id": 438,
     "name": "../node_modules/@vaadin/vaadin-accordion/theme/lumo/vaadin-accordion.js?babel-target=es6 + 4 modules"
    },
    {
     "id": 439,
     "name": "../node_modules/@vaadin/vaadin-login/theme/lumo/vaadin-login-overlay.js?babel-target=es6 + 4 modules"
    },
    {
     "id": 442,
     "name": "../node_modules/@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro.js?babel-target=es6 + 3 modules"
    },
    {
     "id": 444,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/accessibility.src.js?babel-target=es6 + 3 modules"
    },
    {
     "id": 445,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/heatmap.src.js?babel-target=es6 + 3 modules"
    },
    {
     "id": 448,
     "name": "../node_modules/@vaadin/vaadin-app-layout/theme/lumo/vaadin-drawer-toggle.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 449,
     "name": "../node_modules/@vaadin/vaadin-board/vaadin-board.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 450,
     "name": "../node_modules/@vaadin/vaadin-charts/vaadin-chart.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 451,
     "name": "../node_modules/@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox-group.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 452,
     "name": "../node_modules/@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-item.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 453,
     "name": "../node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-tree-toggle.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 454,
     "name": "../node_modules/@vaadin/vaadin-notification/theme/lumo/vaadin-notification.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 455,
     "name": "../node_modules/@vaadin/vaadin-ordered-layout/vaadin-scroller.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 456,
     "name": "../node_modules/@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-group.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 457,
     "name": "../node_modules/@vaadin/vaadin-split-layout/theme/lumo/vaadin-split-layout.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 469,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/data.src.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 470,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/treemap.src.js?babel-target=es6 + 2 modules"
    },
    {
     "id": 473,
     "name": "../node_modules/@vaadin/flow-frontend/vaadin-grid-flow-selection-column.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 474,
     "name": "../node_modules/@vaadin/vaadin-cookie-consent/theme/lumo/vaadin-cookie-consent.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 475,
     "name": "../node_modules/@vaadin/vaadin-icons/vaadin-icons.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 476,
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-integer-field.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 480,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/drilldown.src.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 481,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/exporting.src.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 482,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/funnel.src.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 483,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/solid-gauge.src.js?babel-target=es6 + 1 modules"
    },
    {
     "id": 484,
     "name": "../node_modules/highcharts/js/es-modules/masters/modules/no-data-to-display.src.js?babel-target=es6 + 1 modules"
    }
   ]
  },
  {
   "id": 5,
   "names": [],
   "files": [
    "build/vaadin-5-6b31cd6e26ec361e9a4a.cache.js"
   ],
   "hash": "d233455975b616638d05",
   "modules": [
    {
     "id": 491,
     "name": "../target/frontend/generated-flow-imports-fallback.js",
     "source": "import '@polymer/iron-icon/iron-icon.js';\nimport '@polymer/iron-list/iron-list.js';\nimport '@vaadin/flow-frontend/comboBoxConnector-es6.js';\nimport '@vaadin/flow-frontend/contextMenuConnector-es6.js';\nimport '@vaadin/flow-frontend/datepickerConnector.js';\nimport '@vaadin/flow-frontend/dndConnector-es6.js';\nimport '@vaadin/flow-frontend/flow-component-renderer.js';\nimport '@vaadin/flow-frontend/gridConnector-es6.js';\nimport '@vaadin/flow-frontend/gridProConnector.js';\nimport '@vaadin/flow-frontend/ironListConnector-es6.js';\nimport '@vaadin/flow-frontend/ironListStyles.js';\nimport '@vaadin/flow-frontend/menubarConnector.js';\nimport '@vaadin/flow-frontend/timepickerConnector.js';\nimport '@vaadin/flow-frontend/vaadin-big-decimal-field.js';\nimport '@vaadin/flow-frontend/vaadin-grid-flow-selection-column.js';\nimport '@vaadin/vaadin-accordion/theme/lumo/vaadin-accordion.js';\nimport '@vaadin/vaadin-app-layout/theme/lumo/vaadin-drawer-toggle.js';\nimport '@vaadin/vaadin-board/vaadin-board-row.js';\nimport '@vaadin/vaadin-board/vaadin-board.js';\nimport '@vaadin/vaadin-charts/vaadin-chart.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox-group.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js';\nimport '@vaadin/vaadin-combo-box/theme/lumo/vaadin-combo-box.js';\nimport '@vaadin/vaadin-confirm-dialog/theme/lumo/vaadin-confirm-dialog.js';\nimport '@vaadin/vaadin-context-menu/theme/lumo/vaadin-context-menu.js';\nimport '@vaadin/vaadin-cookie-consent/theme/lumo/vaadin-cookie-consent.js';\nimport '@vaadin/vaadin-crud/src/vaadin-crud-edit-column.js';\nimport '@vaadin/vaadin-crud/theme/lumo/vaadin-crud.js';\nimport '@vaadin/vaadin-custom-field/theme/lumo/vaadin-custom-field.js';\nimport '@vaadin/vaadin-date-picker/theme/lumo/vaadin-date-picker.js';\nimport '@vaadin/vaadin-date-time-picker/theme/lumo/vaadin-date-time-picker.js';\nimport '@vaadin/vaadin-details/theme/lumo/vaadin-details.js';\nimport '@vaadin/vaadin-dialog/theme/lumo/vaadin-dialog.js';\nimport '@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-item.js';\nimport '@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-layout.js';\nimport '@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro-edit-column.js';\nimport '@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column-group.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-sorter.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-tree-toggle.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid.js';\nimport '@vaadin/vaadin-icons/vaadin-icons.js';\nimport '@vaadin/vaadin-item/theme/lumo/vaadin-item.js';\nimport '@vaadin/vaadin-list-box/theme/lumo/vaadin-list-box.js';\nimport '@vaadin/vaadin-login/theme/lumo/vaadin-login-form.js';\nimport '@vaadin/vaadin-login/theme/lumo/vaadin-login-overlay.js';\nimport '@vaadin/vaadin-menu-bar/theme/lumo/vaadin-menu-bar.js';\nimport '@vaadin/vaadin-notification/theme/lumo/vaadin-notification.js';\nimport '@vaadin/vaadin-ordered-layout/vaadin-scroller.js';\nimport '@vaadin/vaadin-progress-bar/theme/lumo/vaadin-progress-bar.js';\nimport '@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-button.js';\nimport '@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-group.js';\nimport '@vaadin/vaadin-rich-text-editor/theme/lumo/vaadin-rich-text-editor.js';\nimport '@vaadin/vaadin-select/theme/lumo/vaadin-select.js';\nimport '@vaadin/vaadin-split-layout/theme/lumo/vaadin-split-layout.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-email-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-integer-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-number-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-password-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-text-field.js';\nimport '@vaadin/vaadin-time-picker/theme/lumo/vaadin-time-picker.js';\nimport '@vaadin/vaadin-upload/src/vaadin-upload-file.js';\nimport '@vaadin/flow-frontend/comboBoxConnector.js';\nimport '@vaadin/flow-frontend/contextMenuConnector.js';\nimport '@vaadin/flow-frontend/dndConnector.js';\nimport '@vaadin/flow-frontend/gridConnector.js';\nimport '@vaadin/flow-frontend/ironListConnector.js';\nimport '@vaadin/flow-frontend/selectConnector.js';"
    }
   ]
  },
  {
   "id": 6,
   "names": [],
   "files": [
    "build/vaadin-6-005498b21b1c249b9ba7.cache.js"
   ],
   "hash": "d0feace738f173611587",
   "modules": [
    {
     "id": 490,
     "name": "../target/frontend/generated-flow-imports-fallback.js",
     "source": "import '@polymer/iron-icon/iron-icon.js';\nimport '@polymer/iron-list/iron-list.js';\nimport '@vaadin/flow-frontend/comboBoxConnector-es6.js';\nimport '@vaadin/flow-frontend/contextMenuConnector-es6.js';\nimport '@vaadin/flow-frontend/datepickerConnector.js';\nimport '@vaadin/flow-frontend/dndConnector-es6.js';\nimport '@vaadin/flow-frontend/flow-component-renderer.js';\nimport '@vaadin/flow-frontend/gridConnector-es6.js';\nimport '@vaadin/flow-frontend/gridProConnector.js';\nimport '@vaadin/flow-frontend/ironListConnector-es6.js';\nimport '@vaadin/flow-frontend/ironListStyles.js';\nimport '@vaadin/flow-frontend/menubarConnector.js';\nimport '@vaadin/flow-frontend/timepickerConnector.js';\nimport '@vaadin/flow-frontend/vaadin-big-decimal-field.js';\nimport '@vaadin/flow-frontend/vaadin-grid-flow-selection-column.js';\nimport '@vaadin/vaadin-accordion/theme/lumo/vaadin-accordion.js';\nimport '@vaadin/vaadin-app-layout/theme/lumo/vaadin-drawer-toggle.js';\nimport '@vaadin/vaadin-board/vaadin-board-row.js';\nimport '@vaadin/vaadin-board/vaadin-board.js';\nimport '@vaadin/vaadin-charts/vaadin-chart.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox-group.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js';\nimport '@vaadin/vaadin-combo-box/theme/lumo/vaadin-combo-box.js';\nimport '@vaadin/vaadin-confirm-dialog/theme/lumo/vaadin-confirm-dialog.js';\nimport '@vaadin/vaadin-context-menu/theme/lumo/vaadin-context-menu.js';\nimport '@vaadin/vaadin-cookie-consent/theme/lumo/vaadin-cookie-consent.js';\nimport '@vaadin/vaadin-crud/src/vaadin-crud-edit-column.js';\nimport '@vaadin/vaadin-crud/theme/lumo/vaadin-crud.js';\nimport '@vaadin/vaadin-custom-field/theme/lumo/vaadin-custom-field.js';\nimport '@vaadin/vaadin-date-picker/theme/lumo/vaadin-date-picker.js';\nimport '@vaadin/vaadin-date-time-picker/theme/lumo/vaadin-date-time-picker.js';\nimport '@vaadin/vaadin-details/theme/lumo/vaadin-details.js';\nimport '@vaadin/vaadin-dialog/theme/lumo/vaadin-dialog.js';\nimport '@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-item.js';\nimport '@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-layout.js';\nimport '@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro-edit-column.js';\nimport '@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column-group.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-sorter.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-tree-toggle.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid.js';\nimport '@vaadin/vaadin-icons/vaadin-icons.js';\nimport '@vaadin/vaadin-item/theme/lumo/vaadin-item.js';\nimport '@vaadin/vaadin-list-box/theme/lumo/vaadin-list-box.js';\nimport '@vaadin/vaadin-login/theme/lumo/vaadin-login-form.js';\nimport '@vaadin/vaadin-login/theme/lumo/vaadin-login-overlay.js';\nimport '@vaadin/vaadin-menu-bar/theme/lumo/vaadin-menu-bar.js';\nimport '@vaadin/vaadin-notification/theme/lumo/vaadin-notification.js';\nimport '@vaadin/vaadin-ordered-layout/vaadin-scroller.js';\nimport '@vaadin/vaadin-progress-bar/theme/lumo/vaadin-progress-bar.js';\nimport '@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-button.js';\nimport '@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-group.js';\nimport '@vaadin/vaadin-rich-text-editor/theme/lumo/vaadin-rich-text-editor.js';\nimport '@vaadin/vaadin-select/theme/lumo/vaadin-select.js';\nimport '@vaadin/vaadin-split-layout/theme/lumo/vaadin-split-layout.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-email-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-integer-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-number-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-password-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-text-field.js';\nimport '@vaadin/vaadin-time-picker/theme/lumo/vaadin-time-picker.js';\nimport '@vaadin/vaadin-upload/src/vaadin-upload-file.js';\nimport '@vaadin/flow-frontend/comboBoxConnector.js';\nimport '@vaadin/flow-frontend/contextMenuConnector.js';\nimport '@vaadin/flow-frontend/dndConnector.js';\nimport '@vaadin/flow-frontend/gridConnector.js';\nimport '@vaadin/flow-frontend/ironListConnector.js';\nimport '@vaadin/flow-frontend/selectConnector.js';"
    }
   ]
  }
 ],
 "modules": [
  {
   "id": 232,
   "name": "../target/frontend/generated-flow-imports.js?babel-target=es6 + 31 modules",
   "modules": [
    {
     "name": "../target/frontend/generated-flow-imports.js?babel-target=es6",
     "source": "var div = document.createElement('div');\ndiv.innerHTML = '<custom-style><style include=\"lumo-color lumo-typography\"></style></custom-style>';\ndocument.head.insertBefore(div.firstElementChild, document.head.firstChild);\n\nfunction addCssBlock(block) {\n  var tpl = document.createElement('template');\n  tpl.innerHTML = block;\n  document.head.appendChild(tpl.content);\n}\n\nimport $css_0 from 'Frontend/styles/views/main/main-view.css';\naddCssBlock(`<dom-module id=\"flow_css_mod_0\" theme-for=\"vaadin-app-layout\"><template><style>${$css_0}</style></template></dom-module>`);\nimport $css_1 from 'Frontend/styles/views/main/main-view.css';\naddCssBlock(`<custom-style><style>${$css_1}</style></custom-style>`);\nimport '@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-layout.js';\nimport '@vaadin/vaadin-button/theme/lumo/vaadin-button.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-email-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-text-field.js';\nimport '@vaadin/vaadin-custom-field/theme/lumo/vaadin-custom-field.js';\nimport '@vaadin/vaadin-ordered-layout/theme/lumo/vaadin-horizontal-layout.js';\nimport '@vaadin/vaadin-combo-box/theme/lumo/vaadin-combo-box.js';\nimport '@vaadin/vaadin-date-picker/theme/lumo/vaadin-date-picker.js';\nimport '@vaadin/vaadin-app-layout/theme/lumo/vaadin-app-layout.js';\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/icons.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport '@vaadin/vaadin-ordered-layout/theme/lumo/vaadin-vertical-layout.js';\nimport '@vaadin/vaadin-tabs/theme/lumo/vaadin-tab.js';\nimport '@vaadin/vaadin-tabs/theme/lumo/vaadin-tabs.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-text-area.js';\nimport '@vaadin/vaadin-upload/theme/lumo/vaadin-upload.js';\nimport 'Frontend/src/views/about/about-view.js';\nimport 'Frontend/src/views/obfuscate/obfuscate-view.js';\nimport 'Frontend/styles/shared-styles.js';\nvar scripts = document.getElementsByTagName('script');\nvar thisScript;\nvar elements = document.getElementsByTagName('script');\n\nfor (var i = 0; i < elements.length; i++) {\n  var script = elements[i];\n\n  if (script.getAttribute('type') == 'module' && script.getAttribute('data-app-id') && !script['vaadin-bundle']) {\n    thisScript = script;\n    break;\n  }\n}\n\nif (!thisScript) {\n  throw new Error('Could not find the bundle script to identify the application id');\n}\n\nthisScript['vaadin-bundle'] = true;\n\nif (!window.Vaadin.Flow.fallbacks) {\n  window.Vaadin.Flow.fallbacks = {};\n}\n\nvar fallbacks = window.Vaadin.Flow.fallbacks;\nfallbacks[thisScript.getAttribute('data-app-id')] = {};\n\nfallbacks[thisScript.getAttribute('data-app-id')].loadFallback = function loadFallback() {\n  return import('./generated-flow-imports-fallback.js');\n};"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-ordered-layout/theme/lumo/vaadin-horizontal-layout.js?babel-target=es6",
     "source": "import './vaadin-horizontal-layout-styles.js';\nimport '../../src/vaadin-horizontal-layout.js';"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-app-layout/theme/lumo/vaadin-app-layout.js?babel-target=es6",
     "source": "import './vaadin-app-layout-styles.js';\nimport '../../src/vaadin-app-layout.js';"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/icons.js?babel-target=es6",
     "source": "import './version.js';\nimport '@polymer/iron-icon/iron-icon.js';\nimport './iconset.js';"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-ordered-layout/theme/lumo/vaadin-vertical-layout.js?babel-target=es6",
     "source": "import './vaadin-vertical-layout-styles.js';\nimport '../../src/vaadin-vertical-layout.js';"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-tabs/theme/lumo/vaadin-tab.js?babel-target=es6",
     "source": "import './vaadin-tab-styles.js';\nimport '../../src/vaadin-tab.js';"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-tabs/theme/lumo/vaadin-tabs.js?babel-target=es6",
     "source": "import './vaadin-tab.js';\nimport './vaadin-tabs-styles.js';\nimport '../../src/vaadin-tabs.js';"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-text-area.js?babel-target=es6",
     "source": "import './vaadin-text-area-styles.js';\nimport './vaadin-text-field.js';\nimport '../../src/vaadin-text-area.js';"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-upload/theme/lumo/vaadin-upload.js?babel-target=es6",
     "source": "import './vaadin-upload-styles.js';\nimport '../../src/vaadin-upload.js';"
    },
    {
     "name": "./src/views/about/about-view.js?babel-target=es6",
     "source": "import { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n\nclass AboutView extends PolymerElement {\n  static get template() {\n    return html`\n      <style include=\"shared-styles\">\n        :host {\n          display: block;\n        }\n      </style>\n\n      <div>Test</div>\n    `;\n  }\n\n  static get is() {\n    return 'about-view';\n  }\n\n}\n\ncustomElements.define(AboutView.is, AboutView);"
    },
    {
     "name": "./src/views/obfuscate/obfuscate-view.js?babel-target=es6",
     "source": "import { html, PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport '@vaadin/vaadin-form-layout/src/vaadin-form-layout.js';\nimport '@vaadin/vaadin-button/src/vaadin-button.js';\nimport '@vaadin/vaadin-text-field/src/vaadin-email-field.js';\nimport '@vaadin/vaadin-text-field/src/vaadin-text-field.js';\nimport '@vaadin/vaadin-custom-field/src/vaadin-custom-field.js';\nimport '@vaadin/vaadin-ordered-layout/src/vaadin-horizontal-layout.js';\nimport '@vaadin/vaadin-combo-box/src/vaadin-combo-box.js';\nimport '@vaadin/vaadin-date-picker/src/vaadin-date-picker.js';\n\nclass ObfuscateView extends PolymerElement {\n  static get template() {\n    return html`\n<style include=\"shared-styles lumo-typography\">\n:host {\n  display: block;\n  height: 100%;\n  padding: 0 var(--lumo-space-l);\n}\n</style>\n\n<vaadin-vertical-layout id=\"content_container\">\n    <h1>Step 1:</h1>\n    <vaadin-horizontal-layout id=\"upload_container\" theme=\"spacing\">\n        <vaadin-upload id=\"upload\" accept=\".class\" max-file-size=\"100000000\">\n            <span slot=\"drop-label\" style=\"\">Drop files or folder here</span>\n        </vaadin-upload>\n    </vaadin-horizontal-layout>\n    <h1>Step 2:</h1>\n    <vaadin-horizontal-layout id=\"compare_container\">\n        <vaadin-text-area id=\"before\"></vaadin-text-area>\n        <vaadin-text-area id=\"after\"></vaadin-text-area>\n    </vaadin-horizontal-layout>\n    <h1>Step 3:</h1>\n    <vaadin-horizontal-layout id=\"download_container\">\n        <vaadin-button id=\"download\" theme=\"primary\">\n            <iron-icon icon=\"vaadin:download-alt\" slot=\"prefix\"></iron-icon>\n            Download Files\n        </vaadin-button>\n    </vaadin-horizontal-layout>\n</vaadin-vertical-layout>\n\n<script>\n  customElements.whenDefined('vaadin-upload').then(function() {\n    const upload = document.querySelector('vaadin-upload');\n    upload.addEventListener('file-reject', function(event) {\n      window.alert(event.detail.file.name + ' error: ' + event.detail.error);\n    });\n  });\n</script>\n\n`;\n  }\n\n  static get is() {\n    return 'obfuscate-view';\n  }\n\n  static get properties() {\n    return {// Declare your properties here.\n    };\n  }\n\n}\n\ncustomElements.define(ObfuscateView.is, ObfuscateView);"
    },
    {
     "name": "./styles/shared-styles.js?babel-target=es6",
     "source": "// eagerly import theme styles so as we can override them\nimport '@vaadin/vaadin-lumo-styles/all-imports';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `\n<custom-style>\n<style>\n</style>\n</custom-style>\n\n\n`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-ordered-layout/theme/lumo/vaadin-horizontal-layout-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/spacing.js';\nimport './vaadin-ordered-layout.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-horizontal-layout\" theme-for=\"vaadin-horizontal-layout\">\n  <template>\n    <style include=\"lumo-ordered-layout\">\n      :host([theme~=\"spacing-xs\"]:not([dir=\"rtl\"])) ::slotted(*) {\n        margin-left: var(--lumo-space-xs);\n      }\n\n      :host([theme~=\"spacing-s\"]:not([dir=\"rtl\"])) ::slotted(*) {\n        margin-left: var(--lumo-space-s);\n      }\n\n      :host([theme~=\"spacing\"]:not([dir=\"rtl\"])) ::slotted(*) {\n        margin-left: var(--lumo-space-m);\n      }\n\n      :host([theme~=\"spacing-l\"]:not([dir=\"rtl\"])) ::slotted(*) {\n        margin-left: var(--lumo-space-l);\n      }\n\n      :host([theme~=\"spacing-xl\"]:not([dir=\"rtl\"])) ::slotted(*) {\n        margin-left: var(--lumo-space-xl);\n      }\n\n      /*\n        Compensate for the first item margin, so that there is no gap around\n        the layout itself.\n       */\n      :host([theme~=\"spacing-xs\"])::before,\n      :host([theme~=\"spacing-s\"])::before,\n      :host([theme~=\"spacing\"])::before,\n      :host([theme~=\"spacing-l\"])::before,\n      :host([theme~=\"spacing-xl\"])::before {\n        content: \"\";\n      }\n\n      :host([theme~=\"spacing-xs\"]:not([dir=\"rtl\"]))::before {\n        margin-left: calc(var(--lumo-space-xs) * -1);\n      }\n\n      :host([theme~=\"spacing-s\"]:not([dir=\"rtl\"]))::before {\n        margin-left: calc(var(--lumo-space-s) * -1);\n      }\n\n      :host([theme~=\"spacing\"]:not([dir=\"rtl\"]))::before {\n        margin-left: calc(var(--lumo-space-m) * -1);\n      }\n\n      :host([theme~=\"spacing-l\"]:not([dir=\"rtl\"]))::before {\n        margin-left: calc(var(--lumo-space-l) * -1);\n      }\n\n      :host([theme~=\"spacing-xl\"]:not([dir=\"rtl\"]))::before {\n        margin-left: calc(var(--lumo-space-xl) * -1);\n      }\n\n      /* RTL styles */\n      :host([dir=\"rtl\"][theme~=\"spacing-xs\"]) ::slotted(*) {\n        margin-right: var(--lumo-space-xs);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"spacing-s\"]) ::slotted(*) {\n        margin-right: var(--lumo-space-s);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"spacing\"]) ::slotted(*) {\n        margin-right: var(--lumo-space-m);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"spacing-l\"]) ::slotted(*) {\n        margin-right: var(--lumo-space-l);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"spacing-xl\"]) ::slotted(*) {\n        margin-right: var(--lumo-space-xl);\n      }\n\n      /*\n        Compensate for the first item margin, so that there is no gap around\n        the layout itself.\n       */\n      :host([dir=\"rtl\"][theme~=\"spacing-xs\"])::before {\n        margin-right: calc(var(--lumo-space-xs) * -1);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"spacing-s\"])::before {\n        margin-right: calc(var(--lumo-space-s) * -1);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"spacing\"])::before {\n        margin-right: calc(var(--lumo-space-m) * -1);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"spacing-l\"])::before {\n        margin-right: calc(var(--lumo-space-l) * -1);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"spacing-xl\"])::before {\n        margin-right: calc(var(--lumo-space-xl) * -1);\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-ordered-layout/src/vaadin-horizontal-layout.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-horizontal-layout>` provides a simple way to horizontally align your HTML elements.\n *\n * ```\n * <vaadin-horizontal-layout>\n *   <div>Item 1</div>\n *   <div>Item 2</div>\n * </vaadin-horizontal-layout>\n * ```\n *\n * ### Built-in Theme Variations\n *\n * `<vaadin-horizontal-layout>` supports the following theme variations:\n *\n * Theme variation | Description\n * ---|---\n * `theme=\"margin\"` | Applies the default amount of CSS margin for the host element (specified by the theme)\n * `theme=\"padding\"` | Applies the default amount of CSS padding for the host element (specified by the theme)\n * `theme=\"spacing\"` | Applies the default amount of CSS margin between items (specified by the theme)\n *\n * @extends PolymerElement\n * @mixes ThemableMixin\n * @mixes ElementMixin\n * @demo demo/index.html\n */\n\nclass HorizontalLayoutElement extends ElementMixin(ThemableMixin(PolymerElement)) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: flex;\n        box-sizing: border-box;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      /* Theme variations */\n      :host([theme~=\"margin\"]) {\n        margin: 1em;\n      }\n\n      :host([theme~=\"padding\"]) {\n        padding: 1em;\n      }\n\n      :host([theme~=\"spacing\"]:not([dir=\"rtl\"])) ::slotted(*) {\n        margin-left: 1em;\n      }\n\n      :host([theme~=\"spacing\"][dir=\"rtl\"]) ::slotted(*) {\n        margin-right: 1em;\n      }\n\n      /*\n        Compensate for the first item margin, so that there is no gap around\n        the layout itself.\n       */\n      :host([theme~=\"spacing\"])::before {\n        content: \"\";\n      }\n\n      :host([theme~=\"spacing\"]:not([dir=\"rtl\"]))::before {\n        margin-left: -1em;\n      }\n\n      :host([theme~=\"spacing\"][dir=\"rtl\"])::before {\n        margin-right: -1em;\n      }\n    </style>\n\n    <slot></slot>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-horizontal-layout';\n  }\n\n  static get version() {\n    return '1.4.0';\n  }\n\n}\n\ncustomElements.define(HorizontalLayoutElement.is, HorizontalLayoutElement);\nexport { HorizontalLayoutElement };"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-app-layout/theme/lumo/vaadin-app-layout-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-app-layout\" theme-for=\"vaadin-app-layout\">\n  <template>\n    <style>\n      [part=\"navbar\"]::before {\n        background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));\n      }\n\n      :host(:not([dir='rtl']):not([overlay])) [part='drawer'] {\n        border-right: 1px solid var(--lumo-contrast-10pct);\n      }\n\n      :host([dir='rtl']:not([overlay])) [part='drawer'] {\n        border-left: 1px solid var(--lumo-contrast-10pct);\n      }\n\n      :host([overlay]) [part=\"drawer\"]::before {\n        background: var(--lumo-base-color);\n      }\n\n      [part=\"navbar\"]::before,\n      :host([overlay]) [part=\"drawer\"]::before {\n        position: absolute;\n        content: \"\";\n        width: 100%;\n        height: 100%;\n        z-index: -1;\n      }\n\n      :host([overlay]) [part='drawer']::before {\n        background: var(--lumo-base-color);\n        height: var(--_vaadin-app-layout-drawer-scroll-size, 100%);\n      }\n\n      [part=\"backdrop\"] {\n        background-color: var(--lumo-shade-20pct);\n        opacity: 1;\n      }\n\n      [part] ::slotted(h2),\n      [part] ::slotted(h3),\n      [part] ::slotted(h4) {\n        margin-top: var(--lumo-space-xs) !important;\n        margin-bottom: var(--lumo-space-xs) !important;\n      }\n\n      @supports (-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px)) {\n        [part=\"navbar\"]::before {\n          opacity: 0.8;\n        }\n\n        [part=\"navbar\"] {\n          -webkit-backdrop-filter: blur(24px);\n          backdrop-filter: blur(24px);\n        }\n\n        :host([overlay]) [part=\"drawer\"]::before {\n          opacity: 0.9;\n        }\n\n        :host([overlay]) [part=\"drawer\"] {\n          -webkit-backdrop-filter: blur(24px);\n          backdrop-filter: blur(24px);\n        }\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-app-layout/src/vaadin-app-layout.js?babel-target=es6",
     "source": "/**\n@license\nVaadin App Layout\nCopyright (C) 2019 Vaadin Ltd\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport './safe-area-inset.js';\nimport './detect-ios-navbar.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { beforeNextRender, afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-app-layout>` is a Web Component providing a quick and easy way to get a common application layout structure done.\n *\n * ```\n * <vaadin-app-layout primary-section=\"navbar|drawer\">\n *  <vaadin-drawer-toggle slot=\"navbar [touch-optimized]\"></vaadin-drawer-toggle>\n *  <h3 slot=\"navbar [touch-optimized]\">Company Name</h3>\n *  <vaadin-tabs orientation=\"vertical\" slot=\"drawer\">\n *    <vaadin-tab>Menu item 1</vaadin-tab>\n *  </vaadin-tabs>\n *  <!-- Everything else will be the page content -->\n *  <div>\n *    <h3>Page title</h3>\n *    <p>Page content</p>\n *  </div>\n * </vaadin-app-layout>\n * ```\n *\n * For best results, the component should be added to the root level of your application (i.e., as a direct child of `<body>`).\n *\n * The page should include a viewport meta tag which contains `viewport-fit=cover`, like the following:\n * ```\n * <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, viewport-fit=cover\">\n * ```\n * This causes the viewport to be scaled to fill the device display.\n * To ensure that important content is displayed, use the provided css variables.\n * ```\n * --safe-area-inset-top\n * --safe-area-inset-right\n * --safe-area-inset-bottom\n * --safe-area-inset-left\n * ```\n *\n * ### Styling\n *\n * The following Shadow DOM parts of the `<vaadin-app-layout>` are available for styling:\n *\n * Part name     | Description\n * --------------|---------------------------------------------------------|\n * `navbar`      | Container for the navigation bar\n * `drawer`      | Container for the drawer area\n * `content`     | Container for page content.\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * ### Component's slots\n *\n * The following slots are available to be set\n *\n * Slot name          | Description\n * -------------------|---------------------------------------------------|\n * no name            | Default container for the page content\n * `navbar `          | Container for the top navbar area\n * `drawer`           | Container for an application menu\n * `touch-optimized`  | Container for the bottom navbar area (only visible for mobile devices)\n *\n *\n * See examples of setting the content into slots in the live demos.\n *\n * #### Touch optimized\n *\n * App Layout has a pseudo-slot `touch-optimized` in order to give more control of the presentation of\n * elements with `slot[navbar]`. Internally, when the user is interacting with App Layout from a\n * touchscreen device, the component will search for elements with `slot[navbar touch-optimized]` and move\n * them to the bottom of the page.\n *\n * ### Navigation\n *\n * As the drawer opens as an overlay in small devices, it makes sense to close it once a navigation happens.\n *\n * In order to do so, there are two options:\n * - If the `vaadin-app-layout` instance is available, then `drawerOpened` can be set to `false`\n * - If not, a custom event `close-overlay-drawer` can be dispatched either by calling\n *  `window.dispatchEvent(new CustomEvent('close-overlay-drawer'))` or by calling\n *  `Vaadin.AppLayoutElement.dispatchCloseOverlayDrawerEvent()`\n *\n * ### Scrolling areas\n *\n * By default, the component will act with the \"body scrolling\", so on mobile (iOS Safari and Android Chrome),\n * the toolbars will collapse when a scroll happens.\n *\n * To use the \"content scrolling\", in case of the content of the page relies on a pre-defined height (for instance,\n * it has a `height:100%`), then the developer can set `height: 100%` to both `html` and `body`.\n * That will make the `[content]` element of app layout scrollable.\n * On this case, the toolbars on mobile device won't collapse.\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nclass AppLayoutElement extends ElementMixin(ThemableMixin(PolymerElement)) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: block;\n        box-sizing: border-box;\n        height: 100%;\n        --vaadin-app-layout-transition: 200ms;\n        transition: padding var(--vaadin-app-layout-transition);\n        --vaadin-app-layout-touch-optimized: false;\n        --vaadin-app-layout-navbar-offset-top: var(--_vaadin-app-layout-navbar-offset-size);\n        --vaadin-app-layout-navbar-offset-bottom: var(--_vaadin-app-layout-navbar-offset-size-bottom);\n        padding-top: var(--vaadin-app-layout-navbar-offset-top);\n        padding-bottom: var(--vaadin-app-layout-navbar-offset-bottom);\n        padding-left: var(--vaadin-app-layout-navbar-offset-left);\n      }\n\n      :host([dir=\"rtl\"]) {\n        padding-left: 0;\n        padding-right: var(--vaadin-app-layout-navbar-offset-left);\n      }\n\n      :host([hidden]),\n      [hidden] {\n        display: none !important;\n      }\n\n      :host([no-anim]) {\n        --vaadin-app-layout-transition: none !important;\n      }\n\n      :host([drawer-opened]) {\n        --vaadin-app-layout-drawer-offset-left: var(--_vaadin-app-layout-drawer-offset-size);\n      }\n\n      :host([overlay]) {\n        --vaadin-app-layout-drawer-offset-left: 0;\n        --vaadin-app-layout-navbar-offset-left: 0;\n      }\n\n      :host(:not([no-scroll])) [content] {\n        overflow: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      [content] {\n        height: 100%;\n      }\n\n      @media (pointer: coarse) and (max-width: 800px) and (min-height: 500px) {\n        :host {\n          --vaadin-app-layout-touch-optimized: true;\n        }\n      }\n\n      [part=\"navbar\"],\n      [part=\"navbar\"]::before {\n        position: fixed;\n        display: flex;\n        align-items: center;\n        top: 0;\n        right: 0;\n        left: 0;\n        transition: left var(--vaadin-app-layout-transition);\n        padding-top: var(--safe-area-inset-top);\n        padding-left: var(--safe-area-inset-left);\n        padding-right: var(--safe-area-inset-right);\n        z-index: 1;\n      }\n\n      :host(:not([dir=\"rtl\"])[primary-section=\"drawer\"][drawer-opened]:not([overlay])) [part=\"navbar\"] {\n        left: var(--vaadin-app-layout-drawer-offset-left, 0);\n      }\n\n      :host([dir=\"rtl\"][primary-section=\"drawer\"][drawer-opened]:not([overlay])) [part=\"navbar\"] {\n        right: var(--vaadin-app-layout-drawer-offset-left, 0);\n      }\n\n      :host([primary-section=\"drawer\"]) [part=\"drawer\"] {\n        top: 0;\n      }\n\n      [part=\"navbar\"][bottom] {\n        top: auto;\n        bottom: 0;\n        padding-bottom: var(--safe-area-inset-bottom);\n      }\n\n      [part=\"drawer\"] {\n        overflow: auto;\n        position: fixed;\n        top: var(--vaadin-app-layout-navbar-offset-top, 0);\n        right: auto;\n        bottom: var(--vaadin-app-layout-navbar-offset-bottom, var(--vaadin-viewport-offset-bottom, 0));\n        left: var(--vaadin-app-layout-navbar-offset-left, 0);\n        transition: transform var(--vaadin-app-layout-transition);\n        transform: translateX(-100%);\n        max-width: 90%;\n        width: 16em;\n        box-sizing: border-box;\n        padding: var(--safe-area-inset-top) 0 var(--safe-area-inset-bottom) var(--safe-area-inset-left);\n        outline: none;\n      }\n\n      :host([drawer-opened]) [part=\"drawer\"] {\n        transform: translateX(0%);\n        touch-action: manipulation;\n      }\n\n      [part=\"backdrop\"] {\n        background-color: #000;\n        opacity: 0.3;\n      }\n\n      :host(:not([drawer-opened])) [part=\"backdrop\"] {\n        opacity: 0;\n      }\n\n      :host([overlay]) [part=\"backdrop\"] {\n        position: fixed;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        pointer-events: none;\n        transition: opacity var(--vaadin-app-layout-transition);\n        -webkit-tap-highlight-color: transparent;\n      }\n\n      :host([overlay]) [part=\"drawer\"] {\n        top: 0;\n        bottom: 0;\n      }\n\n      :host([overlay]) [part=\"drawer\"],\n      :host([overlay]) [part=\"backdrop\"] {\n        z-index: 2;\n      }\n\n      :host([drawer-opened][overlay]) [part=\"backdrop\"] {\n        pointer-events: auto;\n        touch-action: manipulation;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"drawer\"] {\n        left: auto;\n        right: var(--vaadin-app-layout-navbar-offset-start, 0);\n        transform: translateX(100%);\n      }\n\n      :host([dir=\"rtl\"]) [part=\"navbar\"],\n      :host([dir=\"rtl\"]) [part=\"navbar\"]::before {\n        transition: right var(--vaadin-app-layout-transition);\n      }\n\n      :host([dir=\"rtl\"][drawer-opened]) [part='drawer'] {\n        transform: translateX(0%);\n      }\n\n      :host(:not([dir=\"rtl\"])[drawer-opened]:not([overlay])) {\n        padding-left: var(--vaadin-app-layout-drawer-offset-left);\n      }\n\n      :host([dir=\"rtl\"][drawer-opened]:not([overlay])) {\n        padding-right: var(--vaadin-app-layout-drawer-offset-left);\n      }\n\n      @media (max-width: 800px),\n      (max-height: 600px) {\n        :host {\n          --vaadin-app-layout-drawer-overlay: true;\n        }\n\n        [part=\"drawer\"] {\n          width: 20em;\n        }\n      }\n    </style>\n    <div part=\"navbar\" id=\"navbarTop\">\n      <slot name=\"navbar\"></slot>\n    </div>\n    <div part=\"backdrop\" on-click=\"_close\" on-touchstart=\"_close\"></div>\n    <div part=\"drawer\" id=\"drawer\">\n      <slot name=\"drawer\" id=\"drawerSlot\"></slot>\n    </div>\n    <div content=\"\">\n      <slot></slot>\n    </div>\n    <div part=\"navbar\" id=\"navbarBottom\" bottom=\"\" hidden=\"\">\n      <slot name=\"navbar-bottom\"></slot>\n    </div>\n    <div hidden=\"\"><slot id=\"touchSlot\" name=\"navbar touch-optimized\"></slot></div>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-app-layout';\n  }\n\n  static get version() {\n    return '2.2.0';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Defines whether navbar or drawer will come first visually.\n       * - By default (`primary-section=\"navbar\"`), the navbar takes the full available width and moves the drawer down.\n       * - If `primary-section=\"drawer\"` is set, then the drawer will move the navbar, taking the full available height.\n       * @attr {navbar|drawer} primary-section\n       * @type {!PrimarySection}\n       */\n      primarySection: {\n        type: String,\n        value: 'navbar',\n        notify: true,\n        reflectToAttribute: true,\n        observer: '_primarySectionObserver'\n      },\n\n      /**\n       * Controls whether the drawer is opened (visible) or not.\n       * Its default value depends on the viewport:\n       * - `true`, for desktop size views\n       * - `false`, for mobile size views\n       * @attr {boolean} drawer-opened\n       * @type {boolean}\n       */\n      drawerOpened: {\n        type: Boolean,\n        notify: true,\n        value: true,\n        reflectToAttribute: true,\n        observer: '_drawerOpenedObserver'\n      },\n\n      /**\n       *  Drawer is an overlay on top of the content\n       *  Controlled via CSS using `--vaadin-app-layout-drawer-overlay: true|false`;\n       * @type {boolean}\n       */\n      overlay: {\n        type: Boolean,\n        notify: true,\n        readOnly: true,\n        value: false,\n        reflectToAttribute: true\n      }\n    };\n  }\n\n  constructor() {\n    super(); // TODO(jouni): might want to debounce\n\n    this.__boundResizeListener = this._resize.bind(this);\n    this.__drawerToggleClickListener = this._drawerToggleClick.bind(this);\n    this.__closeOverlayDrawerListener = this.__closeOverlayDrawer.bind(this);\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    this._blockAnimationUntilAfterNextRender();\n\n    window.addEventListener('resize', this.__boundResizeListener);\n    this.addEventListener('drawer-toggle-click', this.__drawerToggleClickListener); // Wait for all children to upgrade before trying to measure sizes\n\n    if (window.HTMLImports && !window.HTMLImports.useNative) {\n      Array.from(this.querySelectorAll('*')).forEach(child => {\n        if (child.localName.indexOf('-') > -1) {\n          window.customElements.whenDefined(child.localName).then(() => {\n            // TODO(jouni): might want to debounce\n            beforeNextRender(this, this._afterFirstRender);\n          });\n        }\n      });\n    } else {\n      beforeNextRender(this, this._afterFirstRender);\n    }\n\n    this._updateTouchOptimizedMode();\n\n    var navbarSlot = this.$.navbarTop.firstElementChild;\n    this._navbarChildObserver = new FlattenedNodesObserver(navbarSlot, info => {\n      this._updateTouchOptimizedMode();\n    });\n    this._touchChildObserver = new FlattenedNodesObserver(this.$.touchSlot, info => {\n      this._updateTouchOptimizedMode();\n    });\n    this._drawerChildObserver = new FlattenedNodesObserver(this.$.drawerSlot, info => {\n      this._updateDrawerSize();\n    });\n\n    this._updateDrawerSize();\n\n    this._updateOverlayMode();\n\n    window.addEventListener('close-overlay-drawer', this.__closeOverlayDrawerListener);\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this._navbarChildObserver && this._navbarChildObserver.disconnect();\n    this._drawerChildObserver && this._drawerChildObserver.disconnect();\n    this._touchChildObserver && this._touchChildObserver.disconnect();\n    window.removeEventListener('resize', this.__boundResizeListener);\n    this.removeEventListener('drawer-toggle-click', this.__drawerToggleClickListener);\n    this.removeEventListener('close-overlay-drawer', this.__drawerToggleClickListener);\n  }\n  /**\n   * Helper static method that dispatches a `close-overlay-drawer` event\n   */\n\n\n  static dispatchCloseOverlayDrawerEvent() {\n    window.dispatchEvent(new CustomEvent('close-overlay-drawer'));\n  }\n  /** @private */\n\n\n  _primarySectionObserver(value) {\n    var isValid = ['navbar', 'drawer'].indexOf(value) !== -1;\n\n    if (!isValid) {\n      this.set('primarySection', 'navbar');\n    }\n  }\n  /** @private */\n\n\n  _drawerOpenedObserver() {\n    var drawer = this.$.drawer;\n    drawer.removeAttribute('tabindex');\n\n    if (this.overlay) {\n      if (this.drawerOpened) {\n        drawer.setAttribute('tabindex', 0);\n        drawer.focus();\n\n        this._updateDrawerHeight();\n      }\n    }\n  }\n  /** @private */\n\n\n  _isShadyCSS() {\n    return window.ShadyCSS && !window.ShadyCSS.nativeCss;\n  }\n  /** @protected */\n\n\n  _afterFirstRender() {\n    this._blockAnimationUntilAfterNextRender();\n\n    this._updateOffsetSize();\n  }\n  /** @private */\n\n\n  _drawerToggleClick(e) {\n    e.stopPropagation();\n    this.drawerOpened = !this.drawerOpened;\n  }\n  /** @private */\n\n\n  __closeOverlayDrawer() {\n    if (this.overlay) {\n      this.drawerOpened = false;\n    }\n  }\n  /** @protected */\n\n\n  _updateDrawerSize() {\n    var childCount = this.querySelectorAll('[slot=drawer]').length;\n    var drawer = this.$.drawer;\n\n    if (childCount === 0) {\n      drawer.setAttribute('hidden', '');\n    } else {\n      drawer.removeAttribute('hidden');\n    }\n\n    this._updateOffsetSize();\n  }\n  /** @private */\n\n\n  _resize() {\n    this._blockAnimationUntilAfterNextRender();\n\n    this._updateTouchOptimizedMode();\n\n    this._updateOverlayMode();\n  }\n  /** @protected */\n\n\n  _updateOffsetSize() {\n    var navbar = this.shadowRoot.querySelector('[part=\"navbar\"]');\n    var navbarRect = navbar.getBoundingClientRect();\n    var navbarBottom = this.shadowRoot.querySelector('[part=\"navbar\"][bottom]');\n    var navbarBottomRect = navbarBottom.getBoundingClientRect();\n\n    if (this._isShadyCSS()) {\n      window.ShadyCSS.styleSubtree(this, {\n        '--_vaadin-app-layout-navbar-offset-size': navbarRect.height + 'px',\n        '--_vaadin-app-layout-navbar-offset-size-bottom': navbarBottomRect.height + 'px'\n      });\n    } else {\n      this.style.setProperty('--_vaadin-app-layout-navbar-offset-size', navbarRect.height + 'px');\n      this.style.setProperty('--_vaadin-app-layout-navbar-offset-size-bottom', navbarBottomRect.height + 'px');\n    }\n\n    var drawer = this.$.drawer;\n    var drawerRect = drawer.getBoundingClientRect();\n\n    if (this._isShadyCSS()) {\n      window.ShadyCSS.styleSubtree(this, {\n        '--_vaadin-app-layout-drawer-offset-size': drawerRect.width + 'px',\n        // Have to update both because ShadyCSS may not apply the one below if not in use\n        '--vaadin-app-layout-drawer-offset-left': 'var(--_vaadin-app-layout-drawer-offset-size)'\n      });\n    } else {\n      this.style.setProperty('--_vaadin-app-layout-drawer-offset-size', drawerRect.width + 'px');\n    }\n  }\n  /** @protected */\n\n\n  _updateDrawerHeight() {\n    var {\n      scrollHeight,\n      offsetHeight\n    } = this.$.drawer;\n    var height = scrollHeight > offsetHeight ? `${scrollHeight}px` : '100%';\n\n    if (this._isShadyCSS()) {\n      window.ShadyCSS.styleSubtree(this, {\n        '--_vaadin-app-layout-drawer-scroll-size': height\n      });\n    } else {\n      this.style.setProperty('--_vaadin-app-layout-drawer-scroll-size', height);\n    }\n  }\n  /** @protected */\n\n\n  _updateOverlayMode() {\n    var overlay = this._getCustomPropertyValue('--vaadin-app-layout-drawer-overlay') == 'true';\n    var drawer = this.$.drawer;\n\n    if (!this.overlay && overlay) {\n      // Changed from not overlay to overlay\n      this._drawerStateSaved = this.drawerOpened;\n      this.drawerOpened = false;\n    }\n\n    this._setOverlay(overlay);\n\n    if (this.overlay) {\n      drawer.setAttribute('role', 'dialog');\n      drawer.setAttribute('aria-modal', 'true');\n      drawer.setAttribute('aria-label', 'drawer');\n    } else {\n      if (this._drawerStateSaved) {\n        this.drawerOpened = this._drawerStateSaved;\n        this._drawerStateSaved = null;\n      }\n\n      drawer.removeAttribute('role');\n      drawer.removeAttribute('aria-modal');\n      drawer.removeAttribute('aria-label');\n    }\n\n    this._updateDrawerHeight(); // TODO(jouni): ARIA attributes. The drawer should act similar to a modal dialog when in overlay mode\n\n  }\n  /** @protected */\n\n\n  _close() {\n    this.drawerOpened = false;\n  }\n  /** @private */\n\n\n  _getCustomPropertyValue(customProperty) {\n    var customPropertyValue;\n\n    if (this._isShadyCSS()) {\n      window.ShadyCSS.styleSubtree(this);\n      customPropertyValue = window.ShadyCSS.getComputedStyleValue(this, customProperty);\n    } else {\n      customPropertyValue = getComputedStyle(this).getPropertyValue(customProperty);\n    }\n\n    return (customPropertyValue || '').trim().toLowerCase();\n  }\n  /** @protected */\n\n\n  _updateTouchOptimizedMode() {\n    var touchOptimized = this._getCustomPropertyValue('--vaadin-app-layout-touch-optimized') == 'true';\n    var navbarItems = this.querySelectorAll('[slot*=\"navbar\"]');\n\n    if (navbarItems.length > 0) {\n      Array.from(navbarItems).forEach(navbar => {\n        if (navbar.getAttribute('slot').indexOf('touch-optimized') > -1) {\n          navbar.__touchOptimized = true;\n        }\n\n        if (touchOptimized && navbar.__touchOptimized) {\n          navbar.setAttribute('slot', 'navbar-bottom');\n        } else {\n          navbar.setAttribute('slot', 'navbar');\n        }\n      });\n    }\n\n    if (this.$.navbarTop.querySelector('[name=navbar]').assignedNodes().length === 0) {\n      this.$.navbarTop.setAttribute('hidden', '');\n    } else {\n      this.$.navbarTop.removeAttribute('hidden');\n    }\n\n    if (touchOptimized) {\n      this.$.navbarBottom.removeAttribute('hidden');\n    } else {\n      this.$.navbarBottom.setAttribute('hidden', '');\n    }\n\n    this._updateOffsetSize();\n  }\n  /** @protected */\n\n\n  _blockAnimationUntilAfterNextRender() {\n    this.setAttribute('no-anim', '');\n    afterNextRender(this, () => {\n      this.removeAttribute('no-anim');\n\n      if (this._isShadyCSS()) {\n        window.ShadyCSS.styleSubtree(this);\n      }\n    });\n  }\n  /**\n   * App Layout listens to `close-overlay-drawer` on the window level.\n   * A custom event can be dispatched and the App Layout will close the drawer in overlay.\n   *\n   * That can be used, for instance, when a navigation occurs when user clicks in a menu item inside the drawer.\n   *\n   * See `dispatchCloseOverlayDrawerEvent()` helper method.\n   *\n   * @event close-overlay-drawer\n   */\n\n\n}\n\ncustomElements.define(AppLayoutElement.is, AppLayoutElement);\nexport { AppLayoutElement };"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/iconset.js?babel-target=es6",
     "source": "import './version.js';\nimport '@polymer/iron-iconset-svg/iron-iconset-svg.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<iron-iconset-svg size=\"1000\" name=\"lumo\">\n<svg xmlns=\"http://www.w3.org/2000/svg\">\n<defs>\n<g id=\"angle-down\"><path d=\"M283 391c-18-16-46-15-63 4-16 18-15 46 3 63l244 224c17 15 43 15 60 0l250-229c18-16 20-45 3-63-16-18-45-20-63-4l-220 203-214-198z\"></path></g>\n<g id=\"angle-left\"><path d=\"M601 710c16 18 15 46-3 63-18 16-46 15-63-4l-224-244c-15-17-15-43 0-59l229-250c16-18 45-20 63-4 18 16 20 45 3 63l-203 220 198 215z\"></path></g>\n<g id=\"angle-right\"><path d=\"M399 275c-16-18-15-46 3-63 18-16 46-15 63 4l224 244c15 17 15 43 0 59l-229 250c-16 18-45 20-63 4-18-16-20-45-3-63l203-220-198-215z\"></path></g>\n<g id=\"angle-up\"><path d=\"M283 635c-18 16-46 15-63-3-16-18-15-46 3-63l244-224c17-15 43-15 60 0l250 229c18 16 20 45 3 63-16 18-45 20-63 3l-220-202L283 635z\"></path></g>\n<g id=\"arrow-down\"><path d=\"M538 646l125-112c15-14 39-12 53 4 14 15 12 39-4 53l-187 166c0 0 0 0 0 0-14 13-36 12-50 0l-187-166c-15-14-17-37-4-53 14-15 37-17 53-4L462 646V312c0-21 17-38 38-37s38 17 37 37v334z\"></path></g>\n<g id=\"arrow-left\"><path d=\"M375 538l111 125c14 15 12 39-3 53-15 14-39 12-53-4l-166-187c0 0 0 0 0 0-13-14-12-36 0-50l166-187c14-15 37-17 53-4 15 14 17 37 3 53L375 463h333c21 0 38 17 38 37 0 21-17 38-38 38h-333z\"></path></g>\n<g id=\"arrow-right\"><path d=\"M625 538h-333c-21 0-38-17-38-38 0-21 17-38 38-37h333l-111-126c-14-15-12-39 3-53 15-14 39-12 53 4l166 187c13 14 13 36 0 50 0 0 0 0 0 0l-166 187c-14 15-37 17-53 4-15-14-17-37-3-53l111-125z\"></path></g>\n<g id=\"arrow-up\"><path d=\"M538 354V688c0 21-17 38-38 37s-38-17-38-38V354l-125 112c-15 14-39 12-53-4-14-15-12-39 4-53l187-166c14-13 36-13 50 0 0 0 0 0 0 0l187 166c15 14 17 37 4 53-14 15-37 17-53 4L538 354z\"></path></g>\n<g id=\"bar-chart\"><path d=\"M175 500h108c28 0 50 22 50 50v233c0 28-22 50-50 50H175c-28 0-50-22-50-50v-233c0-28 22-50 50-50z m33 67c-9 0-17 7-16 16v167c0 9 7 17 16 17h42c9 0 17-7 17-17v-167c0-9-7-17-17-16H208zM446 167h108c28 0 50 22 50 50v566c0 28-22 50-50 50h-108c-28 0-50-22-50-50V217c0-28 22-50 50-50z m33 66c-9 0-17 7-17 17v500c0 9 7 17 17 17h42c9 0 17-7 16-17V250c0-9-7-17-16-17h-42zM717 333h108c28 0 50 22 50 50v400c0 28-22 50-50 50h-108c-28 0-50-22-50-50V383c0-28 22-50 50-50z m33 67c-9 0-17 7-17 17v333c0 9 7 17 17 17h42c9 0 17-7 16-17v-333c0-9-7-17-16-17h-42z\"></path></g>\n<g id=\"bell\"><path d=\"M367 675H292v-258C292 325 366 250 459 250H458V208c0-23 18-42 42-41 23 0 42 18 42 41v42h-1C634 250 708 325 708 417V675h-75v-258c0-51-41-92-91-92h-84C408 325 367 366 367 417V675z m-159 37c0-21 17-38 38-37h508c21 0 37 17 38 37 0 21-17 38-38 38H246C225 750 208 733 208 713z m230 71h125v32c0 17-14 31-32 31h-62c-17 0-32-14-31-31v-32z\"></path></g>\n<g id=\"calendar\"><path d=\"M375 208h250v-20C625 176 634 167 646 167h41C699 167 708 176 708 188V208h74c23 0 41 19 41 42v42C823 315 804 333 782 333H218C196 333 177 315 177 292V250C177 227 196 208 218 208H292v-20C292 176 301 167 313 167h41C366 167 375 176 375 188V208zM229 375h42C283 375 292 384 292 396v41C292 449 282 458 271 458h-42C217 458 208 449 208 437v-41C208 384 218 375 229 375z m125 0h42C408 375 417 384 417 396v41C417 449 407 458 396 458h-42C342 458 333 449 333 437v-41C333 384 343 375 354 375z m125 0h42C533 375 542 384 542 396v41C542 449 532 458 521 458h-42C467 458 458 449 458 437v-41C458 384 468 375 479 375z m-250 125h42C283 500 292 509 292 521v41C292 574 282 583 271 583h-42C217 583 208 574 208 562v-41C208 509 218 500 229 500z m125 0h42C408 500 417 509 417 521v41C417 574 407 583 396 583h-42C342 583 333 574 333 562v-41C333 509 343 500 354 500z m125 0h42c12 0 21 9 21 21v41C542 574 532 583 521 583h-42C467 583 458 574 458 562v-41C458 509 468 500 479 500z m-250 125h42C283 625 292 634 292 646v41C292 699 282 708 271 708h-42C217 708 208 699 208 687v-41C208 634 218 625 229 625z m125 0h42C408 625 417 634 417 646v41C417 699 407 708 396 708h-42C342 708 333 699 333 687v-41C333 634 343 625 354 625z m125 0h42c12 0 21 9 21 21v41C542 699 532 708 521 708h-42C467 708 458 699 458 687v-41C458 634 468 625 479 625z m125-250h42C658 375 667 384 667 396v41C667 449 657 458 646 458h-42C592 458 583 449 583 437v-41C583 384 593 375 604 375z m0 125h42c12 0 21 9 21 21v41C667 574 657 583 646 583h-42C592 583 583 574 583 562v-41C583 509 593 500 604 500z m0 125h42c12 0 21 9 21 21v41C667 699 657 708 646 708h-42C592 708 583 699 583 687v-41C583 634 593 625 604 625z m125 0h42c12 0 21 9 21 21v41C792 699 782 708 771 708h-42C717 708 708 699 708 687v-41C708 634 718 625 729 625z m-500 125h42C283 750 292 759 292 771v41C292 824 282 833 271 833h-42C217 833 208 824 208 812v-41C208 759 218 750 229 750z m125 0h42C408 750 417 759 417 771v41C417 824 407 833 396 833h-42C342 833 333 824 333 812v-41C333 759 343 750 354 750z m125 0h42c12 0 21 9 21 21v41C542 824 532 833 521 833h-42C467 833 458 824 458 812v-41C458 759 468 750 479 750z m125 0h42c12 0 21 9 21 21v41C667 824 657 833 646 833h-42C592 833 583 824 583 812v-41C583 759 593 750 604 750z m125 0h42c12 0 21 9 21 21v41C792 824 782 833 771 833h-42C717 833 708 824 708 812v-41C708 759 718 750 729 750z m0-250h42c12 0 21 9 21 21v41C792 574 782 583 771 583h-42C717 583 708 574 708 562v-41C708 509 718 500 729 500z m0-125h42C783 375 792 384 792 396v41C792 449 782 458 771 458h-42C717 458 708 449 708 437v-41C708 384 718 375 729 375z\"></path></g>\n<g id=\"checkmark\"><path d=\"M318 493c-15-15-38-15-53 0-15 15-15 38 0 53l136 136c15 15 38 15 53 0l323-322c15-15 15-38 0-53-15-15-38-15-54 0l-295 296-110-110z\"></path></g>\n<g id=\"chevron-down\"><path d=\"M533 654l210-199c9-9 9-23 0-32C739 419 733 417 726 417H274C261 417 250 427 250 439c0 6 2 12 7 16l210 199c18 17 48 17 66 0z\"></path></g>\n<g id=\"chevron-left\"><path d=\"M346 533l199 210c9 9 23 9 32 0 4-4 7-10 6-17V274C583 261 573 250 561 250c-6 0-12 2-16 7l-199 210c-17 18-17 48 0 66z\"></path></g>\n<g id=\"chevron-right\"><path d=\"M654 533L455 743c-9 9-23 9-32 0C419 739 417 733 417 726V274C417 261 427 250 439 250c6 0 12 2 16 7l199 210c17 18 17 48 0 66z\"></path></g>\n<g id=\"chevron-up\"><path d=\"M533 346l210 199c9 9 9 23 0 32-4 4-10 7-17 6H274C261 583 250 573 250 561c0-6 2-12 7-16l210-199c18-17 48-17 66 0z\"></path></g>\n<g id=\"clock\"><path d=\"M538 489l85 85c15 15 15 38 0 53-15 15-38 15-53 0l-93-93a38 38 0 0 1-2-2C467 525 462 515 462 504V308c0-21 17-38 38-37 21 0 38 17 37 37v181zM500 833c-184 0-333-149-333-333s149-333 333-333 333 149 333 333-149 333-333 333z m0-68c146 0 265-118 265-265 0-146-118-265-265-265-146 0-265 118-265 265 0 146 118 265 265 265z\"></path></g>\n<g id=\"cog\"><path d=\"M833 458l-81-18c-8-25-17-50-29-75L767 292 708 233l-72 49c-21-12-46-25-75-30L542 167h-84l-19 79c-25 8-50 17-71 30L296 233 233 296l47 69c-12 21-21 46-29 71L167 458v84l84 25c8 25 17 50 29 75L233 708 292 767l76-44c21 12 46 25 75 29L458 833h84l19-81c25-8 50-17 75-29L708 767l59-59-44-66c12-21 25-46 29-75L833 542v-84z m-333 217c-96 0-175-79-175-175 0-96 79-175 175-175 96 0 175 79 175 175 0 96-79 175-175 175z\"></path></g>\n<g id=\"cross\"><path d=\"M445 500l-142-141c-15-15-15-40 0-56 15-15 40-15 56 0L500 445l141-142c15-15 40-15 56 0 15 15 15 40 0 56L555 500l142 141c15 15 15 40 0 56-15 15-40 15-56 0L500 555l-141 142c-15 15-40 15-56 0-15-15-15-40 0-56L445 500z\"></path></g>\n<g id=\"download\"><path d=\"M538 521l125-112c15-14 39-12 53 4 14 15 12 39-4 53l-187 166a38 38 0 0 1 0 0c-14 13-36 12-50 0l-187-166c-15-14-17-37-4-53 14-15 37-17 53-4L462 521V188c0-21 17-38 38-38s38 17 37 38v333zM758 704c0-21 17-38 38-37 21 0 38 17 37 37v92c0 21-17 38-37 37H204c-21 0-38-17-37-37v-92c0-21 17-38 37-37s38 17 38 37v54h516v-54z\"></path></g>\n<g id=\"dropdown\"><path d=\"M317 393c-15-14-39-13-53 3-14 15-13 39 3 53l206 189c14 13 36 13 50 0l210-193c15-14 17-38 3-53-14-15-38-17-53-3l-185 171L317 393z\"></path></g>\n<g id=\"edit\"><path d=\"M673 281l62 56-205 233c-9 10-38 24-85 39a8 8 0 0 1-5 0c-4-1-7-6-6-10l0 0c14-47 25-76 35-86l204-232z m37-42l52-59c15-17 41-18 58-2 17 16 18 42 3 59L772 295l-62-56zM626 208l-67 75h-226C305 283 283 306 283 333v334C283 695 306 717 333 717h334c28 0 50-22 50-50v-185L792 398v269C792 736 736 792 667 792H333C264 792 208 736 208 667V333C208 264 264 208 333 208h293z\"></path></g>\n<g id=\"error\"><path d=\"M500 833c-184 0-333-149-333-333s149-333 333-333 333 149 333 333-149 333-333 333z m0-68c146 0 265-118 265-265 0-146-118-265-265-265-146 0-265 118-265 265 0 146 118 265 265 265zM479 292h42c12 0 21 9 20 20l-11 217c0 8-6 13-13 13h-34c-7 0-13-6-13-13l-11-217C459 301 468 292 479 292zM483 608h34c12 0 21 9 20 21v33c0 12-9 21-20 21h-34c-12 0-21-9-21-21v-33c0-12 9-21 21-21z\"></path></g>\n<g id=\"eye-disabled\"><path d=\"M396 735l60-60c15 2 30 3 44 3 89 0 178-34 258-90 31-22 59-46 78-69 6-7 12-14 16-19-4-6-9-12-16-19-20-22-47-46-78-69-8-5-15-11-23-15l50-51C862 397 917 458 917 500c0 87-230 250-417 250-34 0-69-5-104-15zM215 654C138 603 83 542 83 500c0-87 230-250 417-250 34 0 69 5 104 15l-59 60c-15-2-30-3-45-3-89 0-178 34-258 90-31 22-59 46-78 69-6 7-12 14-16 19 4 6 9 12 16 19 20 22 47 46 78 69 8 5 16 11 24 16L215 654z m271-9l159-159c0 5 1 9 1 14 0 81-65 146-146 146-5 0-9 0-14-1z m-131-131C354 510 354 505 354 500c0-81 65-146 146-146 5 0 10 0 14 1l-159 159z m-167 257L780 179c12-12 32-12 44 0 12 12 12 32 0 44L232 815c-12 12-32 12-44 0s-12-32 0-44z\"></path></g>\n<g id=\"eye\"><path d=\"M500 750c-187 0-417-163-417-250s230-250 417-250 417 163 417 250-230 250-417 250z m-336-231c20 22 47 46 78 69C322 644 411 678 500 678s178-34 258-90c31-22 59-46 78-69 6-7 12-14 16-19-4-6-9-12-16-19-20-22-47-46-78-69C678 356 589 322 500 322s-178 34-258 90c-31 22-59 46-78 69-6 7-12 14-16 19 4 6 9 12 16 19zM500 646c-81 0-146-65-146-146s65-146 146-146 146 65 146 146-65 146-146 146z m0-75c39 0 71-32 71-71 0-39-32-71-71-71-39 0-71 32-71 71 0 39 32 71 71 71z\"></path></g>\n<g id=\"menu\"><path d=\"M167 292c0-23 19-42 41-42h584C815 250 833 268 833 292c0 23-19 42-41 41H208C185 333 167 315 167 292z m0 208c0-23 19-42 41-42h584C815 458 833 477 833 500c0 23-19 42-41 42H208C185 542 167 523 167 500z m0 208c0-23 19-42 41-41h584C815 667 833 685 833 708c0 23-19 42-41 42H208C185 750 167 732 167 708z\"></path></g>\n<g id=\"minus\"><path d=\"M261 461c-22 0-39 18-39 39 0 22 18 39 39 39h478c22 0 39-18 39-39 0-22-18-39-39-39H261z\"></path></g>\n<g id=\"ordered-list\"><path d=\"M138 333V198H136l-43 28v-38l45-31h45V333H138z m-61 128c0-35 27-59 68-59 39 0 66 21 66 53 0 20-11 37-43 64l-29 27v2h74V583H80v-30l55-52c26-24 32-33 33-43 0-13-10-22-24-22-15 0-26 10-26 25v1h-41v-1zM123 759v-31h21c15 0 25-8 25-21 0-13-10-21-25-21-15 0-26 9-26 23h-41c1-34 27-56 68-57 39 0 66 20 66 49 0 20-14 36-33 39v3c24 3 40 19 39 41 0 32-30 54-73 54-41 0-69-22-70-57h43c1 13 11 22 28 22 16 0 27-9 27-22 0-14-10-22-28-22h-21zM333 258c0-18 15-33 34-33h516c18 0 33 15 34 33 0 18-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z\"></path></g>\n<g id=\"phone\"><path d=\"M296 208l42-37c17-15 44-13 58 4a42 42 0 0 1 5 7L459 282c12 20 5 45-15 57l-7 4c-17 10-25 30-19 48l20 66a420 420 0 0 0 93 157l41 45c13 14 35 17 51 8l7-5c20-12 45-5 57 16L745 777c12 20 5 45-15 57a42 42 0 0 1-8 4l-52 17c-61 21-129 4-174-43l-50-52c-81-85-141-189-175-302l-24-78c-19-62 0-129 49-172z\"></path></g>\n<g id=\"photo\"><path d=\"M208 167h584c69 0 125 56 125 125v416c0 69-56 125-125 125H208c-69 0-125-56-125-125V292c0-69 56-125 125-125z m584 75H208c-28 0-50 22-50 50v416c0 28 22 50 50 50h584c28 0 50-22 50-50V292c0-28-22-50-50-50zM239 740l167-167c12-12 31-14 45-6l73 43 172-201c13-15 34-18 50-7l95 67v92l-111-78-169 199c-12 14-32 17-47 8l-76-43-111 111H229c2-7 5-13 10-18zM458 427C458 490 407 542 344 542S229 490 229 427c0-63 51-115 115-115S458 364 458 427z m-62 0C396 398 373 375 344 375S292 398 292 427c0 29 23 52 52 52s52-23 52-52z\"></path></g>\n<g id=\"play\"><path d=\"M689 528l-298 175c-13 8-34 8-48 0-6-4-10-9-10-14V311C333 300 348 292 367 292c9 0 17 2 24 5l298 175c26 15 26 40 0 56z\"></path></g>\n<g id=\"plus\"><path d=\"M461 461H261c-22 0-39 18-39 39 0 22 18 39 39 39h200v200c0 22 18 39 39 39 22 0 39-18 39-39v-200h200c22 0 39-18 39-39 0-22-18-39-39-39h-200V261c0-22-18-39-39-39-22 0-39 18-39 39v200z\"></path></g>\n<g id=\"redo\"><path d=\"M290 614C312 523 393 458 491 458c55 0 106 22 144 57l-88 88c-3 3-5 7-5 11 0 8 6 15 15 15l193-5c17 0 31-15 31-32l5-192c0-4-1-8-4-11-6-6-16-6-22 0l-66 67C641 406 570 375 491 375c-136 0-248 90-281 215-1 2-1 5-1 8-8 44 45 68 73 32 4-5 7-11 8-16z\"></path></g>\n<g id=\"reload\"><path d=\"M500 233V137c0-9 7-16 15-16 4 0 8 2 10 4l133 140c12 12 12 32 0 45l-133 140c-6 6-15 6-21 0C502 447 500 443 500 438V308c-117 0-212 95-212 213 0 117 95 212 212 212 117 0 212-95 212-212 0-21 17-38 38-38s38 17 37 38c0 159-129 288-287 287-159 0-288-129-288-287 0-159 129-288 288-288z\"></path></g>\n<g id=\"search\"><path d=\"M662 603l131 131c16 16 16 42 0 59-16 16-43 16-59 0l-131-131C562 691 512 708 458 708c-138 0-250-112-250-250 0-138 112-250 250-250 138 0 250 112 250 250 0 54-17 104-46 145zM458 646c104 0 188-84 188-188S562 271 458 271 271 355 271 458s84 188 187 188z\"></path></g>\n<g id=\"undo\"><path d=\"M710 614C688 523 607 458 509 458c-55 0-106 22-144 57l88 88c3 3 5 7 5 11 0 8-6 15-15 15l-193-5c-17 0-31-15-31-32L214 400c0-4 1-8 4-11 6-6 16-6 22 0l66 67C359 406 430 375 509 375c136 0 248 90 281 215 1 2 1 5 1 8 8 44-45 68-73 32-4-5-7-11-8-16z\"></path></g>\n<g id=\"unordered-list\"><path d=\"M146 325c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63z m0 250c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63z m0 250c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63zM333 258c0-18 15-33 34-33h516c18 0 33 15 34 33 0 18-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z\"></path></g>\n<g id=\"upload\"><path d=\"M454 271V604c0 21-17 38-37 38s-38-17-38-38V271L254 382c-15 14-39 12-53-3-14-15-12-39 3-53L391 160c14-13 36-13 51-1 0 0 0 0 0 1l187 166c15 14 17 37 3 53-14 15-37 17-53 3L454 271zM675 704c0-21 17-38 37-37 21 0 38 17 38 37v92c0 21-17 38-38 37H121c-21 0-38-17-38-37v-92c0-21 17-38 38-37s38 17 37 37v54h517v-54z\"></path></g>\n<g id=\"user\"><path d=\"M500 500c-69 0-125-56-125-125s56-125 125-125 125 56 125 125-56 125-125 125z m-292 292c0-115 131-208 292-209s292 93 292 209H208z\"></path></g>\n</defs>\n</svg>\n</iron-iconset-svg>`;\ndocument.head.appendChild($_documentContainer.content);\n/* NOTICE: Generated with 'gulp icons' */\n\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\n\n;"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-ordered-layout/theme/lumo/vaadin-vertical-layout-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/spacing.js';\nimport './vaadin-ordered-layout.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-vertical-layout\" theme-for=\"vaadin-vertical-layout\">\n  <template>\n    <style include=\"lumo-ordered-layout\">\n      :host([theme~=\"spacing-xs\"]) ::slotted(*) {\n        margin-top: var(--lumo-space-xs);\n      }\n\n      :host([theme~=\"spacing-s\"]) ::slotted(*) {\n        margin-top: var(--lumo-space-s);\n      }\n\n      :host([theme~=\"spacing\"]) ::slotted(*) {\n        margin-top: var(--lumo-space-m);\n      }\n\n      :host([theme~=\"spacing-l\"]) ::slotted(*) {\n        margin-top: var(--lumo-space-l);\n      }\n\n      :host([theme~=\"spacing-xl\"]) ::slotted(*) {\n        margin-top: var(--lumo-space-xl);\n      }\n\n      /*\n        Compensate for the first item margin, so that there is no gap around\n        the layout itself.\n       */\n       :host([theme~=\"spacing-xs\"])::before {\n         content: \"\";\n         margin-top: calc(var(--lumo-space-xs) * -1);\n       }\n\n       :host([theme~=\"spacing-s\"])::before {\n         content: \"\";\n         margin-top: calc(var(--lumo-space-s) * -1);\n       }\n\n      :host([theme~=\"spacing\"])::before {\n        content: \"\";\n        margin-top: calc(var(--lumo-space-m) * -1);\n      }\n\n      :host([theme~=\"spacing-l\"])::before {\n        content: \"\";\n        margin-top: calc(var(--lumo-space-l) * -1);\n      }\n\n      :host([theme~=\"spacing-xl\"])::before {\n        content: \"\";\n        margin-top: calc(var(--lumo-space-xl) * -1);\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-ordered-layout/src/vaadin-vertical-layout.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-vertical-layout>` provides a simple way to vertically align your HTML elements.\n *\n * ```\n * <vaadin-vertical-layout>\n *   <div>Item 1</div>\n *   <div>Item 2</div>\n * </vaadin-vertical-layout>\n * ```\n *\n * ### Built-in Theme Variations\n *\n * `<vaadin-vertical-layout>` supports the following theme variations:\n *\n * Theme variation | Description\n * ---|---\n * `theme=\"margin\"` | Applies the default amount of CSS margin for the host element (specified by the theme)\n * `theme=\"padding\"` | Applies the default amount of CSS padding for the host element (specified by the theme)\n * `theme=\"spacing\"` | Applies the default amount of CSS margin between items (specified by the theme)\n *\n * @extends PolymerElement\n * @mixes ThemableMixin\n * @mixes ElementMixin\n * @demo demo/index.html\n */\n\nclass VerticalLayoutElement extends ElementMixin(ThemableMixin(PolymerElement)) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: flex;\n        flex-direction: column;\n        align-items: flex-start;\n        box-sizing: border-box;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      /* Theme variations */\n      :host([theme~=\"margin\"]) {\n        margin: 1em;\n      }\n\n      :host([theme~=\"padding\"]) {\n        padding: 1em;\n      }\n\n      :host([theme~=\"spacing\"]) ::slotted(*) {\n        margin-top: 1em;\n      }\n\n      /*\n        Compensate for the first item margin, so that there is no gap around\n        the layout itself.\n       */\n      :host([theme~=\"spacing\"])::before {\n        content: \"\";\n        margin-top: -1em;\n      }\n    </style>\n\n    <slot></slot>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-vertical-layout';\n  }\n\n  static get version() {\n    return '1.4.0';\n  }\n\n}\n\ncustomElements.define(VerticalLayoutElement.is, VerticalLayoutElement);\nexport { VerticalLayoutElement };"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-tabs/theme/lumo/vaadin-tab-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-tab\" theme-for=\"vaadin-tab\">\n  <template>\n    <style>\n      :host {\n        box-sizing: border-box;\n        padding: 0.5rem 0.75rem;\n        font-family: var(--lumo-font-family);\n        font-size: var(--lumo-font-size-m);\n        line-height: var(--lumo-line-height-xs);\n        font-weight: 500;\n        opacity: 1;\n        color: var(--lumo-contrast-60pct);\n        transition: 0.15s color, 0.2s transform;\n        flex-shrink: 0;\n        display: flex;\n        align-items: center;\n        position: relative;\n        cursor: pointer;\n        transform-origin: 50% 100%;\n        outline: none;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n        overflow: hidden;\n        min-width: var(--lumo-size-m);\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      :host(:not([orientation=\"vertical\"])) {\n        text-align: center;\n      }\n\n      :host([orientation=\"vertical\"]) {\n        transform-origin: 0% 50%;\n        padding: 0.25rem 1rem;\n        min-height: var(--lumo-size-m);\n        min-width: 0;\n      }\n\n      :host(:hover),\n      :host([focus-ring]) {\n        color: var(--lumo-body-text-color);\n      }\n\n      :host([selected]) {\n        color: var(--lumo-primary-text-color);\n        transition: 0.6s color;\n      }\n\n      :host([active]:not([selected])) {\n        color: var(--lumo-primary-text-color);\n        transition-duration: 0.1s;\n      }\n\n      :host::before,\n      :host::after {\n        content: \"\";\n        position: absolute;\n        display: var(--_lumo-tab-marker-display, block);\n        bottom: 0;\n        left: 50%;\n        width: var(--lumo-size-s);\n        height: 2px;\n        background-color: var(--lumo-contrast-60pct);\n        border-radius: var(--lumo-border-radius) var(--lumo-border-radius) 0 0;\n        transform: translateX(-50%) scale(0);\n        transform-origin: 50% 100%;\n        transition: 0.14s transform cubic-bezier(.12, .32, .54, 1);\n        will-change: transform;\n      }\n\n      :host([selected])::before,\n      :host([selected])::after {\n        background-color: var(--lumo-primary-color);\n      }\n\n      :host([orientation=\"vertical\"])::before,\n      :host([orientation=\"vertical\"])::after {\n        left: 0;\n        bottom: 50%;\n        transform: translateY(50%) scale(0);\n        width: 2px;\n        height: var(--lumo-size-xs);\n        border-radius: 0 var(--lumo-border-radius) var(--lumo-border-radius) 0;\n        transform-origin: 100% 50%;\n      }\n\n      :host::after {\n        box-shadow: 0 0 0 4px var(--lumo-primary-color);\n        opacity: 0.15;\n        transition: 0.15s 0.02s transform, 0.8s 0.17s opacity;\n      }\n\n      :host([selected])::before,\n      :host([selected])::after {\n        transform: translateX(-50%) scale(1);\n        transition-timing-function: cubic-bezier(.12, .32, .54, 1.5);\n      }\n\n      :host([orientation=\"vertical\"][selected])::before,\n      :host([orientation=\"vertical\"][selected])::after {\n        transform: translateY(50%) scale(1);\n      }\n\n      :host([selected]:not([active]))::after {\n        opacity: 0;\n      }\n\n      :host(:not([orientation=\"vertical\"])) ::slotted(a[href]) {\n        justify-content: center;\n      }\n\n      :host ::slotted(a) {\n        display: flex;\n        width: 100%;\n        align-items: center;\n        height: 100%;\n        margin: -0.5rem -0.75rem;\n        padding: 0.5rem 0.75rem;\n        outline: none;\n\n        /*\n          Override the CSS inherited from \\`lumo-color\\` and \\`lumo-typography\\`.\n          Note: \\`!important\\` is needed because of the \\`:slotted\\` specificity.\n        */\n        text-decoration: none !important;\n        color: inherit !important;\n      }\n\n      :host ::slotted(iron-icon) {\n        margin: 0 4px;\n        width: var(--lumo-icon-size-m);\n        height: var(--lumo-icon-size-m);\n      }\n\n      /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */\n      :host ::slotted(iron-icon[icon^=\"vaadin:\"]) {\n        padding: 0.25rem;\n        box-sizing: border-box !important;\n      }\n\n      :host(:not([dir=\"rtl\"])) ::slotted(iron-icon:first-child) {\n        margin-left: 0;\n      }\n\n      :host(:not([dir=\"rtl\"])) ::slotted(iron-icon:last-child) {\n        margin-right: 0;\n      }\n\n      :host([theme~=\"icon-on-top\"]) {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: space-around;\n        text-align: center;\n        padding-bottom: 0.5rem;\n        padding-top: 0.25rem;\n      }\n\n      :host([theme~=\"icon-on-top\"]) ::slotted(a) {\n        flex-direction: column;\n        align-items: center;\n        margin-top: -0.25rem;\n        padding-top: 0.25rem;\n      }\n\n      :host([theme~=\"icon-on-top\"]) ::slotted(iron-icon) {\n        margin: 0;\n      }\n\n      /* Disabled */\n\n      :host([disabled]) {\n        pointer-events: none;\n        opacity: 1;\n        color: var(--lumo-disabled-text-color);\n      }\n\n      /* Focus-ring */\n\n      :host([focus-ring]) {\n        box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);\n        border-radius: var(--lumo-border-radius);\n      }\n\n      /* RTL specific styles */\n\n      :host([dir=\"rtl\"])::before,\n      :host([dir=\"rtl\"])::after {\n        left: auto;\n        right: 50%;\n        transform: translateX(50%) scale(0);\n      }\n\n      :host([dir=\"rtl\"][selected]:not([orientation=\"vertical\"]))::before,\n      :host([dir=\"rtl\"][selected]:not([orientation=\"vertical\"]))::after {\n        transform: translateX(50%) scale(1);\n      }\n\n      :host([dir=\"rtl\"]) ::slotted(iron-icon:first-child) {\n        margin-right: 0;\n      }\n\n      :host([dir=\"rtl\"]) ::slotted(iron-icon:last-child) {\n        margin-left: 0;\n      }\n\n      :host([orientation=\"vertical\"][dir=\"rtl\"]) {\n        transform-origin: 100% 50%;\n      }\n\n      :host([dir=\"rtl\"][orientation=\"vertical\"])::before,\n      :host([dir=\"rtl\"][orientation=\"vertical\"])::after {\n        left: auto;\n        right: 0;\n        border-radius: var(--lumo-border-radius) 0 0 var(--lumo-border-radius);\n        transform-origin: 0% 50%;\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-tabs/src/vaadin-tab.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ItemMixin } from '@vaadin/vaadin-item/src/vaadin-item-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-tab>` is a Web Component providing an accessible and customizable tab.\n *\n * ```\n *   <vaadin-tab>\n *     Tab 1\n *   </vaadin-tab>\n * ```\n *\n * The following state attributes are available for styling:\n *\n * Attribute  | Description | Part name\n * -----------|-------------|------------\n * `disabled` | Set to a disabled tab | :host\n * `focused` | Set when the element is focused | :host\n * `focus-ring` | Set when the element is keyboard focused | :host\n * `selected` | Set when the tab is selected | :host\n * `active` | Set when mousedown or enter/spacebar pressed | :host\n * `orientation` | Set to `horizontal` or `vertical` depending on the direction of items  | :host\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @mixes ItemMixin\n */\n\nclass TabElement extends ElementMixin(ThemableMixin(ItemMixin(PolymerElement))) {\n  static get template() {\n    return html`\n    <slot></slot>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-tab';\n  }\n\n  static get version() {\n    return '3.2.0';\n  }\n\n  ready() {\n    super.ready();\n    this.setAttribute('role', 'tab');\n  }\n  /**\n   * @param {!KeyboardEvent} event\n   * @protected\n   */\n\n\n  _onKeyup(event) {\n    var willClick = this.hasAttribute('active');\n\n    super._onKeyup(event);\n\n    if (willClick) {\n      var anchor = this.querySelector('a');\n\n      if (anchor) {\n        anchor.click();\n      }\n    }\n  }\n\n}\n\ncustomElements.define(TabElement.is, TabElement);\nexport { TabElement };"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-tabs/theme/lumo/vaadin-tabs-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-tabs\" theme-for=\"vaadin-tabs\">\n  <template>\n    <style>\n      :host {\n        -webkit-tap-highlight-color: transparent;\n      }\n\n      :host(:not([orientation=\"vertical\"])) {\n        box-shadow: inset 0 -1px 0 0 var(--lumo-contrast-10pct);\n        position: relative;\n        min-height: var(--lumo-size-l);\n      }\n\n      :host([orientation=\"horizontal\"]) [part=\"tabs\"] ::slotted(vaadin-tab:not([theme~=\"icon-on-top\"])) {\n        justify-content: center;\n      }\n\n      :host([orientation=\"vertical\"]) {\n        box-shadow: -1px 0 0 0 var(--lumo-contrast-10pct);\n      }\n\n      :host([orientation=\"horizontal\"]) [part=\"tabs\"] {\n        margin: 0 0.75rem;\n      }\n\n      :host([orientation=\"vertical\"]) [part=\"tabs\"] {\n        width: 100%;\n        margin: 0.5rem 0;\n      }\n\n      [part=\"forward-button\"],\n      [part=\"back-button\"] {\n        position: absolute;\n        z-index: 1;\n        font-family: lumo-icons;\n        color: var(--lumo-tertiary-text-color);\n        font-size: var(--lumo-icon-size-m);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 1.5em;\n        height: 100%;\n        transition: 0.2s opacity;\n        top: 0;\n      }\n\n      [part=\"forward-button\"]:hover,\n      [part=\"back-button\"]:hover {\n        color: inherit;\n      }\n\n      :host(:not([dir=\"rtl\"])) [part=\"forward-button\"] {\n        right: 0;\n      }\n\n      [part=\"forward-button\"]::after {\n        content: var(--lumo-icons-angle-right);\n      }\n\n      [part=\"back-button\"]::after {\n        content: var(--lumo-icons-angle-left);\n      }\n\n      /* Tabs overflow */\n\n      [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: none;\n        -webkit-mask-image: var(--_lumo-tabs-overflow-mask-image);\n        /* For IE11 */\n        min-height: var(--lumo-size-l);\n      }\n\n      /*\n        TODO: CSS custom property in \\`mask-image\\` causes crash in Edge\n        see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/15415089/\n      */\n      @-moz-document url-prefix() {\n        [part=\"tabs\"] {\n          mask-image: var(--_lumo-tabs-overflow-mask-image);\n        }\n      }\n\n      /* Horizontal tabs overflow */\n\n      /* Both ends overflowing */\n      :host([overflow~=\"start\"][overflow~=\"end\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent 2em, #000 4em, #000 calc(100% - 4em), transparent calc(100% - 2em));\n      }\n\n      /* End overflowing */\n      :host([overflow~=\"end\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, #000 calc(100% - 4em), transparent calc(100% - 2em));\n      }\n\n      /* Start overflowing */\n      :host([overflow~=\"start\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent 2em, #000 4em);\n      }\n\n      /* Vertical tabs overflow */\n\n      /* Both ends overflowing */\n      :host([overflow~=\"start\"][overflow~=\"end\"][orientation=\"vertical\"]) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(transparent, #000 2em, #000 calc(100% - 2em), transparent);\n      }\n\n      /* End overflowing */\n      :host([overflow~=\"end\"][orientation=\"vertical\"]) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(#000 calc(100% - 2em), transparent);\n      }\n\n      /* Start overflowing */\n      :host([overflow~=\"start\"][orientation=\"vertical\"]) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(transparent, #000 2em);\n      }\n\n      :host [part=\"tabs\"] ::slotted(:not(vaadin-tab)) {\n        margin-left: var(--lumo-space-m);\n      }\n\n      /* Centered */\n\n      :host([theme~=\"centered\"][orientation=\"horizontal\"]) [part=\"tabs\"] {\n        justify-content: center;\n      }\n\n      /* Small */\n\n      :host([theme~=\"small\"]),\n      :host([theme~=\"small\"]) [part=\"tabs\"] {\n        min-height: var(--lumo-size-m);\n      }\n\n      :host([theme~=\"small\"]) [part=\"tabs\"] ::slotted(vaadin-tab) {\n        font-size: var(--lumo-font-size-s);\n      }\n\n      /* Minimal */\n\n      :host([theme~=\"minimal\"]) {\n        box-shadow: none;\n        /* This doesn't work with ShadyCSS */\n        --_lumo-tab-marker-display: none;\n      }\n\n      /* Workaround for the above ShadyCSS issue */\n      :host([theme~=\"minimal\"]) [part=\"tabs\"] ::slotted(vaadin-tab[selected])::before,\n      :host([theme~=\"minimal\"]) [part=\"tabs\"] ::slotted(vaadin-tab[selected])::after {\n        display: none;\n      }\n\n      /* Hide-scroll-buttons */\n\n      :host([theme~=\"hide-scroll-buttons\"]) [part=\"back-button\"],\n      :host([theme~=\"hide-scroll-buttons\"]) [part=\"forward-button\"] {\n        display: none;\n      }\n\n      :host([theme~=\"hide-scroll-buttons\"][overflow~=\"start\"][overflow~=\"end\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent, #000 2em, #000 calc(100% - 2em), transparent 100%);\n      }\n\n      :host([theme~=\"hide-scroll-buttons\"][overflow~=\"end\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, #000 calc(100% - 2em), transparent 100%);\n      }\n\n      :host([theme~=\"hide-scroll-buttons\"][overflow~=\"start\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent, #000 2em);\n      }\n\n      /* Equal-width tabs */\n      :host([theme~=\"equal-width-tabs\"]) {\n        flex: auto;\n      }\n\n      :host([theme~=\"equal-width-tabs\"]) [part=\"tabs\"] ::slotted(vaadin-tab) {\n        flex: 1 0 0%;\n      }\n\n      /* RTL specific styles */\n\n      :host([dir=\"rtl\"]) [part=\"forward-button\"]::after {\n        content: var(--lumo-icons-angle-left);\n      }\n\n      :host([dir=\"rtl\"]) [part=\"back-button\"]::after {\n        content: var(--lumo-icons-angle-right);\n      }\n\n      :host([orientation=\"vertical\"][dir=\"rtl\"]) {\n        box-shadow: 1px 0 0 0 var(--lumo-contrast-10pct);\n      }\n\n      :host([dir=\"rtl\"]) [part=\"forward-button\"] {\n        left: 0;\n      }\n\n      :host([dir=\"rtl\"]) [part=\"tabs\"] ::slotted(:not(vaadin-tab)) {\n        margin-left: 0;\n        margin-right: var(--lumo-space-m);\n      }\n\n      /* Both ends overflowing */\n      :host([dir=\"rtl\"][overflow~=\"start\"][overflow~=\"end\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent 2em, #000 4em, #000 calc(100% - 4em), transparent calc(100% - 2em));\n      }\n\n      /* End overflowing */\n      :host([dir=\"rtl\"][overflow~=\"end\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, #000 calc(100% - 4em), transparent calc(100% - 2em));\n      }\n\n      /* Start overflowing */\n      :host([dir=\"rtl\"][overflow~=\"start\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent 2em, #000 4em);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"hide-scroll-buttons\"][overflow~=\"start\"][overflow~=\"end\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent, #000 2em, #000 calc(100% - 2em), transparent 100%);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"hide-scroll-buttons\"][overflow~=\"end\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, #000 calc(100% - 2em), transparent 100%);\n      }\n\n      :host([dir=\"rtl\"][theme~=\"hide-scroll-buttons\"][overflow~=\"start\"]:not([orientation=\"vertical\"])) [part=\"tabs\"] {\n        --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent, #000 2em);\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-tabs/src/vaadin-tabs.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ListMixin } from '@vaadin/vaadin-list-mixin/vaadin-list-mixin.js';\nimport { IronResizableBehavior } from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport './vaadin-tab.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { mixinBehaviors } from '@polymer/polymer/lib/legacy/class.js';\nvar safari10 = /Apple.* Version\\/(9|10)/.test(navigator.userAgent);\n/**\n * `<vaadin-tabs>` is a Web Component for easy switching between different views.\n *\n * ```\n *   <vaadin-tabs selected=\"4\">\n *     <vaadin-tab>Page 1</vaadin-tab>\n *     <vaadin-tab>Page 2</vaadin-tab>\n *     <vaadin-tab>Page 3</vaadin-tab>\n *     <vaadin-tab>Page 4</vaadin-tab>\n *   </vaadin-tabs>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name         | Description\n * ------------------|--------------------------------------\n * `back-button`     | Button for moving the scroll back\n * `tabs`            | The tabs container\n * `forward-button`  | Button for moving the scroll forward\n *\n * The following state attributes are available for styling:\n *\n * Attribute  | Description | Part name\n * -----------|-------------|------------\n * `orientation` | Tabs disposition, valid values are `horizontal` and `vertical`. | :host\n * `overflow` | It's set to `start`, `end`, none or both. | :host\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ElementMixin\n * @mixes ListMixin\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nclass TabsElement extends ElementMixin(ListMixin(ThemableMixin(mixinBehaviors([IronResizableBehavior], PolymerElement)))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: flex;\n        align-items: center;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      :host([orientation=\"vertical\"]) {\n        display: block;\n      }\n\n      :host([orientation=\"horizontal\"]) [part=\"tabs\"] {\n        flex-grow: 1;\n        display: flex;\n        align-self: stretch;\n        overflow-x: auto;\n        -webkit-overflow-scrolling: touch;\n        -ms-overflow-style: none;\n      }\n\n      /* This seems more future-proof than \\`overflow: -moz-scrollbars-none\\` which is marked obsolete\n         and is no longer guaranteed to work:\n         https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#Mozilla_Extensions */\n      @-moz-document url-prefix() {\n        :host([orientation=\"horizontal\"]) [part=\"tabs\"] {\n          overflow: hidden;\n        }\n      }\n\n      :host([orientation=\"horizontal\"]) [part=\"tabs\"]::-webkit-scrollbar {\n        display: none;\n      }\n\n      :host([orientation=\"vertical\"]) [part=\"tabs\"] {\n        height: 100%;\n        overflow-y: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      [part=\"back-button\"],\n      [part=\"forward-button\"] {\n        pointer-events: none;\n        opacity: 0;\n        cursor: default;\n      }\n\n      :host([overflow~=\"start\"]) [part=\"back-button\"],\n      :host([overflow~=\"end\"]) [part=\"forward-button\"] {\n        pointer-events: auto;\n        opacity: 1;\n      }\n\n      [part=\"back-button\"]::after {\n        content: '';\n      }\n\n      [part=\"forward-button\"]::after {\n        content: '';\n      }\n\n      :host([orientation=\"vertical\"]) [part=\"back-button\"],\n      :host([orientation=\"vertical\"]) [part=\"forward-button\"] {\n        display: none;\n      }\n\n      /* RTL specific styles */\n\n      :host([dir=\"rtl\"]) [part=\"back-button\"]::after {\n        content: '';\n      }\n\n      :host([dir=\"rtl\"]) [part=\"forward-button\"]::after {\n        content: '';\n      }\n    </style>\n    <div on-click=\"_scrollBack\" part=\"back-button\"></div>\n\n    <div id=\"scroll\" part=\"tabs\">\n      <slot></slot>\n    </div>\n\n    <div on-click=\"_scrollForward\" part=\"forward-button\"></div>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-tabs';\n  }\n\n  static get version() {\n    return '3.2.0';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Set tabs disposition. Possible values are `horizontal|vertical`\n       * @type {!ListOrientation}\n       */\n      orientation: {\n        value: 'horizontal',\n        type: String\n      },\n\n      /**\n       * The index of the selected tab.\n       */\n      selected: {\n        value: 0,\n        type: Number\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_updateOverflow(items.*, vertical)'];\n  }\n\n  ready() {\n    super.ready();\n    this.addEventListener('iron-resize', () => this._updateOverflow());\n\n    this._scrollerElement.addEventListener('scroll', () => this._updateOverflow());\n\n    this.setAttribute('role', 'tablist'); // Wait for the vaadin-tab elements to upgrade and get styled\n\n    afterNextRender(this, () => {\n      this._updateOverflow();\n    });\n  }\n  /** @private */\n\n\n  _scrollForward() {\n    this._scroll(-this.__direction * this._scrollOffset);\n  }\n  /** @private */\n\n\n  _scrollBack() {\n    this._scroll(this.__direction * this._scrollOffset);\n  }\n  /**\n   * @return {number}\n   * @protected\n   */\n\n\n  get _scrollOffset() {\n    return this._vertical ? this._scrollerElement.offsetHeight : this._scrollerElement.offsetWidth;\n  }\n  /**\n   * @return {!HTMLElement}\n   * @protected\n   */\n\n\n  get _scrollerElement() {\n    return this.$.scroll;\n  }\n  /** @private */\n\n\n  get __direction() {\n    return !this._vertical && this.getAttribute('dir') === 'rtl' ? 1 : -1;\n  }\n  /** @private */\n\n\n  _updateOverflow() {\n    var scrollPosition = this._vertical ? this._scrollerElement.scrollTop : this.__getNormalizedScrollLeft(this._scrollerElement);\n    var scrollSize = this._vertical ? this._scrollerElement.scrollHeight : this._scrollerElement.scrollWidth; // In Edge we need to adjust the size in 1 pixel\n\n    scrollSize -= 1;\n    var overflow = scrollPosition > 0 ? 'start' : '';\n    overflow += scrollPosition + this._scrollOffset < scrollSize ? ' end' : '';\n\n    if (this.__direction == 1) {\n      overflow = overflow.replace(/start|end/gi, matched => {\n        return matched === 'start' ? 'end' : 'start';\n      });\n    }\n\n    overflow ? this.setAttribute('overflow', overflow.trim()) : this.removeAttribute('overflow');\n\n    this._repaintShadowNodesHack();\n  }\n  /** @private */\n\n\n  _repaintShadowNodesHack() {\n    // Safari 10 has an issue with repainting shadow root element styles when a host attribute changes.\n    // Need this workaround (toggle any inline css property on and off) until the issue gets fixed.\n\n    /* istanbul ignore if */\n    if (safari10 && this.root) {\n      var WEBKIT_PROPERTY = '-webkit-backface-visibility';\n      this.root.querySelectorAll('*').forEach(el => {\n        el.style[WEBKIT_PROPERTY] = 'visible';\n        el.style[WEBKIT_PROPERTY] = '';\n      });\n    }\n  }\n\n}\n\ncustomElements.define(TabsElement.is, TabsElement);\nexport { TabsElement };"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-text-area-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-text-area\" theme-for=\"vaadin-text-area\">\n  <template>\n    <style include=\"lumo-text-field\">\n      [part=\"input-field\"],\n      [part=\"input-field\"] ::slotted(textarea) {\n        /* Equal to the implicit padding in vaadin-text-field */\n        padding-top: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);\n        padding-bottom: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);\n        height: auto;\n        box-sizing: border-box;\n        transition: background-color 0.1s;\n        line-height: var(--lumo-line-height-s);\n      }\n\n      :host(:not([readonly])) [part=\"input-field\"]::after {\n        display: none;\n      }\n\n      :host([readonly]) [part=\"input-field\"] {\n        border: 1px dashed var(--lumo-contrast-30pct);\n      }\n\n      :host([readonly]) [part=\"input-field\"]::after {\n        border: none;\n      }\n\n      :host(:hover:not([readonly]):not([focused])) [part=\"input-field\"] {\n        background-color: var(--lumo-contrast-20pct);\n      }\n\n      @media (pointer: coarse) {\n        :host(:hover:not([readonly]):not([focused])) [part=\"input-field\"] {\n          background-color: var(--lumo-contrast-10pct);\n        }\n\n        :host(:active:not([readonly]):not([focused])) [part=\"input-field\"] {\n          background-color: var(--lumo-contrast-20pct);\n        }\n      }\n\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(textarea) {\n        line-height: inherit;\n        --_lumo-text-field-overflow-mask-image: none;\n      }\n\n      /* Vertically align icon prefix/suffix with the first line of text */\n      [part=\"input-field\"] ::slotted(iron-icon) {\n        margin-top: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);\n      }\n\n      [part=\"input-field\"] [part=\"value\"],\n      [part=\"input-field\"] ::slotted(textarea) {\n        white-space: pre-wrap; /* override \\`nowrap\\` from <vaadin-text-field> */\n        align-self: stretch; /* override \\`baseline\\` from <vaadin-text-field> */\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-text-field/src/vaadin-text-area.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { TextFieldMixin } from './vaadin-text-field-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-text-area>` is a Web Component for text area control in forms.\n *\n * ```html\n * <vaadin-text-area label=\"Add description\">\n * </vaadin-text-area>\n * ```\n *\n * ### Prefixes and suffixes\n *\n * These are child elements of a `<vaadin-text-area>` that are displayed\n * inline with the input, before or after.\n * In order for an element to be considered as a prefix, it must have the slot\n * attribute set to `prefix` (and similarly for `suffix`).\n *\n * ```html\n * <vaadin-text-area label=\"Add description\">\n *   <div slot=\"prefix\">Details:</div>\n *   <div slot=\"suffix\">The end!</div>\n * </vaadin-text-area>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ----------------|----------------\n * `label` | The label element\n * `input-field` | The element that wraps prefix, value and suffix\n * `value` | The text value element inside the `input-field` element\n * `error-message` | The error message element\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `disabled` | Set to a disabled text field | :host\n * `has-value` | Set when the element has a value | :host\n * `has-label` | Set when the element has a label | :host\n * `has-helper` | Set when the element has helper text | :host\n * `has-error-message` | Set when the element has an error message | :host\n * `invalid` | Set when the element is invalid | :host\n * `focused` | Set when the element is focused | :host\n * `focus-ring` | Set when the element is keyboard focused | :host\n * `readonly` | Set to a readonly text field | :host\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes TextFieldMixin\n * @mixes ControlStateMixin\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @demo demo/index.html\n */\n\nclass TextAreaElement extends ElementMixin(TextFieldMixin(ControlStateMixin(ThemableMixin(PolymerElement)))) {\n  static get template() {\n    return html`\n    <style include=\"vaadin-text-field-shared-styles\">\n      .vaadin-text-area-container {\n        flex: auto;\n        max-height: inherit; /* MSIE 11 */\n        min-height: inherit; /* MSIE 11 */\n      }\n\n      /* The label, helper text and the error message should neither grow nor shrink. */\n      [part=\"label\"],\n      [part=\"helper-text\"],\n      [part=\"error-message\"] {\n        flex: none;\n      }\n\n      [part=\"input-field\"] {\n        overflow: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      [part=\"value\"] {\n        resize: none;\n      }\n\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(*) {\n        align-self: flex-start;\n      }\n\n      @keyframes vaadin-text-area-appear {\n        to {\n          opacity: 1;\n        }\n      }\n\n      :host {\n        animation: 1ms vaadin-text-area-appear;\n      }\n    </style>\n\n    <div class=\"vaadin-text-area-container\">\n\n      <label part=\"label\" on-click=\"focus\" id=\"[[_labelId]]\">[[label]]</label>\n\n      <div part=\"input-field\" id=\"[[_inputId]]\">\n\n        <slot name=\"prefix\"></slot>\n\n        <slot name=\"textarea\">\n          <textarea part=\"value\"></textarea>\n        </slot>\n\n        <div part=\"clear-button\" id=\"clearButton\" role=\"button\" aria-label\\$=\"[[i18n.clear]]\"></div>\n        <slot name=\"suffix\"></slot>\n\n      </div>\n\n      <div part=\"helper-text\" on-click=\"focus\" id=\"[[_helperTextId]]\">\n        <slot name=\"helper\">[[helperText]]</slot>\n      </div>\n\n      <div part=\"error-message\" id=\"[[_errorId]]\" aria-live=\"assertive\" aria-hidden\\$=\"[[_getErrorMessageAriaHidden(invalid, errorMessage, _errorId)]]\">[[errorMessage]]</div>\n\n    </div>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-text-area';\n  }\n\n  static get version() {\n    return '2.8.2';\n  }\n\n  static get observers() {\n    return ['_textAreaValueChanged(value)'];\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n\n    this._updateHeight();\n\n    this.addEventListener('animationend', this._onAnimationEnd);\n  }\n  /** @private */\n\n\n  _onAnimationEnd(e) {\n    if (e.animationName.indexOf('vaadin-text-area-appear') === 0) {\n      this._updateHeight();\n    }\n  }\n  /**\n   * @return {string}\n   * @protected\n   */\n\n\n  get _slottedTagName() {\n    return 'textarea';\n  }\n  /** @private */\n\n\n  _textAreaValueChanged(value) {\n    this._updateHeight();\n  }\n  /** @private */\n\n\n  _updateHeight() {\n    var inputField = this.root.querySelector('[part=input-field]');\n    var scrollTop = inputField.scrollTop;\n    var input = this.inputElement;\n    var inputWidth = getComputedStyle(input).width;\n    var valueLength = this.value ? this.value.length : 0; // Only clear the height when the content shortens to minimize scrollbar flickering.\n\n    if (this._oldValueLength >= valueLength) {\n      // Fix the input element width so its scroll height isn't affected by host's disappearing scrollbars\n      input.style.maxWidth = inputWidth;\n      input.style.height = 'auto'; // Avoid a jumpy Safari rendering issue\n\n      inputField.style.display = 'block';\n    }\n\n    this._oldValueLength = valueLength;\n    var inputHeight = input.scrollHeight;\n\n    if (inputHeight > input.clientHeight) {\n      input.style.height = inputHeight + 'px';\n    } // Restore\n\n\n    input.style.removeProperty('max-width');\n    inputField.style.removeProperty('display');\n    inputField.scrollTop = scrollTop;\n\n    this._dispatchIronResizeEventIfNeeded('InputHeight', inputHeight);\n  }\n  /**\n   * Fired when the text-area height changes.\n   *\n   * @event iron-resize\n   */\n\n\n}\n\ncustomElements.define(TextAreaElement.is, TextAreaElement);\nexport { TextAreaElement };"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-upload/theme/lumo/vaadin-upload-styles.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport '@vaadin/vaadin-lumo-styles/mixins/field-button.js';\nimport '@vaadin/vaadin-button/theme/lumo/vaadin-button.js';\nimport '@vaadin/vaadin-progress-bar/theme/lumo/vaadin-progress-bar.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar $_documentContainer = html`<dom-module id=\"lumo-upload\" theme-for=\"vaadin-upload\">\n  <template>\n    <style>\n      :host {\n        line-height: var(--lumo-line-height-m);\n      }\n\n      :host(:not([nodrop])) {\n        overflow: hidden;\n        border: 1px dashed var(--lumo-contrast-20pct);\n        border-radius: var(--lumo-border-radius);\n        padding: var(--lumo-space-m);\n        transition: background-color 0.6s, border-color 0.6s;\n      }\n\n      [part=\"primary-buttons\"] > * {\n        display: inline-block;\n        white-space: nowrap;\n      }\n\n      [part=\"drop-label\"] {\n        display: inline-block;\n        white-space: normal;\n        padding: 0 var(--lumo-space-s);\n        color: var(--lumo-secondary-text-color);\n        font-family: var(--lumo-font-family);\n      }\n\n      :host([dragover-valid]) {\n        border-color: var(--lumo-primary-color-50pct);\n        background: var(--lumo-primary-color-10pct);\n        transition: background-color 0.1s, border-color 0.1s;\n      }\n\n      :host([dragover-valid]) [part=\"drop-label\"] {\n        color: var(--lumo-primary-text-color);\n      }\n\n      [part=\"drop-label-icon\"] {\n        display: inline-block;\n      }\n\n      [part=\"drop-label-icon\"]::before {\n        content: var(--lumo-icons-upload);\n        font-family: lumo-icons;\n        font-size: var(--lumo-icon-size-m);\n        line-height: 1;\n        vertical-align: -.25em;\n      }\n    </style>\n  </template>\n</dom-module><dom-module id=\"lumo-upload-file\" theme-for=\"vaadin-upload-file\">\n  <template>\n    <style include=\"lumo-field-button\">\n      :host {\n        padding: var(--lumo-space-s) 0;\n      }\n\n      :host(:not(:first-child)) {\n        border-top: 1px solid var(--lumo-contrast-10pct);\n      }\n\n      [part=\"row\"] {\n        display: flex;\n        align-items: baseline;\n        justify-content: space-between;\n      }\n\n      [part=\"status\"],\n      [part=\"error\"] {\n        color: var(--lumo-secondary-text-color);\n        font-size: var(--lumo-font-size-s);\n      }\n\n      [part=\"info\"] {\n        display: flex;\n        align-items: baseline;\n        flex: auto;\n      }\n\n      [part=\"meta\"] {\n        width: 0.001px;\n        flex: 1 1 auto;\n      }\n\n      [part=\"name\"] {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      [part=\"commands\"] {\n        display: flex;\n        align-items: baseline;\n        flex: none;\n      }\n\n      [part=\"done-icon\"],\n      [part=\"warning-icon\"] {\n        margin-right: var(--lumo-space-xs);\n      }\n\n      /* When both icons are hidden, let us keep space for one */\n      [part=\"done-icon\"][hidden] + [part=\"warning-icon\"][hidden] {\n        display: block !important;\n        visibility: hidden;\n      }\n\n      [part=\"done-icon\"],\n      [part=\"warning-icon\"] {\n        font-size: var(--lumo-icon-size-m);\n        font-family: 'lumo-icons';\n        line-height: 1;\n      }\n\n      [part=\"start-button\"],\n      [part=\"retry-button\"],\n      [part=\"clear-button\"] {\n        flex: none;\n        margin-left: var(--lumo-space-xs);\n      }\n\n      [part=\"done-icon\"]::before,\n      [part=\"warning-icon\"]::before,\n      [part=\"start-button\"]::before,\n      [part=\"retry-button\"]::before,\n      [part=\"clear-button\"]::before {\n        vertical-align: -.25em;\n      }\n\n      [part=\"done-icon\"]::before {\n        content: var(--lumo-icons-checkmark);\n        color: var(--lumo-primary-text-color);\n      }\n\n      [part=\"warning-icon\"]::before {\n        content: var(--lumo-icons-error);\n        color: var(--lumo-error-text-color);\n      }\n\n      [part=\"start-button\"]::before {\n        content: var(--lumo-icons-play);\n      }\n\n      [part=\"retry-button\"]::before {\n        content: var(--lumo-icons-reload);\n      }\n\n      [part=\"clear-button\"]::before {\n        content: var(--lumo-icons-cross);\n      }\n\n      [part=\"error\"] {\n        color: var(--lumo-error-text-color);\n      }\n\n      [part=\"progress\"] {\n        width: auto;\n        margin-left: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));\n        margin-right: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));\n      }\n\n      [part=\"progress\"][complete],\n      [part=\"progress\"][error] {\n        display: none;\n      }\n\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-upload/src/vaadin-upload.js?babel-target=es6",
     "source": "/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { resetMouseCanceller } from '@polymer/polymer/lib/utils/gestures.js';\nimport '@polymer/polymer/lib/elements/dom-repeat.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport '@vaadin/vaadin-button/src/vaadin-button.js';\nimport './vaadin-upload-icons.js';\nimport './vaadin-upload-file.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-upload>` is a Web Component for uploading multiple files with drag and drop support.\n *\n * Example:\n *\n * ```\n * <vaadin-upload></vaadin-upload>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ---|---\n * `primary-buttons` | Upload container\n * `upload-button` | Upload button\n * `drop-label` | Label for drop indicator\n * `drop-label-icon` | Icon for drop indicator\n * `file-list` | File list container\n *\n * The following state attributes are available for styling:\n *\n * Attribute | Description | Part name\n * ---|---|---\n * `nodrop` | Set when drag and drop is disabled (e. g., on touch devices) | `:host`\n * `dragover` | A file is being dragged over the element | `:host`\n * `dragover-valid` | A dragged file is valid with `maxFiles` and `accept` criteria | `:host`\n *\n * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @extends PolymerElement\n * @mixes ThemableMixin\n * @mixes ElementMixin\n * @demo demo/index.html\n */\n\nclass UploadElement extends ElementMixin(ThemableMixin(PolymerElement)) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: block;\n        position: relative;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      [hidden] {\n        display: none !important;\n      }\n    </style>\n\n    <div part=\"primary-buttons\">\n      <div id=\"addFiles\" on-touchend=\"_onAddFilesTouchEnd\" on-click=\"_onAddFilesClick\">\n        <slot name=\"add-button\">\n          <vaadin-button part=\"upload-button\" id=\"addButton\" disabled=\"[[maxFilesReached]]\">\n            [[_i18nPlural(maxFiles, i18n.addFiles, i18n.addFiles.*)]]\n          </vaadin-button>\n        </slot>\n      </div>\n      <div part=\"drop-label\" hidden\\$=\"[[nodrop]]\" id=\"dropLabelContainer\">\n        <slot name=\"drop-label-icon\">\n          <div part=\"drop-label-icon\"></div>\n        </slot>\n        <slot name=\"drop-label\" id=\"dropLabel\">\n          [[_i18nPlural(maxFiles, i18n.dropFiles, i18n.dropFiles.*)]]\n        </slot>\n      </div>\n    </div>\n    <slot name=\"file-list\">\n      <div id=\"fileList\" part=\"file-list\">\n        <template is=\"dom-repeat\" items=\"[[files]]\" as=\"file\">\n          <vaadin-upload-file file=\"[[file]]\"></vaadin-upload-file>\n        </template>\n      </div>\n    </slot>\n    <slot></slot>\n    <input type=\"file\" id=\"fileInput\" on-change=\"_onFileInputChange\" hidden=\"\" accept\\$=\"{{accept}}\" multiple\\$=\"[[_isMultiple(maxFiles)]]\" capture\\$=\"[[capture]]\">\n`;\n  }\n\n  static get is() {\n    return 'vaadin-upload';\n  }\n\n  static get version() {\n    return '4.4.1';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Define whether the element supports dropping files on it for uploading.\n       * By default it's enabled in desktop and disabled in touch devices\n       * because mobile devices do not support drag events in general. Setting\n       * it false means that drop is enabled even in touch-devices, and true\n       * disables drop in all devices.\n       *\n       * @type {boolean}\n       * @default true in touch-devices, false otherwise.\n       */\n      nodrop: {\n        type: Boolean,\n        reflectToAttribute: true,\n        value: function () {\n          try {\n            return !!document.createEvent('TouchEvent');\n          } catch (e) {\n            return false;\n          }\n        }\n      },\n\n      /**\n       * The server URL. The default value is an empty string, which means that\n       * _window.location_ will be used.\n       * @type {string}\n       */\n      target: {\n        type: String,\n        value: ''\n      },\n\n      /**\n       * HTTP Method used to send the files. Only POST and PUT are allowed.\n       * @type {!UploadMethod}\n       */\n      method: {\n        type: String,\n        value: 'POST'\n      },\n\n      /**\n       * Key-Value map to send to the server. If you set this property as an\n       * attribute, use a valid JSON string, for example:\n       * ```\n       * <vaadin-upload headers='{\"X-Foo\": \"Bar\"}'></vaadin-upload>\n       * ```\n       * @type {object | string}\n       */\n      headers: {\n        type: Object,\n        value: {}\n      },\n\n      /**\n       * Max time in milliseconds for the entire upload process, if exceeded the\n       * request will be aborted. Zero means that there is no timeout.\n       * @type {number}\n       */\n      timeout: {\n        type: Number,\n        value: 0\n      },\n\n      /** @private */\n      _dragover: {\n        type: Boolean,\n        value: false,\n        observer: '_dragoverChanged'\n      },\n\n      /**\n       * The array of files being processed, or already uploaded.\n       *\n       * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)\n       * object with a number of extra properties  to track the upload process:\n       * - `uploadTarget`: The target URL used to upload this file.\n       * - `elapsed`: Elapsed time since the upload started.\n       * - `elapsedStr`: Human-readable elapsed time.\n       * - `remaining`: Number of seconds remaining for the upload to finish.\n       * - `remainingStr`: Human-readable remaining time for the upload to finish.\n       * - `progress`: Percentage of the file already uploaded.\n       * - `speed`: Upload speed in kB/s.\n       * - `size`: File size in bytes.\n       * - `totalStr`: Human-readable total size of the file.\n       * - `loaded`: Bytes transferred so far.\n       * - `loadedStr`: Human-readable uploaded size at the moment.\n       * - `status`: Status of the upload process.\n       * - `error`: Error message in case the upload failed.\n       * - `abort`: True if the file was canceled by the user.\n       * - `complete`: True when the file was transferred to the server.\n       * - `uploading`: True while transferring data to the server.\n       * @type {!Array<!UploadFile>}\n       */\n      files: {\n        type: Array,\n        notify: true,\n        value: function () {\n          return [];\n        }\n      },\n\n      /**\n       * Limit of files to upload, by default it is unlimited. If the value is\n       * set to one, native file browser will prevent selecting multiple files.\n       * @attr {number} max-files\n       * @type {number}\n       */\n      maxFiles: {\n        type: Number,\n        value: Infinity\n      },\n\n      /**\n       * Specifies if the maximum number of files have been uploaded\n       * @attr {boolean} max-files-reached\n       * @type {boolean}\n       */\n      maxFilesReached: {\n        type: Boolean,\n        value: false,\n        notify: true,\n        readOnly: true,\n        computed: '_maxFilesAdded(maxFiles, files.length)'\n      },\n\n      /**\n       * Specifies the types of files that the server accepts.\n       * Syntax: a comma-separated list of MIME type patterns (wildcards are\n       * allowed) or file extensions.\n       * Notice that MIME types are widely supported, while file extensions\n       * are only implemented in certain browsers, so avoid using it.\n       * Example: accept=\"video/*,image/tiff\" or accept=\".pdf,audio/mp3\"\n       * @type {string}\n       */\n      accept: {\n        type: String,\n        value: ''\n      },\n\n      /**\n       * Specifies the maximum file size in bytes allowed to upload.\n       * Notice that it is a client-side constraint, which will be checked before\n       * sending the request. Obviously you need to do the same validation in\n       * the server-side and be sure that they are aligned.\n       * @attr {number} max-file-size\n       * @type {number}\n       */\n      maxFileSize: {\n        type: Number,\n        value: Infinity\n      },\n\n      /**\n       * Specifies if the dragover is validated with maxFiles and\n       * accept properties.\n       * @private\n       */\n      _dragoverValid: {\n        type: Boolean,\n        value: false,\n        observer: '_dragoverValidChanged'\n      },\n\n      /**\n       * Specifies the 'name' property at Content-Disposition\n       * @attr {string} form-data-name\n       * @type {string}\n       */\n      formDataName: {\n        type: String,\n        value: 'file'\n      },\n\n      /**\n       * Prevents upload(s) from immediately uploading upon adding file(s).\n       * When set, you must manually trigger uploads using the `uploadFiles` method\n       * @attr {boolean} no-auto\n       * @type {boolean}\n       */\n      noAuto: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Set the withCredentials flag on the request.\n       * @attr {boolean} with-credentials\n       * @type {boolean}\n       */\n      withCredentials: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Pass-through to input's capture attribute. Allows user to trigger device inputs\n       * such as camera or microphone immediately.\n       */\n      capture: String,\n\n      /**\n       * The object used to localize this component.\n       * For changing the default localization, change the entire\n       * _i18n_ object or just the property you want to modify.\n       *\n       * The object has the following JSON structure and default values:\n       {\n        dropFiles: {\n        one: 'Drop file here\n        many: 'Drop files here\n        },\n        addFiles: {\n        one: 'Select File...',\n        many: 'Upload Files...'\n        },\n        cancel: 'Cancel',\n        error: {\n        tooManyFiles: 'Too Many Files.',\n        fileIsTooBig: 'File is Too Big.',\n        incorrectFileType: 'Incorrect File Type.'\n        },\n        uploading: {\n        status: {\n          connecting: 'Connecting...',\n          stalled: 'Stalled',\n          processing: 'Processing File...',\n          held: 'Queued'\n        },\n        remainingTime: {\n          prefix: 'remaining time: ',\n          unknown: 'unknown remaining time'\n        },\n        error: {\n          serverUnavailable: 'Server Unavailable',\n          unexpectedServerError: 'Unexpected Server Error',\n          forbidden: 'Forbidden'\n        }\n        },\n        units: {\n        size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n        sizeBase: 1000\n        },\n        formatSize: function(bytes) {\n        // returns the size followed by the best suitable unit\n        },\n        formatTime: function(seconds, [secs, mins, hours]) {\n        // returns a 'HH:MM:SS' string\n        }\n      }\n       * @type {!UploadI18n}\n      * @default {English}\n      */\n      i18n: {\n        type: Object,\n        value: function () {\n          return {\n            dropFiles: {\n              one: 'Drop file here',\n              many: 'Drop files here'\n            },\n            addFiles: {\n              one: 'Upload File...',\n              many: 'Upload Files...'\n            },\n            cancel: 'Cancel',\n            error: {\n              tooManyFiles: 'Too Many Files.',\n              fileIsTooBig: 'File is Too Big.',\n              incorrectFileType: 'Incorrect File Type.'\n            },\n            uploading: {\n              status: {\n                connecting: 'Connecting...',\n                stalled: 'Stalled.',\n                processing: 'Processing File...',\n                held: 'Queued'\n              },\n              remainingTime: {\n                prefix: 'remaining time: ',\n                unknown: 'unknown remaining time'\n              },\n              error: {\n                serverUnavailable: 'Server Unavailable',\n                unexpectedServerError: 'Unexpected Server Error',\n                forbidden: 'Forbidden'\n              }\n            },\n            units: {\n              size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n            }\n          };\n        }\n      }\n    };\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.addEventListener('dragover', this._onDragover.bind(this));\n    this.addEventListener('dragleave', this._onDragleave.bind(this));\n    this.addEventListener('drop', this._onDrop.bind(this));\n    this.addEventListener('file-retry', this._onFileRetry.bind(this));\n    this.addEventListener('file-abort', this._onFileAbort.bind(this));\n    this.addEventListener('file-remove', this._onFileRemove.bind(this));\n    this.addEventListener('file-start', this._onFileStart.bind(this));\n  }\n  /** @private */\n\n\n  _formatSize(bytes) {\n    if (typeof this.i18n.formatSize === 'function') {\n      return this.i18n.formatSize(bytes);\n    } // https://wiki.ubuntu.com/UnitsPolicy\n\n\n    var base = this.i18n.units.sizeBase || 1000;\n    var unit = ~~(Math.log(bytes) / Math.log(base));\n    var dec = Math.max(0, Math.min(3, unit - 1));\n    var size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));\n    return size + ' ' + this.i18n.units.size[unit];\n  }\n  /** @private */\n\n\n  _splitTimeByUnits(time) {\n    var unitSizes = [60, 60, 24, Infinity];\n    var timeValues = [0];\n\n    for (var i = 0; i < unitSizes.length && time > 0; i++) {\n      timeValues[i] = time % unitSizes[i];\n      time = Math.floor(time / unitSizes[i]);\n    }\n\n    return timeValues;\n  }\n  /** @private */\n\n\n  _formatTime(seconds, split) {\n    if (typeof this.i18n.formatTime === 'function') {\n      return this.i18n.formatTime(seconds, split);\n    } // Fill HH:MM:SS with leading zeros\n\n\n    while (split.length < 3) {\n      split.push(0);\n    }\n\n    return split.reverse().map(number => {\n      return (number < 10 ? '0' : '') + number;\n    }).join(':');\n  }\n  /** @private */\n\n\n  _formatFileProgress(file) {\n    return file.totalStr + ': ' + file.progress + '% (' + (file.loaded > 0 ? this.i18n.uploading.remainingTime.prefix + file.remainingStr : this.i18n.uploading.remainingTime.unknown) + ')';\n  }\n  /** @private */\n\n\n  _maxFilesAdded(maxFiles, numFiles) {\n    return maxFiles >= 0 && numFiles >= maxFiles;\n  }\n  /** @private */\n\n\n  _onDragover(event) {\n    event.preventDefault();\n\n    if (!this.nodrop && !this._dragover) {\n      this._dragoverValid = !this.maxFilesReached;\n      this._dragover = true;\n    }\n\n    event.dataTransfer.dropEffect = !this._dragoverValid || this.nodrop ? 'none' : 'copy';\n  }\n  /** @private */\n\n\n  _onDragleave(event) {\n    event.preventDefault();\n\n    if (this._dragover && !this.nodrop) {\n      this._dragover = this._dragoverValid = false;\n    }\n  }\n  /** @private */\n\n\n  _onDrop(event) {\n    if (!this.nodrop) {\n      event.preventDefault();\n      this._dragover = this._dragoverValid = false;\n\n      this._addFiles(event.dataTransfer.files);\n    }\n  }\n  /** @private */\n\n\n  _createXhr() {\n    return new XMLHttpRequest();\n  }\n  /** @private */\n\n\n  _configureXhr(xhr) {\n    if (typeof this.headers == 'string') {\n      try {\n        this.headers = JSON.parse(this.headers);\n      } catch (e) {\n        this.headers = undefined;\n      }\n    }\n\n    for (var key in this.headers) {\n      xhr.setRequestHeader(key, this.headers[key]);\n    }\n\n    if (this.timeout) {\n      xhr.timeout = this.timeout;\n    }\n\n    xhr.withCredentials = this.withCredentials;\n  }\n  /** @private */\n\n\n  _setStatus(file, total, loaded, elapsed) {\n    file.elapsed = elapsed;\n    file.elapsedStr = this._formatTime(file.elapsed, this._splitTimeByUnits(file.elapsed));\n    file.remaining = Math.ceil(elapsed * (total / loaded - 1));\n    file.remainingStr = this._formatTime(file.remaining, this._splitTimeByUnits(file.remaining));\n    file.speed = ~~(total / elapsed / 1024);\n    file.totalStr = this._formatSize(total);\n    file.loadedStr = this._formatSize(loaded);\n    file.status = this._formatFileProgress(file);\n  }\n  /**\n   * Triggers the upload of any files that are not completed\n   *\n   * @param {!UploadFile | !Array<!UploadFile>=} files - Files being uploaded. Defaults to all outstanding files\n   */\n\n\n  uploadFiles(files) {\n    if (files && !Array.isArray(files)) {\n      files = [files];\n    }\n\n    files = files || this.files;\n    files = files.filter(file => !file.complete);\n    Array.prototype.forEach.call(files, this._uploadFile.bind(this));\n  }\n  /** @private */\n\n\n  _uploadFile(file) {\n    if (file.uploading) {\n      return;\n    }\n\n    var ini = Date.now();\n\n    var xhr = file.xhr = this._createXhr(file);\n\n    var stalledId, last; // onprogress is called always after onreadystatechange\n\n    xhr.upload.onprogress = e => {\n      clearTimeout(stalledId);\n      last = Date.now();\n      var elapsed = (last - ini) / 1000;\n      var loaded = e.loaded,\n          total = e.total,\n          progress = ~~(loaded / total * 100);\n      file.loaded = loaded;\n      file.progress = progress;\n      file.indeterminate = loaded <= 0 || loaded >= total;\n\n      if (file.error) {\n        file.indeterminate = file.status = undefined;\n      } else if (!file.abort) {\n        if (progress < 100) {\n          this._setStatus(file, total, loaded, elapsed);\n\n          stalledId = setTimeout(() => {\n            file.status = this.i18n.uploading.status.stalled;\n\n            this._notifyFileChanges(file);\n          }, 2000);\n        } else {\n          file.loadedStr = file.totalStr;\n          file.status = this.i18n.uploading.status.processing;\n          file.uploading = false;\n        }\n      }\n\n      this._notifyFileChanges(file);\n\n      this.dispatchEvent(new CustomEvent('upload-progress', {\n        detail: {\n          file,\n          xhr\n        }\n      }));\n    }; // More reliable than xhr.onload\n\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState == 4) {\n        clearTimeout(stalledId);\n        file.indeterminate = file.uploading = false;\n\n        if (file.abort) {\n          this._notifyFileChanges(file);\n\n          return;\n        }\n\n        file.status = ''; // Custom listener can modify the default behavior either\n        // preventing default, changing the xhr, or setting the file error\n\n        var _evt = this.dispatchEvent(new CustomEvent('upload-response', {\n          detail: {\n            file,\n            xhr\n          },\n          cancelable: true\n        }));\n\n        if (!_evt) {\n          return;\n        }\n\n        if (xhr.status === 0) {\n          file.error = this.i18n.uploading.error.serverUnavailable;\n        } else if (xhr.status >= 500) {\n          file.error = this.i18n.uploading.error.unexpectedServerError;\n        } else if (xhr.status >= 400) {\n          file.error = this.i18n.uploading.error.forbidden;\n        }\n\n        file.complete = !file.error;\n        this.dispatchEvent(new CustomEvent(`upload-${file.error ? 'error' : 'success'}`, {\n          detail: {\n            file,\n            xhr\n          }\n        }));\n\n        this._notifyFileChanges(file);\n      }\n    };\n\n    var formData = new FormData();\n    file.uploadTarget = file.uploadTarget || this.target || '';\n    file.formDataName = this.formDataName;\n    var evt = this.dispatchEvent(new CustomEvent('upload-before', {\n      detail: {\n        file,\n        xhr\n      },\n      cancelable: true\n    }));\n\n    if (!evt) {\n      return;\n    }\n\n    formData.append(file.formDataName, file, file.name);\n    xhr.open(this.method, file.uploadTarget, true);\n\n    this._configureXhr(xhr);\n\n    file.status = this.i18n.uploading.status.connecting;\n    file.uploading = file.indeterminate = true;\n    file.complete = file.abort = file.error = file.held = false;\n\n    xhr.upload.onloadstart = () => {\n      this.dispatchEvent(new CustomEvent('upload-start', {\n        detail: {\n          file,\n          xhr\n        }\n      }));\n\n      this._notifyFileChanges(file);\n    }; // Custom listener could modify the xhr just before sending it\n    // preventing default\n\n\n    var uploadEvt = this.dispatchEvent(new CustomEvent('upload-request', {\n      detail: {\n        file,\n        xhr,\n        formData\n      },\n      cancelable: true\n    }));\n\n    if (uploadEvt) {\n      xhr.send(formData);\n    }\n  }\n  /** @private */\n\n\n  _retryFileUpload(file) {\n    var evt = this.dispatchEvent(new CustomEvent('upload-retry', {\n      detail: {\n        file,\n        xhr: file.xhr\n      },\n      cancelable: true\n    }));\n\n    if (evt) {\n      this._uploadFile(file);\n    }\n  }\n  /** @private */\n\n\n  _abortFileUpload(file) {\n    var evt = this.dispatchEvent(new CustomEvent('upload-abort', {\n      detail: {\n        file,\n        xhr: file.xhr\n      },\n      cancelable: true\n    }));\n\n    if (evt) {\n      file.abort = true;\n\n      if (file.xhr) {\n        file.xhr.abort();\n      }\n\n      this._notifyFileChanges(file);\n    }\n  }\n  /** @private */\n\n\n  _notifyFileChanges(file) {\n    var p = 'files.' + this.files.indexOf(file) + '.';\n\n    for (var i in file) {\n      if (file.hasOwnProperty(i)) {\n        this.notifyPath(p + i, file[i]);\n      }\n    }\n  }\n  /** @private */\n\n\n  _addFiles(files) {\n    Array.prototype.forEach.call(files, this._addFile.bind(this));\n  }\n  /**\n   * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.\n   *\n   * @param {!UploadFile} file File being added\n   * @protected\n   */\n\n\n  _addFile(file) {\n    if (this.maxFilesReached) {\n      this.dispatchEvent(new CustomEvent('file-reject', {\n        detail: {\n          file,\n          error: this.i18n.error.tooManyFiles\n        }\n      }));\n      return;\n    }\n\n    if (this.maxFileSize >= 0 && file.size > this.maxFileSize) {\n      this.dispatchEvent(new CustomEvent('file-reject', {\n        detail: {\n          file,\n          error: this.i18n.error.fileIsTooBig\n        }\n      }));\n      return;\n    }\n\n    var fileExt = file.name.match(/\\.[^\\.]*$|$/)[0];\n    var re = new RegExp('^(' + this.accept.replace(/[, ]+/g, '|').replace(/\\/\\*/g, '/.*') + ')$', 'i');\n\n    if (this.accept && !(re.test(file.type) || re.test(fileExt))) {\n      this.dispatchEvent(new CustomEvent('file-reject', {\n        detail: {\n          file,\n          error: this.i18n.error.incorrectFileType\n        }\n      }));\n      return;\n    }\n\n    file.loaded = 0;\n    file.held = true;\n    file.status = this.i18n.uploading.status.held;\n    this.unshift('files', file);\n\n    if (!this.noAuto) {\n      this._uploadFile(file);\n    }\n  }\n  /**\n   * Remove file from upload list. Called internally if file upload was canceled.\n   * @param {!UploadFile} file File to remove\n   * @protected\n   */\n\n\n  _removeFile(file) {\n    if (this.files.indexOf(file) > -1) {\n      this.splice('files', this.files.indexOf(file), 1);\n    }\n  }\n  /** @private */\n\n\n  _onAddFilesTouchEnd(e) {\n    // Cancel the event to avoid the following click event\n    e.preventDefault(); // FIXME(platosha): workaround for Polymer Gestures mouseCanceller\n    // cancelling the following synthetic click. See also:\n    // https://github.com/Polymer/polymer/issues/5289\n\n    this.__resetMouseCanceller();\n\n    this._onAddFilesClick();\n  }\n  /** @private */\n\n\n  __resetMouseCanceller() {\n    resetMouseCanceller();\n  }\n  /** @private */\n\n\n  _onAddFilesClick() {\n    if (this.maxFilesReached) {\n      return;\n    }\n\n    this.$.fileInput.value = '';\n    this.$.fileInput.click();\n  }\n  /** @private */\n\n\n  _onFileInputChange(event) {\n    this._addFiles(event.target.files);\n  }\n  /** @private */\n\n\n  _onFileStart(event) {\n    this._uploadFile(event.detail.file);\n  }\n  /** @private */\n\n\n  _onFileRetry(event) {\n    this._retryFileUpload(event.detail.file);\n  }\n  /** @private */\n\n\n  _onFileAbort(event) {\n    this._abortFileUpload(event.detail.file);\n  }\n  /** @private */\n\n\n  _onFileRemove(event) {\n    this._removeFile(event.detail.file);\n  }\n  /** @private */\n\n\n  _dragoverChanged(dragover) {\n    dragover ? this.setAttribute('dragover', dragover) : this.removeAttribute('dragover');\n  }\n  /** @private */\n\n\n  _dragoverValidChanged(dragoverValid) {\n    dragoverValid ? this.setAttribute('dragover-valid', dragoverValid) : this.removeAttribute('dragover-valid');\n  }\n  /** @private */\n\n\n  _i18nPlural(value, plural) {\n    return value == 1 ? plural.one : plural.many;\n  }\n  /** @private */\n\n\n  _isMultiple(maxFiles) {\n    return maxFiles != 1;\n  }\n  /**\n  * Fired when a file cannot be added to the queue due to a constrain:\n  *  file-size, file-type or maxFiles\n  *\n  * @event file-reject\n  * @param {Object} detail\n  * @param {Object} detail.file the file added\n  * @param {string} detail.error the cause\n  */\n\n  /**\n  * Fired before the XHR is opened. Could be used for changing the request\n  * URL. If the default is prevented, then XHR would not be opened.\n  *\n  * @event upload-before\n  * @param {Object} detail\n  * @param {Object} detail.xhr the xhr\n  * @param {Object} detail.file the file being uploaded\n  * @param {Object} detail.file.uploadTarget the upload request URL, initialized with the value of vaadin-upload `target` property\n  */\n\n  /**\n  * Fired when the XHR has been opened but not sent yet. Useful for appending\n  * data keys to the FormData object, for changing some parameters like\n  * headers, etc. If the event is defaultPrevented, `vaadin-upload` will not\n  * send the request allowing the user to do something on his own.\n  *\n  * @event upload-request\n  * @param {Object} detail\n  * @param {Object} detail.xhr the xhr\n  * @param {Object} detail.file the file being uploaded\n  * @param {Object} detail.formData the FormData object\n  */\n\n  /**\n  * Fired when the XHR is sent.\n  *\n  * @event upload-start\n  * @param {Object} detail\n  * @param {Object} detail.xhr the xhr\n  * @param {Object} detail.file the file being uploaded\n  */\n\n  /**\n  * Fired as many times as the progress is updated.\n  *\n  * @event upload-progress\n  * @param {Object} detail\n  * @param {Object} detail.xhr the xhr\n  * @param {Object} detail.file the file being uploaded with loaded info\n  */\n\n  /**\n  * Fired when we have the actual server response, and before the component\n  * analyses it. It's useful for developers to make the upload fail depending\n  * on the server response. If the event is defaultPrevented the vaadin-upload\n  * will return allowing the user to do something on his own like retry the\n  * upload, etc. since he has full access to the `xhr` and `file` objects.\n  * Otherwise, if the event is not prevented default `vaadin-upload` continues\n  * with the normal workflow checking the `xhr.status` and `file.error`\n  * which also might be modified by the user to force a customized response.\n  *\n  * @event upload-response\n  * @param {Object} detail\n  * @param {Object} detail.xhr the xhr\n  * @param {Object} detail.file the file being uploaded\n  */\n\n  /**\n  * Fired in case the upload process succeed.\n  *\n  * @event upload-success\n  * @param {Object} detail\n  * @param {Object} detail.xhr the xhr\n  * @param {Object} detail.file the file being uploaded with loaded info\n  */\n\n  /**\n  * Fired in case the upload process failed.\n  *\n  * @event upload-error\n  * @param {Object} detail\n  * @param {Object} detail.xhr the xhr\n  * @param {Object} detail.file the file being uploaded\n  */\n\n  /**\n  * Fired when retry upload is requested. If the default is prevented, then\n  * retry would not be performed.\n  *\n  * @event upload-retry\n  * @param {Object} detail\n  * @param {Object} detail.xhr the previous upload xhr\n  * @param {Object} detail.file the file being uploaded\n  */\n\n  /**\n  * Fired when retry abort is requested. If the default is prevented, then the\n  * file upload would not be aborted.\n  *\n  * @event upload-abort\n  * @param {Object} detail\n  * @param {Object} detail.xhr the xhr\n  * @param {Object} detail.file the file being uploaded\n  */\n\n\n}\n\ncustomElements.define(UploadElement.is, UploadElement);\nexport { UploadElement };"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/all-imports.js?babel-target=es6",
     "source": "import './mixins/field-button.js';\nimport './mixins/menu-overlay.js';\nimport './mixins/overlay.js';\nimport './mixins/required-field.js';\nimport './badge.js';\nimport './color.js';\nimport './font-icons.js';\nimport './icons.js';\nimport './sizing.js';\nimport './spacing.js';\nimport './style.js';\nimport './typography.js';\n/**\n@license\nCopyright (c) 2019 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\n\n;"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-ordered-layout/theme/lumo/vaadin-ordered-layout.js?babel-target=es6",
     "source": "import '@vaadin/vaadin-lumo-styles/spacing.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<dom-module id=\"lumo-ordered-layout\">\n  <template>\n    <style>\n      :host([theme~=\"margin\"]) {\n        margin: var(--lumo-space-m);\n      }\n\n      :host([theme~=\"padding\"]) {\n        padding: var(--lumo-space-m);\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-app-layout/src/safe-area-inset.js?babel-target=es6",
     "source": "import '@polymer/polymer/lib/elements/custom-style.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<custom-style>\n  <style>\n    /* stylelint-disable length-zero-no-unit */\n    /* Use units so that the values can be used in calc() */\n    html {\n      --safe-area-inset-top: constant(safe-area-inset-top, 0px);\n      --safe-area-inset-right: constant(safe-area-inset-right, 0px);\n      --safe-area-inset-bottom: constant(safe-area-inset-bottom, 0px);\n      --safe-area-inset-left: constant(safe-area-inset-left, 0px);\n    }\n\n    @supports (padding-left: env(safe-area-inset-left)) {\n      html {\n        --safe-area-inset-top: env(safe-area-inset-top, 0px);\n        --safe-area-inset-right: env(safe-area-inset-right, 0px);\n        --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);\n        --safe-area-inset-left: env(safe-area-inset-left, 0px);\n      }\n    }\n    /* stylelint-enable */\n  </style>\n</custom-style>`;\ndocument.head.appendChild($_documentContainer.content);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-app-layout/src/detect-ios-navbar.js?babel-target=es6",
     "source": "export var _detectIosNavbar = function () {\n  if (window.navigator.userAgent.match(/iPhone|iPad/i)) {\n    var innerHeight = window.innerHeight;\n    var innerWidth = window.innerWidth;\n    var landscape = innerWidth > innerHeight;\n    var clientHeight = document.documentElement.clientHeight;\n\n    if (landscape && clientHeight > innerHeight) {\n      document.documentElement.style.setProperty('--vaadin-viewport-offset-bottom', clientHeight - innerHeight + 'px');\n    } else {\n      document.documentElement.style.setProperty('--vaadin-viewport-offset-bottom', '');\n    }\n  }\n};\n\n_detectIosNavbar();\n\nwindow.addEventListener('resize', _detectIosNavbar);"
    },
    {
     "name": "../node_modules/@vaadin/vaadin-lumo-styles/badge.js?babel-target=es6",
     "source": "import './style.js';\nimport './color.js';\nimport './typography.js';\nvar $_documentContainer = document.createElement('template');\n$_documentContainer.innerHTML = `<dom-module id=\"lumo-badge\">\n  <template>\n    <style>\n      [theme~=\"badge\"] {\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n        box-sizing: border-box;\n        padding: 0.4em calc(0.5em + var(--lumo-border-radius-s) / 4);\n        color: var(--lumo-primary-text-color);\n        background-color: var(--lumo-primary-color-10pct);\n        border-radius: var(--lumo-border-radius-s);\n        font-family: var(--lumo-font-family);\n        font-size: var(--lumo-font-size-s);\n        line-height: 1;\n        font-weight: 500;\n        text-transform: initial;\n        letter-spacing: initial;\n        min-width: calc(var(--lumo-line-height-xs) * 1em + 0.45em);\n      }\n\n      /* Ensure proper vertical alignment */\n      [theme~=\"badge\"]::before {\n        display: inline-block;\n        content: \"\\\\2003\";\n        width: 0;\n      }\n\n      [theme~=\"badge\"][theme~=\"small\"] {\n        font-size: var(--lumo-font-size-xxs);\n        line-height: 1;\n      }\n\n      /* Colors */\n\n      [theme~=\"badge\"][theme~=\"success\"] {\n        color: var(--lumo-success-text-color);\n        background-color: var(--lumo-success-color-10pct);\n      }\n\n      [theme~=\"badge\"][theme~=\"error\"] {\n        color: var(--lumo-error-text-color);\n        background-color: var(--lumo-error-color-10pct);\n      }\n\n      [theme~=\"badge\"][theme~=\"contrast\"] {\n        color: var(--lumo-contrast-80pct);\n        background-color: var(--lumo-contrast-5pct);\n      }\n\n      /* Primary */\n\n      [theme~=\"badge\"][theme~=\"primary\"] {\n        color: var(--lumo-primary-contrast-color);\n        background-color: var(--lumo-primary-color);\n      }\n\n      [theme~=\"badge\"][theme~=\"success\"][theme~=\"primary\"] {\n        color: var(--lumo-success-contrast-color);\n        background-color: var(--lumo-success-color);\n      }\n\n      [theme~=\"badge\"][theme~=\"error\"][theme~=\"primary\"] {\n        color: var(--lumo-error-contrast-color);\n        background-color: var(--lumo-error-color);\n      }\n\n      [theme~=\"badge\"][theme~=\"contrast\"][theme~=\"primary\"] {\n        color: var(--lumo-base-color);\n        background-color: var(--lumo-contrast);\n      }\n\n      /* Links */\n\n      [theme~=\"badge\"][href]:hover {\n        text-decoration: none;\n      }\n\n      /* Icon */\n\n      [theme~=\"badge\"] iron-icon {\n        margin: -0.25em 0;\n        --iron-icon-width: 1.5em;\n        --iron-icon-height: 1.5em;\n      }\n\n      [theme~=\"badge\"] iron-icon:first-child {\n        margin-left: -0.375em;\n      }\n\n      [theme~=\"badge\"] iron-icon:last-child {\n        margin-right: -0.375em;\n      }\n\n      [theme~=\"badge\"][icon] {\n        min-width: 0;\n        padding: 0;\n        font-size: 1rem;\n        --iron-icon-width: var(--lumo-icon-size-m);\n        --iron-icon-height: var(--lumo-icon-size-m);\n      }\n\n      [theme~=\"badge\"][icon][theme~=\"small\"] {\n        --iron-icon-width: var(--lumo-icon-size-s);\n        --iron-icon-height: var(--lumo-icon-size-s);\n      }\n\n      /* Empty */\n\n      [theme~=\"badge\"]:not([icon]):empty {\n        min-width: 0;\n        width: 1em;\n        height: 1em;\n        padding: 0;\n        border-radius: 50%;\n        background-color: var(--lumo-primary-color);\n      }\n\n      [theme~=\"badge\"][theme~=\"small\"]:not([icon]):empty {\n        width: 0.75em;\n        height: 0.75em;\n      }\n\n      [theme~=\"badge\"][theme~=\"contrast\"]:not([icon]):empty {\n        background-color: var(--lumo-contrast);\n      }\n\n      [theme~=\"badge\"][theme~=\"success\"]:not([icon]):empty {\n        background-color: var(--lumo-success-color);\n      }\n\n      [theme~=\"badge\"][theme~=\"error\"]:not([icon]):empty {\n        background-color: var(--lumo-error-color);\n      }\n\n      /* Pill */\n\n      [theme~=\"badge\"][theme~=\"pill\"] {\n        --lumo-border-radius-s: 1em;\n      }\n\n      /* RTL specific styles */\n\n      [dir=\"rtl\"][theme~=\"badge\"] iron-icon:first-child {\n        margin-right: -0.375em;\n        margin-left: 0;\n      }\n\n      [dir=\"rtl\"][theme~=\"badge\"] iron-icon:last-child {\n        margin-left: -0.375em;\n        margin-right: 0;\n      }\n    </style>\n  </template>\n</dom-module>`;\ndocument.head.appendChild($_documentContainer.content);"
    }
   ]
  },
  {
   "id": 490,
   "name": "../target/frontend/generated-flow-imports-fallback.js",
   "source": "import '@polymer/iron-icon/iron-icon.js';\nimport '@polymer/iron-list/iron-list.js';\nimport '@vaadin/flow-frontend/comboBoxConnector-es6.js';\nimport '@vaadin/flow-frontend/contextMenuConnector-es6.js';\nimport '@vaadin/flow-frontend/datepickerConnector.js';\nimport '@vaadin/flow-frontend/dndConnector-es6.js';\nimport '@vaadin/flow-frontend/flow-component-renderer.js';\nimport '@vaadin/flow-frontend/gridConnector-es6.js';\nimport '@vaadin/flow-frontend/gridProConnector.js';\nimport '@vaadin/flow-frontend/ironListConnector-es6.js';\nimport '@vaadin/flow-frontend/ironListStyles.js';\nimport '@vaadin/flow-frontend/menubarConnector.js';\nimport '@vaadin/flow-frontend/timepickerConnector.js';\nimport '@vaadin/flow-frontend/vaadin-big-decimal-field.js';\nimport '@vaadin/flow-frontend/vaadin-grid-flow-selection-column.js';\nimport '@vaadin/vaadin-accordion/theme/lumo/vaadin-accordion.js';\nimport '@vaadin/vaadin-app-layout/theme/lumo/vaadin-drawer-toggle.js';\nimport '@vaadin/vaadin-board/vaadin-board-row.js';\nimport '@vaadin/vaadin-board/vaadin-board.js';\nimport '@vaadin/vaadin-charts/vaadin-chart.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox-group.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js';\nimport '@vaadin/vaadin-combo-box/theme/lumo/vaadin-combo-box.js';\nimport '@vaadin/vaadin-confirm-dialog/theme/lumo/vaadin-confirm-dialog.js';\nimport '@vaadin/vaadin-context-menu/theme/lumo/vaadin-context-menu.js';\nimport '@vaadin/vaadin-cookie-consent/theme/lumo/vaadin-cookie-consent.js';\nimport '@vaadin/vaadin-crud/src/vaadin-crud-edit-column.js';\nimport '@vaadin/vaadin-crud/theme/lumo/vaadin-crud.js';\nimport '@vaadin/vaadin-custom-field/theme/lumo/vaadin-custom-field.js';\nimport '@vaadin/vaadin-date-picker/theme/lumo/vaadin-date-picker.js';\nimport '@vaadin/vaadin-date-time-picker/theme/lumo/vaadin-date-time-picker.js';\nimport '@vaadin/vaadin-details/theme/lumo/vaadin-details.js';\nimport '@vaadin/vaadin-dialog/theme/lumo/vaadin-dialog.js';\nimport '@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-item.js';\nimport '@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-layout.js';\nimport '@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro-edit-column.js';\nimport '@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column-group.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-sorter.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-tree-toggle.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid.js';\nimport '@vaadin/vaadin-icons/vaadin-icons.js';\nimport '@vaadin/vaadin-item/theme/lumo/vaadin-item.js';\nimport '@vaadin/vaadin-list-box/theme/lumo/vaadin-list-box.js';\nimport '@vaadin/vaadin-login/theme/lumo/vaadin-login-form.js';\nimport '@vaadin/vaadin-login/theme/lumo/vaadin-login-overlay.js';\nimport '@vaadin/vaadin-menu-bar/theme/lumo/vaadin-menu-bar.js';\nimport '@vaadin/vaadin-notification/theme/lumo/vaadin-notification.js';\nimport '@vaadin/vaadin-ordered-layout/vaadin-scroller.js';\nimport '@vaadin/vaadin-progress-bar/theme/lumo/vaadin-progress-bar.js';\nimport '@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-button.js';\nimport '@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-group.js';\nimport '@vaadin/vaadin-rich-text-editor/theme/lumo/vaadin-rich-text-editor.js';\nimport '@vaadin/vaadin-select/theme/lumo/vaadin-select.js';\nimport '@vaadin/vaadin-split-layout/theme/lumo/vaadin-split-layout.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-email-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-integer-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-number-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-password-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-text-field.js';\nimport '@vaadin/vaadin-time-picker/theme/lumo/vaadin-time-picker.js';\nimport '@vaadin/vaadin-upload/src/vaadin-upload-file.js';\nimport '@vaadin/flow-frontend/comboBoxConnector.js';\nimport '@vaadin/flow-frontend/contextMenuConnector.js';\nimport '@vaadin/flow-frontend/dndConnector.js';\nimport '@vaadin/flow-frontend/gridConnector.js';\nimport '@vaadin/flow-frontend/ironListConnector.js';\nimport '@vaadin/flow-frontend/selectConnector.js';",
   "modules": []
  },
  {
   "id": 491,
   "name": "../target/frontend/generated-flow-imports-fallback.js",
   "source": "import '@polymer/iron-icon/iron-icon.js';\nimport '@polymer/iron-list/iron-list.js';\nimport '@vaadin/flow-frontend/comboBoxConnector-es6.js';\nimport '@vaadin/flow-frontend/contextMenuConnector-es6.js';\nimport '@vaadin/flow-frontend/datepickerConnector.js';\nimport '@vaadin/flow-frontend/dndConnector-es6.js';\nimport '@vaadin/flow-frontend/flow-component-renderer.js';\nimport '@vaadin/flow-frontend/gridConnector-es6.js';\nimport '@vaadin/flow-frontend/gridProConnector.js';\nimport '@vaadin/flow-frontend/ironListConnector-es6.js';\nimport '@vaadin/flow-frontend/ironListStyles.js';\nimport '@vaadin/flow-frontend/menubarConnector.js';\nimport '@vaadin/flow-frontend/timepickerConnector.js';\nimport '@vaadin/flow-frontend/vaadin-big-decimal-field.js';\nimport '@vaadin/flow-frontend/vaadin-grid-flow-selection-column.js';\nimport '@vaadin/vaadin-accordion/theme/lumo/vaadin-accordion.js';\nimport '@vaadin/vaadin-app-layout/theme/lumo/vaadin-drawer-toggle.js';\nimport '@vaadin/vaadin-board/vaadin-board-row.js';\nimport '@vaadin/vaadin-board/vaadin-board.js';\nimport '@vaadin/vaadin-charts/vaadin-chart.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox-group.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js';\nimport '@vaadin/vaadin-combo-box/theme/lumo/vaadin-combo-box.js';\nimport '@vaadin/vaadin-confirm-dialog/theme/lumo/vaadin-confirm-dialog.js';\nimport '@vaadin/vaadin-context-menu/theme/lumo/vaadin-context-menu.js';\nimport '@vaadin/vaadin-cookie-consent/theme/lumo/vaadin-cookie-consent.js';\nimport '@vaadin/vaadin-crud/src/vaadin-crud-edit-column.js';\nimport '@vaadin/vaadin-crud/theme/lumo/vaadin-crud.js';\nimport '@vaadin/vaadin-custom-field/theme/lumo/vaadin-custom-field.js';\nimport '@vaadin/vaadin-date-picker/theme/lumo/vaadin-date-picker.js';\nimport '@vaadin/vaadin-date-time-picker/theme/lumo/vaadin-date-time-picker.js';\nimport '@vaadin/vaadin-details/theme/lumo/vaadin-details.js';\nimport '@vaadin/vaadin-dialog/theme/lumo/vaadin-dialog.js';\nimport '@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-item.js';\nimport '@vaadin/vaadin-form-layout/theme/lumo/vaadin-form-layout.js';\nimport '@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro-edit-column.js';\nimport '@vaadin/vaadin-grid-pro/theme/lumo/vaadin-grid-pro.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column-group.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-column.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-sorter.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid-tree-toggle.js';\nimport '@vaadin/vaadin-grid/theme/lumo/vaadin-grid.js';\nimport '@vaadin/vaadin-icons/vaadin-icons.js';\nimport '@vaadin/vaadin-item/theme/lumo/vaadin-item.js';\nimport '@vaadin/vaadin-list-box/theme/lumo/vaadin-list-box.js';\nimport '@vaadin/vaadin-login/theme/lumo/vaadin-login-form.js';\nimport '@vaadin/vaadin-login/theme/lumo/vaadin-login-overlay.js';\nimport '@vaadin/vaadin-menu-bar/theme/lumo/vaadin-menu-bar.js';\nimport '@vaadin/vaadin-notification/theme/lumo/vaadin-notification.js';\nimport '@vaadin/vaadin-ordered-layout/vaadin-scroller.js';\nimport '@vaadin/vaadin-progress-bar/theme/lumo/vaadin-progress-bar.js';\nimport '@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-button.js';\nimport '@vaadin/vaadin-radio-button/theme/lumo/vaadin-radio-group.js';\nimport '@vaadin/vaadin-rich-text-editor/theme/lumo/vaadin-rich-text-editor.js';\nimport '@vaadin/vaadin-select/theme/lumo/vaadin-select.js';\nimport '@vaadin/vaadin-split-layout/theme/lumo/vaadin-split-layout.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-email-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-integer-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-number-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-password-field.js';\nimport '@vaadin/vaadin-text-field/theme/lumo/vaadin-text-field.js';\nimport '@vaadin/vaadin-time-picker/theme/lumo/vaadin-time-picker.js';\nimport '@vaadin/vaadin-upload/src/vaadin-upload-file.js';\nimport '@vaadin/flow-frontend/comboBoxConnector.js';\nimport '@vaadin/flow-frontend/contextMenuConnector.js';\nimport '@vaadin/flow-frontend/dndConnector.js';\nimport '@vaadin/flow-frontend/gridConnector.js';\nimport '@vaadin/flow-frontend/ironListConnector.js';\nimport '@vaadin/flow-frontend/selectConnector.js';",
   "modules": []
  }
 ]
}